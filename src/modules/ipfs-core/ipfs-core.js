var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined")
    return require.apply(this, arguments);
  throw new Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[Object.keys(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require2() {
  return mod2 || (0, cb[Object.keys(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all6) => {
  __markAsModule(target);
  for (var name5 in all6)
    __defProp(target, name5, { get: all6[name5], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup2 = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code5.length; i < len; ++i) {
      lookup2[i] = code5[i];
      revLookup[code5.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1)
        validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup2[num >> 18 & 63] + lookup2[num >> 12 & 63] + lookup2[num >> 6 & 63] + lookup2[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(lookup2[tmp >> 2] + lookup2[tmp << 4 & 63] + "==");
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(lookup2[tmp >> 10] + lookup2[tmp >> 4 & 63] + lookup2[tmp << 2 & 63] + "=");
      }
      return parts.join("");
    }
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "node_modules/ieee754/index.js"(exports2) {
    init_node_globals();
    exports2.read = function(buffer2, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer2[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer2[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports2.write = function(buffer2, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer2[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer2[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer2[offset + i - d] |= s * 128;
    };
  }
});

// node_modules/buffer/index.js
var require_buffer = __commonJS({
  "node_modules/buffer/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var base642 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports2.Buffer = Buffer2;
    exports2.SlowBuffer = SlowBuffer;
    exports2.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports2.kMaxLength = K_MAX_LENGTH;
    Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer2.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer2.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer2.isBuffer(this))
          return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length4) {
      if (length4 > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length4 + '" is invalid for option "size"');
      }
      const buf2 = new Uint8Array(length4);
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function Buffer2(arg, encodingOrOffset, length4) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError('The "string" argument must be of type string. Received type number');
        }
        return allocUnsafe(arg);
      }
      return from3(arg, encodingOrOffset, length4);
    }
    Buffer2.poolSize = 8192;
    function from3(value, encodingOrOffset, length4) {
      if (typeof value === "string") {
        return fromString4(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length4);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length4);
      }
      if (typeof value === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer2.from(valueOf, encodingOrOffset, length4);
      }
      const b = fromObject(value);
      if (b)
        return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length4);
      }
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    Buffer2.from = function(value, encodingOrOffset, length4) {
      return from3(value, encodingOrOffset, length4);
    };
    Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer2, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc2(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer2.alloc = function(size, fill, encoding) {
      return alloc2(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer2.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer2.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString4(string3, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length4 = byteLength(string3, encoding) | 0;
      let buf2 = createBuffer(length4);
      const actual = buf2.write(string3, encoding);
      if (actual !== length4) {
        buf2 = buf2.slice(0, actual);
      }
      return buf2;
    }
    function fromArrayLike(array2) {
      const length4 = array2.length < 0 ? 0 : checked(array2.length) | 0;
      const buf2 = createBuffer(length4);
      for (let i = 0; i < length4; i += 1) {
        buf2[i] = array2[i] & 255;
      }
      return buf2;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array2, byteOffset, length4) {
      if (byteOffset < 0 || array2.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array2.byteLength < byteOffset + (length4 || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf2;
      if (byteOffset === void 0 && length4 === void 0) {
        buf2 = new Uint8Array(array2);
      } else if (length4 === void 0) {
        buf2 = new Uint8Array(array2, byteOffset);
      } else {
        buf2 = new Uint8Array(array2, byteOffset, length4);
      }
      Object.setPrototypeOf(buf2, Buffer2.prototype);
      return buf2;
    }
    function fromObject(obj) {
      if (Buffer2.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf2 = createBuffer(len);
        if (buf2.length === 0) {
          return buf2;
        }
        obj.copy(buf2, 0, 0, len);
        return buf2;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length4) {
      if (length4 >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length4 | 0;
    }
    function SlowBuffer(length4) {
      if (+length4 != length4) {
        length4 = 0;
      }
      return Buffer2.alloc(+length4);
    }
    Buffer2.isBuffer = function isBuffer3(b) {
      return b != null && b._isBuffer === true && b !== Buffer2.prototype;
    };
    Buffer2.compare = function compare3(a, b) {
      if (isInstance(a, Uint8Array))
        a = Buffer2.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array))
        b = Buffer2.from(b, b.offset, b.byteLength);
      if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      }
      if (a === b)
        return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    Buffer2.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer2.concat = function concat3(list, length4) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer2.alloc(0);
      }
      let i;
      if (length4 === void 0) {
        length4 = 0;
        for (i = 0; i < list.length; ++i) {
          length4 += list[i].length;
        }
      }
      const buffer2 = Buffer2.allocUnsafe(length4);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf2 = list[i];
        if (isInstance(buf2, Uint8Array)) {
          if (pos + buf2.length > buffer2.length) {
            if (!Buffer2.isBuffer(buf2))
              buf2 = Buffer2.from(buf2);
            buf2.copy(buffer2, pos);
          } else {
            Uint8Array.prototype.set.call(buffer2, buf2, pos);
          }
        } else if (!Buffer2.isBuffer(buf2)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf2.copy(buffer2, pos);
        }
        pos += buf2.length;
      }
      return buffer2;
    };
    function byteLength(string3, encoding) {
      if (Buffer2.isBuffer(string3)) {
        return string3.length;
      }
      if (ArrayBuffer.isView(string3) || isInstance(string3, ArrayBuffer)) {
        return string3.byteLength;
      }
      if (typeof string3 !== "string") {
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string3);
      }
      const len = string3.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0)
        return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes2(string3).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string3).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes2(string3).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding)
        encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice2(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer2.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer2.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer2.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer2.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer2.prototype.toString = function toString4() {
      const length4 = this.length;
      if (length4 === 0)
        return "";
      if (arguments.length === 0)
        return utf8Slice2(this, 0, length4);
      return slowToString.apply(this, arguments);
    };
    Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
    Buffer2.prototype.equals = function equals4(b) {
      if (!Buffer2.isBuffer(b))
        throw new TypeError("Argument must be a Buffer");
      if (this === b)
        return true;
      return Buffer2.compare(this, b) === 0;
    };
    Buffer2.prototype.inspect = function inspect() {
      let str = "";
      const max = exports2.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max)
        str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
    }
    Buffer2.prototype.compare = function compare3(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer2.from(target, target.offset, target.byteLength);
      }
      if (!Buffer2.isBuffer(target)) {
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target)
        return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y)
        return -1;
      if (y < x)
        return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer2, val, byteOffset, encoding, dir) {
      if (buffer2.length === 0)
        return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer2.length - 1;
      }
      if (byteOffset < 0)
        byteOffset = buffer2.length + byteOffset;
      if (byteOffset >= buffer2.length) {
        if (dir)
          return -1;
        else
          byteOffset = buffer2.length - 1;
      } else if (byteOffset < 0) {
        if (dir)
          byteOffset = 0;
        else
          return -1;
      }
      if (typeof val === "string") {
        val = Buffer2.from(val, encoding);
      }
      if (Buffer2.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer2, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer2, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer2, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer2, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read2(buf2, i2) {
        if (indexSize === 1) {
          return buf2[i2];
        } else {
          return buf2.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read2(arr, i) === read2(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1)
              foundIndex = i;
            if (i - foundIndex + 1 === valLength)
              return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1)
              i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength)
          byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read2(arr, i + j) !== read2(val, j)) {
              found = false;
              break;
            }
          }
          if (found)
            return i;
        }
      }
      return -1;
    }
    Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf2, string3, offset, length4) {
      offset = Number(offset) || 0;
      const remaining = buf2.length - offset;
      if (!length4) {
        length4 = remaining;
      } else {
        length4 = Number(length4);
        if (length4 > remaining) {
          length4 = remaining;
        }
      }
      const strLen = string3.length;
      if (length4 > strLen / 2) {
        length4 = strLen / 2;
      }
      let i;
      for (i = 0; i < length4; ++i) {
        const parsed = parseInt(string3.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed))
          return i;
        buf2[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf2, string3, offset, length4) {
      return blitBuffer(utf8ToBytes2(string3, buf2.length - offset), buf2, offset, length4);
    }
    function asciiWrite(buf2, string3, offset, length4) {
      return blitBuffer(asciiToBytes(string3), buf2, offset, length4);
    }
    function base64Write(buf2, string3, offset, length4) {
      return blitBuffer(base64ToBytes(string3), buf2, offset, length4);
    }
    function ucs2Write(buf2, string3, offset, length4) {
      return blitBuffer(utf16leToBytes(string3, buf2.length - offset), buf2, offset, length4);
    }
    Buffer2.prototype.write = function write(string3, offset, length4, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length4 = this.length;
        offset = 0;
      } else if (length4 === void 0 && typeof offset === "string") {
        encoding = offset;
        length4 = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length4)) {
          length4 = length4 >>> 0;
          if (encoding === void 0)
            encoding = "utf8";
        } else {
          encoding = length4;
          length4 = void 0;
        }
      } else {
        throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
      }
      const remaining = this.length - offset;
      if (length4 === void 0 || length4 > remaining)
        length4 = remaining;
      if (string3.length > 0 && (length4 < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding)
        encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string3, offset, length4);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string3, offset, length4);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string3, offset, length4);
          case "base64":
            return base64Write(this, string3, offset, length4);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string3, offset, length4);
          default:
            if (loweredCase)
              throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer2.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf2, start, end) {
      if (start === 0 && end === buf2.length) {
        return base642.fromByteArray(buf2);
      } else {
        return base642.fromByteArray(buf2.slice(start, end));
      }
    }
    function utf8Slice2(buf2, start, end) {
      end = Math.min(buf2.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf2[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf2[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf2[i + 1];
              thirdByte = buf2[i + 2];
              fourthByte = buf2[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray2(res);
    }
    var MAX_ARGUMENTS_LENGTH2 = 4096;
    function decodeCodePointsArray2(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH2) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH2));
      }
      return res;
    }
    function asciiSlice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf2, start, end) {
      let ret = "";
      end = Math.min(buf2.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf2[i]);
      }
      return ret;
    }
    function hexSlice(buf2, start, end) {
      const len = buf2.length;
      if (!start || start < 0)
        start = 0;
      if (!end || end < 0 || end > len)
        end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf2[i]];
      }
      return out;
    }
    function utf16leSlice(buf2, start, end) {
      const bytes3 = buf2.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes3.length - 1; i += 2) {
        res += String.fromCharCode(bytes3[i] + bytes3[i + 1] * 256);
      }
      return res;
    }
    Buffer2.prototype.slice = function slice2(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0)
          start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0)
          end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start)
        end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer2.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length4) {
      if (offset % 1 !== 0 || offset < 0)
        throw new RangeError("offset is not uint");
      if (offset + ext > length4)
        throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer2.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first3 = this[offset];
      const last6 = this[offset + 7];
      if (first3 === void 0 || last6 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first3 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last6 * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer2.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first3 = this[offset];
      const last6 = this[offset + 7];
      if (first3 === void 0 || last6 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first3 * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last6;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert)
        checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul)
        val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128))
        return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer2.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first3 = this[offset];
      const last6 = this[offset + 7];
      if (first3 === void 0 || last6 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last6 << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first3 + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer2.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first3 = this[offset];
      const last6 = this[offset + 7];
      if (first3 === void 0 || last6 === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first3 << 24) + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last6);
    });
    Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert)
        checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf2, value, offset, ext, max, min) {
      if (!Buffer2.isBuffer(buf2))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min)
        throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
    }
    Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      lo = lo >> 8;
      buf2[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      hi = hi >> 8;
      buf2[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf2, value, offset, min, max) {
      checkIntBI(value, min, max, buf2, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf2[offset + 7] = lo;
      lo = lo >> 8;
      buf2[offset + 6] = lo;
      lo = lo >> 8;
      buf2[offset + 5] = lo;
      lo = lo >> 8;
      buf2[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf2[offset + 3] = hi;
      hi = hi >> 8;
      buf2[offset + 2] = hi;
      hi = hi >> 8;
      buf2[offset + 1] = hi;
      hi = hi >> 8;
      buf2[offset] = hi;
      return offset + 8;
    }
    Buffer2.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 1, 127, -128);
      if (value < 0)
        value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert)
        checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0)
        value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer2.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer2.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf2, value, offset, ext, max, min) {
      if (offset + ext > buf2.length)
        throw new RangeError("Index out of range");
      if (offset < 0)
        throw new RangeError("Index out of range");
    }
    function writeFloat(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf2, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf2, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf2, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf2, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer2.isBuffer(target))
        throw new TypeError("argument should be a Buffer");
      if (!start)
        start = 0;
      if (!end && end !== 0)
        end = this.length;
      if (targetStart >= target.length)
        targetStart = target.length;
      if (!targetStart)
        targetStart = 0;
      if (end > 0 && end < start)
        end = start;
      if (end === start)
        return 0;
      if (target.length === 0 || this.length === 0)
        return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length)
        throw new RangeError("Index out of range");
      if (end < 0)
        throw new RangeError("sourceEnd out of bounds");
      if (end > this.length)
        end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
      }
      return len;
    };
    Buffer2.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code5 = val.charCodeAt(0);
          if (encoding === "utf8" && code5 < 128 || encoding === "latin1") {
            val = code5;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val)
        val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes3 = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
        const len = bytes3.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes3[i % len];
        }
      }
      return this;
    };
    var errors2 = {};
    function E(sym, getMessage, Base) {
      errors2[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E("ERR_BUFFER_OUT_OF_BOUNDS", function(name5) {
      if (name5) {
        return `${name5} is outside of buffer bounds`;
      }
      return "Attempt to access memory outside buffer bounds";
    }, RangeError);
    E("ERR_INVALID_ARG_TYPE", function(name5, actual) {
      return `The "${name5}" argument must be of type number. Received type ${typeof actual}`;
    }, TypeError);
    E("ERR_OUT_OF_RANGE", function(str, range, input) {
      let msg = `The value of "${str}" is out of range.`;
      let received = input;
      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
        received = addNumericalSeparator(String(input));
      } else if (typeof input === "bigint") {
        received = String(input);
        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
          received = addNumericalSeparator(received);
        }
        received += "n";
      }
      msg += ` It must be ${range}. Received ${received}`;
      return msg;
    }, RangeError);
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf2, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf2[offset] === void 0 || buf2[offset + byteLength2] === void 0) {
        boundsError(offset, buf2.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf2, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors2.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf2, offset, byteLength2);
    }
    function validateNumber(value, name5) {
      if (typeof value !== "number") {
        throw new errors2.ERR_INVALID_ARG_TYPE(name5, "number", value);
      }
    }
    function boundsError(value, length4, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors2.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length4 < 0) {
        throw new errors2.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors2.ERR_OUT_OF_RANGE(type || "offset", `>= ${type ? 1 : 0} and <= ${length4}`, value);
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2)
        return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes2(string3, units) {
      units = units || Infinity;
      let codePoint;
      const length4 = string3.length;
      let leadSurrogate = null;
      const bytes3 = [];
      for (let i = 0; i < length4; ++i) {
        codePoint = string3.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1)
                bytes3.push(239, 191, 189);
              continue;
            } else if (i + 1 === length4) {
              if ((units -= 3) > -1)
                bytes3.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1)
              bytes3.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0)
            break;
          bytes3.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0)
            break;
          bytes3.push(codePoint >> 6 | 192, codePoint & 63 | 128);
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0)
            break;
          bytes3.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0)
            break;
          bytes3.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes3;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0)
          break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base642.toByteArray(base64clean(str));
    }
    function blitBuffer(src2, dst, offset, length4) {
      let i;
      for (i = 0; i < length4; ++i) {
        if (i + offset >= dst.length || i >= src2.length)
          break;
        dst[i + offset] = src2[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// node_modules/process/browser.js
var require_browser = __commonJS({
  "node_modules/process/browser.js"(exports2, module2) {
    init_node_globals();
    var process5 = module2.exports = {};
    var cachedSetTimeout;
    var cachedClearTimeout;
    function defaultSetTimout() {
      throw new Error("setTimeout has not been defined");
    }
    function defaultClearTimeout() {
      throw new Error("clearTimeout has not been defined");
    }
    (function() {
      try {
        if (typeof setTimeout === "function") {
          cachedSetTimeout = setTimeout;
        } else {
          cachedSetTimeout = defaultSetTimout;
        }
      } catch (e) {
        cachedSetTimeout = defaultSetTimout;
      }
      try {
        if (typeof clearTimeout === "function") {
          cachedClearTimeout = clearTimeout;
        } else {
          cachedClearTimeout = defaultClearTimeout;
        }
      } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
      }
    })();
    function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
        return setTimeout(fun, 0);
      }
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
      }
      try {
        return cachedSetTimeout(fun, 0);
      } catch (e) {
        try {
          return cachedSetTimeout.call(null, fun, 0);
        } catch (e2) {
          return cachedSetTimeout.call(this, fun, 0);
        }
      }
    }
    function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
        return clearTimeout(marker);
      }
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
      }
      try {
        return cachedClearTimeout(marker);
      } catch (e) {
        try {
          return cachedClearTimeout.call(null, marker);
        } catch (e2) {
          return cachedClearTimeout.call(this, marker);
        }
      }
    }
    var queue = [];
    var draining = false;
    var currentQueue;
    var queueIndex = -1;
    function cleanUpNextTick() {
      if (!draining || !currentQueue) {
        return;
      }
      draining = false;
      if (currentQueue.length) {
        queue = currentQueue.concat(queue);
      } else {
        queueIndex = -1;
      }
      if (queue.length) {
        drainQueue();
      }
    }
    function drainQueue() {
      if (draining) {
        return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
      var len = queue.length;
      while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
          if (currentQueue) {
            currentQueue[queueIndex].run();
          }
        }
        queueIndex = -1;
        len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
    }
    process5.nextTick = function(fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
          args[i - 1] = arguments[i];
        }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
      }
    };
    function Item(fun, array2) {
      this.fun = fun;
      this.array = array2;
    }
    Item.prototype.run = function() {
      this.fun.apply(null, this.array);
    };
    process5.title = "browser";
    process5.browser = true;
    process5.env = {};
    process5.argv = [];
    process5.version = "";
    process5.versions = {};
    function noop2() {
    }
    process5.on = noop2;
    process5.addListener = noop2;
    process5.once = noop2;
    process5.off = noop2;
    process5.removeListener = noop2;
    process5.removeAllListeners = noop2;
    process5.emit = noop2;
    process5.prependListener = noop2;
    process5.prependOnceListener = noop2;
    process5.listeners = function(name5) {
      return [];
    };
    process5.binding = function(name5) {
      throw new Error("process.binding is not supported");
    };
    process5.cwd = function() {
      return "/";
    };
    process5.chdir = function(dir) {
      throw new Error("process.chdir is not supported");
    };
    process5.umask = function() {
      return 0;
    };
  }
});

// src/node-globals.js
var Buffer, process, global;
var init_node_globals = __esm({
  "src/node-globals.js"() {
    Buffer = require_buffer().Buffer;
    process = require_browser();
    global = typeof global !== "undefined" ? global : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};
    if (globalThis && globalThis.process && globalThis.process.env)
      globalThis.process.env.LIBP2P_FORCE_PNET = false;
  }
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/is-plain-obj/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/merge-options/index.js
var require_merge_options = __commonJS({
  "node_modules/merge-options/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var isOptionObject = require_is_plain_obj();
    var { hasOwnProperty } = Object.prototype;
    var { propertyIsEnumerable } = Object;
    var defineProperty = (object, name5, value) => Object.defineProperty(object, name5, {
      value,
      writable: true,
      enumerable: true,
      configurable: true
    });
    var globalThis2 = exports2;
    var defaultMergeOptions = {
      concatArrays: false,
      ignoreUndefined: false
    };
    var getEnumerableOwnPropertyKeys = (value) => {
      const keys = [];
      for (const key in value) {
        if (hasOwnProperty.call(value, key)) {
          keys.push(key);
        }
      }
      if (Object.getOwnPropertySymbols) {
        const symbols = Object.getOwnPropertySymbols(value);
        for (const symbol of symbols) {
          if (propertyIsEnumerable.call(value, symbol)) {
            keys.push(symbol);
          }
        }
      }
      return keys;
    };
    function clone(value) {
      if (Array.isArray(value)) {
        return cloneArray(value);
      }
      if (isOptionObject(value)) {
        return cloneOptionObject(value);
      }
      return value;
    }
    function cloneArray(array2) {
      const result = array2.slice(0, 0);
      getEnumerableOwnPropertyKeys(array2).forEach((key) => {
        defineProperty(result, key, clone(array2[key]));
      });
      return result;
    }
    function cloneOptionObject(object) {
      const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};
      getEnumerableOwnPropertyKeys(object).forEach((key) => {
        defineProperty(result, key, clone(object[key]));
      });
      return result;
    }
    var mergeKeys = (merged, source, keys, config2) => {
      keys.forEach((key) => {
        if (typeof source[key] === "undefined" && config2.ignoreUndefined) {
          return;
        }
        if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
          defineProperty(merged, key, merge4(merged[key], source[key], config2));
        } else {
          defineProperty(merged, key, clone(source[key]));
        }
      });
      return merged;
    };
    var concatArrays = (merged, source, config2) => {
      let result = merged.slice(0, 0);
      let resultIndex = 0;
      [merged, source].forEach((array2) => {
        const indices = [];
        for (let k = 0; k < array2.length; k++) {
          if (!hasOwnProperty.call(array2, k)) {
            continue;
          }
          indices.push(String(k));
          if (array2 === merged) {
            defineProperty(result, resultIndex++, array2[k]);
          } else {
            defineProperty(result, resultIndex++, clone(array2[k]));
          }
        }
        result = mergeKeys(result, array2, getEnumerableOwnPropertyKeys(array2).filter((key) => !indices.includes(key)), config2);
      });
      return result;
    };
    function merge4(merged, source, config2) {
      if (config2.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
        return concatArrays(merged, source, config2);
      }
      if (!isOptionObject(source) || !isOptionObject(merged)) {
        return clone(source);
      }
      return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config2);
    }
    module2.exports = function(...options) {
      const config2 = merge4(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
      let merged = { _: {} };
      for (const option of options) {
        if (option === void 0) {
          continue;
        }
        if (!isOptionObject(option)) {
          throw new TypeError("`" + option + "` is not an Option Object");
        }
        merged = merge4(merged, { _: option }, config2);
      }
      return merged._;
    };
  }
});

// node_modules/is-electron/index.js
var require_is_electron = __commonJS({
  "node_modules/is-electron/index.js"(exports2, module2) {
    init_node_globals();
    function isElectron() {
      if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
        return true;
      }
      if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
        return true;
      }
      if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
        return true;
      }
      return false;
    }
    module2.exports = isElectron;
  }
});

// node_modules/ipfs-utils/src/env.js
var require_env = __commonJS({
  "node_modules/ipfs-utils/src/env.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var isElectron = require_is_electron();
    var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
    var IS_ELECTRON = isElectron();
    var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
    var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
    var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
    var IS_NODE = typeof __require === "function" && typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
    var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    var IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && false;
    var IS_REACT_NATIVE = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    module2.exports = {
      isTest: IS_TEST,
      isElectron: IS_ELECTRON,
      isElectronMain: IS_ELECTRON_MAIN,
      isElectronRenderer: IS_ELECTRON_RENDERER,
      isNode: IS_NODE,
      isBrowser: IS_BROWSER,
      isWebWorker: IS_WEBWORKER,
      isEnvWithDom: IS_ENV_WITH_DOM,
      isReactNative: IS_REACT_NATIVE
    };
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    init_node_globals();
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse2(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    function plural(ms, msAbs, n, name5) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name5 + (isPlural ? "s" : "");
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    init_node_globals();
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace3) {
        let hash2 = 0;
        for (let i = 0; i < namespace3.length; i++) {
          hash2 = (hash2 << 5) - hash2 + namespace3.charCodeAt(i);
          hash2 |= 0;
        }
        return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace3) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug17(...args) {
          if (!debug17.enabled) {
            return;
          }
          const self2 = debug17;
          const curr = Number(new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug17.namespace = namespace3;
        debug17.useColors = createDebug.useColors();
        debug17.color = createDebug.selectColor(namespace3);
        debug17.extend = extend;
        debug17.destroy = createDebug.destroy;
        Object.defineProperty(debug17, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace3);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug17);
        }
        return debug17;
      }
      function extend(namespace3, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace3);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace3) => "-" + namespace3)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name5) {
        if (name5[name5.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name5)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name5)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    init_node_globals();
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module2.exports = require_common()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS({
  "node_modules/err-code/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code5, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code5 === "object") {
        props = code5;
        code5 = "";
      }
      if (code5) {
        props.code = code5;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        const output = assign(new ErrClass(), props);
        return output;
      }
    }
    module2.exports = createError;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length)
        params[offset++] = arguments[index++];
      return new Promise(function executor(resolve6, reject) {
        params[offset] = function callback(err) {
          if (pending) {
            pending = false;
            if (err)
              reject(err);
            else {
              var params2 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params2.length)
                params2[offset2++] = arguments[offset2];
              resolve6.apply(null, params2);
            }
          }
        };
        try {
          fn.apply(ctx || null, params);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      });
    }
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var base642 = exports2;
    base642.length = function length4(string3) {
      var p = string3.length;
      if (!p)
        return 0;
      var n = 0;
      while (--p % 4 > 1 && string3.charAt(p) === "=")
        ++n;
      return Math.ceil(string3.length * 3) / 4 - n;
    };
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; )
      s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base642.encode = function encode10(buffer2, start, end) {
      var parts = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer2[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1)
          chunk[i2++] = 61;
      }
      if (parts) {
        if (i2)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    };
    var invalidEncoding = "invalid encoding";
    base642.decode = function decode12(string3, buffer2, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string3.length; ) {
        var c = string3.charCodeAt(i2++);
        if (c === 61 && j > 1)
          break;
        if ((c = s64[c]) === void 0)
          throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer2[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer2[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer2[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1)
        throw Error(invalidEncoding);
      return offset - start;
    };
    base642.test = function test(string3) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string3);
    };
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = EventEmitter4;
    function EventEmitter4() {
      this._listeners = {};
    }
    EventEmitter4.prototype.on = function on(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    };
    EventEmitter4.prototype.off = function off(evt, fn) {
      if (evt === void 0)
        this._listeners = {};
      else {
        if (fn === void 0)
          this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; )
            if (listeners[i].fn === fn)
              listeners.splice(i, 1);
            else
              ++i;
        }
      }
      return this;
    };
    EventEmitter4.prototype.emit = function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; )
          args.push(arguments[i++]);
        for (i = 0; i < listeners.length; )
          listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    };
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined")
        (function() {
          var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
          function writeFloat_f32_cpy(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
          }
          function writeFloat_f32_rev(val, buf2, pos) {
            f32[0] = val;
            buf2[pos] = f8b[3];
            buf2[pos + 1] = f8b[2];
            buf2[pos + 2] = f8b[1];
            buf2[pos + 3] = f8b[0];
          }
          exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
          exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
          function readFloat_f32_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            return f32[0];
          }
          function readFloat_f32_rev(buf2, pos) {
            f8b[3] = buf2[pos];
            f8b[2] = buf2[pos + 1];
            f8b[1] = buf2[pos + 2];
            f8b[0] = buf2[pos + 3];
            return f32[0];
          }
          exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
          exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
        })();
      else
        (function() {
          function writeFloat_ieee754(writeUint, val, buf2, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0)
              writeUint(1 / val > 0 ? 0 : 2147483648, buf2, pos);
            else if (isNaN(val))
              writeUint(2143289344, buf2, pos);
            else if (val > 34028234663852886e22)
              writeUint((sign2 << 31 | 2139095040) >>> 0, buf2, pos);
            else if (val < 11754943508222875e-54)
              writeUint((sign2 << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf2, pos);
            else {
              var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
              writeUint((sign2 << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf2, pos);
            }
          }
          exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
          exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
          function readFloat_ieee754(readUint, buf2, pos) {
            var uint8 = readUint(buf2, pos), sign2 = (uint8 >> 31) * 2 + 1, exponent = uint8 >>> 23 & 255, mantissa = uint8 & 8388607;
            return exponent === 255 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 1401298464324817e-60 * mantissa : sign2 * Math.pow(2, exponent - 150) * (mantissa + 8388608);
          }
          exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
          exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
        })();
      if (typeof Float64Array !== "undefined")
        (function() {
          var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
          function writeDouble_f64_cpy(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[0];
            buf2[pos + 1] = f8b[1];
            buf2[pos + 2] = f8b[2];
            buf2[pos + 3] = f8b[3];
            buf2[pos + 4] = f8b[4];
            buf2[pos + 5] = f8b[5];
            buf2[pos + 6] = f8b[6];
            buf2[pos + 7] = f8b[7];
          }
          function writeDouble_f64_rev(val, buf2, pos) {
            f64[0] = val;
            buf2[pos] = f8b[7];
            buf2[pos + 1] = f8b[6];
            buf2[pos + 2] = f8b[5];
            buf2[pos + 3] = f8b[4];
            buf2[pos + 4] = f8b[3];
            buf2[pos + 5] = f8b[2];
            buf2[pos + 6] = f8b[1];
            buf2[pos + 7] = f8b[0];
          }
          exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
          exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
          function readDouble_f64_cpy(buf2, pos) {
            f8b[0] = buf2[pos];
            f8b[1] = buf2[pos + 1];
            f8b[2] = buf2[pos + 2];
            f8b[3] = buf2[pos + 3];
            f8b[4] = buf2[pos + 4];
            f8b[5] = buf2[pos + 5];
            f8b[6] = buf2[pos + 6];
            f8b[7] = buf2[pos + 7];
            return f64[0];
          }
          function readDouble_f64_rev(buf2, pos) {
            f8b[7] = buf2[pos];
            f8b[6] = buf2[pos + 1];
            f8b[5] = buf2[pos + 2];
            f8b[4] = buf2[pos + 3];
            f8b[3] = buf2[pos + 4];
            f8b[2] = buf2[pos + 5];
            f8b[1] = buf2[pos + 6];
            f8b[0] = buf2[pos + 7];
            return f64[0];
          }
          exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
          exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
        })();
      else
        (function() {
          function writeDouble_ieee754(writeUint, off0, off1, val, buf2, pos) {
            var sign2 = val < 0 ? 1 : 0;
            if (sign2)
              val = -val;
            if (val === 0) {
              writeUint(0, buf2, pos + off0);
              writeUint(1 / val > 0 ? 0 : 2147483648, buf2, pos + off1);
            } else if (isNaN(val)) {
              writeUint(0, buf2, pos + off0);
              writeUint(2146959360, buf2, pos + off1);
            } else if (val > 17976931348623157e292) {
              writeUint(0, buf2, pos + off0);
              writeUint((sign2 << 31 | 2146435072) >>> 0, buf2, pos + off1);
            } else {
              var mantissa;
              if (val < 22250738585072014e-324) {
                mantissa = val / 5e-324;
                writeUint(mantissa >>> 0, buf2, pos + off0);
                writeUint((sign2 << 31 | mantissa / 4294967296) >>> 0, buf2, pos + off1);
              } else {
                var exponent = Math.floor(Math.log(val) / Math.LN2);
                if (exponent === 1024)
                  exponent = 1023;
                mantissa = val * Math.pow(2, -exponent);
                writeUint(mantissa * 4503599627370496 >>> 0, buf2, pos + off0);
                writeUint((sign2 << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf2, pos + off1);
              }
            }
          }
          exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
          exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
          function readDouble_ieee754(readUint, off0, off1, buf2, pos) {
            var lo = readUint(buf2, pos + off0), hi = readUint(buf2, pos + off1);
            var sign2 = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
            return exponent === 2047 ? mantissa ? NaN : sign2 * Infinity : exponent === 0 ? sign2 * 5e-324 * mantissa : sign2 * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
          }
          exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
          exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
        })();
      return exports3;
    }
    function writeUintLE(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    function writeUintBE(val, buf2, pos) {
      buf2[pos] = val >>> 24;
      buf2[pos + 1] = val >>> 16 & 255;
      buf2[pos + 2] = val >>> 8 & 255;
      buf2[pos + 3] = val & 255;
    }
    function readUintLE(buf2, pos) {
      return (buf2[pos] | buf2[pos + 1] << 8 | buf2[pos + 2] << 16 | buf2[pos + 3] << 24) >>> 0;
    }
    function readUintBE(buf2, pos) {
      return (buf2[pos] << 24 | buf2[pos + 1] << 16 | buf2[pos + 2] << 8 | buf2[pos + 3]) >>> 0;
    }
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    init_node_globals();
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length))
          return mod;
      } catch (e) {
      }
      return null;
    }
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var utf8 = exports2;
    utf8.length = function utf8_length(string3) {
      var len = 0, c = 0;
      for (var i = 0; i < string3.length; ++i) {
        c = string3.charCodeAt(i);
        if (c < 128)
          len += 1;
        else if (c < 2048)
          len += 2;
        else if ((c & 64512) === 55296 && (string3.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else
          len += 3;
      }
      return len;
    };
    utf8.read = function utf8_read(buffer2, start, end) {
      var len = end - start;
      if (len < 1)
        return "";
      var parts = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer2[start++];
        if (t < 128)
          chunk[i++] = t;
        else if (t > 191 && t < 224)
          chunk[i++] = (t & 31) << 6 | buffer2[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer2[start++] & 63) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else
          chunk[i++] = (t & 15) << 12 | (buffer2[start++] & 63) << 6 | buffer2[start++] & 63;
        if (i > 8191) {
          (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts) {
        if (i)
          parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    };
    utf8.write = function utf8_write(string3, buffer2, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string3.length; ++i) {
        c1 = string3.charCodeAt(i);
        if (c1 < 128) {
          buffer2[offset++] = c1;
        } else if (c1 < 2048) {
          buffer2[offset++] = c1 >> 6 | 192;
          buffer2[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string3.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer2[offset++] = c1 >> 18 | 240;
          buffer2[offset++] = c1 >> 12 & 63 | 128;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        } else {
          buffer2[offset++] = c1 >> 12 | 224;
          buffer2[offset++] = c1 >> 6 & 63 | 128;
          buffer2[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    };
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = pool;
    function pool(alloc2, slice2, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX)
          return alloc2(size2);
        if (offset + size2 > SIZE) {
          slab = alloc2(SIZE);
          offset = 0;
        }
        var buf2 = slice2.call(slab, offset, offset += size2);
        if (offset & 7)
          offset = (offset | 7) + 1;
        return buf2;
      };
    }
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = LongBits;
    var util = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = function fromNumber(value) {
      if (value === 0)
        return zero;
      var sign2 = value < 0;
      if (sign2)
        value = -value;
      var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
      if (sign2) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295)
            hi = 0;
        }
      }
      return new LongBits(lo, hi);
    };
    LongBits.from = function from3(value) {
      if (typeof value === "number")
        return LongBits.fromNumber(value);
      if (util.isString(value)) {
        if (util.Long)
          value = util.Long.fromString(value);
        else
          return LongBits.fromNumber(parseInt(value, 10));
      }
      return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
    };
    LongBits.prototype.toNumber = function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo)
          hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    };
    LongBits.prototype.toLong = function toLong(unsigned) {
      return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };
    };
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = function fromHash(hash2) {
      if (hash2 === zeroHash)
        return zero;
      return new LongBits((charCodeAt.call(hash2, 0) | charCodeAt.call(hash2, 1) << 8 | charCodeAt.call(hash2, 2) << 16 | charCodeAt.call(hash2, 3) << 24) >>> 0, (charCodeAt.call(hash2, 4) | charCodeAt.call(hash2, 5) << 8 | charCodeAt.call(hash2, 6) << 16 | charCodeAt.call(hash2, 7) << 24) >>> 0);
    };
    LongBits.prototype.toHash = function toHash() {
      return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
    };
    LongBits.prototype.zzEncode = function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.zzDecode = function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    };
    LongBits.prototype.length = function length4() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    };
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    init_node_globals();
    "use strict";
    var util = exports2;
    util.asPromise = require_aspromise();
    util.base64 = require_base64();
    util.EventEmitter = require_eventemitter();
    util.float = require_float();
    util.inquire = require_inquire();
    util.utf8 = require_utf8();
    util.pool = require_pool();
    util.LongBits = require_longbits();
    util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util.emptyArray = Object.freeze ? Object.freeze([]) : [];
    util.emptyObject = Object.freeze ? Object.freeze({}) : {};
    util.isInteger = Number.isInteger || function isInteger(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
    };
    util.isString = function isString(value) {
      return typeof value === "string" || value instanceof String;
    };
    util.isObject = function isObject(value) {
      return value && typeof value === "object";
    };
    util.isset = util.isSet = function isSet(obj, prop) {
      var value = obj[prop];
      if (value != null && obj.hasOwnProperty(prop))
        return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
      return false;
    };
    util.Buffer = function() {
      try {
        var Buffer2 = util.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : null;
      } catch (e) {
        return null;
      }
    }();
    util._Buffer_from = null;
    util._Buffer_allocUnsafe = null;
    util.newBuffer = function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    };
    util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
    util.key2Re = /^true|false|0|1$/;
    util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util.longToHash = function longToHash(value) {
      return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
    };
    util.longFromHash = function longFromHash(hash2, unsigned) {
      var bits = util.LongBits.fromHash(hash2);
      if (util.Long)
        return util.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    };
    function merge4(dst, src2, ifNotSet) {
      for (var keys = Object.keys(src2), i = 0; i < keys.length; ++i)
        if (dst[keys[i]] === void 0 || !ifNotSet)
          dst[keys[i]] = src2[keys[i]];
      return dst;
    }
    util.merge = merge4;
    util.lcFirst = function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    };
    function newError(name5) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError))
          return new CustomError(message, properties);
        Object.defineProperty(this, "message", { get: function() {
          return message;
        } });
        if (Error.captureStackTrace)
          Error.captureStackTrace(this, CustomError);
        else
          Object.defineProperty(this, "stack", { value: new Error().stack || "" });
        if (properties)
          merge4(this, properties);
      }
      (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
      Object.defineProperty(CustomError.prototype, "name", { get: function() {
        return name5;
      } });
      CustomError.prototype.toString = function toString4() {
        return this.name + ": " + this.message;
      };
      return CustomError;
    }
    util.newError = newError;
    util.ProtocolError = newError("ProtocolError");
    util.oneOfGetter = function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i)
        fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
          if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
            return keys[i2];
      };
    };
    util.oneOfSetter = function setOneOf(fieldNames) {
      return function(name5) {
        for (var i = 0; i < fieldNames.length; ++i)
          if (fieldNames[i] !== name5)
            delete this[fieldNames[i]];
      };
    };
    util.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util._configure = function() {
      var Buffer2 = util.Buffer;
      if (!Buffer2) {
        util._Buffer_from = util._Buffer_allocUnsafe = null;
        return;
      }
      util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
        return new Buffer2(value, encoding);
      };
      util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      };
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = Writer;
    var util = require_minimal();
    var BufferWriter;
    var LongBits = util.LongBits;
    var base642 = util.base64;
    var utf8 = util.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    function noop2() {
    }
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    function Writer() {
      this.len = 0;
      this.head = new Op(noop2, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    var create7 = function create8() {
      return util.Buffer ? function create_buffer_setup() {
        return (Writer.create = function create_buffer() {
          return new BufferWriter();
        })();
      } : function create_array() {
        return new Writer();
      };
    };
    Writer.create = create7();
    Writer.alloc = function alloc2(size) {
      return new util.Array(size);
    };
    if (util.Array !== Array)
      Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
    Writer.prototype._push = function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    };
    function writeByte(val, buf2, pos) {
      buf2[pos] = val & 255;
    }
    function writeVarint32(val, buf2, pos) {
      while (val > 127) {
        buf2[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf2[pos] = val;
    }
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = function write_uint32(value) {
      this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
      return this;
    };
    Writer.prototype.int32 = function write_int32(value) {
      return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
    };
    Writer.prototype.sint32 = function write_sint32(value) {
      return this.uint32((value << 1 ^ value >> 31) >>> 0);
    };
    function writeVarint64(val, buf2, pos) {
      while (val.hi) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf2[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf2[pos++] = val.lo;
    }
    Writer.prototype.uint64 = function write_uint64(value) {
      var bits = LongBits.from(value);
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = function write_sint64(value) {
      var bits = LongBits.from(value).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    };
    Writer.prototype.bool = function write_bool(value) {
      return this._push(writeByte, 1, value ? 1 : 0);
    };
    function writeFixed32(val, buf2, pos) {
      buf2[pos] = val & 255;
      buf2[pos + 1] = val >>> 8 & 255;
      buf2[pos + 2] = val >>> 16 & 255;
      buf2[pos + 3] = val >>> 24;
    }
    Writer.prototype.fixed32 = function write_fixed32(value) {
      return this._push(writeFixed32, 4, value >>> 0);
    };
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = function write_fixed64(value) {
      var bits = LongBits.from(value);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    };
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = function write_float(value) {
      return this._push(util.float.writeFloatLE, 4, value);
    };
    Writer.prototype.double = function write_double(value) {
      return this._push(util.float.writeDoubleLE, 8, value);
    };
    var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf2, pos) {
      buf2.set(val, pos);
    } : function writeBytes_for(val, buf2, pos) {
      for (var i = 0; i < val.length; ++i)
        buf2[pos + i] = val[i];
    };
    Writer.prototype.bytes = function write_bytes(value) {
      var len = value.length >>> 0;
      if (!len)
        return this._push(writeByte, 1, 0);
      if (util.isString(value)) {
        var buf2 = Writer.alloc(len = base642.length(value));
        base642.decode(value, buf2, 0);
        value = buf2;
      }
      return this.uint32(len)._push(writeBytes, len, value);
    };
    Writer.prototype.string = function write_string(value) {
      var len = utf8.length(value);
      return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
    };
    Writer.prototype.fork = function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop2, 0, 0);
      this.len = 0;
      return this;
    };
    Writer.prototype.reset = function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop2, 0, 0);
        this.len = 0;
      }
      return this;
    };
    Writer.prototype.ldelim = function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    };
    Writer.prototype.finish = function finish() {
      var head = this.head.next, buf2 = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf2, pos);
        pos += head.len;
        head = head.next;
      }
      return buf2;
    };
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create7();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    BufferWriter._configure = function() {
      BufferWriter.alloc = util._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf2, pos) {
        buf2.set(val, pos);
      } : function writeBytesBuffer_copy(val, buf2, pos) {
        if (val.copy)
          val.copy(buf2, pos, 0, val.length);
        else
          for (var i = 0; i < val.length; )
            buf2[pos++] = val[i++];
      };
    };
    BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
      if (util.isString(value))
        value = util._Buffer_from(value, "base64");
      var len = value.length >>> 0;
      this.uint32(len);
      if (len)
        this._push(BufferWriter.writeBytesBuffer, len, value);
      return this;
    };
    function writeStringBuffer(val, buf2, pos) {
      if (val.length < 40)
        util.utf8.write(val, buf2, pos);
      else if (buf2.utf8Write)
        buf2.utf8Write(val, pos);
      else
        buf2.write(val, pos);
    }
    BufferWriter.prototype.string = function write_string_buffer(value) {
      var len = util.Buffer.byteLength(value);
      this.uint32(len);
      if (len)
        this._push(writeStringBuffer, len, value);
      return this;
    };
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = Reader;
    var util = require_minimal();
    var BufferReader;
    var LongBits = util.LongBits;
    var utf8 = util.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    function Reader(buffer2) {
      this.buf = buffer2;
      this.pos = 0;
      this.len = buffer2.length;
    }
    var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer2) {
      if (buffer2 instanceof Uint8Array || Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    } : function create_array2(buffer2) {
      if (Array.isArray(buffer2))
        return new Reader(buffer2);
      throw Error("illegal buffer");
    };
    var create7 = function create8() {
      return util.Buffer ? function create_buffer_setup(buffer2) {
        return (Reader.create = function create_buffer(buffer3) {
          return util.Buffer.isBuffer(buffer3) ? new BufferReader(buffer3) : create_array(buffer3);
        })(buffer2);
      } : create_array;
    };
    Reader.create = create7();
    Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
    Reader.prototype.uint32 = function read_uint32_setup() {
      var value = 4294967295;
      return function read_uint32() {
        value = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128)
          return value;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value;
      };
    }();
    Reader.prototype.int32 = function read_int32() {
      return this.uint32() | 0;
    };
    Reader.prototype.sint32 = function read_sint32() {
      var value = this.uint32();
      return value >>> 1 ^ -(value & 1) | 0;
    };
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128)
            return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    Reader.prototype.bool = function read_bool() {
      return this.uint32() !== 0;
    };
    function readFixed32_end(buf2, end) {
      return (buf2[end - 4] | buf2[end - 3] << 8 | buf2[end - 2] << 16 | buf2[end - 1] << 24) >>> 0;
    }
    Reader.prototype.fixed32 = function read_fixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    };
    Reader.prototype.sfixed32 = function read_sfixed32() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    };
    function readFixed64() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    Reader.prototype.float = function read_float() {
      if (this.pos + 4 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value;
    };
    Reader.prototype.double = function read_double() {
      if (this.pos + 8 > this.len)
        throw indexOutOfRange(this, 4);
      var value = util.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value;
    };
    Reader.prototype.bytes = function read_bytes() {
      var length4 = this.uint32(), start = this.pos, end = this.pos + length4;
      if (end > this.len)
        throw indexOutOfRange(this, length4);
      this.pos += length4;
      if (Array.isArray(this.buf))
        return this.buf.slice(start, end);
      return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
    };
    Reader.prototype.string = function read_string() {
      var bytes3 = this.bytes();
      return utf8.read(bytes3, 0, bytes3.length);
    };
    Reader.prototype.skip = function skip(length4) {
      if (typeof length4 === "number") {
        if (this.pos + length4 > this.len)
          throw indexOutOfRange(this, length4);
        this.pos += length4;
      } else {
        do {
          if (this.pos >= this.len)
            throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    };
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create7();
      BufferReader._configure();
      var fn = util.Long ? "toLong" : "toNumber";
      util.merge(Reader.prototype, {
        int64: function read_int64() {
          return readLongVarint.call(this)[fn](false);
        },
        uint64: function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        },
        sint64: function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        },
        fixed64: function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        },
        sfixed64: function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util = require_minimal();
    function BufferReader(buffer2) {
      Reader.call(this, buffer2);
    }
    BufferReader._configure = function() {
      if (util.Buffer)
        BufferReader.prototype._slice = util.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    };
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = Service;
    var util = require_minimal();
    (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function")
        throw TypeError("rpcImpl must be a function");
      util.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request)
        throw TypeError("request must be specified");
      var self2 = this;
      if (!callback)
        return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
          if (err) {
            self2.emit("error", err, method);
            return callback(err);
          }
          if (response === null) {
            self2.end(true);
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
          }
          self2.emit("data", response, method);
          return callback(null, response);
        });
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    };
    Service.prototype.end = function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC)
          this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    };
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    init_node_globals();
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    init_node_globals();
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure2;
    function configure2() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    configure2();
  }
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS({
  "node_modules/protobufjs/minimal.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = require_index_minimal();
  }
});

// node_modules/ipfs-unixfs/esm/src/unixfs.js
var import_minimal, $Reader, $Writer, $util, $root, Data, UnixTime, Metadata;
var init_unixfs = __esm({
  "node_modules/ipfs-unixfs/esm/src/unixfs.js"() {
    init_node_globals();
    import_minimal = __toModule(require_minimal2());
    $Reader = import_minimal.default.Reader;
    $Writer = import_minimal.default.Writer;
    $util = import_minimal.default.util;
    $root = import_minimal.default.roots["ipfs-unixfs"] || (import_minimal.default.roots["ipfs-unixfs"] = {});
    Data = $root.Data = (() => {
      function Data2(p) {
        this.blocksizes = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Data2.prototype.Type = 0;
      Data2.prototype.Data = $util.newBuffer([]);
      Data2.prototype.filesize = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
      Data2.prototype.blocksizes = $util.emptyArray;
      Data2.prototype.hashType = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
      Data2.prototype.fanout = $util.Long ? $util.Long.fromBits(0, 0, true) : 0;
      Data2.prototype.mode = 0;
      Data2.prototype.mtime = null;
      Data2.encode = function encode10(m, w) {
        if (!w)
          w = $Writer.create();
        w.uint32(8).int32(m.Type);
        if (m.Data != null && Object.hasOwnProperty.call(m, "Data"))
          w.uint32(18).bytes(m.Data);
        if (m.filesize != null && Object.hasOwnProperty.call(m, "filesize"))
          w.uint32(24).uint64(m.filesize);
        if (m.blocksizes != null && m.blocksizes.length) {
          for (var i = 0; i < m.blocksizes.length; ++i)
            w.uint32(32).uint64(m.blocksizes[i]);
        }
        if (m.hashType != null && Object.hasOwnProperty.call(m, "hashType"))
          w.uint32(40).uint64(m.hashType);
        if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
          w.uint32(48).uint64(m.fanout);
        if (m.mode != null && Object.hasOwnProperty.call(m, "mode"))
          w.uint32(56).uint32(m.mode);
        if (m.mtime != null && Object.hasOwnProperty.call(m, "mtime"))
          $root.UnixTime.encode(m.mtime, w.uint32(66).fork()).ldelim();
        return w;
      };
      Data2.decode = function decode12(r, l) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root.Data();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Type = r.int32();
              break;
            case 2:
              m.Data = r.bytes();
              break;
            case 3:
              m.filesize = r.uint64();
              break;
            case 4:
              if (!(m.blocksizes && m.blocksizes.length))
                m.blocksizes = [];
              if ((t & 7) === 2) {
                var c2 = r.uint32() + r.pos;
                while (r.pos < c2)
                  m.blocksizes.push(r.uint64());
              } else
                m.blocksizes.push(r.uint64());
              break;
            case 5:
              m.hashType = r.uint64();
              break;
            case 6:
              m.fanout = r.uint64();
              break;
            case 7:
              m.mode = r.uint32();
              break;
            case 8:
              m.mtime = $root.UnixTime.decode(r, r.uint32());
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Type"))
          throw $util.ProtocolError("missing required 'Type'", { instance: m });
        return m;
      };
      Data2.fromObject = function fromObject(d) {
        if (d instanceof $root.Data)
          return d;
        var m = new $root.Data();
        switch (d.Type) {
          case "Raw":
          case 0:
            m.Type = 0;
            break;
          case "Directory":
          case 1:
            m.Type = 1;
            break;
          case "File":
          case 2:
            m.Type = 2;
            break;
          case "Metadata":
          case 3:
            m.Type = 3;
            break;
          case "Symlink":
          case 4:
            m.Type = 4;
            break;
          case "HAMTShard":
          case 5:
            m.Type = 5;
            break;
        }
        if (d.Data != null) {
          if (typeof d.Data === "string")
            $util.base64.decode(d.Data, m.Data = $util.newBuffer($util.base64.length(d.Data)), 0);
          else if (d.Data.length)
            m.Data = d.Data;
        }
        if (d.filesize != null) {
          if ($util.Long)
            (m.filesize = $util.Long.fromValue(d.filesize)).unsigned = true;
          else if (typeof d.filesize === "string")
            m.filesize = parseInt(d.filesize, 10);
          else if (typeof d.filesize === "number")
            m.filesize = d.filesize;
          else if (typeof d.filesize === "object")
            m.filesize = new $util.LongBits(d.filesize.low >>> 0, d.filesize.high >>> 0).toNumber(true);
        }
        if (d.blocksizes) {
          if (!Array.isArray(d.blocksizes))
            throw TypeError(".Data.blocksizes: array expected");
          m.blocksizes = [];
          for (var i = 0; i < d.blocksizes.length; ++i) {
            if ($util.Long)
              (m.blocksizes[i] = $util.Long.fromValue(d.blocksizes[i])).unsigned = true;
            else if (typeof d.blocksizes[i] === "string")
              m.blocksizes[i] = parseInt(d.blocksizes[i], 10);
            else if (typeof d.blocksizes[i] === "number")
              m.blocksizes[i] = d.blocksizes[i];
            else if (typeof d.blocksizes[i] === "object")
              m.blocksizes[i] = new $util.LongBits(d.blocksizes[i].low >>> 0, d.blocksizes[i].high >>> 0).toNumber(true);
          }
        }
        if (d.hashType != null) {
          if ($util.Long)
            (m.hashType = $util.Long.fromValue(d.hashType)).unsigned = true;
          else if (typeof d.hashType === "string")
            m.hashType = parseInt(d.hashType, 10);
          else if (typeof d.hashType === "number")
            m.hashType = d.hashType;
          else if (typeof d.hashType === "object")
            m.hashType = new $util.LongBits(d.hashType.low >>> 0, d.hashType.high >>> 0).toNumber(true);
        }
        if (d.fanout != null) {
          if ($util.Long)
            (m.fanout = $util.Long.fromValue(d.fanout)).unsigned = true;
          else if (typeof d.fanout === "string")
            m.fanout = parseInt(d.fanout, 10);
          else if (typeof d.fanout === "number")
            m.fanout = d.fanout;
          else if (typeof d.fanout === "object")
            m.fanout = new $util.LongBits(d.fanout.low >>> 0, d.fanout.high >>> 0).toNumber(true);
        }
        if (d.mode != null) {
          m.mode = d.mode >>> 0;
        }
        if (d.mtime != null) {
          if (typeof d.mtime !== "object")
            throw TypeError(".Data.mtime: object expected");
          m.mtime = $root.UnixTime.fromObject(d.mtime);
        }
        return m;
      };
      Data2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.blocksizes = [];
        }
        if (o.defaults) {
          d.Type = o.enums === String ? "Raw" : 0;
          if (o.bytes === String)
            d.Data = "";
          else {
            d.Data = [];
            if (o.bytes !== Array)
              d.Data = $util.newBuffer(d.Data);
          }
          if ($util.Long) {
            var n = new $util.Long(0, 0, true);
            d.filesize = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.filesize = o.longs === String ? "0" : 0;
          if ($util.Long) {
            var n = new $util.Long(0, 0, true);
            d.hashType = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.hashType = o.longs === String ? "0" : 0;
          if ($util.Long) {
            var n = new $util.Long(0, 0, true);
            d.fanout = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.fanout = o.longs === String ? "0" : 0;
          d.mode = 0;
          d.mtime = null;
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root.Data.DataType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        if (m.filesize != null && m.hasOwnProperty("filesize")) {
          if (typeof m.filesize === "number")
            d.filesize = o.longs === String ? String(m.filesize) : m.filesize;
          else
            d.filesize = o.longs === String ? $util.Long.prototype.toString.call(m.filesize) : o.longs === Number ? new $util.LongBits(m.filesize.low >>> 0, m.filesize.high >>> 0).toNumber(true) : m.filesize;
        }
        if (m.blocksizes && m.blocksizes.length) {
          d.blocksizes = [];
          for (var j = 0; j < m.blocksizes.length; ++j) {
            if (typeof m.blocksizes[j] === "number")
              d.blocksizes[j] = o.longs === String ? String(m.blocksizes[j]) : m.blocksizes[j];
            else
              d.blocksizes[j] = o.longs === String ? $util.Long.prototype.toString.call(m.blocksizes[j]) : o.longs === Number ? new $util.LongBits(m.blocksizes[j].low >>> 0, m.blocksizes[j].high >>> 0).toNumber(true) : m.blocksizes[j];
          }
        }
        if (m.hashType != null && m.hasOwnProperty("hashType")) {
          if (typeof m.hashType === "number")
            d.hashType = o.longs === String ? String(m.hashType) : m.hashType;
          else
            d.hashType = o.longs === String ? $util.Long.prototype.toString.call(m.hashType) : o.longs === Number ? new $util.LongBits(m.hashType.low >>> 0, m.hashType.high >>> 0).toNumber(true) : m.hashType;
        }
        if (m.fanout != null && m.hasOwnProperty("fanout")) {
          if (typeof m.fanout === "number")
            d.fanout = o.longs === String ? String(m.fanout) : m.fanout;
          else
            d.fanout = o.longs === String ? $util.Long.prototype.toString.call(m.fanout) : o.longs === Number ? new $util.LongBits(m.fanout.low >>> 0, m.fanout.high >>> 0).toNumber(true) : m.fanout;
        }
        if (m.mode != null && m.hasOwnProperty("mode")) {
          d.mode = m.mode;
        }
        if (m.mtime != null && m.hasOwnProperty("mtime")) {
          d.mtime = $root.UnixTime.toObject(m.mtime, o);
        }
        return d;
      };
      Data2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      };
      Data2.DataType = function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Raw"] = 0;
        values[valuesById[1] = "Directory"] = 1;
        values[valuesById[2] = "File"] = 2;
        values[valuesById[3] = "Metadata"] = 3;
        values[valuesById[4] = "Symlink"] = 4;
        values[valuesById[5] = "HAMTShard"] = 5;
        return values;
      }();
      return Data2;
    })();
    UnixTime = $root.UnixTime = (() => {
      function UnixTime2(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      UnixTime2.prototype.Seconds = $util.Long ? $util.Long.fromBits(0, 0, false) : 0;
      UnixTime2.prototype.FractionalNanoseconds = 0;
      UnixTime2.encode = function encode10(m, w) {
        if (!w)
          w = $Writer.create();
        w.uint32(8).int64(m.Seconds);
        if (m.FractionalNanoseconds != null && Object.hasOwnProperty.call(m, "FractionalNanoseconds"))
          w.uint32(21).fixed32(m.FractionalNanoseconds);
        return w;
      };
      UnixTime2.decode = function decode12(r, l) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root.UnixTime();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Seconds = r.int64();
              break;
            case 2:
              m.FractionalNanoseconds = r.fixed32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Seconds"))
          throw $util.ProtocolError("missing required 'Seconds'", { instance: m });
        return m;
      };
      UnixTime2.fromObject = function fromObject(d) {
        if (d instanceof $root.UnixTime)
          return d;
        var m = new $root.UnixTime();
        if (d.Seconds != null) {
          if ($util.Long)
            (m.Seconds = $util.Long.fromValue(d.Seconds)).unsigned = false;
          else if (typeof d.Seconds === "string")
            m.Seconds = parseInt(d.Seconds, 10);
          else if (typeof d.Seconds === "number")
            m.Seconds = d.Seconds;
          else if (typeof d.Seconds === "object")
            m.Seconds = new $util.LongBits(d.Seconds.low >>> 0, d.Seconds.high >>> 0).toNumber();
        }
        if (d.FractionalNanoseconds != null) {
          m.FractionalNanoseconds = d.FractionalNanoseconds >>> 0;
        }
        return m;
      };
      UnixTime2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if ($util.Long) {
            var n = new $util.Long(0, 0, false);
            d.Seconds = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.Seconds = o.longs === String ? "0" : 0;
          d.FractionalNanoseconds = 0;
        }
        if (m.Seconds != null && m.hasOwnProperty("Seconds")) {
          if (typeof m.Seconds === "number")
            d.Seconds = o.longs === String ? String(m.Seconds) : m.Seconds;
          else
            d.Seconds = o.longs === String ? $util.Long.prototype.toString.call(m.Seconds) : o.longs === Number ? new $util.LongBits(m.Seconds.low >>> 0, m.Seconds.high >>> 0).toNumber() : m.Seconds;
        }
        if (m.FractionalNanoseconds != null && m.hasOwnProperty("FractionalNanoseconds")) {
          d.FractionalNanoseconds = m.FractionalNanoseconds;
        }
        return d;
      };
      UnixTime2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      };
      return UnixTime2;
    })();
    Metadata = $root.Metadata = (() => {
      function Metadata2(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Metadata2.prototype.MimeType = "";
      Metadata2.encode = function encode10(m, w) {
        if (!w)
          w = $Writer.create();
        if (m.MimeType != null && Object.hasOwnProperty.call(m, "MimeType"))
          w.uint32(10).string(m.MimeType);
        return w;
      };
      Metadata2.decode = function decode12(r, l) {
        if (!(r instanceof $Reader))
          r = $Reader.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root.Metadata();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.MimeType = r.string();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Metadata2.fromObject = function fromObject(d) {
        if (d instanceof $root.Metadata)
          return d;
        var m = new $root.Metadata();
        if (d.MimeType != null) {
          m.MimeType = String(d.MimeType);
        }
        return m;
      };
      Metadata2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.MimeType = "";
        }
        if (m.MimeType != null && m.hasOwnProperty("MimeType")) {
          d.MimeType = m.MimeType;
        }
        return d;
      };
      Metadata2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal.default.util.toJSONOptions);
      };
      return Metadata2;
    })();
  }
});

// node_modules/ipfs-unixfs/esm/src/index.js
var src_exports = {};
__export(src_exports, {
  UnixFS: () => UnixFS,
  parseMode: () => parseMode,
  parseMtime: () => parseMtime
});
function parseMode(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "number") {
    return mode & 4095;
  }
  mode = mode.toString();
  if (mode.substring(0, 1) === "0") {
    return parseInt(mode, 8) & 4095;
  }
  return parseInt(mode, 10) & 4095;
}
function parseMtime(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var import_err_code, PBData, types, dirTypes, DEFAULT_FILE_MODE, DEFAULT_DIRECTORY_MODE, UnixFS;
var init_src = __esm({
  "node_modules/ipfs-unixfs/esm/src/index.js"() {
    init_node_globals();
    import_err_code = __toModule(require_err_code());
    init_unixfs();
    PBData = Data;
    types = [
      "raw",
      "directory",
      "file",
      "metadata",
      "symlink",
      "hamt-sharded-directory"
    ];
    dirTypes = [
      "directory",
      "hamt-sharded-directory"
    ];
    DEFAULT_FILE_MODE = parseInt("0644", 8);
    DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
    UnixFS = class {
      static unmarshal(marshaled) {
        const message = PBData.decode(marshaled);
        const decoded = PBData.toObject(message, {
          defaults: false,
          arrays: true,
          longs: Number,
          objects: false
        });
        const data = new UnixFS({
          type: types[decoded.Type],
          data: decoded.Data,
          blockSizes: decoded.blocksizes,
          mode: decoded.mode,
          mtime: decoded.mtime ? {
            secs: decoded.mtime.Seconds,
            nsecs: decoded.mtime.FractionalNanoseconds
          } : void 0
        });
        data._originalMode = decoded.mode || 0;
        return data;
      }
      constructor(options = { type: "file" }) {
        const { type, data, blockSizes, hashType, fanout, mtime, mode } = options;
        if (type && !types.includes(type)) {
          throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
        }
        this.type = type || "file";
        this.data = data;
        this.hashType = hashType;
        this.fanout = fanout;
        this.blockSizes = blockSizes || [];
        this._originalMode = 0;
        this.mode = parseMode(mode);
        if (mtime) {
          this.mtime = parseMtime(mtime);
          if (this.mtime && !this.mtime.nsecs) {
            this.mtime.nsecs = 0;
          }
        }
      }
      set mode(mode) {
        this._mode = this.isDirectory() ? DEFAULT_DIRECTORY_MODE : DEFAULT_FILE_MODE;
        const parsedMode = parseMode(mode);
        if (parsedMode !== void 0) {
          this._mode = parsedMode;
        }
      }
      get mode() {
        return this._mode;
      }
      isDirectory() {
        return Boolean(this.type && dirTypes.includes(this.type));
      }
      addBlockSize(size) {
        this.blockSizes.push(size);
      }
      removeBlockSize(index) {
        this.blockSizes.splice(index, 1);
      }
      fileSize() {
        if (this.isDirectory()) {
          return 0;
        }
        let sum = 0;
        this.blockSizes.forEach((size) => {
          sum += size;
        });
        if (this.data) {
          sum += this.data.length;
        }
        return sum;
      }
      marshal() {
        let type;
        switch (this.type) {
          case "raw":
            type = PBData.DataType.Raw;
            break;
          case "directory":
            type = PBData.DataType.Directory;
            break;
          case "file":
            type = PBData.DataType.File;
            break;
          case "metadata":
            type = PBData.DataType.Metadata;
            break;
          case "symlink":
            type = PBData.DataType.Symlink;
            break;
          case "hamt-sharded-directory":
            type = PBData.DataType.HAMTShard;
            break;
          default:
            throw (0, import_err_code.default)(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
        }
        let data = this.data;
        if (!this.data || !this.data.length) {
          data = void 0;
        }
        let mode;
        if (this.mode != null) {
          mode = this._originalMode & 4294963200 | (parseMode(this.mode) || 0);
          if (mode === DEFAULT_FILE_MODE && !this.isDirectory()) {
            mode = void 0;
          }
          if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
            mode = void 0;
          }
        }
        let mtime;
        if (this.mtime != null) {
          const parsed = parseMtime(this.mtime);
          if (parsed) {
            mtime = {
              Seconds: parsed.secs,
              FractionalNanoseconds: parsed.nsecs
            };
            if (mtime.FractionalNanoseconds === 0) {
              delete mtime.FractionalNanoseconds;
            }
          }
        }
        const pbData = {
          Type: type,
          Data: data,
          filesize: this.isDirectory() ? void 0 : this.fileSize(),
          blocksizes: this.blockSizes,
          hashType: this.hashType,
          fanout: this.fanout,
          mode,
          mtime
        };
        return PBData.encode(pbData).finish();
      }
    };
  }
});

// node_modules/multiformats/esm/vendor/varint.js
function encode(num, out, offset) {
  out = out || [];
  offset = offset || 0;
  var oldOffset = offset;
  while (num >= INT) {
    out[offset++] = num & 255 | MSB;
    num /= 128;
  }
  while (num & MSBALL) {
    out[offset++] = num & 255 | MSB;
    num >>>= 7;
  }
  out[offset] = num | 0;
  encode.bytes = offset - oldOffset + 1;
  return out;
}
function read(buf2, offset) {
  var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
  do {
    if (counter >= l) {
      read.bytes = 0;
      throw new RangeError("Could not decode varint");
    }
    b = buf2[counter++];
    res += shift < 28 ? (b & REST$1) << shift : (b & REST$1) * Math.pow(2, shift);
    shift += 7;
  } while (b >= MSB$1);
  read.bytes = counter - offset;
  return res;
}
var encode_1, MSB, REST, MSBALL, INT, decode, MSB$1, REST$1, N1, N2, N3, N4, N5, N6, N7, N8, N9, length, varint, _brrp_varint, varint_default;
var init_varint = __esm({
  "node_modules/multiformats/esm/vendor/varint.js"() {
    init_node_globals();
    encode_1 = encode;
    MSB = 128;
    REST = 127;
    MSBALL = ~REST;
    INT = Math.pow(2, 31);
    decode = read;
    MSB$1 = 128;
    REST$1 = 127;
    N1 = Math.pow(2, 7);
    N2 = Math.pow(2, 14);
    N3 = Math.pow(2, 21);
    N4 = Math.pow(2, 28);
    N5 = Math.pow(2, 35);
    N6 = Math.pow(2, 42);
    N7 = Math.pow(2, 49);
    N8 = Math.pow(2, 56);
    N9 = Math.pow(2, 63);
    length = function(value) {
      return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
    };
    varint = {
      encode: encode_1,
      decode,
      encodingLength: length
    };
    _brrp_varint = varint;
    varint_default = _brrp_varint;
  }
});

// node_modules/multiformats/esm/src/varint.js
var varint_exports = {};
__export(varint_exports, {
  decode: () => decode2,
  encodeTo: () => encodeTo,
  encodingLength: () => encodingLength
});
var decode2, encodeTo, encodingLength;
var init_varint2 = __esm({
  "node_modules/multiformats/esm/src/varint.js"() {
    init_node_globals();
    init_varint();
    decode2 = (data) => {
      const code5 = varint_default.decode(data);
      return [
        code5,
        varint_default.decode.bytes
      ];
    };
    encodeTo = (int, target, offset = 0) => {
      varint_default.encode(int, target, offset);
      return target;
    };
    encodingLength = (int) => {
      return varint_default.encodingLength(int);
    };
  }
});

// node_modules/multiformats/esm/src/bytes.js
var bytes_exports = {};
__export(bytes_exports, {
  coerce: () => coerce,
  empty: () => empty,
  equals: () => equals,
  fromHex: () => fromHex,
  fromString: () => fromString,
  isBinary: () => isBinary,
  toHex: () => toHex,
  toString: () => toString
});
var empty, toHex, fromHex, equals, coerce, isBinary, fromString, toString;
var init_bytes = __esm({
  "node_modules/multiformats/esm/src/bytes.js"() {
    init_node_globals();
    empty = new Uint8Array(0);
    toHex = (d) => d.reduce((hex, byte) => hex + byte.toString(16).padStart(2, "0"), "");
    fromHex = (hex) => {
      const hexes = hex.match(/../g);
      return hexes ? new Uint8Array(hexes.map((b) => parseInt(b, 16))) : empty;
    };
    equals = (aa, bb) => {
      if (aa === bb)
        return true;
      if (aa.byteLength !== bb.byteLength) {
        return false;
      }
      for (let ii = 0; ii < aa.byteLength; ii++) {
        if (aa[ii] !== bb[ii]) {
          return false;
        }
      }
      return true;
    };
    coerce = (o) => {
      if (o instanceof Uint8Array && o.constructor.name === "Uint8Array")
        return o;
      if (o instanceof ArrayBuffer)
        return new Uint8Array(o);
      if (ArrayBuffer.isView(o)) {
        return new Uint8Array(o.buffer, o.byteOffset, o.byteLength);
      }
      throw new Error("Unknown type, must be binary type");
    };
    isBinary = (o) => o instanceof ArrayBuffer || ArrayBuffer.isView(o);
    fromString = (str) => new TextEncoder().encode(str);
    toString = (b) => new TextDecoder().decode(b);
  }
});

// node_modules/multiformats/esm/src/hashes/digest.js
var digest_exports = {};
__export(digest_exports, {
  Digest: () => Digest,
  create: () => create,
  decode: () => decode3,
  equals: () => equals2
});
var create, decode3, equals2, Digest;
var init_digest = __esm({
  "node_modules/multiformats/esm/src/hashes/digest.js"() {
    init_node_globals();
    init_bytes();
    init_varint2();
    create = (code5, digest) => {
      const size = digest.byteLength;
      const sizeOffset = encodingLength(code5);
      const digestOffset = sizeOffset + encodingLength(size);
      const bytes3 = new Uint8Array(digestOffset + size);
      encodeTo(code5, bytes3, 0);
      encodeTo(size, bytes3, sizeOffset);
      bytes3.set(digest, digestOffset);
      return new Digest(code5, size, digest, bytes3);
    };
    decode3 = (multihash) => {
      const bytes3 = coerce(multihash);
      const [code5, sizeOffset] = decode2(bytes3);
      const [size, digestOffset] = decode2(bytes3.subarray(sizeOffset));
      const digest = bytes3.subarray(sizeOffset + digestOffset);
      if (digest.byteLength !== size) {
        throw new Error("Incorrect length");
      }
      return new Digest(code5, size, digest, bytes3);
    };
    equals2 = (a, b) => {
      if (a === b) {
        return true;
      } else {
        return a.code === b.code && a.size === b.size && equals(a.bytes, b.bytes);
      }
    };
    Digest = class {
      constructor(code5, size, digest, bytes3) {
        this.code = code5;
        this.size = size;
        this.digest = digest;
        this.bytes = bytes3;
      }
    };
  }
});

// node_modules/multiformats/esm/vendor/base-x.js
function base(ALPHABET, name5) {
  if (ALPHABET.length >= 255) {
    throw new TypeError("Alphabet too long");
  }
  var BASE_MAP = new Uint8Array(256);
  for (var j = 0; j < BASE_MAP.length; j++) {
    BASE_MAP[j] = 255;
  }
  for (var i = 0; i < ALPHABET.length; i++) {
    var x = ALPHABET.charAt(i);
    var xc = x.charCodeAt(0);
    if (BASE_MAP[xc] !== 255) {
      throw new TypeError(x + " is ambiguous");
    }
    BASE_MAP[xc] = i;
  }
  var BASE = ALPHABET.length;
  var LEADER = ALPHABET.charAt(0);
  var FACTOR = Math.log(BASE) / Math.log(256);
  var iFACTOR = Math.log(256) / Math.log(BASE);
  function encode10(source) {
    if (source instanceof Uint8Array)
      ;
    else if (ArrayBuffer.isView(source)) {
      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
    } else if (Array.isArray(source)) {
      source = Uint8Array.from(source);
    }
    if (!(source instanceof Uint8Array)) {
      throw new TypeError("Expected Uint8Array");
    }
    if (source.length === 0) {
      return "";
    }
    var zeroes = 0;
    var length4 = 0;
    var pbegin = 0;
    var pend = source.length;
    while (pbegin !== pend && source[pbegin] === 0) {
      pbegin++;
      zeroes++;
    }
    var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
    var b58 = new Uint8Array(size);
    while (pbegin !== pend) {
      var carry = source[pbegin];
      var i2 = 0;
      for (var it1 = size - 1; (carry !== 0 || i2 < length4) && it1 !== -1; it1--, i2++) {
        carry += 256 * b58[it1] >>> 0;
        b58[it1] = carry % BASE >>> 0;
        carry = carry / BASE >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i2;
      pbegin++;
    }
    var it2 = size - length4;
    while (it2 !== size && b58[it2] === 0) {
      it2++;
    }
    var str = LEADER.repeat(zeroes);
    for (; it2 < size; ++it2) {
      str += ALPHABET.charAt(b58[it2]);
    }
    return str;
  }
  function decodeUnsafe(source) {
    if (typeof source !== "string") {
      throw new TypeError("Expected String");
    }
    if (source.length === 0) {
      return new Uint8Array();
    }
    var psz = 0;
    if (source[psz] === " ") {
      return;
    }
    var zeroes = 0;
    var length4 = 0;
    while (source[psz] === LEADER) {
      zeroes++;
      psz++;
    }
    var size = (source.length - psz) * FACTOR + 1 >>> 0;
    var b256 = new Uint8Array(size);
    while (source[psz]) {
      var carry = BASE_MAP[source.charCodeAt(psz)];
      if (carry === 255) {
        return;
      }
      var i2 = 0;
      for (var it3 = size - 1; (carry !== 0 || i2 < length4) && it3 !== -1; it3--, i2++) {
        carry += BASE * b256[it3] >>> 0;
        b256[it3] = carry % 256 >>> 0;
        carry = carry / 256 >>> 0;
      }
      if (carry !== 0) {
        throw new Error("Non-zero carry");
      }
      length4 = i2;
      psz++;
    }
    if (source[psz] === " ") {
      return;
    }
    var it4 = size - length4;
    while (it4 !== size && b256[it4] === 0) {
      it4++;
    }
    var vch = new Uint8Array(zeroes + (size - it4));
    var j2 = zeroes;
    while (it4 !== size) {
      vch[j2++] = b256[it4++];
    }
    return vch;
  }
  function decode12(string3) {
    var buffer2 = decodeUnsafe(string3);
    if (buffer2) {
      return buffer2;
    }
    throw new Error(`Non-${name5} character`);
  }
  return {
    encode: encode10,
    decodeUnsafe,
    decode: decode12
  };
}
var src, _brrp__multiformats_scope_baseX, base_x_default;
var init_base_x = __esm({
  "node_modules/multiformats/esm/vendor/base-x.js"() {
    init_node_globals();
    src = base;
    _brrp__multiformats_scope_baseX = src;
    base_x_default = _brrp__multiformats_scope_baseX;
  }
});

// node_modules/multiformats/esm/src/bases/base.js
var Encoder, Decoder, ComposedDecoder, Codec, from, baseX, decode4, encode2, rfc4648;
var init_base = __esm({
  "node_modules/multiformats/esm/src/bases/base.js"() {
    init_node_globals();
    init_base_x();
    init_bytes();
    Encoder = class {
      constructor(name5, prefix, baseEncode) {
        this.name = name5;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
      }
      encode(bytes3) {
        if (bytes3 instanceof Uint8Array) {
          return `${this.prefix}${this.baseEncode(bytes3)}`;
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
    Decoder = class {
      constructor(name5, prefix, baseDecode) {
        this.name = name5;
        this.prefix = prefix;
        this.baseDecode = baseDecode;
      }
      decode(text) {
        if (typeof text === "string") {
          switch (text[0]) {
            case this.prefix: {
              return this.baseDecode(text.slice(1));
            }
            default: {
              throw Error(`Unable to decode multibase string ${JSON.stringify(text)}, ${this.name} decoder only supports inputs prefixed with ${this.prefix}`);
            }
          }
        } else {
          throw Error("Can only multibase decode strings");
        }
      }
      or(decoder) {
        const decoders = {
          [this.prefix]: this,
          ...decoder.decoders || { [decoder.prefix]: decoder }
        };
        return new ComposedDecoder(decoders);
      }
    };
    ComposedDecoder = class {
      constructor(decoders) {
        this.decoders = decoders;
      }
      or(decoder) {
        const other = decoder.decoders || { [decoder.prefix]: decoder };
        return new ComposedDecoder({
          ...this.decoders,
          ...other
        });
      }
      decode(input) {
        const prefix = input[0];
        const decoder = this.decoders[prefix];
        if (decoder) {
          return decoder.decode(input);
        } else {
          throw RangeError(`Unable to decode multibase string ${JSON.stringify(input)}, only inputs prefixed with ${Object.keys(this.decoders)} are supported`);
        }
      }
    };
    Codec = class {
      constructor(name5, prefix, baseEncode, baseDecode) {
        this.name = name5;
        this.prefix = prefix;
        this.baseEncode = baseEncode;
        this.baseDecode = baseDecode;
        this.encoder = new Encoder(name5, prefix, baseEncode);
        this.decoder = new Decoder(name5, prefix, baseDecode);
      }
      encode(input) {
        return this.encoder.encode(input);
      }
      decode(input) {
        return this.decoder.decode(input);
      }
    };
    from = ({ name: name5, prefix, encode: encode10, decode: decode12 }) => new Codec(name5, prefix, encode10, decode12);
    baseX = ({ prefix, name: name5, alphabet }) => {
      const { encode: encode10, decode: decode12 } = base_x_default(alphabet, name5);
      return from({
        prefix,
        name: name5,
        encode: encode10,
        decode: (text) => coerce(decode12(text))
      });
    };
    decode4 = (string3, alphabet, bitsPerChar, name5) => {
      const codes = {};
      for (let i = 0; i < alphabet.length; ++i) {
        codes[alphabet[i]] = i;
      }
      let end = string3.length;
      while (string3[end - 1] === "=") {
        --end;
      }
      const out = new Uint8Array(end * bitsPerChar / 8 | 0);
      let bits = 0;
      let buffer2 = 0;
      let written = 0;
      for (let i = 0; i < end; ++i) {
        const value = codes[string3[i]];
        if (value === void 0) {
          throw new SyntaxError(`Non-${name5} character`);
        }
        buffer2 = buffer2 << bitsPerChar | value;
        bits += bitsPerChar;
        if (bits >= 8) {
          bits -= 8;
          out[written++] = 255 & buffer2 >> bits;
        }
      }
      if (bits >= bitsPerChar || 255 & buffer2 << 8 - bits) {
        throw new SyntaxError("Unexpected end of data");
      }
      return out;
    };
    encode2 = (data, alphabet, bitsPerChar) => {
      const pad = alphabet[alphabet.length - 1] === "=";
      const mask = (1 << bitsPerChar) - 1;
      let out = "";
      let bits = 0;
      let buffer2 = 0;
      for (let i = 0; i < data.length; ++i) {
        buffer2 = buffer2 << 8 | data[i];
        bits += 8;
        while (bits > bitsPerChar) {
          bits -= bitsPerChar;
          out += alphabet[mask & buffer2 >> bits];
        }
      }
      if (bits) {
        out += alphabet[mask & buffer2 << bitsPerChar - bits];
      }
      if (pad) {
        while (out.length * bitsPerChar & 7) {
          out += "=";
        }
      }
      return out;
    };
    rfc4648 = ({ name: name5, prefix, bitsPerChar, alphabet }) => {
      return from({
        prefix,
        name: name5,
        encode(input) {
          return encode2(input, alphabet, bitsPerChar);
        },
        decode(input) {
          return decode4(input, alphabet, bitsPerChar, name5);
        }
      });
    };
  }
});

// node_modules/multiformats/esm/src/bases/base58.js
var base58_exports = {};
__export(base58_exports, {
  base58btc: () => base58btc,
  base58flickr: () => base58flickr
});
var base58btc, base58flickr;
var init_base58 = __esm({
  "node_modules/multiformats/esm/src/bases/base58.js"() {
    init_node_globals();
    init_base();
    base58btc = baseX({
      name: "base58btc",
      prefix: "z",
      alphabet: "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"
    });
    base58flickr = baseX({
      name: "base58flickr",
      prefix: "Z",
      alphabet: "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base32.js
var base32_exports = {};
__export(base32_exports, {
  base32: () => base32,
  base32hex: () => base32hex,
  base32hexpad: () => base32hexpad,
  base32hexpadupper: () => base32hexpadupper,
  base32hexupper: () => base32hexupper,
  base32pad: () => base32pad,
  base32padupper: () => base32padupper,
  base32upper: () => base32upper,
  base32z: () => base32z
});
var base32, base32upper, base32pad, base32padupper, base32hex, base32hexupper, base32hexpad, base32hexpadupper, base32z;
var init_base32 = __esm({
  "node_modules/multiformats/esm/src/bases/base32.js"() {
    init_node_globals();
    init_base();
    base32 = rfc4648({
      prefix: "b",
      name: "base32",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567",
      bitsPerChar: 5
    });
    base32upper = rfc4648({
      prefix: "B",
      name: "base32upper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
      bitsPerChar: 5
    });
    base32pad = rfc4648({
      prefix: "c",
      name: "base32pad",
      alphabet: "abcdefghijklmnopqrstuvwxyz234567=",
      bitsPerChar: 5
    });
    base32padupper = rfc4648({
      prefix: "C",
      name: "base32padupper",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567=",
      bitsPerChar: 5
    });
    base32hex = rfc4648({
      prefix: "v",
      name: "base32hex",
      alphabet: "0123456789abcdefghijklmnopqrstuv",
      bitsPerChar: 5
    });
    base32hexupper = rfc4648({
      prefix: "V",
      name: "base32hexupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
      bitsPerChar: 5
    });
    base32hexpad = rfc4648({
      prefix: "t",
      name: "base32hexpad",
      alphabet: "0123456789abcdefghijklmnopqrstuv=",
      bitsPerChar: 5
    });
    base32hexpadupper = rfc4648({
      prefix: "T",
      name: "base32hexpadupper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV=",
      bitsPerChar: 5
    });
    base32z = rfc4648({
      prefix: "h",
      name: "base32z",
      alphabet: "ybndrfg8ejkmcpqxot1uwisza345h769",
      bitsPerChar: 5
    });
  }
});

// node_modules/multiformats/esm/src/cid.js
var cid_exports = {};
__export(cid_exports, {
  CID: () => CID
});
var CID, parseCIDtoBytes, toStringV0, toStringV1, DAG_PB_CODE, SHA_256_CODE, encodeCID, cidSymbol, readonly, hidden, version, deprecate, IS_CID_DEPRECATION;
var init_cid = __esm({
  "node_modules/multiformats/esm/src/cid.js"() {
    init_node_globals();
    init_varint2();
    init_digest();
    init_base58();
    init_base32();
    init_bytes();
    CID = class {
      constructor(version3, code5, multihash, bytes3) {
        this.code = code5;
        this.version = version3;
        this.multihash = multihash;
        this.bytes = bytes3;
        this.byteOffset = bytes3.byteOffset;
        this.byteLength = bytes3.byteLength;
        this.asCID = this;
        this._baseCache = new Map();
        Object.defineProperties(this, {
          byteOffset: hidden,
          byteLength: hidden,
          code: readonly,
          version: readonly,
          multihash: readonly,
          bytes: readonly,
          _baseCache: hidden,
          asCID: hidden
        });
      }
      toV0() {
        switch (this.version) {
          case 0: {
            return this;
          }
          default: {
            const { code: code5, multihash } = this;
            if (code5 !== DAG_PB_CODE) {
              throw new Error("Cannot convert a non dag-pb CID to CIDv0");
            }
            if (multihash.code !== SHA_256_CODE) {
              throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
            }
            return CID.createV0(multihash);
          }
        }
      }
      toV1() {
        switch (this.version) {
          case 0: {
            const { code: code5, digest } = this.multihash;
            const multihash = create(code5, digest);
            return CID.createV1(this.code, multihash);
          }
          case 1: {
            return this;
          }
          default: {
            throw Error(`Can not convert CID version ${this.version} to version 0. This is a bug please report`);
          }
        }
      }
      equals(other) {
        return other && this.code === other.code && this.version === other.version && equals2(this.multihash, other.multihash);
      }
      toString(base3) {
        const { bytes: bytes3, version: version3, _baseCache } = this;
        switch (version3) {
          case 0:
            return toStringV0(bytes3, _baseCache, base3 || base58btc.encoder);
          default:
            return toStringV1(bytes3, _baseCache, base3 || base32.encoder);
        }
      }
      toJSON() {
        return {
          code: this.code,
          version: this.version,
          hash: this.multihash.bytes
        };
      }
      get [Symbol.toStringTag]() {
        return "CID";
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return "CID(" + this.toString() + ")";
      }
      static isCID(value) {
        deprecate(/^0\.0/, IS_CID_DEPRECATION);
        return !!(value && (value[cidSymbol] || value.asCID === value));
      }
      get toBaseEncodedString() {
        throw new Error("Deprecated, use .toString()");
      }
      get codec() {
        throw new Error('"codec" property is deprecated, use integer "code" property instead');
      }
      get buffer() {
        throw new Error("Deprecated .buffer property, use .bytes to get Uint8Array instead");
      }
      get multibaseName() {
        throw new Error('"multibaseName" property is deprecated');
      }
      get prefix() {
        throw new Error('"prefix" property is deprecated');
      }
      static asCID(value) {
        if (value instanceof CID) {
          return value;
        } else if (value != null && value.asCID === value) {
          const { version: version3, code: code5, multihash, bytes: bytes3 } = value;
          return new CID(version3, code5, multihash, bytes3 || encodeCID(version3, code5, multihash.bytes));
        } else if (value != null && value[cidSymbol] === true) {
          const { version: version3, multihash, code: code5 } = value;
          const digest = decode3(multihash);
          return CID.create(version3, code5, digest);
        } else {
          return null;
        }
      }
      static create(version3, code5, digest) {
        if (typeof code5 !== "number") {
          throw new Error("String codecs are no longer supported");
        }
        switch (version3) {
          case 0: {
            if (code5 !== DAG_PB_CODE) {
              throw new Error(`Version 0 CID must use dag-pb (code: ${DAG_PB_CODE}) block encoding`);
            } else {
              return new CID(version3, code5, digest, digest.bytes);
            }
          }
          case 1: {
            const bytes3 = encodeCID(version3, code5, digest.bytes);
            return new CID(version3, code5, digest, bytes3);
          }
          default: {
            throw new Error("Invalid version");
          }
        }
      }
      static createV0(digest) {
        return CID.create(0, DAG_PB_CODE, digest);
      }
      static createV1(code5, digest) {
        return CID.create(1, code5, digest);
      }
      static decode(bytes3) {
        const [cid, remainder] = CID.decodeFirst(bytes3);
        if (remainder.length) {
          throw new Error("Incorrect length");
        }
        return cid;
      }
      static decodeFirst(bytes3) {
        const specs = CID.inspectBytes(bytes3);
        const prefixSize = specs.size - specs.multihashSize;
        const multihashBytes = coerce(bytes3.subarray(prefixSize, prefixSize + specs.multihashSize));
        if (multihashBytes.byteLength !== specs.multihashSize) {
          throw new Error("Incorrect length");
        }
        const digestBytes = multihashBytes.subarray(specs.multihashSize - specs.digestSize);
        const digest = new Digest(specs.multihashCode, specs.digestSize, digestBytes, multihashBytes);
        const cid = specs.version === 0 ? CID.createV0(digest) : CID.createV1(specs.codec, digest);
        return [
          cid,
          bytes3.subarray(specs.size)
        ];
      }
      static inspectBytes(initialBytes) {
        let offset = 0;
        const next = () => {
          const [i, length4] = decode2(initialBytes.subarray(offset));
          offset += length4;
          return i;
        };
        let version3 = next();
        let codec = DAG_PB_CODE;
        if (version3 === 18) {
          version3 = 0;
          offset = 0;
        } else if (version3 === 1) {
          codec = next();
        }
        if (version3 !== 0 && version3 !== 1) {
          throw new RangeError(`Invalid CID version ${version3}`);
        }
        const prefixSize = offset;
        const multihashCode = next();
        const digestSize = next();
        const size = offset + digestSize;
        const multihashSize = size - prefixSize;
        return {
          version: version3,
          codec,
          multihashCode,
          digestSize,
          multihashSize,
          size
        };
      }
      static parse(source, base3) {
        const [prefix, bytes3] = parseCIDtoBytes(source, base3);
        const cid = CID.decode(bytes3);
        cid._baseCache.set(prefix, source);
        return cid;
      }
    };
    parseCIDtoBytes = (source, base3) => {
      switch (source[0]) {
        case "Q": {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(`${base58btc.prefix}${source}`)
          ];
        }
        case base58btc.prefix: {
          const decoder = base3 || base58btc;
          return [
            base58btc.prefix,
            decoder.decode(source)
          ];
        }
        case base32.prefix: {
          const decoder = base3 || base32;
          return [
            base32.prefix,
            decoder.decode(source)
          ];
        }
        default: {
          if (base3 == null) {
            throw Error("To parse non base32 or base58btc encoded CID multibase decoder must be provided");
          }
          return [
            source[0],
            base3.decode(source)
          ];
        }
      }
    };
    toStringV0 = (bytes3, cache2, base3) => {
      const { prefix } = base3;
      if (prefix !== base58btc.prefix) {
        throw Error(`Cannot string encode V0 in ${base3.name} encoding`);
      }
      const cid = cache2.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes3).slice(1);
        cache2.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    toStringV1 = (bytes3, cache2, base3) => {
      const { prefix } = base3;
      const cid = cache2.get(prefix);
      if (cid == null) {
        const cid2 = base3.encode(bytes3);
        cache2.set(prefix, cid2);
        return cid2;
      } else {
        return cid;
      }
    };
    DAG_PB_CODE = 112;
    SHA_256_CODE = 18;
    encodeCID = (version3, code5, multihash) => {
      const codeOffset = encodingLength(version3);
      const hashOffset = codeOffset + encodingLength(code5);
      const bytes3 = new Uint8Array(hashOffset + multihash.byteLength);
      encodeTo(version3, bytes3, 0);
      encodeTo(code5, bytes3, codeOffset);
      bytes3.set(multihash, hashOffset);
      return bytes3;
    };
    cidSymbol = Symbol.for("@ipld/js-cid/CID");
    readonly = {
      writable: false,
      configurable: false,
      enumerable: true
    };
    hidden = {
      writable: false,
      enumerable: false,
      configurable: false
    };
    version = "0.0.0-dev";
    deprecate = (range, message) => {
      if (range.test(version)) {
        console.warn(message);
      } else {
        throw new Error(message);
      }
    };
    IS_CID_DEPRECATION = `CID.isCID(v) is deprecated and will be removed in the next major release.
Following code pattern:

if (CID.isCID(value)) {
  doSomethingWithCID(value)
}

Is replaced with:

const cid = CID.asCID(value)
if (cid) {
  // Make sure to use cid instead of value
  doSomethingWithCID(cid)
}
`;
  }
});

// node_modules/@ipld/dag-pb/esm/src/pb-decode.js
function decodeVarint(bytes3, offset) {
  let v = 0;
  for (let shift = 0; ; shift += 7) {
    if (shift >= 64) {
      throw new Error("protobuf: varint overflow");
    }
    if (offset >= bytes3.length) {
      throw new Error("protobuf: unexpected end of data");
    }
    const b = bytes3[offset++];
    v += shift < 28 ? (b & 127) << shift : (b & 127) * 2 ** shift;
    if (b < 128) {
      break;
    }
  }
  return [
    v,
    offset
  ];
}
function decodeBytes(bytes3, offset) {
  let byteLen;
  [byteLen, offset] = decodeVarint(bytes3, offset);
  const postOffset = offset + byteLen;
  if (byteLen < 0 || postOffset < 0) {
    throw new Error("protobuf: invalid length");
  }
  if (postOffset > bytes3.length) {
    throw new Error("protobuf: unexpected end of data");
  }
  return [
    bytes3.subarray(offset, postOffset),
    postOffset
  ];
}
function decodeKey(bytes3, index) {
  let wire;
  [wire, index] = decodeVarint(bytes3, index);
  return [
    wire & 7,
    wire >> 3,
    index
  ];
}
function decodeLink(bytes3) {
  const link = {};
  const l = bytes3.length;
  let index = 0;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes3, index);
    if (fieldNum === 1) {
      if (link.Hash) {
        throw new Error("protobuf: (PBLink) duplicate Hash section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Hash`);
      }
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Name before Hash");
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Hash");
      }
      ;
      [link.Hash, index] = decodeBytes(bytes3, index);
    } else if (fieldNum === 2) {
      if (link.Name !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Name section");
      }
      if (wireType !== 2) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Name`);
      }
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) invalid order, found Tsize before Name");
      }
      let byts;
      [byts, index] = decodeBytes(bytes3, index);
      link.Name = textDecoder.decode(byts);
    } else if (fieldNum === 3) {
      if (link.Tsize !== void 0) {
        throw new Error("protobuf: (PBLink) duplicate Tsize section");
      }
      if (wireType !== 0) {
        throw new Error(`protobuf: (PBLink) wrong wireType (${wireType}) for Tsize`);
      }
      ;
      [link.Tsize, index] = decodeVarint(bytes3, index);
    } else {
      throw new Error(`protobuf: (PBLink) invalid fieldNumber, expected 1, 2 or 3, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBLink) unexpected end of data");
  }
  return link;
}
function decodeNode(bytes3) {
  const l = bytes3.length;
  let index = 0;
  let links2;
  let linksBeforeData = false;
  let data;
  while (index < l) {
    let wireType, fieldNum;
    [wireType, fieldNum, index] = decodeKey(bytes3, index);
    if (wireType !== 2) {
      throw new Error(`protobuf: (PBNode) invalid wireType, expected 2, got ${wireType}`);
    }
    if (fieldNum === 1) {
      if (data) {
        throw new Error("protobuf: (PBNode) duplicate Data section");
      }
      ;
      [data, index] = decodeBytes(bytes3, index);
      if (links2) {
        linksBeforeData = true;
      }
    } else if (fieldNum === 2) {
      if (linksBeforeData) {
        throw new Error("protobuf: (PBNode) duplicate Links section");
      } else if (!links2) {
        links2 = [];
      }
      let byts;
      [byts, index] = decodeBytes(bytes3, index);
      links2.push(decodeLink(byts));
    } else {
      throw new Error(`protobuf: (PBNode) invalid fieldNumber, expected 1 or 2, got ${fieldNum}`);
    }
  }
  if (index > l) {
    throw new Error("protobuf: (PBNode) unexpected end of data");
  }
  const node = {};
  if (data) {
    node.Data = data;
  }
  node.Links = links2 || [];
  return node;
}
var textDecoder;
var init_pb_decode = __esm({
  "node_modules/@ipld/dag-pb/esm/src/pb-decode.js"() {
    init_node_globals();
    textDecoder = new TextDecoder();
  }
});

// node_modules/@ipld/dag-pb/esm/src/pb-encode.js
function encodeLink(link, bytes3) {
  let i = bytes3.length;
  if (typeof link.Tsize === "number") {
    if (link.Tsize < 0) {
      throw new Error("Tsize cannot be negative");
    }
    if (!Number.isSafeInteger(link.Tsize)) {
      throw new Error("Tsize too large for encoding");
    }
    i = encodeVarint(bytes3, i, link.Tsize) - 1;
    bytes3[i] = 24;
  }
  if (typeof link.Name === "string") {
    const nameBytes = textEncoder.encode(link.Name);
    i -= nameBytes.length;
    bytes3.set(nameBytes, i);
    i = encodeVarint(bytes3, i, nameBytes.length) - 1;
    bytes3[i] = 18;
  }
  if (link.Hash) {
    i -= link.Hash.length;
    bytes3.set(link.Hash, i);
    i = encodeVarint(bytes3, i, link.Hash.length) - 1;
    bytes3[i] = 10;
  }
  return bytes3.length - i;
}
function encodeNode(node) {
  const size = sizeNode(node);
  const bytes3 = new Uint8Array(size);
  let i = size;
  if (node.Data) {
    i -= node.Data.length;
    bytes3.set(node.Data, i);
    i = encodeVarint(bytes3, i, node.Data.length) - 1;
    bytes3[i] = 10;
  }
  if (node.Links) {
    for (let index = node.Links.length - 1; index >= 0; index--) {
      const size2 = encodeLink(node.Links[index], bytes3.subarray(0, i));
      i -= size2;
      i = encodeVarint(bytes3, i, size2) - 1;
      bytes3[i] = 18;
    }
  }
  return bytes3;
}
function sizeLink(link) {
  let n = 0;
  if (link.Hash) {
    const l = link.Hash.length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Name === "string") {
    const l = textEncoder.encode(link.Name).length;
    n += 1 + l + sov(l);
  }
  if (typeof link.Tsize === "number") {
    n += 1 + sov(link.Tsize);
  }
  return n;
}
function sizeNode(node) {
  let n = 0;
  if (node.Data) {
    const l = node.Data.length;
    n += 1 + l + sov(l);
  }
  if (node.Links) {
    for (const link of node.Links) {
      const l = sizeLink(link);
      n += 1 + l + sov(l);
    }
  }
  return n;
}
function encodeVarint(bytes3, offset, v) {
  offset -= sov(v);
  const base3 = offset;
  while (v >= maxUInt32) {
    bytes3[offset++] = v & 127 | 128;
    v /= 128;
  }
  while (v >= 128) {
    bytes3[offset++] = v & 127 | 128;
    v >>>= 7;
  }
  bytes3[offset] = v;
  return base3;
}
function sov(x) {
  if (x % 2 === 0) {
    x++;
  }
  return Math.floor((len64(x) + 6) / 7);
}
function len64(x) {
  let n = 0;
  if (x >= maxInt32) {
    x = Math.floor(x / maxInt32);
    n = 32;
  }
  if (x >= 1 << 16) {
    x >>>= 16;
    n += 16;
  }
  if (x >= 1 << 8) {
    x >>>= 8;
    n += 8;
  }
  return n + len8tab[x];
}
var textEncoder, maxInt32, maxUInt32, len8tab;
var init_pb_encode = __esm({
  "node_modules/@ipld/dag-pb/esm/src/pb-encode.js"() {
    init_node_globals();
    textEncoder = new TextEncoder();
    maxInt32 = 2 ** 32;
    maxUInt32 = 2 ** 31;
    len8tab = [
      0,
      1,
      2,
      2,
      3,
      3,
      3,
      3,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      4,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      7,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8,
      8
    ];
  }
});

// node_modules/@ipld/dag-pb/esm/src/util.js
function linkComparator(a, b) {
  if (a === b) {
    return 0;
  }
  const abuf = a.Name ? textEncoder2.encode(a.Name) : [];
  const bbuf = b.Name ? textEncoder2.encode(b.Name) : [];
  let x = abuf.length;
  let y = bbuf.length;
  for (let i = 0, len = Math.min(x, y); i < len; ++i) {
    if (abuf[i] !== bbuf[i]) {
      x = abuf[i];
      y = bbuf[i];
      break;
    }
  }
  return x < y ? -1 : y < x ? 1 : 0;
}
function hasOnlyProperties(node, properties) {
  return !Object.keys(node).some((p) => !properties.includes(p));
}
function asLink(link) {
  if (typeof link.asCID === "object") {
    const Hash = CID.asCID(link);
    if (!Hash) {
      throw new TypeError("Invalid DAG-PB form");
    }
    return { Hash };
  }
  if (typeof link !== "object" || Array.isArray(link)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbl = {};
  if (link.Hash) {
    let cid = CID.asCID(link.Hash);
    try {
      if (!cid) {
        if (typeof link.Hash === "string") {
          cid = CID.parse(link.Hash);
        } else if (link.Hash instanceof Uint8Array) {
          cid = CID.decode(link.Hash);
        }
      }
    } catch (e) {
      throw new TypeError(`Invalid DAG-PB form: ${e.message}`);
    }
    if (cid) {
      pbl.Hash = cid;
    }
  }
  if (!pbl.Hash) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (typeof link.Name === "string") {
    pbl.Name = link.Name;
  }
  if (typeof link.Tsize === "number") {
    pbl.Tsize = link.Tsize;
  }
  return pbl;
}
function prepare(node) {
  if (node instanceof Uint8Array || typeof node === "string") {
    node = { Data: node };
  }
  if (typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  const pbn = {};
  if (node.Data !== void 0) {
    if (typeof node.Data === "string") {
      pbn.Data = textEncoder2.encode(node.Data);
    } else if (node.Data instanceof Uint8Array) {
      pbn.Data = node.Data;
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  }
  if (node.Links !== void 0) {
    if (Array.isArray(node.Links)) {
      pbn.Links = node.Links.map(asLink);
      pbn.Links.sort(linkComparator);
    } else {
      throw new TypeError("Invalid DAG-PB form");
    }
  } else {
    pbn.Links = [];
  }
  return pbn;
}
function validate(node) {
  if (!node || typeof node !== "object" || Array.isArray(node)) {
    throw new TypeError("Invalid DAG-PB form");
  }
  if (!hasOnlyProperties(node, pbNodeProperties)) {
    throw new TypeError("Invalid DAG-PB form (extraneous properties)");
  }
  if (node.Data !== void 0 && !(node.Data instanceof Uint8Array)) {
    throw new TypeError("Invalid DAG-PB form (Data must be a Uint8Array)");
  }
  if (!Array.isArray(node.Links)) {
    throw new TypeError("Invalid DAG-PB form (Links must be an array)");
  }
  for (let i = 0; i < node.Links.length; i++) {
    const link = node.Links[i];
    if (!link || typeof link !== "object" || Array.isArray(link)) {
      throw new TypeError("Invalid DAG-PB form (bad link object)");
    }
    if (!hasOnlyProperties(link, pbLinkProperties)) {
      throw new TypeError("Invalid DAG-PB form (extraneous properties on link object)");
    }
    if (!link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link must have a Hash)");
    }
    if (link.Hash.asCID !== link.Hash) {
      throw new TypeError("Invalid DAG-PB form (link Hash must be a CID)");
    }
    if (link.Name !== void 0 && typeof link.Name !== "string") {
      throw new TypeError("Invalid DAG-PB form (link Name must be a string)");
    }
    if (link.Tsize !== void 0 && (typeof link.Tsize !== "number" || link.Tsize % 1 !== 0)) {
      throw new TypeError("Invalid DAG-PB form (link Tsize must be an integer)");
    }
    if (i > 0 && linkComparator(link, node.Links[i - 1]) === -1) {
      throw new TypeError("Invalid DAG-PB form (links must be sorted by Name bytes)");
    }
  }
}
function createNode(data, links2 = []) {
  return prepare({
    Data: data,
    Links: links2
  });
}
function createLink(name5, size, cid) {
  return asLink({
    Hash: cid,
    Name: name5,
    Tsize: size
  });
}
var pbNodeProperties, pbLinkProperties, textEncoder2;
var init_util = __esm({
  "node_modules/@ipld/dag-pb/esm/src/util.js"() {
    init_node_globals();
    init_cid();
    pbNodeProperties = [
      "Data",
      "Links"
    ];
    pbLinkProperties = [
      "Hash",
      "Name",
      "Tsize"
    ];
    textEncoder2 = new TextEncoder();
  }
});

// node_modules/@ipld/dag-pb/esm/src/index.js
var src_exports2 = {};
__export(src_exports2, {
  code: () => code,
  createLink: () => createLink,
  createNode: () => createNode,
  decode: () => decode5,
  encode: () => encode3,
  name: () => name,
  prepare: () => prepare,
  validate: () => validate
});
function encode3(node) {
  validate(node);
  const pbn = {};
  if (node.Links) {
    pbn.Links = node.Links.map((l) => {
      const link = {};
      if (l.Hash) {
        link.Hash = l.Hash.bytes;
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  if (node.Data) {
    pbn.Data = node.Data;
  }
  return encodeNode(pbn);
}
function decode5(bytes3) {
  const pbn = decodeNode(bytes3);
  const node = {};
  if (pbn.Data) {
    node.Data = pbn.Data;
  }
  if (pbn.Links) {
    node.Links = pbn.Links.map((l) => {
      const link = {};
      try {
        link.Hash = CID.decode(l.Hash);
      } catch (e) {
      }
      if (!link.Hash) {
        throw new Error("Invalid Hash field found in link, expected CID");
      }
      if (l.Name !== void 0) {
        link.Name = l.Name;
      }
      if (l.Tsize !== void 0) {
        link.Tsize = l.Tsize;
      }
      return link;
    });
  }
  return node;
}
var name, code;
var init_src2 = __esm({
  "node_modules/@ipld/dag-pb/esm/src/index.js"() {
    init_node_globals();
    init_cid();
    init_pb_decode();
    init_pb_encode();
    init_util();
    name = "dag-pb";
    code = 112;
  }
});

// node_modules/cborg/esm/lib/is.js
function is(value) {
  if (value === null) {
    return "null";
  }
  if (value === void 0) {
    return "undefined";
  }
  if (value === true || value === false) {
    return "boolean";
  }
  const typeOf2 = typeof value;
  if (typeofs.includes(typeOf2)) {
    return typeOf2;
  }
  if (typeOf2 === "function") {
    return "Function";
  }
  if (Array.isArray(value)) {
    return "Array";
  }
  if (isBuffer(value)) {
    return "Buffer";
  }
  const objectType = getObjectType(value);
  if (objectType) {
    return objectType;
  }
  return "Object";
}
function isBuffer(value) {
  return value && value.constructor && value.constructor.isBuffer && value.constructor.isBuffer.call(null, value);
}
function getObjectType(value) {
  const objectTypeName = Object.prototype.toString.call(value).slice(8, -1);
  if (objectTypeNames.includes(objectTypeName)) {
    return objectTypeName;
  }
  return void 0;
}
var typeofs, objectTypeNames;
var init_is = __esm({
  "node_modules/cborg/esm/lib/is.js"() {
    init_node_globals();
    typeofs = [
      "string",
      "number",
      "bigint",
      "symbol"
    ];
    objectTypeNames = [
      "Function",
      "Generator",
      "AsyncGenerator",
      "GeneratorFunction",
      "AsyncGeneratorFunction",
      "AsyncFunction",
      "Observable",
      "Array",
      "Buffer",
      "Object",
      "RegExp",
      "Date",
      "Error",
      "Map",
      "Set",
      "WeakMap",
      "WeakSet",
      "ArrayBuffer",
      "SharedArrayBuffer",
      "DataView",
      "Promise",
      "URL",
      "HTMLElement",
      "Int8Array",
      "Uint8Array",
      "Uint8ClampedArray",
      "Int16Array",
      "Uint16Array",
      "Int32Array",
      "Uint32Array",
      "Float32Array",
      "Float64Array",
      "BigInt64Array",
      "BigUint64Array"
    ];
  }
});

// node_modules/cborg/esm/lib/token.js
var Type, Token;
var init_token = __esm({
  "node_modules/cborg/esm/lib/token.js"() {
    init_node_globals();
    Type = class {
      constructor(major, name5, terminal) {
        this.major = major;
        this.majorEncoded = major << 5;
        this.name = name5;
        this.terminal = terminal;
      }
      toString() {
        return `Type[${this.major}].${this.name}`;
      }
      compare(typ) {
        return this.major < typ.major ? -1 : this.major > typ.major ? 1 : 0;
      }
    };
    Type.uint = new Type(0, "uint", true);
    Type.negint = new Type(1, "negint", true);
    Type.bytes = new Type(2, "bytes", true);
    Type.string = new Type(3, "string", true);
    Type.array = new Type(4, "array", false);
    Type.map = new Type(5, "map", false);
    Type.tag = new Type(6, "tag", false);
    Type.float = new Type(7, "float", true);
    Type.false = new Type(7, "false", true);
    Type.true = new Type(7, "true", true);
    Type.null = new Type(7, "null", true);
    Type.undefined = new Type(7, "undefined", true);
    Type.break = new Type(7, "break", true);
    Token = class {
      constructor(type, value, encodedLength) {
        this.type = type;
        this.value = value;
        this.encodedLength = encodedLength;
        this.encodedBytes = void 0;
      }
      toString() {
        return `Token[${this.type}].${this.value}`;
      }
    };
  }
});

// node_modules/cborg/esm/lib/byte-utils.js
function isBuffer2(buf2) {
  return useBuffer && globalThis.Buffer.isBuffer(buf2);
}
function asU8A(buf2) {
  if (!(buf2 instanceof Uint8Array)) {
    return Uint8Array.from(buf2);
  }
  return isBuffer2(buf2) ? new Uint8Array(buf2.buffer, buf2.byteOffset, buf2.byteLength) : buf2;
}
function compare(b1, b2) {
  if (isBuffer2(b1) && isBuffer2(b2)) {
    return b1.compare(b2);
  }
  for (let i = 0; i < b1.length; i++) {
    if (b1[i] === b2[i]) {
      continue;
    }
    return b1[i] < b2[i] ? -1 : 1;
  }
  return 0;
}
function utf8ToBytes(string3, units = Infinity) {
  let codePoint;
  const length4 = string3.length;
  let leadSurrogate = null;
  const bytes3 = [];
  for (let i = 0; i < length4; ++i) {
    codePoint = string3.charCodeAt(i);
    if (codePoint > 55295 && codePoint < 57344) {
      if (!leadSurrogate) {
        if (codePoint > 56319) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          continue;
        } else if (i + 1 === length4) {
          if ((units -= 3) > -1)
            bytes3.push(239, 191, 189);
          continue;
        }
        leadSurrogate = codePoint;
        continue;
      }
      if (codePoint < 56320) {
        if ((units -= 3) > -1)
          bytes3.push(239, 191, 189);
        leadSurrogate = codePoint;
        continue;
      }
      codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
    } else if (leadSurrogate) {
      if ((units -= 3) > -1)
        bytes3.push(239, 191, 189);
    }
    leadSurrogate = null;
    if (codePoint < 128) {
      if ((units -= 1) < 0)
        break;
      bytes3.push(codePoint);
    } else if (codePoint < 2048) {
      if ((units -= 2) < 0)
        break;
      bytes3.push(codePoint >> 6 | 192, codePoint & 63 | 128);
    } else if (codePoint < 65536) {
      if ((units -= 3) < 0)
        break;
      bytes3.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else if (codePoint < 1114112) {
      if ((units -= 4) < 0)
        break;
      bytes3.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
    } else {
      throw new Error("Invalid code point");
    }
  }
  return bytes3;
}
function utf8Slice(buf2, offset, end) {
  const res = [];
  while (offset < end) {
    const firstByte = buf2[offset];
    let codePoint = null;
    let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
    if (offset + bytesPerSequence <= end) {
      let secondByte, thirdByte, fourthByte, tempCodePoint;
      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 128) {
            codePoint = firstByte;
          }
          break;
        case 2:
          secondByte = buf2[offset + 1];
          if ((secondByte & 192) === 128) {
            tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
            if (tempCodePoint > 127) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 3:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
            if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
              codePoint = tempCodePoint;
            }
          }
          break;
        case 4:
          secondByte = buf2[offset + 1];
          thirdByte = buf2[offset + 2];
          fourthByte = buf2[offset + 3];
          if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
            tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
            if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
              codePoint = tempCodePoint;
            }
          }
      }
    }
    if (codePoint === null) {
      codePoint = 65533;
      bytesPerSequence = 1;
    } else if (codePoint > 65535) {
      codePoint -= 65536;
      res.push(codePoint >>> 10 & 1023 | 55296);
      codePoint = 56320 | codePoint & 1023;
    }
    res.push(codePoint);
    offset += bytesPerSequence;
  }
  return decodeCodePointsArray(res);
}
function decodeCodePointsArray(codePoints) {
  const len = codePoints.length;
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints);
  }
  let res = "";
  let i = 0;
  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }
  return res;
}
var useBuffer, textDecoder2, textEncoder3, toString2, fromString2, fromArray, slice, concat, alloc, MAX_ARGUMENTS_LENGTH;
var init_byte_utils = __esm({
  "node_modules/cborg/esm/lib/byte-utils.js"() {
    init_node_globals();
    useBuffer = globalThis.process && !globalThis.process.browser && globalThis.Buffer && typeof globalThis.Buffer.isBuffer === "function";
    textDecoder2 = new TextDecoder();
    textEncoder3 = new TextEncoder();
    toString2 = useBuffer ? (bytes3, start, end) => {
      return end - start > 64 ? globalThis.Buffer.from(bytes3.subarray(start, end)).toString("utf8") : utf8Slice(bytes3, start, end);
    } : (bytes3, start, end) => {
      return end - start > 64 ? textDecoder2.decode(bytes3.subarray(start, end)) : utf8Slice(bytes3, start, end);
    };
    fromString2 = useBuffer ? (string3) => {
      return string3.length > 64 ? globalThis.Buffer.from(string3) : utf8ToBytes(string3);
    } : (string3) => {
      return string3.length > 64 ? textEncoder3.encode(string3) : utf8ToBytes(string3);
    };
    fromArray = (arr) => {
      return Uint8Array.from(arr);
    };
    slice = useBuffer ? (bytes3, start, end) => {
      if (isBuffer2(bytes3)) {
        return new Uint8Array(bytes3.subarray(start, end));
      }
      return bytes3.slice(start, end);
    } : (bytes3, start, end) => {
      return bytes3.slice(start, end);
    };
    concat = useBuffer ? (chunks, length4) => {
      chunks = chunks.map((c) => c instanceof Uint8Array ? c : globalThis.Buffer.from(c));
      return asU8A(globalThis.Buffer.concat(chunks, length4));
    } : (chunks, length4) => {
      const out = new Uint8Array(length4);
      let off = 0;
      for (let b of chunks) {
        if (off + b.length > out.length) {
          b = b.subarray(0, out.length - off);
        }
        out.set(b, off);
        off += b.length;
      }
      return out;
    };
    alloc = useBuffer ? (size) => {
      return globalThis.Buffer.allocUnsafe(size);
    } : (size) => {
      return new Uint8Array(size);
    };
    MAX_ARGUMENTS_LENGTH = 4096;
  }
});

// node_modules/cborg/esm/lib/bl.js
var defaultChunkSize, Bl;
var init_bl = __esm({
  "node_modules/cborg/esm/lib/bl.js"() {
    init_node_globals();
    init_byte_utils();
    defaultChunkSize = 256;
    Bl = class {
      constructor(chunkSize = defaultChunkSize) {
        this.chunkSize = chunkSize;
        this.cursor = 0;
        this.maxCursor = -1;
        this.chunks = [];
        this._initReuseChunk = null;
      }
      reset() {
        this.chunks = [];
        this.cursor = 0;
        this.maxCursor = -1;
        if (this._initReuseChunk !== null) {
          this.chunks.push(this._initReuseChunk);
          this.maxCursor = this._initReuseChunk.length - 1;
        }
      }
      push(bytes3) {
        let topChunk = this.chunks[this.chunks.length - 1];
        const newMax = this.cursor + bytes3.length;
        if (newMax <= this.maxCursor + 1) {
          const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
          topChunk.set(bytes3, chunkPos);
        } else {
          if (topChunk) {
            const chunkPos = topChunk.length - (this.maxCursor - this.cursor) - 1;
            if (chunkPos < topChunk.length) {
              this.chunks[this.chunks.length - 1] = topChunk.subarray(0, chunkPos);
              this.maxCursor = this.cursor - 1;
            }
          }
          if (bytes3.length < 64 && bytes3.length < this.chunkSize) {
            topChunk = alloc(this.chunkSize);
            this.chunks.push(topChunk);
            this.maxCursor += topChunk.length;
            if (this._initReuseChunk === null) {
              this._initReuseChunk = topChunk;
            }
            topChunk.set(bytes3, 0);
          } else {
            this.chunks.push(bytes3);
            this.maxCursor += bytes3.length;
          }
        }
        this.cursor += bytes3.length;
      }
      toBytes(reset = false) {
        let byts;
        if (this.chunks.length === 1) {
          const chunk = this.chunks[0];
          if (reset && this.cursor > chunk.length / 2) {
            byts = this.cursor === chunk.length ? chunk : chunk.subarray(0, this.cursor);
            this._initReuseChunk = null;
            this.chunks = [];
          } else {
            byts = slice(chunk, 0, this.cursor);
          }
        } else {
          byts = concat(this.chunks, this.cursor);
        }
        if (reset) {
          this.reset();
        }
        return byts;
      }
    };
  }
});

// node_modules/cborg/esm/lib/common.js
function assertEnoughData(data, pos, need) {
  if (data.length - pos < need) {
    throw new Error(`${decodeErrPrefix} not enough data for type`);
  }
}
var decodeErrPrefix, encodeErrPrefix, uintMinorPrefixBytes;
var init_common = __esm({
  "node_modules/cborg/esm/lib/common.js"() {
    init_node_globals();
    decodeErrPrefix = "CBOR decode error:";
    encodeErrPrefix = "CBOR encode error:";
    uintMinorPrefixBytes = [];
    uintMinorPrefixBytes[23] = 1;
    uintMinorPrefixBytes[24] = 2;
    uintMinorPrefixBytes[25] = 3;
    uintMinorPrefixBytes[26] = 5;
    uintMinorPrefixBytes[27] = 9;
  }
});

// node_modules/cborg/esm/lib/0uint.js
function readUint8(data, offset, options) {
  assertEnoughData(data, offset, 1);
  const value = data[offset];
  if (options.strict === true && value < uintBoundaries[0]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint16(data, offset, options) {
  assertEnoughData(data, offset, 2);
  const value = data[offset] << 8 | data[offset + 1];
  if (options.strict === true && value < uintBoundaries[1]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint32(data, offset, options) {
  assertEnoughData(data, offset, 4);
  const value = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  if (options.strict === true && value < uintBoundaries[2]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  return value;
}
function readUint64(data, offset, options) {
  assertEnoughData(data, offset, 8);
  const hi = data[offset] * 16777216 + (data[offset + 1] << 16) + (data[offset + 2] << 8) + data[offset + 3];
  const lo = data[offset + 4] * 16777216 + (data[offset + 5] << 16) + (data[offset + 6] << 8) + data[offset + 7];
  const value = (BigInt(hi) << BigInt(32)) + BigInt(lo);
  if (options.strict === true && value < uintBoundaries[3]) {
    throw new Error(`${decodeErrPrefix} integer encoded in more bytes than necessary (strict decode)`);
  }
  if (value <= Number.MAX_SAFE_INTEGER) {
    return Number(value);
  }
  if (options.allowBigInt === true) {
    return value;
  }
  throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
}
function decodeUint8(data, pos, _minor, options) {
  return new Token(Type.uint, readUint8(data, pos + 1, options), 2);
}
function decodeUint16(data, pos, _minor, options) {
  return new Token(Type.uint, readUint16(data, pos + 1, options), 3);
}
function decodeUint32(data, pos, _minor, options) {
  return new Token(Type.uint, readUint32(data, pos + 1, options), 5);
}
function decodeUint64(data, pos, _minor, options) {
  return new Token(Type.uint, readUint64(data, pos + 1, options), 9);
}
function encodeUint(buf2, token) {
  return encodeUintValue(buf2, 0, token.value);
}
function encodeUintValue(buf2, major, uint8) {
  if (uint8 < uintBoundaries[0]) {
    const nuint = Number(uint8);
    buf2.push([major | nuint]);
  } else if (uint8 < uintBoundaries[1]) {
    const nuint = Number(uint8);
    buf2.push([
      major | 24,
      nuint
    ]);
  } else if (uint8 < uintBoundaries[2]) {
    const nuint = Number(uint8);
    buf2.push([
      major | 25,
      nuint >>> 8,
      nuint & 255
    ]);
  } else if (uint8 < uintBoundaries[3]) {
    const nuint = Number(uint8);
    buf2.push([
      major | 26,
      nuint >>> 24 & 255,
      nuint >>> 16 & 255,
      nuint >>> 8 & 255,
      nuint & 255
    ]);
  } else {
    const buint = BigInt(uint8);
    if (buint < uintBoundaries[4]) {
      const set = [
        major | 27,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ];
      let lo = Number(buint & BigInt(4294967295));
      let hi = Number(buint >> BigInt(32) & BigInt(4294967295));
      set[8] = lo & 255;
      lo = lo >> 8;
      set[7] = lo & 255;
      lo = lo >> 8;
      set[6] = lo & 255;
      lo = lo >> 8;
      set[5] = lo & 255;
      set[4] = hi & 255;
      hi = hi >> 8;
      set[3] = hi & 255;
      hi = hi >> 8;
      set[2] = hi & 255;
      hi = hi >> 8;
      set[1] = hi & 255;
      buf2.push(set);
    } else {
      throw new Error(`${decodeErrPrefix} encountered BigInt larger than allowable range`);
    }
  }
}
var uintBoundaries;
var init_uint = __esm({
  "node_modules/cborg/esm/lib/0uint.js"() {
    init_node_globals();
    init_token();
    init_common();
    uintBoundaries = [
      24,
      256,
      65536,
      4294967296,
      BigInt("18446744073709551616")
    ];
    encodeUint.encodedSize = function encodedSize(token) {
      return encodeUintValue.encodedSize(token.value);
    };
    encodeUintValue.encodedSize = function encodedSize2(uint8) {
      if (uint8 < uintBoundaries[0]) {
        return 1;
      }
      if (uint8 < uintBoundaries[1]) {
        return 2;
      }
      if (uint8 < uintBoundaries[2]) {
        return 3;
      }
      if (uint8 < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeUint.compareTokens = function compareTokens(tok1, tok2) {
      return tok1.value < tok2.value ? -1 : tok1.value > tok2.value ? 1 : 0;
    };
  }
});

// node_modules/cborg/esm/lib/1negint.js
function decodeNegint8(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint8(data, pos + 1, options), 2);
}
function decodeNegint16(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint16(data, pos + 1, options), 3);
}
function decodeNegint32(data, pos, _minor, options) {
  return new Token(Type.negint, -1 - readUint32(data, pos + 1, options), 5);
}
function decodeNegint64(data, pos, _minor, options) {
  const int = readUint64(data, pos + 1, options);
  if (typeof int !== "bigint") {
    const value = -1 - int;
    if (value >= Number.MIN_SAFE_INTEGER) {
      return new Token(Type.negint, value, 9);
    }
  }
  if (options.allowBigInt !== true) {
    throw new Error(`${decodeErrPrefix} integers outside of the safe integer range are not supported`);
  }
  return new Token(Type.negint, neg1b - BigInt(int), 9);
}
function encodeNegint(buf2, token) {
  const negint2 = token.value;
  const unsigned = typeof negint2 === "bigint" ? negint2 * neg1b - pos1b : negint2 * -1 - 1;
  encodeUintValue(buf2, token.type.majorEncoded, unsigned);
}
var neg1b, pos1b;
var init_negint = __esm({
  "node_modules/cborg/esm/lib/1negint.js"() {
    init_node_globals();
    init_token();
    init_uint();
    init_common();
    neg1b = BigInt(-1);
    pos1b = BigInt(1);
    encodeNegint.encodedSize = function encodedSize3(token) {
      const negint2 = token.value;
      const unsigned = typeof negint2 === "bigint" ? negint2 * neg1b - pos1b : negint2 * -1 - 1;
      if (unsigned < uintBoundaries[0]) {
        return 1;
      }
      if (unsigned < uintBoundaries[1]) {
        return 2;
      }
      if (unsigned < uintBoundaries[2]) {
        return 3;
      }
      if (unsigned < uintBoundaries[3]) {
        return 5;
      }
      return 9;
    };
    encodeNegint.compareTokens = function compareTokens2(tok1, tok2) {
      return tok1.value < tok2.value ? 1 : tok1.value > tok2.value ? -1 : 0;
    };
  }
});

// node_modules/cborg/esm/lib/2bytes.js
function toToken(data, pos, prefix, length4) {
  assertEnoughData(data, pos, prefix + length4);
  const buf2 = slice(data, pos + prefix, pos + prefix + length4);
  return new Token(Type.bytes, buf2, prefix + length4);
}
function decodeBytesCompact(data, pos, minor, _options) {
  return toToken(data, pos, 1, minor);
}
function decodeBytes8(data, pos, _minor, options) {
  return toToken(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeBytes16(data, pos, _minor, options) {
  return toToken(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeBytes32(data, pos, _minor, options) {
  return toToken(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeBytes64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer bytes lengths not supported`);
  }
  return toToken(data, pos, 9, l);
}
function tokenBytes(token) {
  if (token.encodedBytes === void 0) {
    token.encodedBytes = token.type === Type.string ? fromString2(token.value) : token.value;
  }
  return token.encodedBytes;
}
function encodeBytes(buf2, token) {
  const bytes3 = tokenBytes(token);
  encodeUintValue(buf2, token.type.majorEncoded, bytes3.length);
  buf2.push(bytes3);
}
function compareBytes(b1, b2) {
  return b1.length < b2.length ? -1 : b1.length > b2.length ? 1 : compare(b1, b2);
}
var init_bytes2 = __esm({
  "node_modules/cborg/esm/lib/2bytes.js"() {
    init_node_globals();
    init_token();
    init_common();
    init_uint();
    init_byte_utils();
    encodeBytes.encodedSize = function encodedSize4(token) {
      const bytes3 = tokenBytes(token);
      return encodeUintValue.encodedSize(bytes3.length) + bytes3.length;
    };
    encodeBytes.compareTokens = function compareTokens3(tok1, tok2) {
      return compareBytes(tokenBytes(tok1), tokenBytes(tok2));
    };
  }
});

// node_modules/cborg/esm/lib/3string.js
function toToken2(data, pos, prefix, length4) {
  const totLength = prefix + length4;
  assertEnoughData(data, pos, totLength);
  return new Token(Type.string, toString2(data, pos + prefix, pos + totLength), totLength);
}
function decodeStringCompact(data, pos, minor, _options) {
  return toToken2(data, pos, 1, minor);
}
function decodeString8(data, pos, _minor, options) {
  return toToken2(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeString16(data, pos, _minor, options) {
  return toToken2(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeString32(data, pos, _minor, options) {
  return toToken2(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeString64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer string lengths not supported`);
  }
  return toToken2(data, pos, 9, l);
}
var encodeString;
var init_string = __esm({
  "node_modules/cborg/esm/lib/3string.js"() {
    init_node_globals();
    init_token();
    init_common();
    init_uint();
    init_bytes2();
    init_byte_utils();
    encodeString = encodeBytes;
  }
});

// node_modules/cborg/esm/lib/4array.js
function toToken3(_data, _pos, prefix, length4) {
  return new Token(Type.array, length4, prefix);
}
function decodeArrayCompact(data, pos, minor, _options) {
  return toToken3(data, pos, 1, minor);
}
function decodeArray8(data, pos, _minor, options) {
  return toToken3(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeArray16(data, pos, _minor, options) {
  return toToken3(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeArray32(data, pos, _minor, options) {
  return toToken3(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeArray64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer array lengths not supported`);
  }
  return toToken3(data, pos, 9, l);
}
function decodeArrayIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken3(data, pos, 1, Infinity);
}
function encodeArray(buf2, token) {
  encodeUintValue(buf2, Type.array.majorEncoded, token.value);
}
var init_array = __esm({
  "node_modules/cborg/esm/lib/4array.js"() {
    init_node_globals();
    init_token();
    init_uint();
    init_common();
    encodeArray.compareTokens = encodeUint.compareTokens;
  }
});

// node_modules/cborg/esm/lib/5map.js
function toToken4(_data, _pos, prefix, length4) {
  return new Token(Type.map, length4, prefix);
}
function decodeMapCompact(data, pos, minor, _options) {
  return toToken4(data, pos, 1, minor);
}
function decodeMap8(data, pos, _minor, options) {
  return toToken4(data, pos, 2, readUint8(data, pos + 1, options));
}
function decodeMap16(data, pos, _minor, options) {
  return toToken4(data, pos, 3, readUint16(data, pos + 1, options));
}
function decodeMap32(data, pos, _minor, options) {
  return toToken4(data, pos, 5, readUint32(data, pos + 1, options));
}
function decodeMap64(data, pos, _minor, options) {
  const l = readUint64(data, pos + 1, options);
  if (typeof l === "bigint") {
    throw new Error(`${decodeErrPrefix} 64-bit integer map lengths not supported`);
  }
  return toToken4(data, pos, 9, l);
}
function decodeMapIndefinite(data, pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return toToken4(data, pos, 1, Infinity);
}
function encodeMap(buf2, token) {
  encodeUintValue(buf2, Type.map.majorEncoded, token.value);
}
var init_map = __esm({
  "node_modules/cborg/esm/lib/5map.js"() {
    init_node_globals();
    init_token();
    init_uint();
    init_common();
    encodeMap.compareTokens = encodeUint.compareTokens;
  }
});

// node_modules/cborg/esm/lib/6tag.js
function decodeTagCompact(_data, _pos, minor, _options) {
  return new Token(Type.tag, minor, 1);
}
function decodeTag8(data, pos, _minor, options) {
  return new Token(Type.tag, readUint8(data, pos + 1, options), 2);
}
function decodeTag16(data, pos, _minor, options) {
  return new Token(Type.tag, readUint16(data, pos + 1, options), 3);
}
function decodeTag32(data, pos, _minor, options) {
  return new Token(Type.tag, readUint32(data, pos + 1, options), 5);
}
function decodeTag64(data, pos, _minor, options) {
  return new Token(Type.tag, readUint64(data, pos + 1, options), 9);
}
function encodeTag(buf2, token) {
  encodeUintValue(buf2, Type.tag.majorEncoded, token.value);
}
var init_tag = __esm({
  "node_modules/cborg/esm/lib/6tag.js"() {
    init_node_globals();
    init_token();
    init_uint();
    encodeTag.compareTokens = encodeUint.compareTokens;
  }
});

// node_modules/cborg/esm/lib/7float.js
function decodeUndefined(_data, _pos, _minor, options) {
  if (options.allowUndefined === false) {
    throw new Error(`${decodeErrPrefix} undefined values are not supported`);
  }
  return new Token(Type.undefined, void 0, 1);
}
function decodeBreak(_data, _pos, _minor, options) {
  if (options.allowIndefinite === false) {
    throw new Error(`${decodeErrPrefix} indefinite length items not allowed`);
  }
  return new Token(Type.break, void 0, 1);
}
function createToken(value, bytes3, options) {
  if (options) {
    if (options.allowNaN === false && Number.isNaN(value)) {
      throw new Error(`${decodeErrPrefix} NaN values are not supported`);
    }
    if (options.allowInfinity === false && (value === Infinity || value === -Infinity)) {
      throw new Error(`${decodeErrPrefix} Infinity values are not supported`);
    }
  }
  return new Token(Type.float, value, bytes3);
}
function decodeFloat16(data, pos, _minor, options) {
  return createToken(readFloat16(data, pos + 1), 3, options);
}
function decodeFloat32(data, pos, _minor, options) {
  return createToken(readFloat32(data, pos + 1), 5, options);
}
function decodeFloat64(data, pos, _minor, options) {
  return createToken(readFloat64(data, pos + 1), 9, options);
}
function encodeFloat(buf2, token, options) {
  const float2 = token.value;
  if (float2 === false) {
    buf2.push([Type.float.majorEncoded | MINOR_FALSE]);
  } else if (float2 === true) {
    buf2.push([Type.float.majorEncoded | MINOR_TRUE]);
  } else if (float2 === null) {
    buf2.push([Type.float.majorEncoded | MINOR_NULL]);
  } else if (float2 === void 0) {
    buf2.push([Type.float.majorEncoded | MINOR_UNDEFINED]);
  } else {
    let decoded;
    let success = false;
    if (!options || options.float64 !== true) {
      encodeFloat16(float2);
      decoded = readFloat16(ui8a, 1);
      if (float2 === decoded || Number.isNaN(float2)) {
        ui8a[0] = 249;
        buf2.push(ui8a.slice(0, 3));
        success = true;
      } else {
        encodeFloat32(float2);
        decoded = readFloat32(ui8a, 1);
        if (float2 === decoded) {
          ui8a[0] = 250;
          buf2.push(ui8a.slice(0, 5));
          success = true;
        }
      }
    }
    if (!success) {
      encodeFloat64(float2);
      decoded = readFloat64(ui8a, 1);
      ui8a[0] = 251;
      buf2.push(ui8a.slice(0, 9));
    }
  }
}
function encodeFloat16(inp) {
  if (inp === Infinity) {
    dataView.setUint16(0, 31744, false);
  } else if (inp === -Infinity) {
    dataView.setUint16(0, 64512, false);
  } else if (Number.isNaN(inp)) {
    dataView.setUint16(0, 32256, false);
  } else {
    dataView.setFloat32(0, inp);
    const valu32 = dataView.getUint32(0);
    const exponent = (valu32 & 2139095040) >> 23;
    const mantissa = valu32 & 8388607;
    if (exponent === 255) {
      dataView.setUint16(0, 31744, false);
    } else if (exponent === 0) {
      dataView.setUint16(0, (inp & 2147483648) >> 16 | mantissa >> 13, false);
    } else {
      const logicalExponent = exponent - 127;
      if (logicalExponent < -24) {
        dataView.setUint16(0, 0);
      } else if (logicalExponent < -14) {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | 1 << 24 + logicalExponent, false);
      } else {
        dataView.setUint16(0, (valu32 & 2147483648) >> 16 | logicalExponent + 15 << 10 | mantissa >> 13, false);
      }
    }
  }
}
function readFloat16(ui8a2, pos) {
  if (ui8a2.length - pos < 2) {
    throw new Error(`${decodeErrPrefix} not enough data for float16`);
  }
  const half = (ui8a2[pos] << 8) + ui8a2[pos + 1];
  if (half === 31744) {
    return Infinity;
  }
  if (half === 64512) {
    return -Infinity;
  }
  if (half === 32256) {
    return NaN;
  }
  const exp = half >> 10 & 31;
  const mant = half & 1023;
  let val;
  if (exp === 0) {
    val = mant * 2 ** -24;
  } else if (exp !== 31) {
    val = (mant + 1024) * 2 ** (exp - 25);
  } else {
    val = mant === 0 ? Infinity : NaN;
  }
  return half & 32768 ? -val : val;
}
function encodeFloat32(inp) {
  dataView.setFloat32(0, inp, false);
}
function readFloat32(ui8a2, pos) {
  if (ui8a2.length - pos < 4) {
    throw new Error(`${decodeErrPrefix} not enough data for float32`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 4).getFloat32(0, false);
}
function encodeFloat64(inp) {
  dataView.setFloat64(0, inp, false);
}
function readFloat64(ui8a2, pos) {
  if (ui8a2.length - pos < 8) {
    throw new Error(`${decodeErrPrefix} not enough data for float64`);
  }
  const offset = (ui8a2.byteOffset || 0) + pos;
  return new DataView(ui8a2.buffer, offset, 8).getFloat64(0, false);
}
var MINOR_FALSE, MINOR_TRUE, MINOR_NULL, MINOR_UNDEFINED, buffer, dataView, ui8a;
var init_float = __esm({
  "node_modules/cborg/esm/lib/7float.js"() {
    init_node_globals();
    init_token();
    init_common();
    init_uint();
    MINOR_FALSE = 20;
    MINOR_TRUE = 21;
    MINOR_NULL = 22;
    MINOR_UNDEFINED = 23;
    encodeFloat.encodedSize = function encodedSize5(token, options) {
      const float2 = token.value;
      if (float2 === false || float2 === true || float2 === null || float2 === void 0) {
        return 1;
      }
      let decoded;
      if (!options || options.float64 !== true) {
        encodeFloat16(float2);
        decoded = readFloat16(ui8a, 1);
        if (float2 === decoded || Number.isNaN(float2)) {
          return 3;
        }
        encodeFloat32(float2);
        decoded = readFloat32(ui8a, 1);
        if (float2 === decoded) {
          return 5;
        }
      }
      return 9;
    };
    buffer = new ArrayBuffer(9);
    dataView = new DataView(buffer, 1);
    ui8a = new Uint8Array(buffer, 0);
    encodeFloat.compareTokens = encodeUint.compareTokens;
  }
});

// node_modules/cborg/esm/lib/jump.js
function invalidMinor(data, pos, minor) {
  throw new Error(`${decodeErrPrefix} encountered invalid minor (${minor}) for major ${data[pos] >>> 5}`);
}
function errorer(msg) {
  return () => {
    throw new Error(`${decodeErrPrefix} ${msg}`);
  };
}
function quickEncodeToken(token) {
  switch (token.type) {
    case Type.false:
      return fromArray([244]);
    case Type.true:
      return fromArray([245]);
    case Type.null:
      return fromArray([246]);
    case Type.bytes:
      if (!token.value.length) {
        return fromArray([64]);
      }
      return;
    case Type.string:
      if (token.value === "") {
        return fromArray([96]);
      }
      return;
    case Type.array:
      if (token.value === 0) {
        return fromArray([128]);
      }
      return;
    case Type.map:
      if (token.value === 0) {
        return fromArray([160]);
      }
      return;
    case Type.uint:
      if (token.value < 24) {
        return fromArray([Number(token.value)]);
      }
      return;
    case Type.negint:
      if (token.value >= -24) {
        return fromArray([31 - Number(token.value)]);
      }
  }
}
var jump, quick;
var init_jump = __esm({
  "node_modules/cborg/esm/lib/jump.js"() {
    init_node_globals();
    init_token();
    init_uint();
    init_negint();
    init_bytes2();
    init_string();
    init_array();
    init_map();
    init_tag();
    init_float();
    init_common();
    init_byte_utils();
    jump = [];
    for (let i = 0; i <= 23; i++) {
      jump[i] = invalidMinor;
    }
    jump[24] = decodeUint8;
    jump[25] = decodeUint16;
    jump[26] = decodeUint32;
    jump[27] = decodeUint64;
    jump[28] = invalidMinor;
    jump[29] = invalidMinor;
    jump[30] = invalidMinor;
    jump[31] = invalidMinor;
    for (let i = 32; i <= 55; i++) {
      jump[i] = invalidMinor;
    }
    jump[56] = decodeNegint8;
    jump[57] = decodeNegint16;
    jump[58] = decodeNegint32;
    jump[59] = decodeNegint64;
    jump[60] = invalidMinor;
    jump[61] = invalidMinor;
    jump[62] = invalidMinor;
    jump[63] = invalidMinor;
    for (let i = 64; i <= 87; i++) {
      jump[i] = decodeBytesCompact;
    }
    jump[88] = decodeBytes8;
    jump[89] = decodeBytes16;
    jump[90] = decodeBytes32;
    jump[91] = decodeBytes64;
    jump[92] = invalidMinor;
    jump[93] = invalidMinor;
    jump[94] = invalidMinor;
    jump[95] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 96; i <= 119; i++) {
      jump[i] = decodeStringCompact;
    }
    jump[120] = decodeString8;
    jump[121] = decodeString16;
    jump[122] = decodeString32;
    jump[123] = decodeString64;
    jump[124] = invalidMinor;
    jump[125] = invalidMinor;
    jump[126] = invalidMinor;
    jump[127] = errorer("indefinite length bytes/strings are not supported");
    for (let i = 128; i <= 151; i++) {
      jump[i] = decodeArrayCompact;
    }
    jump[152] = decodeArray8;
    jump[153] = decodeArray16;
    jump[154] = decodeArray32;
    jump[155] = decodeArray64;
    jump[156] = invalidMinor;
    jump[157] = invalidMinor;
    jump[158] = invalidMinor;
    jump[159] = decodeArrayIndefinite;
    for (let i = 160; i <= 183; i++) {
      jump[i] = decodeMapCompact;
    }
    jump[184] = decodeMap8;
    jump[185] = decodeMap16;
    jump[186] = decodeMap32;
    jump[187] = decodeMap64;
    jump[188] = invalidMinor;
    jump[189] = invalidMinor;
    jump[190] = invalidMinor;
    jump[191] = decodeMapIndefinite;
    for (let i = 192; i <= 215; i++) {
      jump[i] = decodeTagCompact;
    }
    jump[216] = decodeTag8;
    jump[217] = decodeTag16;
    jump[218] = decodeTag32;
    jump[219] = decodeTag64;
    jump[220] = invalidMinor;
    jump[221] = invalidMinor;
    jump[222] = invalidMinor;
    jump[223] = invalidMinor;
    for (let i = 224; i <= 243; i++) {
      jump[i] = errorer("simple values are not supported");
    }
    jump[244] = invalidMinor;
    jump[245] = invalidMinor;
    jump[246] = invalidMinor;
    jump[247] = decodeUndefined;
    jump[248] = errorer("simple values are not supported");
    jump[249] = decodeFloat16;
    jump[250] = decodeFloat32;
    jump[251] = decodeFloat64;
    jump[252] = invalidMinor;
    jump[253] = invalidMinor;
    jump[254] = invalidMinor;
    jump[255] = decodeBreak;
    quick = [];
    for (let i = 0; i < 24; i++) {
      quick[i] = new Token(Type.uint, i, 1);
    }
    for (let i = -1; i >= -24; i--) {
      quick[31 - i] = new Token(Type.negint, i, 1);
    }
    quick[64] = new Token(Type.bytes, new Uint8Array(0), 1);
    quick[96] = new Token(Type.string, "", 1);
    quick[128] = new Token(Type.array, 0, 1);
    quick[160] = new Token(Type.map, 0, 1);
    quick[244] = new Token(Type.false, false, 1);
    quick[245] = new Token(Type.true, true, 1);
    quick[246] = new Token(Type.null, null, 1);
  }
});

// node_modules/cborg/esm/lib/encode.js
function objectToTokens(obj, options = {}, refStack) {
  const typ = is(obj);
  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];
  if (typeof customTypeEncoder === "function") {
    const tokens = customTypeEncoder(obj, typ, options, refStack);
    if (tokens != null) {
      return tokens;
    }
  }
  const typeEncoder = typeEncoders[typ];
  if (!typeEncoder) {
    throw new Error(`${encodeErrPrefix} unsupported type: ${typ}`);
  }
  return typeEncoder(obj, typ, options, refStack);
}
function sortMapEntries(entries, options) {
  if (options.mapSorter) {
    entries.sort(options.mapSorter);
  }
}
function mapSorter(e1, e2) {
  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];
  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];
  if (keyToken1.type !== keyToken2.type) {
    return keyToken1.type.compare(keyToken2.type);
  }
  const major = keyToken1.type.major;
  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);
  if (tcmp === 0) {
    console.warn("WARNING: complex key types used, CBOR key sorting guarantees are gone");
  }
  return tcmp;
}
function tokensToEncoded(buf2, tokens, encoders, options) {
  if (Array.isArray(tokens)) {
    for (const token of tokens) {
      tokensToEncoded(buf2, token, encoders, options);
    }
  } else {
    encoders[tokens.type.major](buf2, tokens, options);
  }
}
function encodeCustom(data, encoders, options) {
  const tokens = objectToTokens(data, options);
  if (!Array.isArray(tokens) && options.quickEncodeToken) {
    const quickBytes = options.quickEncodeToken(tokens);
    if (quickBytes) {
      return quickBytes;
    }
    const encoder = encoders[tokens.type.major];
    if (encoder.encodedSize) {
      const size = encoder.encodedSize(tokens, options);
      const buf2 = new Bl(size);
      encoder(buf2, tokens, options);
      if (buf2.chunks.length !== 1) {
        throw new Error(`Unexpected error: pre-calculated length for ${tokens} was wrong`);
      }
      return asU8A(buf2.chunks[0]);
    }
  }
  tokensToEncoded(buf, tokens, encoders, options);
  return buf.toBytes(true);
}
function encode4(data, options) {
  options = Object.assign({}, defaultEncodeOptions, options);
  return encodeCustom(data, cborEncoders, options);
}
var defaultEncodeOptions, cborEncoders, buf, Ref, simpleTokens, typeEncoders;
var init_encode = __esm({
  "node_modules/cborg/esm/lib/encode.js"() {
    init_node_globals();
    init_is();
    init_token();
    init_bl();
    init_common();
    init_jump();
    init_byte_utils();
    init_uint();
    init_negint();
    init_bytes2();
    init_string();
    init_array();
    init_map();
    init_tag();
    init_float();
    defaultEncodeOptions = {
      float64: false,
      mapSorter,
      quickEncodeToken
    };
    cborEncoders = [];
    cborEncoders[Type.uint.major] = encodeUint;
    cborEncoders[Type.negint.major] = encodeNegint;
    cborEncoders[Type.bytes.major] = encodeBytes;
    cborEncoders[Type.string.major] = encodeString;
    cborEncoders[Type.array.major] = encodeArray;
    cborEncoders[Type.map.major] = encodeMap;
    cborEncoders[Type.tag.major] = encodeTag;
    cborEncoders[Type.float.major] = encodeFloat;
    buf = new Bl();
    Ref = class {
      constructor(obj, parent2) {
        this.obj = obj;
        this.parent = parent2;
      }
      includes(obj) {
        let p = this;
        do {
          if (p.obj === obj) {
            return true;
          }
        } while (p = p.parent);
        return false;
      }
      static createCheck(stack, obj) {
        if (stack && stack.includes(obj)) {
          throw new Error(`${encodeErrPrefix} object contains circular references`);
        }
        return new Ref(obj, stack);
      }
    };
    simpleTokens = {
      null: new Token(Type.null, null),
      undefined: new Token(Type.undefined, void 0),
      true: new Token(Type.true, true),
      false: new Token(Type.false, false),
      emptyArray: new Token(Type.array, 0),
      emptyMap: new Token(Type.map, 0)
    };
    typeEncoders = {
      number(obj, _typ, _options, _refStack) {
        if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {
          return new Token(Type.float, obj);
        } else if (obj >= 0) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      bigint(obj, _typ, _options, _refStack) {
        if (obj >= BigInt(0)) {
          return new Token(Type.uint, obj);
        } else {
          return new Token(Type.negint, obj);
        }
      },
      Uint8Array(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, obj);
      },
      string(obj, _typ, _options, _refStack) {
        return new Token(Type.string, obj);
      },
      boolean(obj, _typ, _options, _refStack) {
        return obj ? simpleTokens.true : simpleTokens.false;
      },
      null(_obj, _typ, _options, _refStack) {
        return simpleTokens.null;
      },
      undefined(_obj, _typ, _options, _refStack) {
        return simpleTokens.undefined;
      },
      ArrayBuffer(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj));
      },
      DataView(obj, _typ, _options, _refStack) {
        return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));
      },
      Array(obj, _typ, options, refStack) {
        if (!obj.length) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens.emptyArray,
              new Token(Type.break)
            ];
          }
          return simpleTokens.emptyArray;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries = [];
        let i = 0;
        for (const e of obj) {
          entries[i++] = objectToTokens(e, options, refStack);
        }
        if (options.addBreakTokens) {
          return [
            new Token(Type.array, obj.length),
            entries,
            new Token(Type.break)
          ];
        }
        return [
          new Token(Type.array, obj.length),
          entries
        ];
      },
      Object(obj, typ, options, refStack) {
        const isMap = typ !== "Object";
        const keys = isMap ? obj.keys() : Object.keys(obj);
        const length4 = isMap ? obj.size : keys.length;
        if (!length4) {
          if (options.addBreakTokens === true) {
            return [
              simpleTokens.emptyMap,
              new Token(Type.break)
            ];
          }
          return simpleTokens.emptyMap;
        }
        refStack = Ref.createCheck(refStack, obj);
        const entries = [];
        let i = 0;
        for (const key of keys) {
          entries[i++] = [
            objectToTokens(key, options, refStack),
            objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)
          ];
        }
        sortMapEntries(entries, options);
        if (options.addBreakTokens) {
          return [
            new Token(Type.map, length4),
            entries,
            new Token(Type.break)
          ];
        }
        return [
          new Token(Type.map, length4),
          entries
        ];
      }
    };
    typeEncoders.Map = typeEncoders.Object;
    typeEncoders.Buffer = typeEncoders.Uint8Array;
    for (const typ of "Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64".split(" ")) {
      typeEncoders[`${typ}Array`] = typeEncoders.DataView;
    }
  }
});

// node_modules/cborg/esm/lib/decode.js
function tokenToArray(token, tokeniser, options) {
  const arr = [];
  for (let i = 0; i < token.value; i++) {
    const value = tokensToObject(tokeniser, options);
    if (value === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed array`);
    }
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found array but not enough entries (got ${i}, expected ${token.value})`);
    }
    arr[i] = value;
  }
  return arr;
}
function tokenToMap(token, tokeniser, options) {
  const useMaps = options.useMaps === true;
  const obj = useMaps ? void 0 : {};
  const m = useMaps ? new Map() : void 0;
  for (let i = 0; i < token.value; i++) {
    const key = tokensToObject(tokeniser, options);
    if (key === BREAK) {
      if (token.value === Infinity) {
        break;
      }
      throw new Error(`${decodeErrPrefix} got unexpected break to lengthed map`);
    }
    if (key === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no key], expected ${token.value})`);
    }
    if (useMaps !== true && typeof key !== "string") {
      throw new Error(`${decodeErrPrefix} non-string keys not supported (got ${typeof key})`);
    }
    const value = tokensToObject(tokeniser, options);
    if (value === DONE) {
      throw new Error(`${decodeErrPrefix} found map but not enough entries (got ${i} [no value], expected ${token.value})`);
    }
    if (useMaps) {
      m.set(key, value);
    } else {
      obj[key] = value;
    }
  }
  return useMaps ? m : obj;
}
function tokensToObject(tokeniser, options) {
  if (tokeniser.done()) {
    return DONE;
  }
  const token = tokeniser.next();
  if (token.type === Type.break) {
    return BREAK;
  }
  if (token.type.terminal) {
    return token.value;
  }
  if (token.type === Type.array) {
    return tokenToArray(token, tokeniser, options);
  }
  if (token.type === Type.map) {
    return tokenToMap(token, tokeniser, options);
  }
  if (token.type === Type.tag) {
    if (options.tags && typeof options.tags[token.value] === "function") {
      const tagged = tokensToObject(tokeniser, options);
      return options.tags[token.value](tagged);
    }
    throw new Error(`${decodeErrPrefix} tag not supported (${token.value})`);
  }
  throw new Error("unsupported");
}
function decode6(data, options) {
  if (!(data instanceof Uint8Array)) {
    throw new Error(`${decodeErrPrefix} data to decode must be a Uint8Array`);
  }
  options = Object.assign({}, defaultDecodeOptions, options);
  const tokeniser = options.tokenizer || new Tokeniser(data, options);
  const decoded = tokensToObject(tokeniser, options);
  if (decoded === DONE) {
    throw new Error(`${decodeErrPrefix} did not find any content to decode`);
  }
  if (decoded === BREAK) {
    throw new Error(`${decodeErrPrefix} got unexpected break`);
  }
  if (!tokeniser.done()) {
    throw new Error(`${decodeErrPrefix} too many terminals, data makes no sense`);
  }
  return decoded;
}
var defaultDecodeOptions, Tokeniser, DONE, BREAK;
var init_decode = __esm({
  "node_modules/cborg/esm/lib/decode.js"() {
    init_node_globals();
    init_common();
    init_token();
    init_jump();
    defaultDecodeOptions = {
      strict: false,
      allowIndefinite: true,
      allowUndefined: true,
      allowBigInt: true
    };
    Tokeniser = class {
      constructor(data, options = {}) {
        this.pos = 0;
        this.data = data;
        this.options = options;
      }
      done() {
        return this.pos >= this.data.length;
      }
      next() {
        const byt = this.data[this.pos];
        let token = quick[byt];
        if (token === void 0) {
          const decoder = jump[byt];
          if (!decoder) {
            throw new Error(`${decodeErrPrefix} no decoder for major type ${byt >>> 5} (byte 0x${byt.toString(16).padStart(2, "0")})`);
          }
          const minor = byt & 31;
          token = decoder(this.data, this.pos, minor, this.options);
        }
        this.pos += token.encodedLength;
        return token;
      }
    };
    DONE = Symbol.for("DONE");
    BREAK = Symbol.for("BREAK");
  }
});

// node_modules/cborg/esm/cborg.js
var init_cborg = __esm({
  "node_modules/cborg/esm/cborg.js"() {
    init_node_globals();
    init_encode();
    init_decode();
    init_token();
  }
});

// node_modules/@ipld/dag-cbor/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  code: () => code2,
  decode: () => decode7,
  encode: () => encode5,
  name: () => name2
});
function cidEncoder(obj) {
  if (obj.asCID !== obj) {
    return null;
  }
  const cid = CID.asCID(obj);
  if (!cid) {
    return null;
  }
  const bytes3 = new Uint8Array(cid.bytes.byteLength + 1);
  bytes3.set(cid.bytes, 1);
  return [
    new Token(Type.tag, CID_CBOR_TAG),
    new Token(Type.bytes, bytes3)
  ];
}
function undefinedEncoder() {
  throw new Error("`undefined` is not supported by the IPLD Data Model and cannot be encoded");
}
function numberEncoder(num) {
  if (Number.isNaN(num)) {
    throw new Error("`NaN` is not supported by the IPLD Data Model and cannot be encoded");
  }
  if (num === Infinity || num === -Infinity) {
    throw new Error("`Infinity` and `-Infinity` is not supported by the IPLD Data Model and cannot be encoded");
  }
  return null;
}
function cidDecoder(bytes3) {
  if (bytes3[0] !== 0) {
    throw new Error("Invalid CID for CBOR tag 42; expected leading 0x00");
  }
  return CID.decode(bytes3.subarray(1));
}
var CID_CBOR_TAG, encodeOptions, decodeOptions, name2, code2, encode5, decode7;
var init_esm = __esm({
  "node_modules/@ipld/dag-cbor/esm/index.js"() {
    init_node_globals();
    init_cborg();
    init_cid();
    CID_CBOR_TAG = 42;
    encodeOptions = {
      float64: true,
      typeEncoders: {
        Object: cidEncoder,
        undefined: undefinedEncoder,
        number: numberEncoder
      }
    };
    decodeOptions = {
      allowIndefinite: false,
      allowUndefined: false,
      allowNaN: false,
      allowInfinity: false,
      allowBigInt: true,
      strict: true,
      useMaps: false,
      tags: []
    };
    decodeOptions.tags[CID_CBOR_TAG] = cidDecoder;
    name2 = "dag-cbor";
    code2 = 113;
    encode5 = (node) => encode4(node, encodeOptions);
    decode7 = (data) => decode6(data, decodeOptions);
  }
});

// node_modules/multiformats/esm/src/hashes/hasher.js
var hasher_exports = {};
__export(hasher_exports, {
  Hasher: () => Hasher,
  from: () => from2
});
var from2, Hasher;
var init_hasher = __esm({
  "node_modules/multiformats/esm/src/hashes/hasher.js"() {
    init_node_globals();
    init_digest();
    from2 = ({ name: name5, code: code5, encode: encode10 }) => new Hasher(name5, code5, encode10);
    Hasher = class {
      constructor(name5, code5, encode10) {
        this.name = name5;
        this.code = code5;
        this.encode = encode10;
      }
      async digest(input) {
        if (input instanceof Uint8Array) {
          const digest = await this.encode(input);
          return create(this.code, digest);
        } else {
          throw Error("Unknown type, must be binary type");
        }
      }
    };
  }
});

// node_modules/multiformats/esm/src/hashes/identity.js
var identity_exports = {};
__export(identity_exports, {
  identity: () => identity
});
var identity;
var init_identity = __esm({
  "node_modules/multiformats/esm/src/hashes/identity.js"() {
    init_node_globals();
    init_hasher();
    init_bytes();
    identity = from2({
      name: "identity",
      code: 0,
      encode: (input) => coerce(input)
    });
  }
});

// node_modules/multiformats/esm/src/bases/identity.js
var identity_exports2 = {};
__export(identity_exports2, {
  identity: () => identity2
});
var identity2;
var init_identity2 = __esm({
  "node_modules/multiformats/esm/src/bases/identity.js"() {
    init_node_globals();
    init_base();
    init_bytes();
    identity2 = from({
      prefix: "\0",
      name: "identity",
      encode: (buf2) => toString(buf2),
      decode: (str) => fromString(str)
    });
  }
});

// node_modules/multiformats/esm/src/bases/base2.js
var base2_exports = {};
__export(base2_exports, {
  base2: () => base2
});
var base2;
var init_base2 = __esm({
  "node_modules/multiformats/esm/src/bases/base2.js"() {
    init_node_globals();
    init_base();
    base2 = rfc4648({
      prefix: "0",
      name: "base2",
      alphabet: "01",
      bitsPerChar: 1
    });
  }
});

// node_modules/multiformats/esm/src/bases/base8.js
var base8_exports = {};
__export(base8_exports, {
  base8: () => base8
});
var base8;
var init_base8 = __esm({
  "node_modules/multiformats/esm/src/bases/base8.js"() {
    init_node_globals();
    init_base();
    base8 = rfc4648({
      prefix: "7",
      name: "base8",
      alphabet: "01234567",
      bitsPerChar: 3
    });
  }
});

// node_modules/multiformats/esm/src/bases/base10.js
var base10_exports = {};
__export(base10_exports, {
  base10: () => base10
});
var base10;
var init_base10 = __esm({
  "node_modules/multiformats/esm/src/bases/base10.js"() {
    init_node_globals();
    init_base();
    base10 = baseX({
      prefix: "9",
      name: "base10",
      alphabet: "0123456789"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base16.js
var base16_exports = {};
__export(base16_exports, {
  base16: () => base16,
  base16upper: () => base16upper
});
var base16, base16upper;
var init_base16 = __esm({
  "node_modules/multiformats/esm/src/bases/base16.js"() {
    init_node_globals();
    init_base();
    base16 = rfc4648({
      prefix: "f",
      name: "base16",
      alphabet: "0123456789abcdef",
      bitsPerChar: 4
    });
    base16upper = rfc4648({
      prefix: "F",
      name: "base16upper",
      alphabet: "0123456789ABCDEF",
      bitsPerChar: 4
    });
  }
});

// node_modules/multiformats/esm/src/bases/base36.js
var base36_exports = {};
__export(base36_exports, {
  base36: () => base36,
  base36upper: () => base36upper
});
var base36, base36upper;
var init_base36 = __esm({
  "node_modules/multiformats/esm/src/bases/base36.js"() {
    init_node_globals();
    init_base();
    base36 = baseX({
      prefix: "k",
      name: "base36",
      alphabet: "0123456789abcdefghijklmnopqrstuvwxyz"
    });
    base36upper = baseX({
      prefix: "K",
      name: "base36upper",
      alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    });
  }
});

// node_modules/multiformats/esm/src/bases/base64.js
var base64_exports = {};
__export(base64_exports, {
  base64: () => base64,
  base64pad: () => base64pad,
  base64url: () => base64url,
  base64urlpad: () => base64urlpad
});
var base64, base64pad, base64url, base64urlpad;
var init_base64 = __esm({
  "node_modules/multiformats/esm/src/bases/base64.js"() {
    init_node_globals();
    init_base();
    base64 = rfc4648({
      prefix: "m",
      name: "base64",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      bitsPerChar: 6
    });
    base64pad = rfc4648({
      prefix: "M",
      name: "base64pad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
      bitsPerChar: 6
    });
    base64url = rfc4648({
      prefix: "u",
      name: "base64url",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
      bitsPerChar: 6
    });
    base64urlpad = rfc4648({
      prefix: "U",
      name: "base64urlpad",
      alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=",
      bitsPerChar: 6
    });
  }
});

// node_modules/multiformats/esm/src/hashes/sha2-browser.js
var sha2_browser_exports = {};
__export(sha2_browser_exports, {
  sha256: () => sha256,
  sha512: () => sha512
});
var sha, sha256, sha512;
var init_sha2_browser = __esm({
  "node_modules/multiformats/esm/src/hashes/sha2-browser.js"() {
    init_node_globals();
    init_hasher();
    sha = (name5) => async (data) => new Uint8Array(await crypto.subtle.digest(name5, data));
    sha256 = from2({
      name: "sha2-256",
      code: 18,
      encode: sha("SHA-256")
    });
    sha512 = from2({
      name: "sha2-512",
      code: 19,
      encode: sha("SHA-512")
    });
  }
});

// node_modules/multiformats/esm/src/codecs/raw.js
var raw_exports = {};
__export(raw_exports, {
  code: () => code3,
  decode: () => decode8,
  encode: () => encode6,
  name: () => name3
});
var name3, code3, encode6, decode8;
var init_raw = __esm({
  "node_modules/multiformats/esm/src/codecs/raw.js"() {
    init_node_globals();
    init_bytes();
    name3 = "raw";
    code3 = 85;
    encode6 = (node) => coerce(node);
    decode8 = (data) => coerce(data);
  }
});

// node_modules/multiformats/esm/src/codecs/json.js
var json_exports = {};
__export(json_exports, {
  code: () => code4,
  decode: () => decode9,
  encode: () => encode7,
  name: () => name4
});
var textEncoder4, textDecoder3, name4, code4, encode7, decode9;
var init_json = __esm({
  "node_modules/multiformats/esm/src/codecs/json.js"() {
    init_node_globals();
    textEncoder4 = new TextEncoder();
    textDecoder3 = new TextDecoder();
    name4 = "json";
    code4 = 512;
    encode7 = (node) => textEncoder4.encode(JSON.stringify(node));
    decode9 = (data) => JSON.parse(textDecoder3.decode(data));
  }
});

// node_modules/multiformats/esm/src/index.js
var init_src3 = __esm({
  "node_modules/multiformats/esm/src/index.js"() {
    init_node_globals();
    init_cid();
    init_varint2();
    init_bytes();
    init_hasher();
    init_digest();
  }
});

// node_modules/multiformats/esm/src/basics.js
var basics_exports = {};
__export(basics_exports, {
  CID: () => CID,
  bases: () => bases,
  bytes: () => bytes_exports,
  codecs: () => codecs,
  digest: () => digest_exports,
  hasher: () => hasher_exports,
  hashes: () => hashes,
  varint: () => varint_exports
});
var bases, hashes, codecs;
var init_basics = __esm({
  "node_modules/multiformats/esm/src/basics.js"() {
    init_node_globals();
    init_identity2();
    init_base2();
    init_base8();
    init_base10();
    init_base16();
    init_base32();
    init_base36();
    init_base58();
    init_base64();
    init_sha2_browser();
    init_identity();
    init_raw();
    init_json();
    init_src3();
    bases = {
      ...identity_exports2,
      ...base2_exports,
      ...base8_exports,
      ...base10_exports,
      ...base16_exports,
      ...base32_exports,
      ...base36_exports,
      ...base58_exports,
      ...base64_exports
    };
    hashes = {
      ...sha2_browser_exports,
      ...identity_exports
    };
    codecs = {
      raw: raw_exports,
      json: json_exports
    };
  }
});

// node_modules/ipfs-core-config/esm/src/init-assets.browser.js
var init_assets_browser_exports = {};
__export(init_assets_browser_exports, {
  initAssets: () => initAssets
});
function initAssets() {
}
var init_init_assets_browser = __esm({
  "node_modules/ipfs-core-config/esm/src/init-assets.browser.js"() {
    init_node_globals();
  }
});

// node_modules/ipfs-core/cjs/src/errors.js
var require_errors = __commonJS({
  "node_modules/ipfs-core/cjs/src/errors.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var NotInitializedError = class extends Error {
      constructor(message = "not initialized") {
        super(message);
        this.name = "NotInitializedError";
        this.code = NotInitializedError.code;
      }
    };
    NotInitializedError.code = "ERR_NOT_INITIALIZED";
    var AlreadyInitializingError = class extends Error {
      constructor(message = "cannot initialize an initializing node") {
        super(message);
        this.name = "AlreadyInitializingError";
        this.code = AlreadyInitializedError.code;
      }
    };
    AlreadyInitializingError.code = "ERR_ALREADY_INITIALIZING";
    var AlreadyInitializedError = class extends Error {
      constructor(message = "cannot re-initialize an initialized node") {
        super(message);
        this.name = "AlreadyInitializedError";
        this.code = AlreadyInitializedError.code;
      }
    };
    AlreadyInitializedError.code = "ERR_ALREADY_INITIALIZED";
    var NotStartedError = class extends Error {
      constructor(message = "not started") {
        super(message);
        this.name = "NotStartedError";
        this.code = NotStartedError.code;
      }
    };
    NotStartedError.code = "ERR_NOT_STARTED";
    var AlreadyStartingError = class extends Error {
      constructor(message = "cannot start, already startin") {
        super(message);
        this.name = "AlreadyStartingError";
        this.code = AlreadyStartingError.code;
      }
    };
    AlreadyStartingError.code = "ERR_ALREADY_STARTING";
    var AlreadyStartedError = class extends Error {
      constructor(message = "cannot start, already started") {
        super(message);
        this.name = "AlreadyStartedError";
        this.code = AlreadyStartedError.code;
      }
    };
    AlreadyStartedError.code = "ERR_ALREADY_STARTED";
    var NotEnabledError = class extends Error {
      constructor(message = "not enabled") {
        super(message);
        this.name = "NotEnabledError";
        this.code = NotEnabledError.code;
      }
    };
    NotEnabledError.code = "ERR_NOT_ENABLED";
    exports2.AlreadyInitializedError = AlreadyInitializedError;
    exports2.AlreadyInitializingError = AlreadyInitializingError;
    exports2.AlreadyStartedError = AlreadyStartedError;
    exports2.AlreadyStartingError = AlreadyStartingError;
    exports2.NotEnabledError = NotEnabledError;
    exports2.NotInitializedError = NotInitializedError;
    exports2.NotStartedError = NotStartedError;
  }
});

// node_modules/uint8arrays/esm/src/util/bases.js
function createCodec(name5, prefix, encode10, decode12) {
  return {
    name: name5,
    prefix,
    encoder: {
      name: name5,
      prefix,
      encode: encode10
    },
    decoder: { decode: decode12 }
  };
}
var string2, ascii, BASES, bases_default;
var init_bases = __esm({
  "node_modules/uint8arrays/esm/src/util/bases.js"() {
    init_node_globals();
    init_basics();
    string2 = createCodec("utf8", "u", (buf2) => {
      const decoder = new TextDecoder("utf8");
      return "u" + decoder.decode(buf2);
    }, (str) => {
      const encoder = new TextEncoder();
      return encoder.encode(str.substring(1));
    });
    ascii = createCodec("ascii", "a", (buf2) => {
      let string3 = "a";
      for (let i = 0; i < buf2.length; i++) {
        string3 += String.fromCharCode(buf2[i]);
      }
      return string3;
    }, (str) => {
      str = str.substring(1);
      const buf2 = new Uint8Array(str.length);
      for (let i = 0; i < str.length; i++) {
        buf2[i] = str.charCodeAt(i);
      }
      return buf2;
    });
    BASES = {
      utf8: string2,
      "utf-8": string2,
      hex: bases.base16,
      latin1: ascii,
      ascii,
      binary: ascii,
      ...bases
    };
    bases_default = BASES;
  }
});

// node_modules/uint8arrays/esm/src/from-string.js
var from_string_exports = {};
__export(from_string_exports, {
  fromString: () => fromString3
});
function fromString3(string3, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base3.decoder.decode(`${base3.prefix}${string3}`);
}
var init_from_string = __esm({
  "node_modules/uint8arrays/esm/src/from-string.js"() {
    init_node_globals();
    init_bases();
  }
});

// node_modules/ip-regex/index.js
var require_ip_regex = __commonJS({
  "node_modules/ip-regex/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var word = "[a-fA-F\\d:]";
    var b = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
    var v4exact = new RegExp(`^${v4}$`);
    var v6exact = new RegExp(`^${v6}$`);
    var ip = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, "g");
    ip.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, "g");
    ip.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, "g");
    module2.exports = ip;
  }
});

// node_modules/is-ip/index.js
var require_is_ip = __commonJS({
  "node_modules/is-ip/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var ipRegex = require_ip_regex();
    var isIp = (string3) => ipRegex({ exact: true }).test(string3);
    isIp.v4 = (string3) => ipRegex.v4({ exact: true }).test(string3);
    isIp.v6 = (string3) => ipRegex.v6({ exact: true }).test(string3);
    isIp.version = (string3) => isIp(string3) ? isIp.v4(string3) ? 4 : 6 : void 0;
    module2.exports = isIp;
  }
});

// node_modules/uint8arrays/esm/src/to-string.js
var to_string_exports = {};
__export(to_string_exports, {
  toString: () => toString3
});
function toString3(array2, encoding = "utf8") {
  const base3 = bases_default[encoding];
  if (!base3) {
    throw new Error(`Unsupported encoding "${encoding}"`);
  }
  return base3.encoder.encode(array2).substring(1);
}
var init_to_string = __esm({
  "node_modules/uint8arrays/esm/src/to-string.js"() {
    init_node_globals();
    init_bases();
  }
});

// node_modules/multiaddr/src/ip.js
var require_ip = __commonJS({
  "node_modules/multiaddr/src/ip.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var isIp = require_is_ip();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var isIP = isIp;
    var isV4 = isIp.v4;
    var isV6 = isIp.v6;
    var toBytes2 = function(ip, buff, offset) {
      offset = ~~offset;
      let result;
      if (isV4(ip)) {
        result = buff || new Uint8Array(offset + 4);
        ip.split(/\./g).map(function(byte) {
          result[offset++] = parseInt(byte, 10) & 255;
        });
      } else if (isV6(ip)) {
        const sections = ip.split(":", 8);
        let i;
        for (i = 0; i < sections.length; i++) {
          const isv4 = isV4(sections[i]);
          let v4Buffer;
          if (isv4) {
            v4Buffer = toBytes2(sections[i]);
            sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), "base16");
          }
          if (v4Buffer && ++i < 8) {
            sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), "base16"));
          }
        }
        if (sections[0] === "") {
          while (sections.length < 8)
            sections.unshift("0");
        } else if (sections[sections.length - 1] === "") {
          while (sections.length < 8)
            sections.push("0");
        } else if (sections.length < 8) {
          for (i = 0; i < sections.length && sections[i] !== ""; i++)
            ;
          const argv = [i, "1"];
          for (i = 9 - sections.length; i > 0; i--) {
            argv.push("0");
          }
          sections.splice.apply(sections, argv);
        }
        result = buff || new Uint8Array(offset + 16);
        for (i = 0; i < sections.length; i++) {
          const word = parseInt(sections[i], 16);
          result[offset++] = word >> 8 & 255;
          result[offset++] = word & 255;
        }
      }
      if (!result) {
        throw Error("Invalid ip address: " + ip);
      }
      return result;
    };
    var toString4 = function(buff, offset, length4) {
      offset = ~~offset;
      length4 = length4 || buff.length - offset;
      const result = [];
      let string3;
      const view = new DataView(buff.buffer);
      if (length4 === 4) {
        for (let i = 0; i < length4; i++) {
          result.push(buff[offset + i]);
        }
        string3 = result.join(".");
      } else if (length4 === 16) {
        for (let i = 0; i < length4; i += 2) {
          result.push(view.getUint16(offset + i).toString(16));
        }
        string3 = result.join(":");
        string3 = string3.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
        string3 = string3.replace(/:{3,4}/, "::");
      }
      return string3;
    };
    module2.exports = {
      isIP,
      isV4,
      isV6,
      toBytes: toBytes2,
      toString: toString4
    };
  }
});

// node_modules/multiaddr/src/protocols-table.js
var require_protocols_table = __commonJS({
  "node_modules/multiaddr/src/protocols-table.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function Protocols(proto) {
      if (typeof proto === "number") {
        if (Protocols.codes[proto]) {
          return Protocols.codes[proto];
        }
        throw new Error("no protocol with code: " + proto);
      } else if (typeof proto === "string") {
        if (Protocols.names[proto]) {
          return Protocols.names[proto];
        }
        throw new Error("no protocol with name: " + proto);
      }
      throw new Error("invalid protocol id type: " + proto);
    }
    var V = -1;
    Protocols.lengthPrefixedVarSize = V;
    Protocols.V = V;
    Protocols.table = [
      [4, 32, "ip4"],
      [6, 16, "tcp"],
      [33, 16, "dccp"],
      [41, 128, "ip6"],
      [42, V, "ip6zone"],
      [53, V, "dns", "resolvable"],
      [54, V, "dns4", "resolvable"],
      [55, V, "dns6", "resolvable"],
      [56, V, "dnsaddr", "resolvable"],
      [132, 16, "sctp"],
      [273, 16, "udp"],
      [275, 0, "p2p-webrtc-star"],
      [276, 0, "p2p-webrtc-direct"],
      [277, 0, "p2p-stardust"],
      [290, 0, "p2p-circuit"],
      [301, 0, "udt"],
      [302, 0, "utp"],
      [400, V, "unix", false, "path"],
      [421, V, "ipfs"],
      [421, V, "p2p"],
      [443, 0, "https"],
      [444, 96, "onion"],
      [445, 296, "onion3"],
      [446, V, "garlic64"],
      [460, 0, "quic"],
      [477, 0, "ws"],
      [478, 0, "wss"],
      [479, 0, "p2p-websocket-star"],
      [480, 0, "http"],
      [777, V, "memory"]
    ];
    Protocols.names = {};
    Protocols.codes = {};
    Protocols.table.map((row) => {
      const proto = p.apply(null, row);
      Protocols.codes[proto.code] = proto;
      Protocols.names[proto.name] = proto;
      return null;
    });
    Protocols.object = p;
    function p(code5, size, name5, resolvable, path) {
      return {
        code: code5,
        size,
        name: name5,
        resolvable: Boolean(resolvable),
        path: Boolean(path)
      };
    }
    module2.exports = Protocols;
  }
});

// node_modules/varint/encode.js
var require_encode = __commonJS({
  "node_modules/varint/encode.js"(exports2, module2) {
    init_node_globals();
    module2.exports = encode10;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode10(num, out, offset) {
      if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
        encode10.bytes = 0;
        throw new RangeError("Could not encode varint");
      }
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode10.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint/decode.js
var require_decode = __commonJS({
  "node_modules/varint/decode.js"(exports2, module2) {
    init_node_globals();
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l || shift > 49) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint/length.js
var require_length = __commonJS({
  "node_modules/varint/length.js"(exports2, module2) {
    init_node_globals();
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});

// node_modules/varint/index.js
var require_varint = __commonJS({
  "node_modules/varint/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = {
      encode: require_encode(),
      decode: require_decode(),
      encodingLength: require_length()
    };
  }
});

// node_modules/uint8arrays/esm/src/concat.js
var concat_exports = {};
__export(concat_exports, {
  concat: () => concat2
});
function concat2(arrays, length4) {
  if (!length4) {
    length4 = arrays.reduce((acc, curr) => acc + curr.length, 0);
  }
  const output = new Uint8Array(length4);
  let offset = 0;
  for (const arr of arrays) {
    output.set(arr, offset);
    offset += arr.length;
  }
  return output;
}
var init_concat = __esm({
  "node_modules/uint8arrays/esm/src/concat.js"() {
    init_node_globals();
  }
});

// node_modules/multiaddr/src/convert.js
var require_convert = __commonJS({
  "node_modules/multiaddr/src/convert.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var ip = require_ip();
    var protocols = require_protocols_table();
    var { CID: CID2 } = (init_cid(), cid_exports);
    var { base32: base322 } = (init_base32(), base32_exports);
    var { base58btc: base58btc2 } = (init_base58(), base58_exports);
    var Digest9 = (init_digest(), digest_exports);
    var varint7 = require_varint();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
    module2.exports = Convert;
    function Convert(proto, a) {
      if (a instanceof Uint8Array) {
        return Convert.toString(proto, a);
      } else {
        return Convert.toBytes(proto, a);
      }
    }
    Convert.toString = function convertToString(proto, buf2) {
      const protocol = protocols(proto);
      switch (protocol.code) {
        case 4:
        case 41:
          return bytes2ip(buf2);
        case 6:
        case 273:
        case 33:
        case 132:
          return bytes2port(buf2).toString();
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 777:
          return bytes2str(buf2);
        case 421:
          return bytes2mh(buf2);
        case 444:
          return bytes2onion(buf2);
        case 445:
          return bytes2onion(buf2);
        default:
          return uint8ArrayToString(buf2, "base16");
      }
    };
    Convert.toBytes = function convertToBytes(proto, str) {
      const protocol = protocols(proto);
      switch (protocol.code) {
        case 4:
          return ip2bytes(str);
        case 41:
          return ip2bytes(str);
        case 6:
        case 273:
        case 33:
        case 132:
          return port2bytes(parseInt(str, 10));
        case 53:
        case 54:
        case 55:
        case 56:
        case 400:
        case 777:
          return str2bytes(str);
        case 421:
          return mh2bytes(str);
        case 444:
          return onion2bytes(str);
        case 445:
          return onion32bytes(str);
        default:
          return uint8ArrayFromString(str, "base16");
      }
    };
    function ip2bytes(ipString) {
      if (!ip.isIP(ipString)) {
        throw new Error("invalid ip address");
      }
      return ip.toBytes(ipString);
    }
    function bytes2ip(ipBuff) {
      const ipString = ip.toString(ipBuff);
      if (!ipString || !ip.isIP(ipString)) {
        throw new Error("invalid ip address");
      }
      return ipString;
    }
    function port2bytes(port) {
      const buf2 = new ArrayBuffer(2);
      const view = new DataView(buf2);
      view.setUint16(0, port);
      return new Uint8Array(buf2);
    }
    function bytes2port(buf2) {
      const view = new DataView(buf2.buffer);
      return view.getUint16(buf2.byteOffset);
    }
    function str2bytes(str) {
      const buf2 = uint8ArrayFromString(str);
      const size = Uint8Array.from(varint7.encode(buf2.length));
      return uint8ArrayConcat([size, buf2], size.length + buf2.length);
    }
    function bytes2str(buf2) {
      const size = varint7.decode(buf2);
      buf2 = buf2.slice(varint7.decode.bytes);
      if (buf2.length !== size) {
        throw new Error("inconsistent lengths");
      }
      return uint8ArrayToString(buf2);
    }
    function mh2bytes(hash2) {
      let mh2;
      if (hash2[0] === "Q" || hash2[0] === "1") {
        mh2 = Digest9.decode(base58btc2.decode(`z${hash2}`)).bytes;
      } else {
        mh2 = CID2.parse(hash2).multihash.bytes;
      }
      const size = Uint8Array.from(varint7.encode(mh2.length));
      return uint8ArrayConcat([size, mh2], size.length + mh2.length);
    }
    function bytes2mh(buf2) {
      const size = varint7.decode(buf2);
      const address = buf2.slice(varint7.decode.bytes);
      if (address.length !== size) {
        throw new Error("inconsistent lengths");
      }
      return uint8ArrayToString(address, "base58btc");
    }
    function onion2bytes(str) {
      const addr = str.split(":");
      if (addr.length !== 2) {
        throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
      }
      if (addr[0].length !== 16) {
        throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion address.");
      }
      const buf2 = base322.decode("b" + addr[0]);
      const port = parseInt(addr[1], 10);
      if (port < 1 || port > 65536) {
        throw new Error("Port number is not in range(1, 65536)");
      }
      const portBuf = port2bytes(port);
      return uint8ArrayConcat([buf2, portBuf], buf2.length + portBuf.length);
    }
    function onion32bytes(str) {
      const addr = str.split(":");
      if (addr.length !== 2) {
        throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
      }
      if (addr[0].length !== 56) {
        throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion3 address.");
      }
      const buf2 = base322.decode("b" + addr[0]);
      const port = parseInt(addr[1], 10);
      if (port < 1 || port > 65536) {
        throw new Error("Port number is not in range(1, 65536)");
      }
      const portBuf = port2bytes(port);
      return uint8ArrayConcat([buf2, portBuf], buf2.length + portBuf.length);
    }
    function bytes2onion(buf2) {
      const addrBytes = buf2.slice(0, buf2.length - 2);
      const portBytes = buf2.slice(buf2.length - 2);
      const addr = uint8ArrayToString(addrBytes, "base32");
      const port = bytes2port(portBytes);
      return addr + ":" + port;
    }
  }
});

// node_modules/multiaddr/src/codec.js
var require_codec = __commonJS({
  "node_modules/multiaddr/src/codec.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var convert = require_convert();
    var protocols = require_protocols_table();
    var varint7 = require_varint();
    var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    module2.exports = {
      stringToStringTuples,
      stringTuplesToString,
      tuplesToStringTuples,
      stringTuplesToTuples,
      bytesToTuples,
      tuplesToBytes,
      bytesToString,
      stringToBytes,
      fromString: fromString4,
      fromBytes: fromBytes2,
      validateBytes,
      isValidBytes,
      cleanPath,
      ParseError,
      protoFromTuple,
      sizeForAddr
    };
    function stringToStringTuples(str) {
      const tuples = [];
      const parts = str.split("/").slice(1);
      if (parts.length === 1 && parts[0] === "") {
        return [];
      }
      for (let p = 0; p < parts.length; p++) {
        const part = parts[p];
        const proto = protocols(part);
        if (proto.size === 0) {
          tuples.push([part]);
          continue;
        }
        p++;
        if (p >= parts.length) {
          throw ParseError("invalid address: " + str);
        }
        if (proto.path) {
          tuples.push([
            part,
            cleanPath(parts.slice(p).join("/"))
          ]);
          break;
        }
        tuples.push([part, parts[p]]);
      }
      return tuples;
    }
    function stringTuplesToString(tuples) {
      const parts = [];
      tuples.map((tup) => {
        const proto = protoFromTuple(tup);
        parts.push(proto.name);
        if (tup.length > 1) {
          parts.push(tup[1]);
        }
        return null;
      });
      return cleanPath(parts.join("/"));
    }
    function stringTuplesToTuples(tuples) {
      return tuples.map((tup) => {
        if (!Array.isArray(tup)) {
          tup = [tup];
        }
        const proto = protoFromTuple(tup);
        if (tup.length > 1) {
          return [proto.code, convert.toBytes(proto.code, tup[1])];
        }
        return [proto.code];
      });
    }
    function tuplesToStringTuples(tuples) {
      return tuples.map((tup) => {
        const proto = protoFromTuple(tup);
        if (tup[1]) {
          return [proto.code, convert.toString(proto.code, tup[1])];
        }
        return [proto.code];
      });
    }
    function tuplesToBytes(tuples) {
      return fromBytes2(uint8ArrayConcat(tuples.map((tup) => {
        const proto = protoFromTuple(tup);
        let buf2 = Uint8Array.from(varint7.encode(proto.code));
        if (tup.length > 1) {
          buf2 = uint8ArrayConcat([buf2, tup[1]]);
        }
        return buf2;
      })));
    }
    function sizeForAddr(p, addr) {
      if (p.size > 0) {
        return p.size / 8;
      } else if (p.size === 0) {
        return 0;
      } else {
        const size = varint7.decode(addr);
        return size + varint7.decode.bytes;
      }
    }
    function bytesToTuples(buf2) {
      const tuples = [];
      let i = 0;
      while (i < buf2.length) {
        const code5 = varint7.decode(buf2, i);
        const n = varint7.decode.bytes;
        const p = protocols(code5);
        const size = sizeForAddr(p, buf2.slice(i + n));
        if (size === 0) {
          tuples.push([code5]);
          i += n;
          continue;
        }
        const addr = buf2.slice(i + n, i + n + size);
        i += size + n;
        if (i > buf2.length) {
          throw ParseError("Invalid address Uint8Array: " + uint8ArrayToString(buf2, "base16"));
        }
        tuples.push([code5, addr]);
      }
      return tuples;
    }
    function bytesToString(buf2) {
      const a = bytesToTuples(buf2);
      const b = tuplesToStringTuples(a);
      return stringTuplesToString(b);
    }
    function stringToBytes(str) {
      str = cleanPath(str);
      const a = stringToStringTuples(str);
      const b = stringTuplesToTuples(a);
      return tuplesToBytes(b);
    }
    function fromString4(str) {
      return stringToBytes(str);
    }
    function fromBytes2(buf2) {
      const err = validateBytes(buf2);
      if (err)
        throw err;
      return Uint8Array.from(buf2);
    }
    function validateBytes(buf2) {
      try {
        bytesToTuples(buf2);
      } catch (err) {
        return err;
      }
    }
    function isValidBytes(buf2) {
      return validateBytes(buf2) === void 0;
    }
    function cleanPath(str) {
      return "/" + str.trim().split("/").filter((a) => a).join("/");
    }
    function ParseError(str) {
      return new Error("Error parsing address: " + str);
    }
    function protoFromTuple(tup) {
      const proto = protocols(tup[0]);
      return proto;
    }
  }
});

// node_modules/uint8arrays/esm/src/equals.js
var equals_exports = {};
__export(equals_exports, {
  equals: () => equals3
});
function equals3(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
var init_equals = __esm({
  "node_modules/uint8arrays/esm/src/equals.js"() {
    init_node_globals();
  }
});

// node_modules/multiaddr/src/index.js
var require_src = __commonJS({
  "node_modules/multiaddr/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var codec = require_codec();
    var protocols = require_protocols_table();
    var varint7 = require_varint();
    var { CID: CID2 } = (init_cid(), cid_exports);
    var { base58btc: base58btc2 } = (init_base58(), base58_exports);
    var errCode32 = require_err_code();
    var inspect = Symbol.for("nodejs.util.inspect.custom");
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var resolvers2 = new Map();
    var symbol = Symbol.for("@multiformats/js-multiaddr/multiaddr");
    var Multiaddr18 = class {
      constructor(addr) {
        if (addr == null) {
          addr = "";
        }
        Object.defineProperty(this, symbol, { value: true });
        if (addr instanceof Uint8Array) {
          this.bytes = codec.fromBytes(addr);
        } else if (typeof addr === "string") {
          if (addr.length > 0 && addr.charAt(0) !== "/") {
            throw new Error(`multiaddr "${addr}" must start with a "/"`);
          }
          this.bytes = codec.fromString(addr);
        } else if (Multiaddr18.isMultiaddr(addr)) {
          this.bytes = codec.fromBytes(addr.bytes);
        } else {
          throw new Error("addr must be a string, Buffer, or another Multiaddr");
        }
      }
      toString() {
        return codec.bytesToString(this.bytes);
      }
      toJSON() {
        return this.toString();
      }
      toOptions() {
        const opts = {};
        const parsed = this.toString().split("/");
        opts.family = parsed[1] === "ip4" ? 4 : 6;
        opts.host = parsed[2];
        opts.transport = parsed[3];
        opts.port = parseInt(parsed[4]);
        return opts;
      }
      protos() {
        return this.protoCodes().map((code5) => Object.assign({}, protocols(code5)));
      }
      protoCodes() {
        const codes = [];
        const buf2 = this.bytes;
        let i = 0;
        while (i < buf2.length) {
          const code5 = varint7.decode(buf2, i);
          const n = varint7.decode.bytes;
          const p = protocols(code5);
          const size = codec.sizeForAddr(p, buf2.slice(i + n));
          i += size + n;
          codes.push(code5);
        }
        return codes;
      }
      protoNames() {
        return this.protos().map((proto) => proto.name);
      }
      tuples() {
        return codec.bytesToTuples(this.bytes);
      }
      stringTuples() {
        const t = codec.bytesToTuples(this.bytes);
        return codec.tuplesToStringTuples(t);
      }
      encapsulate(addr) {
        addr = new Multiaddr18(addr);
        return new Multiaddr18(this.toString() + addr.toString());
      }
      decapsulate(addr) {
        const addrString = addr.toString();
        const s = this.toString();
        const i = s.lastIndexOf(addrString);
        if (i < 0) {
          throw new Error("Address " + this + " does not contain subaddress: " + addr);
        }
        return new Multiaddr18(s.slice(0, i));
      }
      decapsulateCode(code5) {
        const tuples = this.tuples();
        for (let i = tuples.length - 1; i >= 0; i--) {
          if (tuples[i][0] === code5) {
            return new Multiaddr18(codec.tuplesToBytes(tuples.slice(0, i)));
          }
        }
        return this;
      }
      getPeerId() {
        try {
          const tuples = this.stringTuples().filter((tuple2) => {
            if (tuple2[0] === protocols.names.ipfs.code) {
              return true;
            }
            return false;
          });
          const tuple = tuples.pop();
          if (tuple && tuple[1]) {
            const peerIdStr = tuple[1];
            if (peerIdStr[0] === "Q" || peerIdStr[0] === "1") {
              return uint8ArrayToString(base58btc2.decode(`z${peerIdStr}`), "base58btc");
            }
            return uint8ArrayToString(CID2.parse(peerIdStr).multihash.bytes, "base58btc");
          }
          return null;
        } catch (e) {
          return null;
        }
      }
      getPath() {
        let path = null;
        try {
          path = this.stringTuples().filter((tuple) => {
            const proto = protocols(tuple[0]);
            if (proto.path) {
              return true;
            }
            return false;
          })[0][1];
          if (!path) {
            path = null;
          }
        } catch (e) {
          path = null;
        }
        return path;
      }
      equals(addr) {
        return uint8ArrayEquals(this.bytes, addr.bytes);
      }
      async resolve() {
        const resolvableProto = this.protos().find((p) => p.resolvable);
        if (!resolvableProto) {
          return [this];
        }
        const resolver = resolvers2.get(resolvableProto.name);
        if (!resolver) {
          throw errCode32(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
        }
        const addresses = await resolver(this);
        return addresses.map((a) => new Multiaddr18(a));
      }
      nodeAddress() {
        const codes = this.protoCodes();
        const names = this.protoNames();
        const parts = this.toString().split("/").slice(1);
        if (parts.length < 4) {
          throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');
        } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {
          throw new Error(`no protocol with name: "'${names[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);
        } else if (parts[2] !== "tcp" && parts[2] !== "udp") {
          throw new Error(`no protocol with name: "'${names[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
        }
        return {
          family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,
          address: parts[1],
          port: parseInt(parts[3])
        };
      }
      isThinWaistAddress(addr) {
        const protos = (addr || this).protos();
        if (protos.length !== 2) {
          return false;
        }
        if (protos[0].code !== 4 && protos[0].code !== 41) {
          return false;
        }
        if (protos[1].code !== 6 && protos[1].code !== 273) {
          return false;
        }
        return true;
      }
      static fromNodeAddress(addr, transport) {
        if (!addr) {
          throw new Error("requires node address object");
        }
        if (!transport) {
          throw new Error("requires transport protocol");
        }
        let ip;
        switch (addr.family) {
          case 4:
            ip = "ip4";
            break;
          case 6:
            ip = "ip6";
            break;
          default:
            throw Error(`Invalid addr family. Got '${addr.family}' instead of 4 or 6`);
        }
        return new Multiaddr18("/" + [ip, addr.address, transport, addr.port].join("/"));
      }
      static isName(addr) {
        if (!Multiaddr18.isMultiaddr(addr)) {
          return false;
        }
        return addr.protos().some((proto) => proto.resolvable);
      }
      static isMultiaddr(value) {
        return value instanceof Multiaddr18 || Boolean(value && value[symbol]);
      }
      [inspect]() {
        return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
      }
      inspect() {
        return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
      }
    };
    Multiaddr18.protocols = protocols;
    Multiaddr18.resolvers = resolvers2;
    function multiaddr(addr) {
      return new Multiaddr18(addr);
    }
    module2.exports = { Multiaddr: Multiaddr18, multiaddr, protocols, resolvers: resolvers2 };
  }
});

// node_modules/mafmt/src/index.js
var require_src2 = __commonJS({
  "node_modules/mafmt/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { Multiaddr: Multiaddr18 } = require_src();
    var DNS4 = base3("dns4");
    var DNS6 = base3("dns6");
    var DNSADDR = base3("dnsaddr");
    var DNS = or(base3("dns"), DNSADDR, DNS4, DNS6);
    var IP = or(base3("ip4"), base3("ip6"));
    var TCP = or(and(IP, base3("tcp")), and(DNS, base3("tcp")));
    var UDP = and(IP, base3("udp"));
    var UTP = and(UDP, base3("utp"));
    var QUIC = and(UDP, base3("quic"));
    var WebSockets = or(and(TCP, base3("ws")), and(DNS, base3("ws")));
    var WebSocketsSecure = or(and(TCP, base3("wss")), and(DNS, base3("wss")));
    var HTTP4 = or(and(TCP, base3("http")), and(IP, base3("http")), and(DNS, base3("http")));
    var HTTPS = or(and(TCP, base3("https")), and(IP, base3("https")), and(DNS, base3("https")));
    var WebRTCStar2 = or(and(WebSockets, base3("p2p-webrtc-star"), base3("p2p")), and(WebSocketsSecure, base3("p2p-webrtc-star"), base3("p2p")), and(WebSockets, base3("p2p-webrtc-star")), and(WebSocketsSecure, base3("p2p-webrtc-star")));
    var WebSocketStar = or(and(WebSockets, base3("p2p-websocket-star"), base3("p2p")), and(WebSocketsSecure, base3("p2p-websocket-star"), base3("p2p")), and(WebSockets, base3("p2p-websocket-star")), and(WebSocketsSecure, base3("p2p-websocket-star")));
    var WebRTCDirect = or(and(HTTP4, base3("p2p-webrtc-direct"), base3("p2p")), and(HTTPS, base3("p2p-webrtc-direct"), base3("p2p")), and(HTTP4, base3("p2p-webrtc-direct")), and(HTTPS, base3("p2p-webrtc-direct")));
    var Reliable = or(WebSockets, WebSocketsSecure, HTTP4, HTTPS, WebRTCStar2, WebRTCDirect, TCP, UTP, QUIC, DNS);
    var Stardust = or(and(Reliable, base3("p2p-stardust"), base3("p2p")), and(Reliable, base3("p2p-stardust")));
    var _P2P = or(and(Reliable, base3("p2p")), WebRTCStar2, WebRTCDirect, base3("p2p"));
    var _Circuit = or(and(_P2P, base3("p2p-circuit"), _P2P), and(_P2P, base3("p2p-circuit")), and(base3("p2p-circuit"), _P2P), and(Reliable, base3("p2p-circuit")), and(base3("p2p-circuit"), Reliable), base3("p2p-circuit"));
    var CircuitRecursive = () => or(and(_Circuit, CircuitRecursive), _Circuit);
    var Circuit = CircuitRecursive();
    var P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
    module2.exports = {
      DNS,
      DNS4,
      DNS6,
      DNSADDR,
      IP,
      TCP,
      UDP,
      QUIC,
      UTP,
      HTTP: HTTP4,
      HTTPS,
      WebSockets,
      WebSocketsSecure,
      WebSocketStar,
      WebRTCStar: WebRTCStar2,
      WebRTCDirect,
      Reliable,
      Stardust,
      Circuit,
      P2P,
      IPFS: P2P
    };
    function makeMatchesFunction(partialMatch) {
      function matches(a) {
        if (!Multiaddr18.isMultiaddr(a)) {
          try {
            a = new Multiaddr18(a);
          } catch (err) {
            return false;
          }
        }
        const out = partialMatch(a.protoNames());
        if (out === null) {
          return false;
        }
        if (out === true || out === false) {
          return out;
        }
        return out.length === 0;
      }
      return matches;
    }
    function and(...args) {
      function partialMatch(a) {
        if (a.length < args.length) {
          return null;
        }
        let out = a;
        args.some((arg) => {
          out = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
          if (Array.isArray(out)) {
            a = out;
          }
          if (out === null) {
            return true;
          }
          return false;
        });
        return out;
      }
      return {
        toString: function() {
          return "{ " + args.join(" ") + " }";
        },
        input: args,
        matches: makeMatchesFunction(partialMatch),
        partialMatch
      };
    }
    function or(...args) {
      function partialMatch(a) {
        let out = null;
        args.some((arg) => {
          const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
          if (res) {
            out = res;
            return true;
          }
          return false;
        });
        return out;
      }
      const result = {
        toString: function() {
          return "{ " + args.join(" ") + " }";
        },
        input: args,
        matches: makeMatchesFunction(partialMatch),
        partialMatch
      };
      return result;
    }
    function base3(n) {
      const name5 = n;
      function matches(a) {
        let ma;
        if (typeof a === "string" || a instanceof Uint8Array) {
          try {
            ma = new Multiaddr18(a);
          } catch (err) {
            return false;
          }
        } else {
          ma = a;
        }
        const pnames = ma.protoNames();
        if (pnames.length === 1 && pnames[0] === name5) {
          return true;
        }
        return false;
      }
      function partialMatch(protos) {
        if (protos.length === 0) {
          return null;
        }
        if (protos[0] === name5) {
          return protos.slice(1);
        }
        return null;
      }
      return {
        toString: function() {
          return name5;
        },
        matches,
        partialMatch
      };
    }
  }
});

// node_modules/iso-url/src/url-browser.js
var require_url_browser = __commonJS({
  "node_modules/iso-url/src/url-browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var isReactNative = typeof navigator !== "undefined" && navigator.product === "ReactNative";
    function getDefaultBase() {
      if (isReactNative) {
        return "http://localhost";
      }
      return self.location.protocol + "//" + self.location.host;
    }
    var URL2 = self.URL;
    var defaultBase = getDefaultBase();
    var URLWithLegacySupport = class {
      constructor(url = "", base3 = defaultBase) {
        this.super = new URL2(url, base3);
        this.path = this.pathname + this.search;
        this.auth = this.username && this.password ? this.username + ":" + this.password : null;
        this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
      }
      get hash() {
        return this.super.hash;
      }
      get host() {
        return this.super.host;
      }
      get hostname() {
        return this.super.hostname;
      }
      get href() {
        return this.super.href;
      }
      get origin() {
        return this.super.origin;
      }
      get password() {
        return this.super.password;
      }
      get pathname() {
        return this.super.pathname;
      }
      get port() {
        return this.super.port;
      }
      get protocol() {
        return this.super.protocol;
      }
      get search() {
        return this.super.search;
      }
      get searchParams() {
        return this.super.searchParams;
      }
      get username() {
        return this.super.username;
      }
      set hash(hash2) {
        this.super.hash = hash2;
      }
      set host(host) {
        this.super.host = host;
      }
      set hostname(hostname) {
        this.super.hostname = hostname;
      }
      set href(href) {
        this.super.href = href;
      }
      set password(password) {
        this.super.password = password;
      }
      set pathname(pathname) {
        this.super.pathname = pathname;
      }
      set port(port) {
        this.super.port = port;
      }
      set protocol(protocol) {
        this.super.protocol = protocol;
      }
      set search(search) {
        this.super.search = search;
      }
      set username(username) {
        this.super.username = username;
      }
      static createObjectURL(o) {
        return URL2.createObjectURL(o);
      }
      static revokeObjectURL(o) {
        URL2.revokeObjectURL(o);
      }
      toJSON() {
        return this.super.toJSON();
      }
      toString() {
        return this.super.toString();
      }
      format() {
        return this.toString();
      }
    };
    function format(obj) {
      if (typeof obj === "string") {
        const url = new URL2(obj);
        return url.toString();
      }
      if (!(obj instanceof URL2)) {
        const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
        const auth = obj.auth ? obj.auth + "@" : "";
        const port = obj.port ? ":" + obj.port : "";
        const protocol = obj.protocol ? obj.protocol + "//" : "";
        const host = obj.host || "";
        const hostname = obj.hostname || "";
        const search = obj.search || (obj.query ? "?" + obj.query : "");
        const hash2 = obj.hash || "";
        const pathname = obj.pathname || "";
        const path = obj.path || pathname + search;
        return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash2}`;
      }
    }
    module2.exports = {
      URLWithLegacySupport,
      URLSearchParams: self.URLSearchParams,
      defaultBase,
      format
    };
  }
});

// node_modules/iso-url/src/relative.js
var require_relative = __commonJS({
  "node_modules/iso-url/src/relative.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { URLWithLegacySupport, format } = require_url_browser();
    module2.exports = (url, location2 = {}, protocolMap = {}, defaultProtocol) => {
      let protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
      protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
      let urlParsed;
      try {
        urlParsed = new URLWithLegacySupport(url);
      } catch (err) {
        urlParsed = {};
      }
      const base3 = Object.assign({}, location2, {
        protocol: protocol || urlParsed.protocol,
        host: location2.host || urlParsed.host
      });
      return new URLWithLegacySupport(url, format(base3)).toString();
    };
  }
});

// node_modules/iso-url/index.js
var require_iso_url = __commonJS({
  "node_modules/iso-url/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var {
      URLWithLegacySupport,
      format,
      URLSearchParams: URLSearchParams2,
      defaultBase
    } = require_url_browser();
    var relative = require_relative();
    module2.exports = {
      URL: URLWithLegacySupport,
      URLSearchParams: URLSearchParams2,
      format,
      relative,
      defaultBase
    };
  }
});

// node_modules/is-ipfs/src/index.js
var require_src3 = __commonJS({
  "node_modules/is-ipfs/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { base58btc: base58btc2 } = (init_base58(), base58_exports);
    var { base32: base322 } = (init_base32(), base32_exports);
    var Digest9 = (init_digest(), digest_exports);
    var { Multiaddr: Multiaddr18 } = require_src();
    var mafmt = require_src2();
    var { CID: CID2 } = (init_cid(), cid_exports);
    var { URL: URL2 } = require_iso_url();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var pathGatewayPattern = /^https?:\/\/[^/]+\/(ip[fn]s)\/([^/?#]+)/;
    var pathPattern = /^\/(ip[fn]s)\/([^/?#]+)/;
    var defaultProtocolMatch = 1;
    var defaultHashMath = 2;
    var subdomainGatewayPattern = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/;
    var subdomainIdMatch = 1;
    var subdomainProtocolMatch = 2;
    var fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
    function isMultihash(hash2) {
      const formatted = convertToString(hash2);
      try {
        Digest9.decode(base58btc2.decode("z" + formatted));
      } catch {
        return false;
      }
      return true;
    }
    function isBase32EncodedMultibase(hash2) {
      try {
        base322.decode(hash2);
      } catch {
        return false;
      }
      return true;
    }
    function isCID(hash2) {
      try {
        if (typeof hash2 === "string") {
          return Boolean(CID2.parse(hash2));
        }
        if (hash2 instanceof Uint8Array) {
          return Boolean(CID2.decode(hash2));
        }
        return Boolean(CID2.asCID(hash2));
      } catch (e) {
        return false;
      }
    }
    function isMultiaddr(input) {
      if (!input)
        return false;
      if (Multiaddr18.isMultiaddr(input))
        return true;
      try {
        new Multiaddr18(input);
        return true;
      } catch (e) {
        return false;
      }
    }
    function isPeerMultiaddr(input) {
      return isMultiaddr(input) && mafmt.P2P.matches(input);
    }
    function isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
      const formatted = convertToString(input);
      if (!formatted) {
        return false;
      }
      const match = formatted.match(pattern);
      if (!match) {
        return false;
      }
      if (match[protocolMatch] !== "ipfs") {
        return false;
      }
      let hash2 = match[hashMatch];
      if (hash2 && pattern === subdomainGatewayPattern) {
        hash2 = hash2.toLowerCase();
      }
      return isCID(hash2);
    }
    function isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
      const formatted = convertToString(input);
      if (!formatted) {
        return false;
      }
      const match = formatted.match(pattern);
      if (!match) {
        return false;
      }
      if (match[protocolMatch] !== "ipns") {
        return false;
      }
      let ipnsId = match[hashMatch];
      if (ipnsId && pattern === subdomainGatewayPattern) {
        ipnsId = ipnsId.toLowerCase();
        if (isCID(ipnsId))
          return true;
        try {
          if (!ipnsId.includes(".") && ipnsId.includes("-")) {
            ipnsId = ipnsId.replace(/--/g, "@").replace(/-/g, ".").replace(/@/g, "-");
          }
          const { hostname } = new URL2(`http://${ipnsId}`);
          return fqdnWithTld.test(hostname);
        } catch (e) {
          return false;
        }
      }
      return true;
    }
    function isString(input) {
      return typeof input === "string";
    }
    function convertToString(input) {
      if (input instanceof Uint8Array) {
        return uint8ArrayToString(input, "base58btc");
      }
      if (isString(input)) {
        return input;
      }
      return false;
    }
    var ipfsSubdomain = (url2) => isIpfs(url2, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);
    var ipnsSubdomain = (url2) => isIpns(url2, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);
    var subdomain = (url2) => ipfsSubdomain(url2) || ipnsSubdomain(url2);
    var ipfsUrl = (url2) => isIpfs(url2, pathGatewayPattern) || ipfsSubdomain(url2);
    var ipnsUrl = (url2) => isIpns(url2, pathGatewayPattern) || ipnsSubdomain(url2);
    var url = (url2) => ipfsUrl(url2) || ipnsUrl(url2) || subdomain(url2);
    var path = (path2) => isIpfs(path2, pathPattern) || isIpns(path2, pathPattern);
    module2.exports = {
      multihash: isMultihash,
      multiaddr: isMultiaddr,
      peerMultiaddr: isPeerMultiaddr,
      cid: isCID,
      base32cid: (cid) => isBase32EncodedMultibase(cid) && isCID(cid),
      ipfsSubdomain,
      ipnsSubdomain,
      subdomain,
      subdomainGatewayPattern,
      ipfsUrl,
      ipnsUrl,
      url,
      pathGatewayPattern,
      ipfsPath: (path2) => isIpfs(path2, pathPattern),
      ipnsPath: (path2) => isIpns(path2, pathPattern),
      path,
      pathPattern,
      urlOrPath: (x) => url(x) || path(x),
      cidPath: (path2) => isString(path2) && !isCID(path2) && isIpfs(`/ipfs/${path2}`, pathPattern)
    };
  }
});

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet;
var init_url_alphabet = __esm({
  "node_modules/nanoid/url-alphabet/index.js"() {
    init_node_globals();
    urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  }
});

// node_modules/nanoid/index.prod.js
var index_prod_exports = {};
__export(index_prod_exports, {
  customAlphabet: () => customAlphabet,
  customRandom: () => customRandom,
  nanoid: () => nanoid,
  random: () => random,
  urlAlphabet: () => urlAlphabet
});
var random, customRandom, customAlphabet, nanoid;
var init_index_prod = __esm({
  "node_modules/nanoid/index.prod.js"() {
    init_node_globals();
    init_url_alphabet();
    if (false) {
      if (typeof navigator !== "undefined" && navigator.product === "ReactNative" && typeof crypto === "undefined") {
        throw new Error("React Native does not have a built-in secure random generator. If you don\u2019t need unpredictable IDs use `nanoid/non-secure`. For secure IDs, import `react-native-get-random-values` before Nano ID.");
      }
      if (typeof msCrypto !== "undefined" && typeof crypto === "undefined") {
        throw new Error("Import file with `if (!window.crypto) window.crypto = window.msCrypto` before importing Nano ID to fix IE 11 support");
      }
      if (typeof crypto === "undefined") {
        throw new Error("Your browser does not have secure random generator. If you don\u2019t need unpredictable IDs, you can use nanoid/non-secure.");
      }
    }
    random = (bytes3) => crypto.getRandomValues(new Uint8Array(bytes3));
    customRandom = (alphabet, size, getRandom) => {
      let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
      let step = -~(1.6 * mask * size / alphabet.length);
      return () => {
        let id = "";
        while (true) {
          let bytes3 = getRandom(step);
          let j = step;
          while (j--) {
            id += alphabet[bytes3[j] & mask] || "";
            if (id.length === size)
              return id;
          }
        }
      };
    };
    customAlphabet = (alphabet, size) => customRandom(alphabet, size, random);
    nanoid = (size = 21) => {
      let id = "";
      let bytes3 = crypto.getRandomValues(new Uint8Array(size));
      while (size--) {
        let byte = bytes3[size] & 63;
        if (byte < 36) {
          id += byte.toString(36);
        } else if (byte < 62) {
          id += (byte - 26).toString(36).toUpperCase();
        } else if (byte < 63) {
          id += "_";
        } else {
          id += "-";
        }
      }
      return id;
    };
  }
});

// node_modules/interface-datastore/esm/src/key.js
var key_exports = {};
__export(key_exports, {
  Key: () => Key
});
function namespaceType(ns) {
  const parts = ns.split(":");
  if (parts.length < 2) {
    return "";
  }
  return parts.slice(0, -1).join(":");
}
function namespaceValue(ns) {
  const parts = ns.split(":");
  return parts[parts.length - 1];
}
function flatten(arr) {
  return [].concat(...arr);
}
var pathSepS, pathSepB, pathSep, Key;
var init_key = __esm({
  "node_modules/interface-datastore/esm/src/key.js"() {
    init_node_globals();
    init_index_prod();
    init_to_string();
    init_from_string();
    pathSepS = "/";
    pathSepB = new TextEncoder().encode(pathSepS);
    pathSep = pathSepB[0];
    Key = class {
      constructor(s, clean) {
        if (typeof s === "string") {
          this._buf = fromString3(s);
        } else if (s instanceof Uint8Array) {
          this._buf = s;
        } else {
          throw new Error("Invalid key, should be String of Uint8Array");
        }
        if (clean == null) {
          clean = true;
        }
        if (clean) {
          this.clean();
        }
        if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
          throw new Error("Invalid key");
        }
      }
      toString(encoding = "utf8") {
        return toString3(this._buf, encoding);
      }
      uint8Array() {
        return this._buf;
      }
      get [Symbol.toStringTag]() {
        return `Key(${this.toString()})`;
      }
      static withNamespaces(list) {
        return new Key(list.join(pathSepS));
      }
      static random() {
        return new Key(nanoid().replace(/-/g, ""));
      }
      static asKey(other) {
        if (other instanceof Uint8Array || typeof other === "string") {
          return new Key(other);
        }
        if (other.uint8Array) {
          return new Key(other.uint8Array());
        }
        return null;
      }
      clean() {
        if (!this._buf || this._buf.byteLength === 0) {
          this._buf = pathSepB;
        }
        if (this._buf[0] !== pathSep) {
          const bytes3 = new Uint8Array(this._buf.byteLength + 1);
          bytes3.fill(pathSep, 0, 1);
          bytes3.set(this._buf, 1);
          this._buf = bytes3;
        }
        while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
          this._buf = this._buf.subarray(0, -1);
        }
      }
      less(key) {
        const list1 = this.list();
        const list2 = key.list();
        for (let i = 0; i < list1.length; i++) {
          if (list2.length < i + 1) {
            return false;
          }
          const c1 = list1[i];
          const c2 = list2[i];
          if (c1 < c2) {
            return true;
          } else if (c1 > c2) {
            return false;
          }
        }
        return list1.length < list2.length;
      }
      reverse() {
        return Key.withNamespaces(this.list().slice().reverse());
      }
      namespaces() {
        return this.list();
      }
      baseNamespace() {
        const ns = this.namespaces();
        return ns[ns.length - 1];
      }
      list() {
        return this.toString().split(pathSepS).slice(1);
      }
      type() {
        return namespaceType(this.baseNamespace());
      }
      name() {
        return namespaceValue(this.baseNamespace());
      }
      instance(s) {
        return new Key(this.toString() + ":" + s);
      }
      path() {
        let p = this.parent().toString();
        if (!p.endsWith(pathSepS)) {
          p += pathSepS;
        }
        p += this.type();
        return new Key(p);
      }
      parent() {
        const list = this.list();
        if (list.length === 1) {
          return new Key(pathSepS);
        }
        return new Key(list.slice(0, -1).join(pathSepS));
      }
      child(key) {
        if (this.toString() === pathSepS) {
          return key;
        } else if (key.toString() === pathSepS) {
          return this;
        }
        return new Key(this.toString() + key.toString(), false);
      }
      isAncestorOf(other) {
        if (other.toString() === this.toString()) {
          return false;
        }
        return other.toString().startsWith(this.toString());
      }
      isDecendantOf(other) {
        if (other.toString() === this.toString()) {
          return false;
        }
        return this.toString().startsWith(other.toString());
      }
      isTopLevel() {
        return this.list().length === 1;
      }
      concat(...keys) {
        return Key.withNamespaces([
          ...this.namespaces(),
          ...flatten(keys.map((key) => key.namespaces()))
        ]);
      }
    };
  }
});

// node_modules/abort-controller/browser.js
var require_browser3 = __commonJS({
  "node_modules/abort-controller/browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { AbortController: AbortController13, AbortSignal } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : void 0;
    module2.exports = AbortController13;
    module2.exports.AbortSignal = AbortSignal;
    module2.exports.default = AbortController13;
  }
});

// node_modules/timeout-abort-controller/node_modules/retimer/time-browser.js
var require_time_browser = __commonJS({
  "node_modules/timeout-abort-controller/node_modules/retimer/time-browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = function getTime() {
      return Date.now();
    };
  }
});

// node_modules/timeout-abort-controller/node_modules/retimer/retimer.js
var require_retimer = __commonJS({
  "node_modules/timeout-abort-controller/node_modules/retimer/retimer.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var getTime = require_time_browser();
    function Retimer(callback, timeout, args) {
      var that = this;
      this._started = getTime();
      this._rescheduled = 0;
      this._scheduled = timeout;
      this._args = args;
      this._timer = setTimeout(timerWrapper, timeout);
      function timerWrapper() {
        if (that._rescheduled > 0) {
          that._scheduled = that._rescheduled - (getTime() - that._started);
          that._timer = setTimeout(timerWrapper, that._scheduled);
          that._rescheduled = 0;
        } else {
          callback.apply(null, that._args);
        }
      }
    }
    Retimer.prototype.reschedule = function(timeout) {
      var now = getTime();
      if (now + timeout - (this._started + this._scheduled) < 0) {
        return false;
      } else {
        this._started = now;
        this._rescheduled = timeout;
        return true;
      }
    };
    Retimer.prototype.clear = function() {
      clearTimeout(this._timer);
    };
    function retimer() {
      if (typeof arguments[0] !== "function") {
        throw new Error("callback needed");
      }
      if (typeof arguments[1] !== "number") {
        throw new Error("timeout needed");
      }
      var args;
      if (arguments.length > 0) {
        args = new Array(arguments.length - 2);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 2];
        }
      }
      return new Retimer(arguments[0], arguments[1], args);
    }
    module2.exports = retimer;
  }
});

// node_modules/timeout-abort-controller/index.js
var require_timeout_abort_controller = __commonJS({
  "node_modules/timeout-abort-controller/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { AbortController: AbortController13 } = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : require_browser3();
    var retimer = require_retimer();
    var TimeoutController2 = class extends AbortController13 {
      constructor(ms) {
        super();
        this._ms = ms;
        this._timer = retimer(() => this.abort(), ms);
        Object.setPrototypeOf(this, TimeoutController2.prototype);
      }
      abort() {
        this._timer.clear();
        return super.abort();
      }
      clear() {
        this._timer.clear();
      }
      reset() {
        this._timer.clear();
        this._timer = retimer(() => this.abort(), this._ms);
      }
    };
    module2.exports = TimeoutController2;
    module2.exports.TimeoutController = TimeoutController2;
  }
});

// node_modules/native-abort-controller/src/index.js
var require_src4 = __commonJS({
  "node_modules/native-abort-controller/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var impl;
    if (globalThis.AbortController && globalThis.AbortSignal) {
      impl = globalThis;
    } else {
      impl = require_browser3();
    }
    module2.exports.AbortSignal = impl.AbortSignal;
    module2.exports.AbortController = impl.AbortController;
  }
});

// node_modules/any-signal/index.js
var require_any_signal = __commonJS({
  "node_modules/any-signal/index.js"(exports2, module2) {
    init_node_globals();
    var { AbortController: AbortController13 } = require_src4();
    function anySignal4(signals) {
      const controller = new AbortController13();
      function onAbort() {
        controller.abort();
        for (const signal of signals) {
          if (!signal || !signal.removeEventListener)
            continue;
          signal.removeEventListener("abort", onAbort);
        }
      }
      for (const signal of signals) {
        if (!signal || !signal.addEventListener)
          continue;
        if (signal.aborted) {
          onAbort();
          break;
        }
        signal.addEventListener("abort", onAbort);
      }
      return controller.signal;
    }
    module2.exports = anySignal4;
    module2.exports.anySignal = anySignal4;
  }
});

// node_modules/parse-duration/index.mjs
function parse(str = "", format = "ms") {
  var result = null;
  str = (str + "").replace(/(\d)[,_](\d)/g, "$1$2");
  str.replace(durationRE, function(_, n, units) {
    units = unitRatio(units);
    if (units)
      result = (result || 0) + parseFloat(n, 10) * units;
  });
  return result && result / (unitRatio(format) || 1);
}
function unitRatio(str) {
  return parse[str] || parse[str.toLowerCase().replace(/s$/, "")];
}
var durationRE, parse_duration_default;
var init_parse_duration = __esm({
  "node_modules/parse-duration/index.mjs"() {
    init_node_globals();
    durationRE = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
    parse.nanosecond = parse.ns = 1 / 1e6;
    parse["\xB5s"] = parse["\u03BCs"] = parse.us = parse.microsecond = 1 / 1e3;
    parse.millisecond = parse.ms = parse[""] = 1;
    parse.second = parse.sec = parse.s = parse.ms * 1e3;
    parse.minute = parse.min = parse.m = parse.s * 60;
    parse.hour = parse.hr = parse.h = parse.m * 60;
    parse.day = parse.d = parse.h * 24;
    parse.week = parse.wk = parse.w = parse.d * 7;
    parse.month = parse.b = parse.d * (365.25 / 12);
    parse.year = parse.yr = parse.y = parse.d * 365.25;
    parse_duration_default = parse;
  }
});

// node_modules/ipfs-core-utils/esm/src/errors.js
var TimeoutError;
var init_errors = __esm({
  "node_modules/ipfs-core-utils/esm/src/errors.js"() {
    init_node_globals();
    TimeoutError = class extends Error {
      constructor(message = "request timed out") {
        super(message);
        this.name = "TimeoutError";
        this.code = TimeoutError.code;
      }
    };
    TimeoutError.code = "ERR_TIMEOUT";
  }
});

// node_modules/ipfs-core-utils/esm/src/with-timeout-option.js
var with_timeout_option_exports = {};
__export(with_timeout_option_exports, {
  withTimeoutOption: () => withTimeoutOption
});
function withTimeoutOption(fn, optionsArgIndex) {
  return (...args) => {
    const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];
    if (!options || !options.timeout)
      return fn(...args);
    const timeout = typeof options.timeout === "string" ? parse_duration_default(options.timeout) : options.timeout;
    const controller = new import_timeout_abort_controller.default(timeout);
    options.signal = (0, import_any_signal.anySignal)([
      options.signal,
      controller.signal
    ]);
    const fnRes = fn(...args);
    const timeoutPromise = new Promise((_resolve, reject) => {
      controller.signal.addEventListener("abort", () => {
        reject(new TimeoutError());
      });
    });
    const start = Date.now();
    const maybeThrowTimeoutError = () => {
      if (controller.signal.aborted) {
        throw new TimeoutError();
      }
      const timeTaken = Date.now() - start;
      if (timeTaken > timeout) {
        controller.abort();
        throw new TimeoutError();
      }
    };
    if (fnRes[Symbol.asyncIterator]) {
      return async function* () {
        const it = fnRes[Symbol.asyncIterator]();
        try {
          while (true) {
            const { value, done } = await Promise.race([
              it.next(),
              timeoutPromise
            ]);
            if (done) {
              break;
            }
            maybeThrowTimeoutError();
            yield value;
          }
        } catch (err) {
          maybeThrowTimeoutError();
          throw err;
        } finally {
          controller.clear();
          if (it.return) {
            it.return();
          }
        }
      }();
    }
    return (async () => {
      try {
        const res = await Promise.race([
          fnRes,
          timeoutPromise
        ]);
        maybeThrowTimeoutError();
        return res;
      } catch (err) {
        maybeThrowTimeoutError();
        throw err;
      } finally {
        controller.clear();
      }
    })();
  };
}
var import_timeout_abort_controller, import_any_signal;
var init_with_timeout_option = __esm({
  "node_modules/ipfs-core-utils/esm/src/with-timeout-option.js"() {
    init_node_globals();
    import_timeout_abort_controller = __toModule(require_timeout_abort_controller());
    import_any_signal = __toModule(require_any_signal());
    init_parse_duration();
    init_errors();
  }
});

// node_modules/ipfs-core-utils/esm/src/to-cid-and-path.js
var to_cid_and_path_exports = {};
__export(to_cid_and_path_exports, {
  toCidAndPath: () => toCidAndPath
});
function toCidAndPath(string3) {
  if (string3 instanceof Uint8Array) {
    try {
      string3 = CID.decode(string3);
    } catch (err) {
      throw (0, import_err_code2.default)(err, "ERR_INVALID_CID");
    }
  }
  let cid = CID.asCID(string3);
  if (cid) {
    return {
      cid,
      path: void 0
    };
  }
  string3 = string3.toString();
  if (string3.startsWith(IPFS_PREFIX)) {
    string3 = string3.substring(IPFS_PREFIX.length);
  }
  const parts = string3.split("/");
  let path;
  try {
    cid = CID.parse(parts.shift() || "");
  } catch (err) {
    throw (0, import_err_code2.default)(err, "ERR_INVALID_CID");
  }
  if (parts.length) {
    path = `/${parts.join("/")}`;
  }
  return {
    cid,
    path
  };
}
var import_err_code2, IPFS_PREFIX;
var init_to_cid_and_path = __esm({
  "node_modules/ipfs-core-utils/esm/src/to-cid-and-path.js"() {
    init_node_globals();
    init_cid();
    import_err_code2 = __toModule(require_err_code());
    IPFS_PREFIX = "/ipfs/";
  }
});

// node_modules/ipfs-core/cjs/src/utils.js
var require_utils = __commonJS({
  "node_modules/ipfs-core/cjs/src/utils.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isIpfs = require_src3();
    var cid = (init_cid(), cid_exports);
    var key = (init_key(), key_exports);
    var errCode32 = require_err_code();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var toCidAndPath2 = (init_to_cid_and_path(), to_cid_and_path_exports);
    var dagPB = (init_src2(), src_exports2);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var isIpfs__default = /* @__PURE__ */ _interopDefaultLegacy(isIpfs);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var ERR_BAD_PATH = "ERR_BAD_PATH";
    var OFFLINE_ERROR = "This command must be run in online mode. Try running 'ipfs daemon' first.";
    var MFS_ROOT_KEY3 = new key.Key("/local/filesroot");
    var MFS_MAX_CHUNK_SIZE = 262144;
    var MFS_MAX_LINKS = 174;
    var normalizePath = (pathStr) => {
      const cid$1 = cid.CID.asCID(pathStr);
      if (cid$1) {
        return `/ipfs/${pathStr}`;
      }
      const str = pathStr.toString();
      try {
        return `/ipfs/${cid.CID.parse(str)}`;
      } catch {
      }
      if (isIpfs__default["default"].path(str)) {
        return str;
      } else {
        throw errCode__default["default"](new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);
      }
    };
    var normalizeCidPath = (path) => {
      if (path instanceof Uint8Array) {
        return cid.CID.decode(path).toString();
      }
      path = path.toString();
      if (path.indexOf("/ipfs/") === 0) {
        path = path.substring("/ipfs/".length);
      }
      if (path.charAt(path.length - 1) === "/") {
        path = path.substring(0, path.length - 1);
      }
      return path;
    };
    var resolvePath = async function(repo, codecs2, ipfsPath2, options = {}) {
      const { cid: cid$1, path } = toCidAndPath2.toCidAndPath(ipfsPath2);
      if (path) {
        options.path = path;
      }
      let lastCid = cid$1;
      let lastRemainderPath = options.path || "";
      if (lastRemainderPath.startsWith("/")) {
        lastRemainderPath = lastRemainderPath.substring(1);
      }
      if (options.path) {
        try {
          for await (const { value, remainderPath } of resolve6(cid$1, options.path, codecs2, repo, { signal: options.signal })) {
            if (!cid.CID.asCID(value)) {
              break;
            }
            lastRemainderPath = remainderPath;
            lastCid = value;
          }
        } catch (err) {
          if (err.message.startsWith("Object has no property")) {
            err.message = `no link named "${lastRemainderPath.split("/")[0]}" under ${lastCid}`;
            err.code = "ERR_NO_LINK";
          }
          throw err;
        }
      }
      return {
        cid: lastCid,
        remainderPath: lastRemainderPath || ""
      };
    };
    var mapFile = (file) => {
      if (file.type !== "file" && file.type !== "directory" && file.type !== "raw") {
        throw new Error(`Unknown node type '${file.type}'`);
      }
      const output = {
        cid: file.cid,
        path: file.path,
        name: file.name,
        size: file.size,
        type: "file"
      };
      if (file.type === "directory") {
        output.type = "dir";
      }
      if (file.type === "file") {
        output.size = file.unixfs.fileSize();
      }
      if (file.type === "file" || file.type === "directory") {
        output.mode = file.unixfs.mode;
        if (file.unixfs.mtime !== void 0) {
          output.mtime = file.unixfs.mtime;
        }
      }
      return output;
    };
    var withTimeout = withTimeoutOption2.withTimeoutOption(async (promise, _options) => await promise);
    var resolve6 = async function* (cid$1, path, codecs2, repo, options) {
      const load = async (cid2) => {
        const codec = await codecs2.getCodec(cid2.code);
        const block = await repo.blocks.get(cid2, options);
        return codec.decode(block);
      };
      const parts = path.split("/").filter(Boolean);
      let value = await load(cid$1);
      let lastCid = cid$1;
      if (!parts.length) {
        yield {
          value,
          remainderPath: ""
        };
      }
      while (parts.length) {
        const key2 = parts.shift();
        if (!key2) {
          throw errCode__default["default"](new Error(`Could not resolve path "${path}"`), "ERR_INVALID_PATH");
        }
        if (cid$1.code === dagPB__namespace.code && Array.isArray(value.Links)) {
          const link = value.Links.find((l) => l.Name === key2);
          if (link) {
            yield {
              value: link.Hash,
              remainderPath: parts.join("/")
            };
            value = await load(link.Hash);
            lastCid = link.Hash;
            continue;
          }
        }
        if (Object.prototype.hasOwnProperty.call(value, key2)) {
          value = value[key2];
          yield {
            value,
            remainderPath: parts.join("/")
          };
        } else {
          throw errCode__default["default"](new Error(`no link named "${key2}" under ${lastCid}`), "ERR_NO_LINK");
        }
        if (cid.CID.asCID(value)) {
          lastCid = value;
          value = await load(value);
        }
      }
    };
    exports2.MFS_MAX_CHUNK_SIZE = MFS_MAX_CHUNK_SIZE;
    exports2.MFS_MAX_LINKS = MFS_MAX_LINKS;
    exports2.MFS_ROOT_KEY = MFS_ROOT_KEY3;
    exports2.OFFLINE_ERROR = OFFLINE_ERROR;
    exports2.mapFile = mapFile;
    exports2.normalizeCidPath = normalizeCidPath;
    exports2.normalizePath = normalizePath;
    exports2.resolve = resolve6;
    exports2.resolvePath = resolvePath;
    exports2.withTimeout = withTimeout;
  }
});

// node_modules/ipfs-core/cjs/src/utils/service.js
var require_service2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/utils/service.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errors2 = require_errors();
    var utils = require_utils();
    var Service = class {
      static create({ start, stop }) {
        return new Service(start, stop);
      }
      static async start(service, options) {
        const { state, activate } = service;
        switch (state.status) {
          case "stopped": {
            try {
              const promise = activate(options);
              service.state = {
                status: "starting",
                ready: promise
              };
              const result = await promise;
              service.state = {
                status: "started",
                value: result
              };
              return result;
            } catch (error) {
              service.state = { status: "stopped" };
              throw error;
            }
          }
          case "starting": {
            throw new errors2.AlreadyStartingError();
          }
          case "started": {
            throw new errors2.AlreadyStartedError();
          }
          case "stopping": {
            await state.ready;
            return await Service.start(service, options);
          }
          default: {
            return Service.panic(service);
          }
        }
      }
      static async stop(service) {
        const { state, deactivate } = service;
        switch (state.status) {
          case "stopped": {
            break;
          }
          case "starting": {
            try {
              await state.ready;
            } catch (_) {
            }
            return await Service.stop(service);
          }
          case "stopping": {
            return await state.ready;
          }
          case "started": {
            if (deactivate) {
              await deactivate(state.value);
            }
            service.state = { status: "stopped" };
            break;
          }
          default: {
            Service.panic(state);
          }
        }
      }
      static try({ state }) {
        switch (state.status) {
          case "started":
            return state.value;
          default:
            return null;
        }
      }
      static async use({ state }, options) {
        switch (state.status) {
          case "started":
            return state.value;
          case "starting":
            return await utils.withTimeout(state.ready, options);
          default:
            throw new errors2.NotStartedError();
        }
      }
      static panic({ state }) {
        const status = JSON.stringify({ status: state.status });
        throw RangeError(`Service in invalid state ${status}, should never happen if you see this please report a bug`);
      }
      constructor(activate, deactivate) {
        this.activate = activate;
        this.deactivate = deactivate;
        this.state = { status: "stopped" };
      }
      async use(options) {
        return await Service.use(this, options);
      }
      try() {
        return Service.try(this);
      }
    };
    exports2.Service = Service;
  }
});

// node_modules/ipfs-core/cjs/src/components/start.js
var require_start = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/start.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var service = require_service2();
    function createStart2({ network, preload: preload2, peerId, keychain, repo, ipns: ipns2, mfsPreload, print, options }) {
      const start = async () => {
        const { libp2p } = await service.Service.start(network, {
          peerId,
          repo,
          print,
          options
        });
        await Promise.all([
          ipns2.startOnline({
            keychain,
            libp2p,
            peerId,
            repo
          }),
          preload2.start(),
          mfsPreload.start()
        ]);
      };
      return start;
    }
    exports2.createStart = createStart2;
  }
});

// node_modules/ipfs-core/cjs/src/components/stop.js
var require_stop = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/stop.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var service = require_service2();
    function createStop2({ network, preload: preload2, ipns: ipns2, repo, mfsPreload }) {
      const stop = async () => {
        await Promise.all([
          preload2.stop(),
          ipns2.stop(),
          mfsPreload.stop(),
          service.Service.stop(network),
          repo.close()
        ]);
      };
      return stop;
    }
    exports2.createStop = createStop2;
  }
});

// node_modules/hashlru/index.js
var require_hashlru = __commonJS({
  "node_modules/hashlru/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = function(max) {
      if (!max)
        throw Error("hashlru must have a max value, of type number, greater than 0");
      var size = 0, cache2 = Object.create(null), _cache = Object.create(null);
      function update(key, value) {
        cache2[key] = value;
        size++;
        if (size >= max) {
          size = 0;
          _cache = cache2;
          cache2 = Object.create(null);
        }
      }
      return {
        has: function(key) {
          return cache2[key] !== void 0 || _cache[key] !== void 0;
        },
        remove: function(key) {
          if (cache2[key] !== void 0)
            cache2[key] = void 0;
          if (_cache[key] !== void 0)
            _cache[key] = void 0;
        },
        get: function(key) {
          var v = cache2[key];
          if (v !== void 0)
            return v;
          if ((v = _cache[key]) !== void 0) {
            update(key, v);
            return v;
          }
        },
        set: function(key, value) {
          if (cache2[key] !== void 0)
            cache2[key] = value;
          else
            update(key, value);
        },
        clear: function() {
          cache2 = Object.create(null);
          _cache = Object.create(null);
        }
      };
    };
  }
});

// node_modules/ipfs-core-config/esm/src/utils/tlru.js
var import_hashlru, TLRU;
var init_tlru = __esm({
  "node_modules/ipfs-core-config/esm/src/utils/tlru.js"() {
    init_node_globals();
    import_hashlru = __toModule(require_hashlru());
    TLRU = class {
      constructor(maxSize) {
        this.lru = (0, import_hashlru.default)(maxSize);
      }
      get(key) {
        const value = this.lru.get(key);
        if (value) {
          if (value.expire && value.expire < Date.now()) {
            this.lru.remove(key);
            return void 0;
          }
          return value.value;
        }
        return void 0;
      }
      set(key, value, ttl2) {
        this.lru.set(key, {
          value,
          expire: Date.now() + ttl2
        });
      }
      has(key) {
        const value = this.get(key);
        if (value) {
          return true;
        }
        return false;
      }
      remove(key) {
        this.lru.remove(key);
      }
      clear() {
        this.lru.clear();
      }
    };
  }
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/eventemitter3/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = Object.create(null);
      if (!new Events().__proto__)
        prefix = false;
    }
    function EE(fn, context, once) {
      this.fn = fn;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn, context, once) {
      if (typeof fn !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt])
        emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn)
        emitter._events[evt].push(listener);
      else
        emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0)
        emitter._events = new Events();
      else
        delete emitter._events[evt];
    }
    function EventEmitter4() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter4.prototype.eventNames = function eventNames() {
      var names = [], events, name5;
      if (this._eventsCount === 0)
        return names;
      for (name5 in events = this._events) {
        if (has.call(events, name5))
          names.push(prefix ? name5.slice(1) : name5);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter4.prototype.listeners = function listeners(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers)
        return [];
      if (handlers.fn)
        return [handlers.fn];
      for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
        ee[i] = handlers[i].fn;
      }
      return ee;
    };
    EventEmitter4.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners = this._events[evt];
      if (!listeners)
        return 0;
      if (listeners.fn)
        return 1;
      return listeners.length;
    };
    EventEmitter4.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return false;
      var listeners = this._events[evt], len = arguments.length, args, i;
      if (listeners.fn) {
        if (listeners.once)
          this.removeListener(event, listeners.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners.fn.call(listeners.context), true;
          case 2:
            return listeners.fn.call(listeners.context, a1), true;
          case 3:
            return listeners.fn.call(listeners.context, a1, a2), true;
          case 4:
            return listeners.fn.call(listeners.context, a1, a2, a3), true;
          case 5:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
          case 6:
            return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
        }
        for (i = 1, args = new Array(len - 1); i < len; i++) {
          args[i - 1] = arguments[i];
        }
        listeners.fn.apply(listeners.context, args);
      } else {
        var length4 = listeners.length, j;
        for (i = 0; i < length4; i++) {
          if (listeners[i].once)
            this.removeListener(event, listeners[i].fn, void 0, true);
          switch (len) {
            case 1:
              listeners[i].fn.call(listeners[i].context);
              break;
            case 2:
              listeners[i].fn.call(listeners[i].context, a1);
              break;
            case 3:
              listeners[i].fn.call(listeners[i].context, a1, a2);
              break;
            case 4:
              listeners[i].fn.call(listeners[i].context, a1, a2, a3);
              break;
            default:
              if (!args)
                for (j = 1, args = new Array(len - 1); j < len; j++) {
                  args[j - 1] = arguments[j];
                }
              listeners[i].fn.apply(listeners[i].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter4.prototype.on = function on(event, fn, context) {
      return addListener(this, event, fn, context, false);
    };
    EventEmitter4.prototype.once = function once(event, fn, context) {
      return addListener(this, event, fn, context, true);
    };
    EventEmitter4.prototype.removeListener = function removeListener(event, fn, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt])
        return this;
      if (!fn) {
        clearEvent(this, evt);
        return this;
      }
      var listeners = this._events[evt];
      if (listeners.fn) {
        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i = 0, events = [], length4 = listeners.length; i < length4; i++) {
          if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
            events.push(listeners[i]);
          }
        }
        if (events.length)
          this._events[evt] = events.length === 1 ? events[0] : events;
        else
          clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter4.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt])
          clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter4.prototype.off = EventEmitter4.prototype.removeListener;
    EventEmitter4.prototype.addListener = EventEmitter4.prototype.on;
    EventEmitter4.prefixed = prefix;
    EventEmitter4.EventEmitter = EventEmitter4;
    if (typeof module2 !== "undefined") {
      module2.exports = EventEmitter4;
    }
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS({
  "node_modules/p-finally/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = (promise, onFinally) => {
      onFinally = onFinally || (() => {
      });
      return promise.then((val) => new Promise((resolve6) => {
        resolve6(onFinally());
      }).then(() => val), (err) => new Promise((resolve6) => {
        resolve6(onFinally());
      }).then(() => {
        throw err;
      }));
    };
  }
});

// node_modules/p-queue/node_modules/p-timeout/index.js
var require_p_timeout = __commonJS({
  "node_modules/p-queue/node_modules/p-timeout/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var pFinally = require_p_finally();
    var TimeoutError2 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve6, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve6(promise);
        return;
      }
      const timer = setTimeout(() => {
        if (typeof fallback === "function") {
          try {
            resolve6(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError2(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      pFinally(promise.then(resolve6, reject), () => {
        clearTimeout(timer);
      });
    });
    module2.exports = pTimeout;
    module2.exports.default = pTimeout;
    module2.exports.TimeoutError = TimeoutError2;
  }
});

// node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS({
  "node_modules/p-queue/dist/lower-bound.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function lowerBound(array2, value, comparator) {
      let first3 = 0;
      let count = array2.length;
      while (count > 0) {
        const step = count / 2 | 0;
        let it = first3 + step;
        if (comparator(array2[it], value) <= 0) {
          first3 = ++it;
          count -= step + 1;
        } else {
          count = step;
        }
      }
      return first3;
    }
    exports2.default = lowerBound;
  }
});

// node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS({
  "node_modules/p-queue/dist/priority-queue.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var lower_bound_1 = require_lower_bound();
    var PriorityQueue = class {
      constructor() {
        this._queue = [];
      }
      enqueue(run, options) {
        options = Object.assign({ priority: 0 }, options);
        const element = {
          priority: options.priority,
          run
        };
        if (this.size && this._queue[this.size - 1].priority >= options.priority) {
          this._queue.push(element);
          return;
        }
        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
        this._queue.splice(index, 0, element);
      }
      dequeue() {
        const item = this._queue.shift();
        return item === null || item === void 0 ? void 0 : item.run;
      }
      filter(options) {
        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
      }
      get size() {
        return this._queue.length;
      }
    };
    exports2.default = PriorityQueue;
  }
});

// node_modules/p-queue/dist/index.js
var require_dist = __commonJS({
  "node_modules/p-queue/dist/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var EventEmitter4 = require_eventemitter3();
    var p_timeout_1 = require_p_timeout();
    var priority_queue_1 = require_priority_queue();
    var empty2 = () => {
    };
    var timeoutError = new p_timeout_1.TimeoutError();
    var PQueue4 = class extends EventEmitter4 {
      constructor(options) {
        var _a, _b, _c, _d;
        super();
        this._intervalCount = 0;
        this._intervalEnd = 0;
        this._pendingCount = 0;
        this._resolveEmpty = empty2;
        this._resolveIdle = empty2;
        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);
        if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
          throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
        }
        if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
          throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
        }
        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
        this._intervalCap = options.intervalCap;
        this._interval = options.interval;
        this._queue = new options.queueClass();
        this._queueClass = options.queueClass;
        this.concurrency = options.concurrency;
        this._timeout = options.timeout;
        this._throwOnTimeout = options.throwOnTimeout === true;
        this._isPaused = options.autoStart === false;
      }
      get _doesIntervalAllowAnother() {
        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
      }
      get _doesConcurrentAllowAnother() {
        return this._pendingCount < this._concurrency;
      }
      _next() {
        this._pendingCount--;
        this._tryToStartAnother();
        this.emit("next");
      }
      _resolvePromises() {
        this._resolveEmpty();
        this._resolveEmpty = empty2;
        if (this._pendingCount === 0) {
          this._resolveIdle();
          this._resolveIdle = empty2;
          this.emit("idle");
        }
      }
      _onResumeInterval() {
        this._onInterval();
        this._initializeIntervalIfNeeded();
        this._timeoutId = void 0;
      }
      _isIntervalPaused() {
        const now = Date.now();
        if (this._intervalId === void 0) {
          const delay = this._intervalEnd - now;
          if (delay < 0) {
            this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
          } else {
            if (this._timeoutId === void 0) {
              this._timeoutId = setTimeout(() => {
                this._onResumeInterval();
              }, delay);
            }
            return true;
          }
        }
        return false;
      }
      _tryToStartAnother() {
        if (this._queue.size === 0) {
          if (this._intervalId) {
            clearInterval(this._intervalId);
          }
          this._intervalId = void 0;
          this._resolvePromises();
          return false;
        }
        if (!this._isPaused) {
          const canInitializeInterval = !this._isIntervalPaused();
          if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
            const job = this._queue.dequeue();
            if (!job) {
              return false;
            }
            this.emit("active");
            job();
            if (canInitializeInterval) {
              this._initializeIntervalIfNeeded();
            }
            return true;
          }
        }
        return false;
      }
      _initializeIntervalIfNeeded() {
        if (this._isIntervalIgnored || this._intervalId !== void 0) {
          return;
        }
        this._intervalId = setInterval(() => {
          this._onInterval();
        }, this._interval);
        this._intervalEnd = Date.now() + this._interval;
      }
      _onInterval() {
        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
          clearInterval(this._intervalId);
          this._intervalId = void 0;
        }
        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        this._processQueue();
      }
      _processQueue() {
        while (this._tryToStartAnother()) {
        }
      }
      get concurrency() {
        return this._concurrency;
      }
      set concurrency(newConcurrency) {
        if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
        }
        this._concurrency = newConcurrency;
        this._processQueue();
      }
      async add(fn, options = {}) {
        return new Promise((resolve6, reject) => {
          const run = async () => {
            this._pendingCount++;
            this._intervalCount++;
            try {
              const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
                if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                  reject(timeoutError);
                }
                return void 0;
              });
              resolve6(await operation);
            } catch (error) {
              reject(error);
            }
            this._next();
          };
          this._queue.enqueue(run, options);
          this._tryToStartAnother();
          this.emit("add");
        });
      }
      async addAll(functions, options) {
        return Promise.all(functions.map(async (function_) => this.add(function_, options)));
      }
      start() {
        if (!this._isPaused) {
          return this;
        }
        this._isPaused = false;
        this._processQueue();
        return this;
      }
      pause() {
        this._isPaused = true;
      }
      clear() {
        this._queue = new this._queueClass();
      }
      async onEmpty() {
        if (this._queue.size === 0) {
          return;
        }
        return new Promise((resolve6) => {
          const existingResolve = this._resolveEmpty;
          this._resolveEmpty = () => {
            existingResolve();
            resolve6();
          };
        });
      }
      async onIdle() {
        if (this._pendingCount === 0 && this._queue.size === 0) {
          return;
        }
        return new Promise((resolve6) => {
          const existingResolve = this._resolveIdle;
          this._resolveIdle = () => {
            existingResolve();
            resolve6();
          };
        });
      }
      get size() {
        return this._queue.size;
      }
      sizeBy(options) {
        return this._queue.filter(options).length;
      }
      get pending() {
        return this._pendingCount;
      }
      get isPaused() {
        return this._isPaused;
      }
      get timeout() {
        return this._timeout;
      }
      set timeout(milliseconds) {
        this._timeout = milliseconds;
      }
    };
    exports2.default = PQueue4;
  }
});

// node_modules/ipfs-utils/src/http/error.js
var require_error = __commonJS({
  "node_modules/ipfs-utils/src/http/error.js"(exports2) {
    init_node_globals();
    "use strict";
    var TimeoutError2 = class extends Error {
      constructor(message = "Request timed out") {
        super(message);
        this.name = "TimeoutError";
      }
    };
    exports2.TimeoutError = TimeoutError2;
    var AbortError = class extends Error {
      constructor(message = "The operation was aborted.") {
        super(message);
        this.name = "AbortError";
      }
    };
    exports2.AbortError = AbortError;
    var HTTPError2 = class extends Error {
      constructor(response) {
        super(response.statusText);
        this.name = "HTTPError";
        this.response = response;
      }
    };
    exports2.HTTPError = HTTPError2;
  }
});

// (disabled):node_modules/electron-fetch/lib/index.es.js
var require_index_es = __commonJS({
  "(disabled):node_modules/electron-fetch/lib/index.es.js"() {
    init_node_globals();
  }
});

// node_modules/node-fetch/browser.js
var require_browser4 = __commonJS({
  "node_modules/node-fetch/browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var getGlobal = function() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global2 !== "undefined") {
        return global2;
      }
      throw new Error("unable to locate global object");
    };
    var global2 = getGlobal();
    module2.exports = exports2 = global2.fetch;
    if (global2.fetch) {
      exports2.default = global2.fetch.bind(global2);
    }
    exports2.Headers = global2.Headers;
    exports2.Request = global2.Request;
    exports2.Response = global2.Response;
  }
});

// node_modules/native-fetch/src/index.js
var require_src5 = __commonJS({
  "node_modules/native-fetch/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    if (globalThis.fetch && globalThis.Headers && globalThis.Request && globalThis.Response) {
      module2.exports = {
        default: globalThis.fetch,
        Headers: globalThis.Headers,
        Request: globalThis.Request,
        Response: globalThis.Response
      };
    } else {
      module2.exports = {
        default: require_browser4().default,
        Headers: require_browser4().Headers,
        Request: require_browser4().Request,
        Response: require_browser4().Response
      };
    }
  }
});

// node_modules/ipfs-utils/src/fetch.js
var require_fetch = __commonJS({
  "node_modules/ipfs-utils/src/fetch.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { isElectronMain } = require_env();
    if (isElectronMain) {
      module2.exports = require_index_es();
    } else {
      module2.exports = require_src5();
    }
  }
});

// node_modules/ipfs-utils/src/http/fetch.browser.js
var require_fetch_browser = __commonJS({
  "node_modules/ipfs-utils/src/http/fetch.browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { TimeoutError: TimeoutError2, AbortError } = require_error();
    var { Response: Response2, Request, Headers, default: fetch } = require_fetch();
    var fetchWithProgress = (url, options = {}) => {
      const request = new XMLHttpRequest();
      request.open(options.method || "GET", url.toString(), true);
      const { timeout, headers } = options;
      if (timeout && timeout > 0 && timeout < Infinity) {
        request.timeout = timeout;
      }
      if (options.overrideMimeType != null) {
        request.overrideMimeType(options.overrideMimeType);
      }
      if (headers) {
        for (const [name5, value] of new Headers(headers)) {
          request.setRequestHeader(name5, value);
        }
      }
      if (options.signal) {
        options.signal.onabort = () => request.abort();
      }
      if (options.onUploadProgress) {
        request.upload.onprogress = options.onUploadProgress;
      }
      request.responseType = "arraybuffer";
      return new Promise((resolve6, reject) => {
        const handleEvent = (event) => {
          switch (event.type) {
            case "error": {
              resolve6(Response2.error());
              break;
            }
            case "load": {
              resolve6(new ResponseWithURL(request.responseURL, request.response, {
                status: request.status,
                statusText: request.statusText,
                headers: parseHeaders(request.getAllResponseHeaders())
              }));
              break;
            }
            case "timeout": {
              reject(new TimeoutError2());
              break;
            }
            case "abort": {
              reject(new AbortError());
              break;
            }
            default: {
              break;
            }
          }
        };
        request.onerror = handleEvent;
        request.onload = handleEvent;
        request.ontimeout = handleEvent;
        request.onabort = handleEvent;
        request.send(options.body);
      });
    };
    var fetchWithStreaming = fetch;
    var fetchWith = (url, options = {}) => options.onUploadProgress != null ? fetchWithProgress(url, options) : fetchWithStreaming(url, options);
    var parseHeaders = (input) => {
      const headers = new Headers();
      for (const line of input.trim().split(/[\r\n]+/)) {
        const index = line.indexOf(": ");
        if (index > 0) {
          headers.set(line.slice(0, index), line.slice(index + 1));
        }
      }
      return headers;
    };
    var ResponseWithURL = class extends Response2 {
      constructor(url, body, options) {
        super(body, options);
        Object.defineProperty(this, "url", { value: url });
      }
    };
    module2.exports = {
      fetch: fetchWith,
      Request,
      Headers
    };
  }
});

// node_modules/ipfs-utils/src/http.js
var require_http = __commonJS({
  "node_modules/ipfs-utils/src/http.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { fetch, Request, Headers } = require_fetch_browser();
    var { TimeoutError: TimeoutError2, HTTPError: HTTPError2 } = require_error();
    var merge4 = require_merge_options().bind({ ignoreUndefined: true });
    var { URL: URL2, URLSearchParams: URLSearchParams2 } = require_iso_url();
    var { AbortController: AbortController13 } = require_src4();
    var anySignal4 = require_any_signal();
    var timeout = (promise, ms, abortController) => {
      if (ms === void 0) {
        return promise;
      }
      const start = Date.now();
      const timedOut = () => {
        const time = Date.now() - start;
        return time >= ms;
      };
      return new Promise((resolve6, reject) => {
        const timeoutID = setTimeout(() => {
          if (timedOut()) {
            reject(new TimeoutError2());
            abortController.abort();
          }
        }, ms);
        const after = (next) => {
          const fn = (res) => {
            clearTimeout(timeoutID);
            if (timedOut()) {
              reject(new TimeoutError2());
              return;
            }
            next(res);
          };
          return fn;
        };
        promise.then(after(resolve6), after(reject));
      });
    };
    var defaults = {
      throwHttpErrors: true,
      credentials: "same-origin"
    };
    var HTTP4 = class {
      constructor(options = {}) {
        this.opts = merge4(defaults, options);
      }
      async fetch(resource, options = {}) {
        const opts = merge4(this.opts, options);
        const headers = new Headers(opts.headers);
        if (typeof resource !== "string" && !(resource instanceof URL2 || resource instanceof Request)) {
          throw new TypeError("`resource` must be a string, URL, or Request");
        }
        const url = new URL2(resource.toString(), opts.base);
        const {
          searchParams,
          transformSearchParams,
          json
        } = opts;
        if (searchParams) {
          if (typeof transformSearchParams === "function") {
            url.search = transformSearchParams(new URLSearchParams2(opts.searchParams));
          } else {
            url.search = new URLSearchParams2(opts.searchParams);
          }
        }
        if (json) {
          opts.body = JSON.stringify(opts.json);
          headers.set("content-type", "application/json");
        }
        const abortController = new AbortController13();
        const signal = anySignal4([abortController.signal, opts.signal]);
        const response = await timeout(fetch(url.toString(), {
          ...opts,
          signal,
          timeout: void 0,
          headers
        }), opts.timeout, abortController);
        if (!response.ok && opts.throwHttpErrors) {
          if (opts.handleError) {
            await opts.handleError(response);
          }
          throw new HTTPError2(response);
        }
        response.iterator = function() {
          return fromStream(response.body);
        };
        response.ndjson = async function* () {
          for await (const chunk of ndjson(response.iterator())) {
            if (options.transform) {
              yield options.transform(chunk);
            } else {
              yield chunk;
            }
          }
        };
        return response;
      }
      post(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "POST" });
      }
      get(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "GET" });
      }
      put(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "PUT" });
      }
      delete(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "DELETE" });
      }
      options(resource, options = {}) {
        return this.fetch(resource, { ...options, method: "OPTIONS" });
      }
    };
    var ndjson = async function* (source) {
      const decoder = new TextDecoder();
      let buf2 = "";
      for await (const chunk of source) {
        buf2 += decoder.decode(chunk, { stream: true });
        const lines = buf2.split(/\r?\n/);
        for (let i = 0; i < lines.length - 1; i++) {
          const l = lines[i].trim();
          if (l.length > 0) {
            yield JSON.parse(l);
          }
        }
        buf2 = lines[lines.length - 1];
      }
      buf2 += decoder.decode();
      buf2 = buf2.trim();
      if (buf2.length !== 0) {
        yield JSON.parse(buf2);
      }
    };
    var fromStream = (source) => {
      if (isNodeReadableStream(source)) {
        const iter = source[Symbol.asyncIterator]();
        return {
          [Symbol.asyncIterator]() {
            return {
              next: iter.next.bind(iter),
              return(value) {
                source.destroy();
                if (typeof iter.return === "function") {
                  return iter.return();
                }
                return Promise.resolve({ done: true, value });
              }
            };
          }
        };
      }
      if (isWebReadableStream(source)) {
        const reader = source.getReader();
        return async function* () {
          try {
            while (true) {
              const { done, value } = await reader.read();
              if (done)
                return;
              if (value) {
                yield value;
              }
            }
          } finally {
            reader.releaseLock();
          }
        }();
      }
      if (isAsyncIterable2(source)) {
        return source;
      }
      throw new TypeError("Body can't be converted to AsyncIterable");
    };
    var isAsyncIterable2 = (value) => {
      return typeof value === "object" && value !== null && typeof value[Symbol.asyncIterator] === "function";
    };
    var isWebReadableStream = (value) => {
      return value && typeof value.getReader === "function";
    };
    var isNodeReadableStream = (value) => Object.prototype.hasOwnProperty.call(value, "readable") && Object.prototype.hasOwnProperty.call(value, "writable");
    HTTP4.HTTPError = HTTPError2;
    HTTP4.TimeoutError = TimeoutError2;
    HTTP4.streamToAsyncIterator = fromStream;
    HTTP4.post = (resource, options) => new HTTP4(options).post(resource, options);
    HTTP4.get = (resource, options) => new HTTP4(options).get(resource, options);
    HTTP4.put = (resource, options) => new HTTP4(options).put(resource, options);
    HTTP4.delete = (resource, options) => new HTTP4(options).delete(resource, options);
    HTTP4.options = (resource, options) => new HTTP4(options).options(resource, options);
    module2.exports = HTTP4;
  }
});

// node_modules/ipfs-core-config/esm/src/dns.browser.js
var dns_browser_exports = {};
__export(dns_browser_exports, {
  resolveDnslink: () => resolveDnslink
});
async function resolveDnslink(fqdn, opts) {
  const resolve6 = async (fqdn2, opts2 = {}) => {
    const searchParams = new URLSearchParams(opts2);
    searchParams.set("arg", fqdn2);
    const query = searchParams.toString();
    if (!opts2.nocache && cache.has(query)) {
      const response2 = cache.get(query);
      return ipfsPath(response2);
    }
    const response = await httpQueue.add(async () => {
      const res = await import_http.default.get("https://ipfs.io/api/v0/dns", { searchParams });
      const query2 = new URL(res.url).search.slice(1);
      const json = await res.json();
      cache.set(query2, json, ttl);
      return json;
    });
    return ipfsPath(response);
  };
  return resolve6(fqdn, opts);
}
var import_p_queue, import_http, cache, ttl, Queue, httpQueue, ipfsPath;
var init_dns_browser = __esm({
  "node_modules/ipfs-core-config/esm/src/dns.browser.js"() {
    init_node_globals();
    init_tlru();
    import_p_queue = __toModule(require_dist());
    import_http = __toModule(require_http());
    cache = new TLRU(1e3);
    ttl = 60 * 1e3;
    Queue = import_p_queue.default.default ? import_p_queue.default.default : import_p_queue.default;
    httpQueue = new Queue({ concurrency: 4 });
    ipfsPath = (response) => {
      if (response.Path)
        return response.Path;
      throw new Error(response.Message);
    };
  }
});

// node_modules/ipfs-core/cjs/src/components/dns.js
var require_dns = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/dns.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dns = (init_dns_browser(), dns_browser_exports);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function fqdnFixups(domain) {
      if (domain.endsWith(".eth")) {
        domain = domain.replace(/.eth$/, ".eth.link");
      }
      return domain;
    }
    function createDns2() {
      const resolveDNS = async (domain, options = { recursive: true }) => {
        if (typeof domain !== "string") {
          throw new Error("Invalid arguments, domain must be a string");
        }
        domain = fqdnFixups(domain);
        return dns.resolveDnslink(domain, options);
      };
      return withTimeoutOption2.withTimeoutOption(resolveDNS);
    }
    exports2.createDns = createDns2;
  }
});

// node_modules/ipfs-core/cjs/src/components/is-online.js
var require_is_online = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/is-online.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function createIsOnline2({ network }) {
      return () => {
        const net = network.try();
        return net != null && Boolean(net.libp2p.isStarted());
      };
    }
    exports2.createIsOnline = createIsOnline2;
  }
});

// node_modules/libp2p-crypto/src/keys/keys.js
var require_keys = __commonJS({
  "node_modules/libp2p-crypto/src/keys/keys.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var $protobuf5 = require_minimal2();
    var $Reader5 = $protobuf5.Reader;
    var $Writer5 = $protobuf5.Writer;
    var $util5 = $protobuf5.util;
    var $root5 = $protobuf5.roots["libp2p-crypto-keys"] || ($protobuf5.roots["libp2p-crypto-keys"] = {});
    $root5.KeyType = function() {
      var valuesById = {}, values = Object.create(valuesById);
      values[valuesById[0] = "RSA"] = 0;
      values[valuesById[1] = "Ed25519"] = 1;
      values[valuesById[2] = "Secp256k1"] = 2;
      return values;
    }();
    $root5.PublicKey = function() {
      function PublicKey(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      PublicKey.prototype.Type = 0;
      PublicKey.prototype.Data = $util5.newBuffer([]);
      PublicKey.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        w.uint32(8).int32(m.Type);
        w.uint32(18).bytes(m.Data);
        return w;
      };
      PublicKey.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.PublicKey();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Type = r.int32();
              break;
            case 2:
              m.Data = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Type"))
          throw $util5.ProtocolError("missing required 'Type'", { instance: m });
        if (!m.hasOwnProperty("Data"))
          throw $util5.ProtocolError("missing required 'Data'", { instance: m });
        return m;
      };
      PublicKey.fromObject = function fromObject(d) {
        if (d instanceof $root5.PublicKey)
          return d;
        var m = new $root5.PublicKey();
        switch (d.Type) {
          case "RSA":
          case 0:
            m.Type = 0;
            break;
          case "Ed25519":
          case 1:
            m.Type = 1;
            break;
          case "Secp256k1":
          case 2:
            m.Type = 2;
            break;
        }
        if (d.Data != null) {
          if (typeof d.Data === "string")
            $util5.base64.decode(d.Data, m.Data = $util5.newBuffer($util5.base64.length(d.Data)), 0);
          else if (d.Data.length)
            m.Data = d.Data;
        }
        return m;
      };
      PublicKey.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.Type = o.enums === String ? "RSA" : 0;
          if (o.bytes === String)
            d.Data = "";
          else {
            d.Data = [];
            if (o.bytes !== Array)
              d.Data = $util5.newBuffer(d.Data);
          }
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root5.KeyType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util5.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        return d;
      };
      PublicKey.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      return PublicKey;
    }();
    $root5.PrivateKey = function() {
      function PrivateKey(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      PrivateKey.prototype.Type = 0;
      PrivateKey.prototype.Data = $util5.newBuffer([]);
      PrivateKey.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        w.uint32(8).int32(m.Type);
        w.uint32(18).bytes(m.Data);
        return w;
      };
      PrivateKey.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.PrivateKey();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.Type = r.int32();
              break;
            case 2:
              m.Data = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("Type"))
          throw $util5.ProtocolError("missing required 'Type'", { instance: m });
        if (!m.hasOwnProperty("Data"))
          throw $util5.ProtocolError("missing required 'Data'", { instance: m });
        return m;
      };
      PrivateKey.fromObject = function fromObject(d) {
        if (d instanceof $root5.PrivateKey)
          return d;
        var m = new $root5.PrivateKey();
        switch (d.Type) {
          case "RSA":
          case 0:
            m.Type = 0;
            break;
          case "Ed25519":
          case 1:
            m.Type = 1;
            break;
          case "Secp256k1":
          case 2:
            m.Type = 2;
            break;
        }
        if (d.Data != null) {
          if (typeof d.Data === "string")
            $util5.base64.decode(d.Data, m.Data = $util5.newBuffer($util5.base64.length(d.Data)), 0);
          else if (d.Data.length)
            m.Data = d.Data;
        }
        return m;
      };
      PrivateKey.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.Type = o.enums === String ? "RSA" : 0;
          if (o.bytes === String)
            d.Data = "";
          else {
            d.Data = [];
            if (o.bytes !== Array)
              d.Data = $util5.newBuffer(d.Data);
          }
        }
        if (m.Type != null && m.hasOwnProperty("Type")) {
          d.Type = o.enums === String ? $root5.KeyType[m.Type] : m.Type;
        }
        if (m.Data != null && m.hasOwnProperty("Data")) {
          d.Data = o.bytes === String ? $util5.base64.encode(m.Data, 0, m.Data.length) : o.bytes === Array ? Array.prototype.slice.call(m.Data) : m.Data;
        }
        return d;
      };
      PrivateKey.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      return PrivateKey;
    }();
    module2.exports = $root5;
  }
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "node_modules/node-forge/lib/forge.js"(exports2, module2) {
    init_node_globals();
    module2.exports = {
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/node-forge/lib/baseN.js"(exports2, module2) {
    init_node_globals();
    var api = {};
    module2.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet, maxline) {
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet);
      } else {
        var i = 0;
        var base3 = alphabet.length;
        var first3 = alphabet.charAt(0);
        var digits = [0];
        for (i = 0; i < input.length; ++i) {
          for (var j = 0, carry = input[i]; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base3;
            carry = carry / base3 | 0;
          }
          while (carry > 0) {
            digits.push(carry % base3);
            carry = carry / base3 | 0;
          }
        }
        for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
          output += first3;
        }
        for (i = digits.length - 1; i >= 0; --i) {
          output += alphabet[digits[i]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table = _reverseAlphabets[alphabet];
      if (!table) {
        table = _reverseAlphabets[alphabet] = [];
        for (var i = 0; i < alphabet.length; ++i) {
          table[alphabet.charCodeAt(i)] = i;
        }
      }
      input = input.replace(/\s/g, "");
      var base3 = alphabet.length;
      var first3 = alphabet.charAt(0);
      var bytes3 = [0];
      for (var i = 0; i < input.length; i++) {
        var value = table[input.charCodeAt(i)];
        if (value === void 0) {
          return;
        }
        for (var j = 0, carry = value; j < bytes3.length; ++j) {
          carry += bytes3[j] * base3;
          bytes3[j] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes3.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k = 0; input[k] === first3 && k < input.length - 1; ++k) {
        bytes3.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes3.reverse());
      }
      return new Uint8Array(bytes3.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet) {
      var i = 0;
      var base3 = alphabet.length;
      var first3 = alphabet.charAt(0);
      var digits = [0];
      for (i = 0; i < input.length(); ++i) {
        for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base3;
          carry = carry / base3 | 0;
        }
        while (carry > 0) {
          digits.push(carry % base3);
          carry = carry / base3 | 0;
        }
      }
      var output = "";
      for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
        output += first3;
      }
      for (i = digits.length - 1; i >= 0; --i) {
        output += alphabet[digits[i]];
      }
      return output;
    }
  }
});

// node_modules/node-forge/lib/util.js
var require_util = __commonJS({
  "node_modules/node-forge/lib/util.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    var baseN = require_baseN();
    var util = module2.exports = forge.util = forge.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util.setImmediate = setImmediate;
        } else {
          util.setImmediate = util.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        var msg = "forge.setImmediate";
        var callbacks = [];
        util.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util.setImmediate;
        util.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util.nextTick = util.setImmediate;
    })();
    util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util.globalScope = function() {
      if (util.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    };
    util.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
    };
    util.isArrayBufferView = function(x) {
      return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
    };
    function _checkBitsParam(n) {
      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
      }
    }
    util.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b) {
      this.data = "";
      this.read = 0;
      if (typeof b === "string") {
        this.data = b;
      } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
        if (typeof Buffer !== "undefined" && b instanceof Buffer) {
          this.data = b.toString("binary");
        } else {
          var arr = new Uint8Array(b);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e) {
            for (var i = 0; i < arr.length; ++i) {
              this.putByte(arr[i]);
            }
          }
        }
      } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
        this.data = b.data;
        this.read = b.read;
      }
      this._constructedStringLength = 0;
    }
    util.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.ByteStringBuffer.prototype.putByte = function(b) {
      return this.putBytes(String.fromCharCode(b));
    };
    util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
      b = String.fromCharCode(b);
      var d = this.data;
      while (n > 0) {
        if (n & 1) {
          d += b;
        }
        n >>>= 1;
        if (n > 0) {
          b += b;
        }
      }
      this.data = d;
      this._optimizeConstructedString(n);
      return this;
    };
    util.ByteStringBuffer.prototype.putBytes = function(bytes3) {
      this.data += bytes3;
      this._optimizeConstructedString(bytes3.length);
      return this;
    };
    util.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util.encodeUtf8(str));
    };
    util.ByteStringBuffer.prototype.putInt16 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
    };
    util.ByteStringBuffer.prototype.putInt24 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
    };
    util.ByteStringBuffer.prototype.putInt32 = function(i) {
      return this.putBytes(String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
    };
    util.ByteStringBuffer.prototype.putInt16Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255));
    };
    util.ByteStringBuffer.prototype.putInt24Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255));
    };
    util.ByteStringBuffer.prototype.putInt32Le = function(i) {
      return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255));
    };
    util.ByteStringBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      var bytes3 = "";
      do {
        n -= 8;
        bytes3 += String.fromCharCode(i >> n & 255);
      } while (n > 0);
      return this.putBytes(bytes3);
    };
    util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.ByteStringBuffer.prototype.putBuffer = function(buffer2) {
      return this.putBytes(buffer2.getBytes());
    };
    util.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.ByteStringBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.ByteStringBuffer.prototype.at = function(i) {
      return this.data.charCodeAt(this.read + i);
    };
    util.ByteStringBuffer.prototype.setAt = function(i, b) {
      this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
      return this;
    };
    util.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util.ByteStringBuffer.prototype.copy = function() {
      var c = util.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.truncate = function(count) {
      var len = Math.max(0, this.length() - count);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.length; ++i) {
        var b = this.data.charCodeAt(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.toString = function() {
      return util.decodeUtf8(this.bytes());
    };
    function DataBuffer(b, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer = util.isArrayBuffer(b);
      var isArrayBufferView = util.isArrayBufferView(b);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b);
        } else {
          this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b !== null && b !== void 0) {
        this.putBytes(b);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    util.DataBuffer = DataBuffer;
    util.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src2 = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src2);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util.DataBuffer.prototype.putByte = function(b) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b);
      return this;
    };
    util.DataBuffer.prototype.fillWithByte = function(b, n) {
      this.accommodate(n);
      for (var i = 0; i < n; ++i) {
        this.data.setUint8(b);
      }
      return this;
    };
    util.DataBuffer.prototype.putBytes = function(bytes3, encoding) {
      if (util.isArrayBufferView(bytes3)) {
        var src2 = new Uint8Array(bytes3.buffer, bytes3.byteOffset, bytes3.byteLength);
        var len = src2.byteLength - src2.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src2);
        this.write += len;
        return this;
      }
      if (util.isArrayBuffer(bytes3)) {
        var src2 = new Uint8Array(bytes3);
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src2, this.write);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes3 instanceof util.DataBuffer || typeof bytes3 === "object" && typeof bytes3.read === "number" && typeof bytes3.write === "number" && util.isArrayBufferView(bytes3.data)) {
        var src2 = new Uint8Array(bytes3.data.byteLength, bytes3.read, bytes3.length());
        this.accommodate(src2.byteLength);
        var dst = new Uint8Array(bytes3.data.byteLength, this.write);
        dst.set(src2);
        this.write += src2.byteLength;
        return this;
      }
      if (bytes3 instanceof util.ByteStringBuffer) {
        bytes3 = bytes3.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes3 === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes3.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.hex.decode(bytes3, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes3.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.base64.decode(bytes3, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes3 = util.encodeUtf8(bytes3);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes3.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes3.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes3);
    };
    util.DataBuffer.prototype.putBuffer = function(buffer2) {
      this.putBytes(buffer2);
      buffer2.clear();
      return this;
    };
    util.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util.DataBuffer.prototype.putInt16 = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24 = function(i) {
      this.accommodate(3);
      this.data.setInt16(this.write, i >> 8 & 65535);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32 = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt16Le = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i, true);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24Le = function(i) {
      this.accommodate(3);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.data.setInt16(this.write, i >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32Le = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i, true);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, i >> n & 255);
      } while (n > 0);
      return this;
    };
    util.DataBuffer.prototype.putSignedInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.DataBuffer.prototype.getBytes = function(count) {
      var rval;
      if (count) {
        count = Math.min(this.length(), count);
        rval = this.data.slice(this.read, this.read + count);
        this.read += count;
      } else if (count === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.DataBuffer.prototype.bytes = function(count) {
      return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
    };
    util.DataBuffer.prototype.at = function(i) {
      return this.data.getUint8(this.read + i);
    };
    util.DataBuffer.prototype.setAt = function(i, b) {
      this.data.setUint8(i, b);
      return this;
    };
    util.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util.DataBuffer.prototype.copy = function() {
      return new util.DataBuffer(this);
    };
    util.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src2 = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src2.byteLength);
        dst.set(src2);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util.DataBuffer.prototype.truncate = function(count) {
      this.write = Math.max(0, this.length() - count);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.byteLength; ++i) {
        var b = this.data.getUint8(i);
        if (b < 16) {
          rval += "0";
        }
        rval += b.toString(16);
      }
      return rval;
    };
    util.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util.encodeUtf8(input);
      }
      return new util.ByteBuffer(input);
    };
    util.fillString = function(c, n) {
      var s = "";
      while (n > 0) {
        if (n & 1) {
          s += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s;
    };
    util.xorBytes = function(s1, s2, n) {
      var s3 = "";
      var b = "";
      var t = "";
      var i = 0;
      var c = 0;
      for (; n > 0; --n, ++i) {
        b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
        if (c >= 10) {
          s3 += t;
          t = "";
          c = 0;
        }
        t += String.fromCharCode(b);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util.hexToBytes = function(hex) {
      var rval = "";
      var i = 0;
      if (hex.length & true) {
        i = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i < hex.length; i += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
      return rval;
    };
    util.bytesToHex = function(bytes3) {
      return util.createBuffer(bytes3).toHex();
    };
    util.int32ToBytes = function(i) {
      return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      62,
      -1,
      -1,
      -1,
      63,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.length) {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i = 0;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util.binary.raw.encode = function(bytes3) {
      return String.fromCharCode.apply(null, bytes3);
    };
    util.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util.binary.hex.encode = util.bytesToHex;
    util.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i = 0, j = offset;
      if (hex.length & 1) {
        i = 1;
        out[j++] = parseInt(hex[0], 16);
      }
      for (; i < hex.length; i += 2) {
        out[j++] = parseInt(hex.substr(i, 2), 16);
      }
      return output ? j - offset : out;
    };
    util.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.byteLength) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i = 0, j = offset;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        out[j++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j - offset : out.subarray(0, j);
    };
    util.binary.base58.encode = function(input, maxline) {
      return util.binary.baseN.encode(input, _base58, maxline);
    };
    util.binary.base58.decode = function(input, maxline) {
      return util.binary.baseN.decode(input, _base58, maxline);
    };
    util.text = {
      utf8: {},
      utf16: {}
    };
    util.text.utf8.encode = function(str, output, offset) {
      str = util.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util.text.utf8.decode = function(bytes3) {
      return util.decodeUtf8(String.fromCharCode.apply(null, bytes3));
    };
    util.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i = 0; i < str.length; ++i) {
        view[k++] = str.charCodeAt(i);
        j += 2;
      }
      return output ? j - offset : out;
    };
    util.text.utf16.decode = function(bytes3) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes3.buffer));
    };
    util.deflate = function(api, bytes3, raw7) {
      bytes3 = util.decode64(api.deflate(util.encode64(bytes3)).rval);
      if (raw7) {
        var start = 2;
        var flg = bytes3.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes3 = bytes3.substring(start, bytes3.length - 4);
      }
      return bytes3;
    };
    util.inflate = function(api, bytes3, raw7) {
      var rval = api.inflate(util.encode64(bytes3)).rval;
      return rval === null ? null : util.decode64(rval);
    };
    var _setStorageObject = function(api, id, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error = new Error(rval.error.message);
        error.id = rval.error.id;
        error.name = rval.error.name;
        throw error;
      }
    };
    var _getStorageObject = function(api, id) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error = new Error(rval.error.message);
            error.id = rval.error.id;
            error.name = rval.error.name;
            throw error;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util.decode64(rval));
      }
      return rval;
    };
    var _setItem = function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    };
    var _getItem = function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    };
    var _removeItem = function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty2 = true;
        for (var prop in obj) {
          empty2 = false;
          break;
        }
        if (empty2) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    };
    var _clearItems = function(api, id) {
      _setStorageObject(api, id, null);
    };
    var _callStorageFunction = function(func, args, location2) {
      var rval = null;
      if (typeof location2 === "undefined") {
        location2 = ["web", "flash"];
      }
      var type;
      var done = false;
      var exception = null;
      for (var idx in location2) {
        type = location2[idx];
        try {
          if (type === "flash" || type === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type === "flash";
          }
          if (type === "web" || type === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    };
    util.setItem = function(api, id, key, data, location2) {
      _callStorageFunction(_setItem, arguments, location2);
    };
    util.getItem = function(api, id, key, location2) {
      return _callStorageFunction(_getItem, arguments, location2);
    };
    util.removeItem = function(api, id, key, location2) {
      _callStorageFunction(_removeItem, arguments, location2);
    };
    util.clearItems = function(api, id, location2) {
      _callStorageFunction(_clearItems, arguments, location2);
    };
    util.parseUrl = function(str) {
      var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
      regex.lastIndex = 0;
      var m = regex.exec(str);
      var url = m === null ? null : {
        full: str,
        scheme: m[1],
        host: m[2],
        port: m[3],
        path: m[4]
      };
      if (url) {
        url.fullHost = url.host;
        if (url.port) {
          if (url.port !== 80 && url.scheme === "http") {
            url.fullHost += ":" + url.port;
          } else if (url.port !== 443 && url.scheme === "https") {
            url.fullHost += ":" + url.port;
          }
        } else if (url.scheme === "http") {
          url.port = 80;
        } else if (url.scheme === "https") {
          url.port = 443;
        }
        url.full = url.scheme + "://" + url.fullHost;
      }
      return url;
    };
    var _queryVariables = null;
    util.getQueryVariables = function(query) {
      var parse2 = function(q) {
        var rval2 = {};
        var kvpairs = q.split("&");
        for (var i = 0; i < kvpairs.length; i++) {
          var pos = kvpairs[i].indexOf("=");
          var key;
          var val;
          if (pos > 0) {
            key = kvpairs[i].substring(0, pos);
            val = kvpairs[i].substring(pos + 1);
          } else {
            key = kvpairs[i];
            val = null;
          }
          if (!(key in rval2)) {
            rval2[key] = [];
          }
          if (!(key in Object.prototype) && val !== null) {
            rval2[key].push(unescape(val));
          }
        }
        return rval2;
      };
      var rval;
      if (typeof query === "undefined") {
        if (_queryVariables === null) {
          if (typeof window !== "undefined" && window.location && window.location.search) {
            _queryVariables = parse2(window.location.search.substring(1));
          } else {
            _queryVariables = {};
          }
        }
        rval = _queryVariables;
      } else {
        rval = parse2(query);
      }
      return rval;
    };
    util.parseFragment = function(fragment) {
      var fp = fragment;
      var fq = "";
      var pos = fragment.indexOf("?");
      if (pos > 0) {
        fp = fragment.substring(0, pos);
        fq = fragment.substring(pos + 1);
      }
      var path = fp.split("/");
      if (path.length > 0 && path[0] === "") {
        path.shift();
      }
      var query = fq === "" ? {} : util.getQueryVariables(fq);
      return {
        pathString: fp,
        queryString: fq,
        path,
        query
      };
    };
    util.makeRequest = function(reqString) {
      var frag = util.parseFragment(reqString);
      var req = {
        path: frag.pathString,
        query: frag.queryString,
        getPath: function(i) {
          return typeof i === "undefined" ? frag.path : frag.path[i];
        },
        getQuery: function(k, i) {
          var rval;
          if (typeof k === "undefined") {
            rval = frag.query;
          } else {
            rval = frag.query[k];
            if (rval && typeof i !== "undefined") {
              rval = rval[i];
            }
          }
          return rval;
        },
        getQueryLast: function(k, _default) {
          var rval;
          var vals = req.getQuery(k);
          if (vals) {
            rval = vals[vals.length - 1];
          } else {
            rval = _default;
          }
          return rval;
        }
      };
      return req;
    };
    util.makeLink = function(path, query, fragment) {
      path = jQuery.isArray(path) ? path.join("/") : path;
      var qstr = jQuery.param(query || {});
      fragment = fragment || "";
      return path + (qstr.length > 0 ? "?" + qstr : "") + (fragment.length > 0 ? "#" + fragment : "");
    };
    util.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util.format = function(format) {
      var re = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last6 = 0;
      while (match = re.exec(format)) {
        part = format.substring(last6, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last6 = re.lastIndex;
        var code5 = match[0][1];
        switch (code5) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code5 + "?>");
        }
      }
      parts.push(format.substring(last6));
      return parts.join("");
    };
    util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
      var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
      var j = i.length > 3 ? i.length % 3 : 0;
      return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
    };
    util.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util.bytesFromIPv6(ip);
      }
      return null;
    };
    util.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b = util.createBuffer();
      for (var i = 0; i < ip.length; ++i) {
        var num = parseInt(ip[i], 10);
        if (isNaN(num)) {
          return null;
        }
        b.putByte(num);
      }
      return b.getBytes();
    };
    util.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e) {
        if (e.length === 0)
          ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b = util.createBuffer();
      for (var i = 0; i < 8; ++i) {
        if (!ip[i] || ip[i].length === 0) {
          b.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes3 = util.hexToBytes(ip[i]);
        if (bytes3.length < 2) {
          b.putByte(0);
        }
        b.putBytes(bytes3);
      }
      return b.getBytes();
    };
    util.bytesToIP = function(bytes3) {
      if (bytes3.length === 4) {
        return util.bytesToIPv4(bytes3);
      }
      if (bytes3.length === 16) {
        return util.bytesToIPv6(bytes3);
      }
      return null;
    };
    util.bytesToIPv4 = function(bytes3) {
      if (bytes3.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i = 0; i < bytes3.length; ++i) {
        ip.push(bytes3.charCodeAt(i));
      }
      return ip.join(".");
    };
    util.bytesToIPv6 = function(bytes3) {
      if (bytes3.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i = 0; i < bytes3.length; i += 2) {
        var hex = util.bytesToHex(bytes3[i] + bytes3[i + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last6 = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last6 || idx !== last6.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last6.end = idx;
            if (last6.end - last6.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group = zeroGroups[zeroMaxGroup];
        if (group.end - group.start > 0) {
          ip.splice(group.start, group.end - group.start + 1, "");
          if (group.start === 0) {
            ip.unshift("");
          }
          if (group.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util && !options.update) {
        return callback(null, util.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util.cores = navigator.hardwareConcurrency;
        return callback(null, util.cores);
      }
      if (typeof Worker === "undefined") {
        util.cores = 1;
        return callback(null, util.cores);
      }
      if (typeof Blob === "undefined") {
        util.cores = 2;
        return callback(null, util.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e) {
            var st = Date.now();
            var et = st + 4;
            while (Date.now() < et)
              ;
            self.postMessage({ st, et });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x) {
            return avg2 + x;
          }, 0) / max.length);
          util.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util.cores);
        }
        map8(numWorkers, function(err, results) {
          max.push(reduce2(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      function map8(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i = 0; i < numWorkers; ++i) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i2 = 0; i2 < numWorkers; ++i2) {
                workers[i2].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].postMessage(i);
        }
      }
      function reduce2(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i = 0; i < numWorkers; ++i) {
            if (n === i) {
              continue;
            }
            var r2 = results[i];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
    };
  }
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "node_modules/node-forge/lib/oids.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    forge.pki = forge.pki || {};
    var oids = module2.exports = forge.pki.oids = forge.oids = forge.oids || {};
    function _IN(id, name5) {
      oids[id] = name5;
      oids[name5] = id;
    }
    function _I_(id, name5) {
      oids[id] = name5;
    }
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.5", "serialName");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/node-forge/lib/asn1.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_util();
    require_oids();
    var asn1 = module2.exports = forge.asn1 = forge.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type, constructed, value, options) {
      if (forge.util.isArray(value)) {
        var tmp = [];
        for (var i = 0; i < value.length; ++i) {
          if (value[i] !== void 0) {
            tmp.push(value[i]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type,
        constructed,
        composed: constructed || forge.util.isArray(value),
        value
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy;
      if (forge.util.isArray(obj)) {
        copy = [];
        for (var i = 0; i < obj.length; ++i) {
          copy.push(asn1.copy(obj[i], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge.util.isArray(obj1)) {
        if (!forge.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i = 0; i < obj1.length; ++i) {
          if (!asn1.equals(obj1[i], obj2[i])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b) {
      var b2 = b.getByte();
      if (b2 === 128) {
        return void 0;
      }
      var length4;
      var longForm = b2 & 128;
      if (!longForm) {
        length4 = b2;
      } else {
        length4 = b.getInt((b2 & 127) << 3);
      }
      return length4;
    };
    function _checkBufferLength(bytes3, remaining, n) {
      if (n > remaining) {
        var error = new Error("Too few bytes to parse DER.");
        error.available = bytes3.length();
        error.remaining = remaining;
        error.requested = n;
        throw error;
      }
    }
    var _getValueLength = function(bytes3, remaining) {
      var b2 = bytes3.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length4;
      var longForm = b2 & 128;
      if (!longForm) {
        length4 = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes3, remaining, longFormBytes);
        length4 = bytes3.getInt(longFormBytes << 3);
      }
      if (length4 < 0) {
        throw new Error("Negative length: " + length4);
      }
      return length4;
    };
    asn1.fromDer = function(bytes3, options) {
      if (options === void 0) {
        options = {
          strict: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes3 === "string") {
        bytes3 = forge.util.createBuffer(bytes3);
      }
      return _fromDer(bytes3, bytes3.length(), 0, options);
    };
    function _fromDer(bytes3, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes3, remaining, 2);
      var b1 = bytes3.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type = b1 & 31;
      start = bytes3.length();
      var length4 = _getValueLength(bytes3, remaining);
      remaining -= start - bytes3.length();
      if (length4 !== void 0 && length4 > remaining) {
        if (options.strict) {
          var error = new Error("Too few bytes to read ASN.1 value.");
          error.available = bytes3.length();
          error.remaining = remaining;
          error.requested = length4;
          throw error;
        }
        length4 = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length4 === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes3, remaining, 2);
            if (bytes3.bytes(2) === String.fromCharCode(0, 0)) {
              bytes3.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes3.length();
            value.push(_fromDer(bytes3, remaining, depth + 1, options));
            remaining -= start - bytes3.length();
          }
        } else {
          while (length4 > 0) {
            start = bytes3.length();
            value.push(_fromDer(bytes3, length4, depth + 1, options));
            remaining -= start - bytes3.length();
            length4 -= start - bytes3.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
        bitStringContents = bytes3.bytes(length4);
      }
      if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length4 > 1) {
        var savedRead = bytes3.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes3, remaining, 1);
          unused = bytes3.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes3.length();
            var subOptions = {
              verbose: options.verbose,
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes3, remaining, depth + 1, subOptions);
            var used = start - bytes3.length();
            remaining -= used;
            if (type == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length4 && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes3.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length4 === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length4 = remaining;
        }
        if (type === asn1.Type.BMPSTRING) {
          value = "";
          for (; length4 > 0; length4 -= 2) {
            _checkBufferLength(bytes3, remaining, 2);
            value += String.fromCharCode(bytes3.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes3.getBytes(length4);
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type, constructed, value, asn1Options);
    }
    asn1.toDer = function(obj) {
      var bytes3 = forge.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            value.putBuffer(asn1.toDer(obj.value[i]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i = 0; i < obj.value.length; ++i) {
            value.putInt16(obj.value.charCodeAt(i));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes3.putByte(b1);
      if (value.length() <= 127) {
        bytes3.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes3.putByte(lenBytes.length | 128);
        for (var i = lenBytes.length - 1; i >= 0; --i) {
          bytes3.putByte(lenBytes.charCodeAt(i));
        }
      }
      bytes3.putBuffer(value);
      return bytes3;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes3 = forge.util.createBuffer();
      bytes3.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last6, valueBytes, value, b;
      for (var i = 2; i < values.length; ++i) {
        last6 = true;
        valueBytes = [];
        value = parseInt(values[i], 10);
        do {
          b = value & 127;
          value = value >>> 7;
          if (!last6) {
            b |= 128;
          }
          valueBytes.push(b);
          last6 = false;
        } while (value > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes3.putByte(valueBytes[n]);
        }
      }
      return bytes3;
    };
    asn1.derToOid = function(bytes3) {
      var oid;
      if (typeof bytes3 === "string") {
        bytes3 = forge.util.createBuffer(bytes3);
      }
      var b = bytes3.getByte();
      oid = Math.floor(b / 40) + "." + b % 40;
      var value = 0;
      while (bytes3.length() > 0) {
        b = bytes3.getByte();
        value = value << 7;
        if (b & 128) {
          value += b & 127;
        } else {
          oid += "." + (value + b);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = new Date();
      var year = parseInt(utc.substr(0, 2), 10);
      year = year >= 50 ? 1900 + year : 2e3 + year;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== "+" && c !== "-") {
          ss = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year, MM, DD);
      date.setUTCHours(hh, mm, ss, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c = gentime.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push(("" + date.getUTCFullYear()).substr(2));
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += "0";
        }
        rval += format[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format = [];
      format.push("" + date.getUTCFullYear());
      format.push("" + (date.getUTCMonth() + 1));
      format.push("" + date.getUTCDate());
      format.push("" + date.getUTCHours());
      format.push("" + date.getUTCMinutes());
      format.push("" + date.getUTCSeconds());
      for (var i = 0; i < format.length; ++i) {
        if (format[i].length < 2) {
          rval += "0";
        }
        rval += format[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge.util.createBuffer();
      if (x >= -128 && x < 128) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -32768 && x < 32768) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -8388608 && x < 8388608) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -2147483648 && x < 2147483648) {
        return rval.putSignedInt(x, 32);
      }
      var error = new Error("Integer too large; max is 32-bits.");
      error.integer = x;
      throw error;
    };
    asn1.derToInteger = function(bytes3) {
      if (typeof bytes3 === "string") {
        bytes3 = forge.util.createBuffer(bytes3);
      }
      var n = bytes3.length() * 8;
      if (n > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes3.getSignedInt(n);
    };
    asn1.validate = function(obj, v, capture, errors2) {
      var rval = false;
      if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
        if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
          rval = true;
          if (v.value && forge.util.isArray(v.value)) {
            var j = 0;
            for (var i = 0; rval && i < v.value.length; ++i) {
              rval = v.value[i].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v.value[i], capture, errors2);
                if (rval) {
                  ++j;
                } else if (v.value[i].optional) {
                  rval = true;
                }
              }
              if (!rval && errors2) {
                errors2.push("[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"');
              }
            }
          }
          if (rval && capture) {
            if (v.capture) {
              capture[v.capture] = obj.value;
            }
            if (v.captureAsn1) {
              capture[v.captureAsn1] = obj;
            }
            if (v.captureBitStringContents && "bitStringContents" in obj) {
              capture[v.captureBitStringContents] = obj.bitStringContents;
            }
            if (v.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error("captureBitStringValue only supported for zero unused bits");
                }
                capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors2) {
          errors2.push("[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"');
        }
      } else if (errors2) {
        if (obj.tagClass !== v.tagClass) {
          errors2.push("[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"');
        }
        if (obj.type !== v.type) {
          errors2.push("[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"');
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i = 0; i < level * indentation; ++i) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
            if (i + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge.pki && forge.pki.oids) {
            if (oid in forge.pki.oids) {
              rval += " (" + forge.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          rval += forge.util.decodeUtf8(obj.value);
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "node_modules/node-forge/lib/cipher.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_util();
    module2.exports = forge.cipher = forge.cipher || {};
    forge.cipher.algorithms = forge.cipher.algorithms || {};
    forge.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge.cipher.registerAlgorithm = function(name5, algorithm) {
      name5 = name5.toUpperCase();
      forge.cipher.algorithms[name5] = algorithm;
    };
    forge.cipher.getAlgorithm = function(name5) {
      name5 = name5.toUpperCase();
      if (name5 in forge.cipher.algorithms) {
        return forge.cipher.algorithms[name5];
      }
      return null;
    };
    var BlockCipher = forge.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge.util.createBuffer();
      this.output = options.output || forge.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "node_modules/node-forge/lib/cipherModes.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_util();
    forge.cipher = forge.cipher || {};
    var modes = module2.exports = forge.cipher.modes = forge.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._prev[i] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._prev[i] ^ this._outBlock[i]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count = output.at(len - 1);
      if (count > this.blockSize << 2) {
        return false;
      }
      output.truncate(count);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
          output.putInt32(this._inBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
        this._partialOutput.putInt32(this._partialBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
          output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
          this._inBlock[i] = this._outBlock[i];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._outBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
        }
        this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._outBlock[i] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag2 = [];
      this.cipher.encrypt(this._j0, tag2);
      for (var i = 0; i < this._ints; ++i) {
        this.tag.putInt32(this._s[i] ^ tag2[i]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y) {
      var z_i = [0, 0, 0, 0];
      var v_i = y.slice(0);
      for (var i = 0; i < 128; ++i) {
        var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i = 3; i > 0; --i) {
        out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z = [0, 0, 0, 0];
      for (var i = 0; i < 32; ++i) {
        var idx = i / 8 | 0;
        var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
        var ah = this._m[i][x_i];
        z[0] ^= ah[0];
        z[1] ^= ah[1];
        z[2] ^= ah[2];
        z[3] ^= ah[3];
      }
      return z;
    };
    modes.gcm.prototype.ghash = function(h, y, x) {
      y[0] ^= x[0];
      y[1] ^= x[1];
      y[2] ^= x[2];
      y[3] ^= x[3];
      return this.tableMultiply(y);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m = new Array(size);
      for (var i = 0; i < size; ++i) {
        var tmp = [0, 0, 0, 0];
        var idx = i / perInt | 0;
        var shft = (perInt - 1 - i % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
      }
      return m;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m = new Array(size);
      m[half] = mid.slice(0);
      var i = half >>> 1;
      while (i > 0) {
        this.pow(m[2 * i], m[i] = []);
        i >>= 1;
      }
      i = 2;
      while (i < half) {
        for (var j = 1; j < i; ++j) {
          var m_i = m[i];
          var m_j = m[j];
          m[i + j] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i *= 2;
      }
      m[0] = [0, 0, 0, 0];
      for (i = half + 1; i < size; ++i) {
        var c = m[i ^ half];
        m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge.util.createBuffer(iv);
      }
      if (forge.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          iv.putByte(tmp[i]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
      }
      if (!forge.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i = 0; i < blocks; ++i) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "node_modules/node-forge/lib/aes.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge.aes = forge.aes || {};
    forge.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.aes.Algorithm = function(name5, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name5;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge.util.createBuffer(key);
      } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }
      if (!forge.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i = 0; i < len; ++i) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge.aes._expandKey = function(key, decrypt) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt);
    };
    forge.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
    function registerAlgorithm(name5, mode) {
      var factory = function() {
        return new forge.aes.Algorithm(name5, mode);
      };
      forge.cipher.registerAlgorithm(name5, factory);
    }
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i = 0; i < 128; ++i) {
        xtime[i] = i << 1;
        xtime[i + 128] = i + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i = 0; i < 4; ++i) {
        mix[i] = new Array(256);
        imix[i] = new Array(256);
      }
      var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
      for (var i = 0; i < 256; ++i) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me;
          imix[n][sx] = ime;
          me = me << 24 | me >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    function _expandKey(key, decrypt) {
      var w = key.slice(0);
      var temp, iNk = 1;
      var Nk = w.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i = Nk; i < end; ++i) {
        temp = w[i - 1];
        if (i % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w[i] = w[i - Nk] ^ temp;
      }
      if (decrypt) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w.slice(0);
        end = w.length;
        for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
          if (i === 0 || i === end - Nb) {
            wnew[i] = w[wi];
            wnew[i + 1] = w[wi + 3];
            wnew[i + 2] = w[wi + 2];
            wnew[i + 3] = w[wi + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w[wi + n];
              wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w = wnew;
      }
      return w;
    }
    function _updateBlock(w, input, output, decrypt) {
      var Nr = w.length / 4 - 1;
      var m0, m1, m2, m3, sub;
      if (decrypt) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a, b, c, d, a2, b2, c2;
      a = input[0] ^ w[0];
      b = input[decrypt ? 3 : 1] ^ w[1];
      c = input[2] ^ w[2];
      d = input[decrypt ? 1 : 3] ^ w[3];
      var i = 3;
      for (var round = 1; round < Nr; ++round) {
        a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
        b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
        c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
        d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
        a = a2;
        b = b2;
        c = c2;
      }
      output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
      output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
      output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
      output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "node_modules/node-forge/lib/des.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util();
    module2.exports = forge.des = forge.des || {};
    forge.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.des.Algorithm = function(name5, mode) {
      var self2 = this;
      self2.name = name5;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          },
          decrypt: function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }
        }
      });
      self2._init = false;
    };
    forge.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
    function registerAlgorithm(name5, mode) {
      var factory = function() {
        return new forge.des.Algorithm(name5, mode);
      };
      forge.cipher.registerAlgorithm(name5, factory);
    }
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0, tmp;
      for (var j = 0; j < iterations; j++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i = 0; i < shifts.length; ++i) {
          if (shifts[i]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    function _updateBlock(keys, input, output, decrypt) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i = looping[j]; i != endloop; i += loopinc) {
          var right1 = right ^ keys[i];
          var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
  }
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "node_modules/node-forge/lib/md.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    module2.exports = forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
  }
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/node-forge/lib/hmac.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_md();
    require_util();
    var hmac = module2.exports = forge.hmac = forge.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge.md.algorithms) {
              _md = forge.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge.util.createBuffer(key);
          } else if (forge.util.isArray(key)) {
            var tmp = key;
            key = forge.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              key.putByte(tmp[i]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge.util.createBuffer();
          _opadding = forge.util.createBuffer();
          keylen = key.length();
          for (var i = 0; i < keylen; ++i) {
            var tmp = key.at(i);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i = 0; i < tmp; ++i) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes3) {
        _md.update(bytes3);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// (disabled):crypto
var require_crypto = __commonJS({
  "(disabled):crypto"() {
    init_node_globals();
  }
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/node-forge/lib/pbkdf2.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_hmac();
    require_md();
    require_util();
    var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
    var crypto3;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
      crypto3 = require_crypto();
    }
    module2.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto3.pbkdf2 && (md === null || typeof md !== "object") && (crypto3.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p = Buffer.from(p, "binary");
        s = Buffer.from(s, "binary");
        if (!callback) {
          if (crypto3.pbkdf2Sync.length === 4) {
            return crypto3.pbkdf2Sync(p, s, c, dkLen).toString("binary");
          }
          return crypto3.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
        }
        if (crypto3.pbkdf2Sync.length === 4) {
          return crypto3.pbkdf2(p, s, c, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto3.pbkdf2(p, s, c, dkLen, md, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r = dkLen - (len - 1) * hLen;
      var prf = forge.hmac.create();
      prf.start(md, p);
      var dk = "";
      var xor2, u_c, u_c1;
      if (!callback) {
        for (var i = 1; i <= len; ++i) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge.util.int32ToBytes(i));
          xor2 = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor2 = forge.util.xorBytes(xor2, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i < len ? xor2 : xor2.substr(0, r);
        }
        return dk;
      }
      var i = 1, j;
      function outer() {
        if (i > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge.util.int32ToBytes(i));
        xor2 = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor2 = forge.util.xorBytes(xor2, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge.util.setImmediate(inner);
        }
        dk += i < len ? xor2 : xor2.substr(0, r);
        ++i;
        outer();
      }
      outer();
    };
  }
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "node_modules/node-forge/lib/pem.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_util();
    var pem = module2.exports = forge.pem = forge.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i = 0; i < msg.headers.length; ++i) {
          rval += foldHeader(msg.headers[i]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var msg = {
          type: match[1],
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi = 0; vi < values.length; ++vi) {
              header.values.push(ltrim(values[vi]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = function(match, $1) {
        return " " + $1;
      };
      for (var i = 0; i < header.values.length; ++i) {
        values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length4 = 0;
      var candidate = -1;
      for (var i = 0; i < rval.length; ++i, ++length4) {
        if (length4 > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length4 = i - candidate - 1;
          candidate = -1;
          ++i;
        } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
          candidate = i;
        }
      }
      return rval;
    }
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
  }
});

// node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/node-forge/lib/sha256.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_md();
    require_util();
    var sha2562 = module2.exports = forge.sha256 = forge.sha256 || {};
    forge.md.sha256 = forge.md.algorithms.sha256 = sha2562;
    sha2562.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    function _update(s, w, bytes3) {
      var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
      var len = bytes3.length();
      while (len >= 64) {
        for (i = 0; i < 16; ++i) {
          w[i] = bytes3.getInt32();
        }
        for (; i < 64; ++i) {
          t1 = w[i - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w[i - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
        }
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        f = s.h5;
        g = s.h6;
        h = s.h7;
        for (i = 0; i < 64; ++i) {
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ch = g ^ e & (f ^ g);
          s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
          maj = a & b | c & (a ^ b);
          t1 = h + s1 + ch + _k[i] + w[i];
          t2 = s0 + maj;
          h = g;
          g = f;
          f = e;
          e = d + t1 >>> 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 >>> 0;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        s.h5 = s.h5 + f | 0;
        s.h6 = s.h6 + g | 0;
        s.h7 = s.h7 + h | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "node_modules/node-forge/lib/prng.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_util();
    var _crypto = null;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto();
    }
    var prng = module2.exports = forge.prng = forge.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        reseeds: 0,
        generated: 0,
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i = 0; i < 32; ++i) {
        pools[i] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count, callback) {
        if (!callback) {
          return ctx.generateSync(count);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b = forge.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b.length() >= count) {
            return callback(null, b.getBytes(count));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes3 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes3.length;
          b.putBytes(bytes3);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge.util.setImmediate(generate);
        }
      };
      ctx.generateSync = function(count) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b = forge.util.createBuffer();
        while (b.length() < count) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes3 = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes3.length;
          b.putBytes(bytes3);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b.getBytes(count);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes3) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes3);
          _seed();
          callback();
        });
      }
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k = 0; k < 32; ++k) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k].digest().getBytes());
            ctx.pools[k].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      function defaultSeedFile(needed) {
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto2.getRandomValues(arr);
          };
        }
        var b = forge.util.createBuffer();
        if (getRandomValues) {
          while (b.length() < needed) {
            var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count));
            try {
              getRandomValues(entropy);
              for (var i2 = 0; i2 < entropy.length; ++i2) {
                b.putInt32(entropy[i2]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b.length() < needed) {
          var hi, lo, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b.length() < needed) {
            lo = 16807 * (seed & 65535);
            hi = 16807 * (seed >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed = lo & 4294967295;
            for (var i2 = 0; i2 < 3; ++i2) {
              next = seed >>> (i2 << 3);
              next ^= Math.floor(Math.random() * 256);
              b.putByte(String.fromCharCode(next & 255));
            }
          }
        }
        return b.getBytes(needed);
      }
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes3) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes3.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes3) {
        var count = bytes3.length;
        for (var i2 = 0; i2 < count; ++i2) {
          ctx.pools[ctx.pool].update(bytes3.substr(i2, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i2, n) {
        var bytes3 = "";
        for (var x = 0; x < n; x += 8) {
          bytes3 += String.fromCharCode(i2 >> x & 255);
        }
        ctx.collect(bytes3);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes3) {
                worker.postMessage({ forge: { prng: { err, bytes: bytes3 } } });
              });
            }
          };
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "node_modules/node-forge/lib/random.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_aes();
    require_sha256();
    require_prng();
    require_util();
    (function() {
      if (forge.random && forge.random.getBytes) {
        module2.exports = forge.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge.md.sha256;
        function spawnPrng() {
          var ctx = forge.prng.create(prng_aes);
          ctx.getBytes = function(count, callback) {
            return ctx.generate(count, callback);
          };
          ctx.getBytesSync = function(count) {
            return ctx.generate(count);
          };
          return ctx;
        }
        var _ctx = spawnPrng();
        var getRandomValues = null;
        var globalScope = forge.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues = function(arr) {
            return _crypto.getRandomValues(arr);
          };
        }
        if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e) {
              _ctx.collectInt(e.clientX, 16);
              _ctx.collectInt(e.clientY, 16);
            });
            jQuery2().keypress(function(e) {
              _ctx.collectInt(e.charCode, 8);
            });
          }
        }
        if (!forge.random) {
          forge.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge.random[key] = _ctx[key];
          }
        }
        forge.random.createInstance = spawnPrng;
        module2.exports = forge.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "node_modules/node-forge/lib/rc2.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_util();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s = [1, 2, 3, 5];
    var rol = function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    };
    var ror = function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    };
    module2.exports = forge.rc2 = forge.rc2 || {};
    forge.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L = key;
      var T = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i;
      for (i = T; i < 128; i++) {
        L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i = 127 - T8; i >= 0; i--) {
        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
      }
      return L;
    };
    var createCipher = function(key, bits, encrypt) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i, j, K = [];
      key = forge.rc2.expandKey(key, bits);
      for (i = 0; i < 64; i++) {
        K.push(key.getInt16Le());
      }
      if (encrypt) {
        mixRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            R[i] = rol(R[i], s[i]);
            j++;
          }
        };
        mashRound = function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[R[(i + 3) % 4] & 63];
          }
        };
      } else {
        mixRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] = ror(R[i], s[i]);
            R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            j--;
          }
        };
        mashRound = function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] -= K[R[(i + 3) % 4] & 63];
          }
        };
      }
      var runPlan = function(plan) {
        var R = [];
        for (i = 0; i < 4; i++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R.push(val & 65535);
        }
        j = encrypt ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R);
          }
        }
        for (i = 0; i < 4; i++) {
          if (_iv !== null) {
            if (encrypt) {
              _iv.putInt16Le(R[i]);
            } else {
              R[i] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i]);
        }
      };
      var cipher = null;
      cipher = {
        start: function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge.util.createBuffer();
          _output = output || new forge.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        },
        update: function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        },
        finish: function(pad) {
          var rval = true;
          if (encrypt) {
            if (pad) {
              rval = pad(8, _input, !encrypt);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt);
              } else {
                var len = _output.length();
                var count = _output.at(len - 1);
                if (count > len) {
                  rval = false;
                } else {
                  _output.truncate(count);
                }
              }
            }
          }
          return rval;
        }
      };
      return cipher;
    };
    forge.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher(key, bits, true);
    };
    forge.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher(key, bits, false);
    };
  }
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "node_modules/node-forge/lib/jsbn.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    module2.exports = forge.jsbn = forge.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      this.data = [];
      if (a != null)
        if (typeof a == "number")
          this.fromNumber(a, b, c);
        else if (b == null && typeof a != "string")
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    forge.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this.data[i++] + w.data[j] + c;
        c = Math.floor(v / 67108864);
        w.data[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i] & 32767;
        var h = this.data[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w.data[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i] & 16383;
        var h = this.data[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w.data[j++] = l & 268435455;
      }
      return c;
    }
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i)
        r.data[i] = this.data[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this.data[0] = x;
      else if (x < -1)
        this.data[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this.data[i] & (1 << p) - 1) << k - p;
            d |= this.data[--i] >> (p += this.DB - k);
          } else {
            d = this.data[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i >= 0)
        if ((r = this.data[i] - a.data[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i)
        r.data[i + n] = this.data[i];
      for (i = n - 1; i >= 0; --i)
        r.data[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i)
        r.data[i - n] = this.data[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1; i >= 0; --i) {
        r.data[i + ds + 1] = this.data[i] >> cbs | c;
        c = (this.data[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i)
        r.data[i] = 0;
      r.data[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r.data[0] = this.data[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
        r.data[i - ds] = this.data[i] >> bs;
      }
      if (bs > 0)
        r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] - a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r.data[i++] = this.DV + c;
      else if (c > 0)
        r.data[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < y.t; ++i)
        r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
        if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r.data[i + x.t] -= x.DV;
          r.data[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y.data[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j = i - ys, t = q == null ? nbi() : q;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r.data[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys)
        y.data[y.t++] = 0;
      while (--j >= 0) {
        var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
        if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r.data[i] < --qd)
            r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms)
          BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this.data[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x.data[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z.sqrTo(r, r2);
        if ((e & 1 << i) > 0)
          z.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z.revert(r);
    }
    function bnModPowInt(e, m) {
      var z;
      if (e < 256 || m.isEven())
        z = new Classic(m);
      else
        z = new Montgomery(m);
      return this.exp(e, z);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this.data[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this.data[0];
      else if (this.t == 0)
        return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d, y, z);
      while (y.signum() > 0) {
        r = (a + z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z);
      }
      return z.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if (typeof b == "number") {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t > 0)
          x[0] &= (1 << t) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (this.data[i] & (1 << p) - 1) << 8 - p;
            d |= this.data[--i] >> (p += this.DB - 8);
          } else {
            d = this.data[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i, f, m = Math.min(a.t, this.t);
      for (i = 0; i < m; ++i)
        r.data[i] = op(this.data[i], a.data[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m; i < this.t; ++i)
          r.data[i] = op(this.data[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m; i < a.t; ++i)
          r.data[i] = op(f, a.data[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i)
        r.data[i] = this.DM & ~this.data[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this.data[i] != 0)
          return i * this.DB + lbit(this.data[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i)
        r += cbit(this.data[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this.data[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this.data[i] + a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r.data[i++] = c;
      else if (c < -1)
        r.data[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this.data[this.t++] = 0;
      this.data[w] += n;
      while (this.data[w] >= this.DV) {
        this.data[w] -= this.DV;
        if (++w >= this.t)
          this.data[this.t++] = 0;
        ++this.data[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r.data[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i)
        r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i)
        this.am(0, a.data[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r.data[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z = new Classic(m);
      else if (m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = e.data[j] >> i - k1 & km;
        else {
          w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w |= e.data[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z.sqrTo(r, r2);
            z.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e.data[j] & 1 << i) == 0) {
          z.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this.data[0] % n;
        else
          for (var i = this.t - 1; i >= 0; --i)
            r = (d * r + this.data[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x.data[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t);
    }
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a;
      for (var i = 0; i < t; ++i) {
        do {
          a = new BigInteger(this.bitLength(), prng);
        } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    function bnGetPrng() {
      return {
        nextBytes: function(x) {
          for (var i = 0; i < x.length; ++i) {
            x[i] = Math.floor(Math.random() * 256);
          }
        }
      };
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// node_modules/node-forge/lib/sha1.js
var require_sha1 = __commonJS({
  "node_modules/node-forge/lib/sha1.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_md();
    require_util();
    var sha1 = module2.exports = forge.sha1 = forge.sha1 || {};
    forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    function _update(s, w, bytes3) {
      var t, a, b, c, d, e, f, i;
      var len = bytes3.length();
      while (len >= 64) {
        a = s.h0;
        b = s.h1;
        c = s.h2;
        d = s.h3;
        e = s.h4;
        for (i = 0; i < 16; ++i) {
          t = bytes3.getInt32();
          w[i] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 20; ++i) {
          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
          t = t << 1 | t >>> 31;
          w[i] = t;
          f = d ^ b & (c ^ d);
          t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 32; ++i) {
          t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
          t = t << 1 | t >>> 31;
          w[i] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 40; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 60; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f = b & c | d & (b ^ c);
          t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        for (; i < 80; ++i) {
          t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
          t = t << 2 | t >>> 30;
          w[i] = t;
          f = b ^ c ^ d;
          t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
          e = d;
          d = c;
          c = (b << 30 | b >>> 2) >>> 0;
          b = a;
          a = t;
        }
        s.h0 = s.h0 + a | 0;
        s.h1 = s.h1 + b | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d | 0;
        s.h4 = s.h4 + e | 0;
        len -= 64;
      }
    }
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/node-forge/lib/pkcs1.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_util();
    require_random();
    require_sha1();
    var pkcs1 = module2.exports = forge.pkcs1 = forge.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message, options) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message.length > maxLength) {
        var error = new Error("RSAES-OAEP input message length is too long.");
        error.length = message.length;
        error.maxLength = maxLength;
        throw error;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message.length;
      for (var i = 0; i < PS_length; i++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message;
      if (!seed) {
        seed = forge.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error.seedLength = seed.length;
        error.digestLength = md.digestLength;
        throw error;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error = new Error("RSAES-OAEP encoded message length is invalid.");
        error.length = em.length;
        error.expectedLength = keyLength;
        throw error;
      }
      if (md === void 0) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error = y !== "\0";
      for (var i = 0; i < md.digestLength; ++i) {
        error |= lHash.charAt(i) !== lHashPrime.charAt(i);
      }
      var in_ps = 1;
      var index = md.digestLength;
      for (var j = md.digestLength; j < db.length; j++) {
        var code5 = db.charCodeAt(j);
        var is_0 = code5 & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error |= code5 & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash2) {
      if (!hash2) {
        hash2 = forge.md.sha1.create();
      }
      var t = "";
      var count = Math.ceil(maskLength / hash2.digestLength);
      for (var i = 0; i < count; ++i) {
        var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
        hash2.start();
        hash2.update(seed + c);
        t += hash2.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "node_modules/node-forge/lib/prime.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_util();
    require_jsbn();
    require_random();
    (function() {
      if (forge.prime) {
        module2.exports = forge.prime;
        return;
      }
      var prime = module2.exports = forge.prime = forge.prime || {};
      var BigInteger = forge.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = function(x, y) {
        return x | y;
      };
      prime.generateProbablePrime = function(bits, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge.random;
        var rng = {
          nextBytes: function(x) {
            var b = prng.getBytesSync(x.length);
            for (var i = 0; i < x.length; ++i) {
              x[i] = b.charCodeAt(i);
            }
          }
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
        var num = generateRandom(bits, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
        forge.util.setImmediate(function() {
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
        }
        var num = generateRandom(bits, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i = 0; i < numWorkers; ++i) {
            workers[i] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e) {
            if (found) {
              return;
            }
            --running;
            var data = e.data;
            if (data.found) {
              for (var i2 = 0; i2 < workers.length; ++i2) {
                workers[i2].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            var hex = num.toString(16);
            e.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
        }
      }
      function generateRandom(bits, rng) {
        var num = new BigInteger(bits, rng);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      function getMillerRabinTests(bits) {
        if (bits <= 100)
          return 27;
        if (bits <= 150)
          return 18;
        if (bits <= 200)
          return 15;
        if (bits <= 250)
          return 12;
        if (bits <= 300)
          return 9;
        if (bits <= 350)
          return 8;
        if (bits <= 400)
          return 7;
        if (bits <= 500)
          return 6;
        if (bits <= 600)
          return 5;
        if (bits <= 800)
          return 4;
        if (bits <= 1250)
          return 3;
        return 2;
      }
    })();
  }
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "node_modules/node-forge/lib/rsa.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge.util.isNodejs ? require_crypto() : null;
    var asn1 = forge.asn1;
    var util = forge.util;
    forge.pki = forge.pki || {};
    module2.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
    var pki = forge.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var emsaPkcs1v15encode = function(md) {
      var oid;
      if (md.algorithm in pki.oids) {
        oid = pki.oids[md.algorithm];
      } else {
        var error = new Error("Unknown message digest algorithm.");
        error.algorithm = md.algorithm;
        throw error;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
      digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ""));
      var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest);
      return asn1.toDer(digestInfo).getBytes();
    };
    var _modPow = function(x, key, pub) {
      if (pub) {
        return x.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r;
      do {
        r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);
      } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      var xp = x.mod(key.p).modPow(key.dP, key.p);
      var xq = x.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y = y.multiply(r.modInverse(key.n)).mod(key.n);
      return y;
    };
    pki.rsa.encrypt = function(m, key, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m, key, bt);
      } else {
        eb = forge.util.createBuffer();
        eb.putBytes(m);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y = _modPow(x, key, pub);
      var yhex = y.toString(16);
      var ed = forge.util.createBuffer();
      var zeros = k - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0);
        --zeros;
      }
      ed.putBytes(forge.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki.rsa.decrypt = function(ed, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k) {
        var error = new Error("Encrypted message length is invalid.");
        error.length = ed.length;
        error.expected = k;
        throw error;
      }
      var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
      if (y.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x = _modPow(y, key, pub);
      var xhex = x.toString(16);
      var eb = forge.util.createBuffer();
      var zeros = k - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge.random;
      var rng = {
        nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = function(x, y) {
        return x | y;
      };
      var t1 = +new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e === "function") {
            callback = e;
            e = void 0;
          } else if (typeof e !== "number") {
            options = e;
            e = void 0;
          }
        } else {
          options = bits;
          callback = e;
          bits = void 0;
          e = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e;
          e = void 0;
        }
      }
      options = options || {};
      if (bits === void 0) {
        bits = options.bits || 2048;
      }
      if (e === void 0) {
        e = options.e || 65537;
      }
      if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e2) {
              var pair = e2.target.result;
              var exportOp = util.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
              exportOp.oncomplete = function(e3) {
                var pkcs8 = e3.target.result;
                var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair.privateKey),
              publicKey: pki.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
      var key = {
        n,
        e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: function(m, key2, pub) {
              return _encodePkcs1_v1_5(m, key2, 2).getBytes();
            }
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: function(m, key2) {
              return forge.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: function(e3) {
            return e3;
          } };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e2 = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e2, key, true);
      };
      key.verify = function(digest, signature, scheme) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: function(digest2, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              var obj = asn1.fromDer(d2);
              return digest2 === obj.value[1].value;
            }
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: function(digest2, d2) {
              d2 = _decodePkcs1_v1_5(d2, key, true);
              return digest2 === d2;
            }
          };
        }
        var d = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest, d, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
      var key = {
        n,
        e,
        d,
        p,
        q,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d2 = pki.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: function(d3, key2) {
              return forge.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
            }
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: function(d3) {
            return d3;
          } };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d2, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: function() {
            return md;
          } };
          bt = 1;
        }
        var d2 = scheme.encode(md, key.n.bitLength());
        return pki.rsa.encrypt(d2, key, bt);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors2)) {
        obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors2 = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error.errors = errors2;
        throw error;
      }
      var n, e, d, p, q, dP, dQ, qInv;
      n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors2)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error = new Error("Cannot read public key. Unknown OID.");
          error.oid = oid;
          throw error;
        }
        obj = capture.rsaPublicKey;
      }
      errors2 = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error.errors = errors2;
        throw error;
      }
      var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))
      ]);
    };
    function _encodePkcs1_v1_5(m, key, bt) {
      var eb = forge.util.createBuffer();
      var k = Math.ceil(key.n.bitLength() / 8);
      if (m.length > k - 11) {
        var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error.length = m.length;
        error.max = k - 11;
        throw error;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k - 3 - m.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i = 0; i < padNum; ++i) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge.random.getBytes(padNum);
          for (var i = 0; i < padNum; ++i) {
            padByte = padBytes.charCodeAt(i);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m);
      return eb;
    }
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      var eb = forge.util.createBuffer(em);
      var first3 = eb.getByte();
      var bt = eb.getByte();
      if (first3 !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k - 3 - ml;
        for (var i = 0; i < padNum; ++i) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      function getPrime(bits, callback2) {
        forge.prime.generateProbablePrime(bits, opts, callback2);
      }
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
    }
    function _bnToBytes(b) {
      var hex = b.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes3 = forge.util.hexToBytes(hex);
      if (bytes3.length > 1 && (bytes3.charCodeAt(0) === 0 && (bytes3.charCodeAt(1) & 128) === 0 || bytes3.charCodeAt(0) === 255 && (bytes3.charCodeAt(1) & 128) === 128)) {
        return bytes3.substr(1);
      }
      return bytes3;
    }
    function _getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
    function _detectNodeCrypto(fn) {
      return forge.util.isNodejs && typeof _crypto[fn] === "function";
    }
    function _detectSubtleCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
    }
    function _detectSubtleMsCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
    }
    function _intToUint8Array(x) {
      var bytes3 = forge.util.hexToBytes(x.toString(16));
      var buffer2 = new Uint8Array(bytes3.length);
      for (var i = 0; i < bytes3.length; ++i) {
        buffer2[i] = bytes3.charCodeAt(i);
      }
      return buffer2;
    }
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "node_modules/node-forge/lib/pbe.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    module2.exports = pki.pbe = forge.pbe = forge.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge.random.getBytesSync(options.saltSize);
      var count = options.count;
      var countBytes = asn1.integerToDer(count);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge.des.createEncryptionCipher;
            break;
          default:
            var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error.algorithm = options.algorithm;
            throw error;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
        var iv = forge.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()),
              params
            ]),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)
            ])
          ])
        ]);
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
        var cipher = forge.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
          ])
        ]);
      } else {
        var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error.algorithm = options.algorithm;
        throw error;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        encryptionAlgorithm,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)
      ]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors2)) {
        var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error.algorithm = options.algorithm;
          throw error;
      }
      var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error.headerType = error;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 40);
            };
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 64);
            };
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = function(key) {
              return forge.rc2.createDecryptionCipher(key, 128);
            };
            break;
          default:
            var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error.algorithm = msg.dekInfo.algorithm;
            throw error;
        }
        var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
      var j, l;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge.md.sha1.create();
      }
      var u = md.digestLength;
      var v = md.blockLength;
      var result = new forge.util.ByteBuffer();
      var passBuf = new forge.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p = passBuf.length();
      var s = salt.length();
      var D = new forge.util.ByteBuffer();
      D.fillWithByte(id, v);
      var Slen = v * Math.ceil(s / v);
      var S = new forge.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S.putByte(salt.at(l % s));
      }
      var Plen = v * Math.ceil(p / v);
      var P = new forge.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p));
      }
      var I = S;
      I.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i = 1; i <= c; i++) {
        var buf2 = new forge.util.ByteBuffer();
        buf2.putBytes(D.bytes());
        buf2.putBytes(I.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf2.getBytes());
          buf2 = md.digest();
        }
        var B = new forge.util.ByteBuffer();
        for (l = 0; l < v; l++) {
          B.putByte(buf2.at(l % u));
        }
        var k = Math.ceil(s / v) + Math.ceil(p / v);
        var Inew = new forge.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge.util.ByteBuffer(I.getBytes(v));
          var x = 511;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 255);
          }
          Inew.putBuffer(chunk);
        }
        I = Inew;
        result.putBuffer(buf2);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids["pkcs5PBES2"]:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error.oid = oid;
          error.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors2)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids["pkcs5PBKDF2"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error.oid = oid;
        error.supportedOids = ["pkcs5PBKDF2"];
        throw error;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
        var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error.oid = oid;
        error.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error;
      }
      var salt = capture.kdfSalt;
      var count = forge.util.createBuffer(capture.kdfIterationCount);
      count = count.getInt(count.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors2)) {
        var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error.errors = errors2;
        throw error;
      }
      var salt = forge.util.createBuffer(capture.salt);
      var count = forge.util.createBuffer(capture.iterations);
      count = count.getInt(count.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge.des.startDecrypting;
          break;
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = function(key2, iv2) {
            var cipher = forge.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          };
          break;
        default:
          var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error.oid = oid;
          throw error;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
      md.start();
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
      return cipherFn(key, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash2(md, password + salt)];
      for (var length4 = 16, i = 1; length4 < dkLen; ++i, length4 += 16) {
        digests.push(hash2(md, digests[i - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash2(md, bytes3) {
      return md.start().update(bytes3).digest().getBytes();
    }
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error = new Error("Unsupported PRF OID.");
          error.oid = prfOid;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error = new Error("Unsupported PRF algorithm.");
          error.algorithm = prfAlgorithm;
          error.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]));
      }
      return params;
    }
  }
});

// node_modules/libp2p-crypto/src/webcrypto.js
var require_webcrypto = __commonJS({
  "node_modules/libp2p-crypto/src/webcrypto.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.get = (win = self) => {
      const nativeCrypto = win.crypto || win.msCrypto;
      if (!nativeCrypto || !nativeCrypto.subtle) {
        throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), { code: "ERR_MISSING_WEB_CRYPTO" });
      }
      return nativeCrypto;
    };
  }
});

// node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js
var require_aes_gcm_browser = __commonJS({
  "node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { concat: concat3 } = (init_concat(), concat_exports);
    var { fromString: fromString4 } = (init_from_string(), from_string_exports);
    var webcrypto = require_webcrypto();
    function create7({
      algorithm = "AES-GCM",
      nonceLength = 12,
      keyLength = 16,
      digest = "SHA-256",
      saltLength = 16,
      iterations = 32767
    } = {}) {
      const crypto3 = webcrypto.get();
      keyLength *= 8;
      async function encrypt(data, password) {
        const salt = crypto3.getRandomValues(new Uint8Array(saltLength));
        const nonce = crypto3.getRandomValues(new Uint8Array(nonceLength));
        const aesGcm = { name: algorithm, iv: nonce };
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest } };
        const rawKey = await crypto3.subtle.importKey("raw", fromString4(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
        const cryptoKey = await crypto3.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["encrypt"]);
        const ciphertext = await crypto3.subtle.encrypt(aesGcm, cryptoKey, data);
        return concat3([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
      }
      async function decrypt(data, password) {
        const salt = data.slice(0, saltLength);
        const nonce = data.slice(saltLength, saltLength + nonceLength);
        const ciphertext = data.slice(saltLength + nonceLength);
        const aesGcm = { name: algorithm, iv: nonce };
        const deriveParams = { name: "PBKDF2", salt, iterations, hash: { name: digest } };
        const rawKey = await crypto3.subtle.importKey("raw", fromString4(password), { name: "PBKDF2" }, false, ["deriveKey", "deriveBits"]);
        const cryptoKey = await crypto3.subtle.deriveKey(deriveParams, rawKey, { name: algorithm, length: keyLength }, true, ["decrypt"]);
        const plaintext = await crypto3.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
        return new Uint8Array(plaintext);
      }
      return {
        encrypt,
        decrypt
      };
    }
    module2.exports = {
      create: create7
    };
  }
});

// node_modules/libp2p-crypto/src/keys/importer.js
var require_importer = __commonJS({
  "node_modules/libp2p-crypto/src/keys/importer.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { base64: base642 } = (init_base64(), base64_exports);
    var ciphers = require_aes_gcm_browser();
    module2.exports = {
      import: async function(privateKey, password) {
        const encryptedKey = base642.decode(privateKey);
        const cipher = ciphers.create();
        return await cipher.decrypt(encryptedKey, password);
      }
    };
  }
});

// node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/node-forge/lib/sha512.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_md();
    require_util();
    var sha5122 = module2.exports = forge.sha512 = forge.sha512 || {};
    forge.md.sha512 = forge.md.algorithms.sha512 = sha5122;
    var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
    sha384.create = function() {
      return sha5122.create("SHA-384");
    };
    forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
    forge.sha512.sha256 = forge.sha512.sha256 || {
      create: function() {
        return sha5122.create("SHA-512/256");
      }
    };
    forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
    forge.sha512.sha224 = forge.sha512.sha224 || {
      create: function() {
        return sha5122.create("SHA-512/224");
      }
    };
    forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
    sha5122.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      for (var wi = 0; wi < 80; ++wi) {
        _w[wi] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        messageLength: 0,
        fullMessageLength: null,
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _h = new Array(_state.length);
        for (var i = 0; i < _state.length; ++i) {
          _h[i] = _state[i].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h = new Array(_h.length);
        for (var i = 0; i < _h.length; ++i) {
          h[i] = _h[i].slice(0);
        }
        _update(h, _w, finalBlock);
        var rval = forge.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h.length;
        } else if (algorithm === "SHA-384") {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i = 0; i < hlen; ++i) {
          rval.putInt32(h[i][0]);
          if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h[i][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    function _update(s, w, bytes3) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i, hi, lo, w2, w7, w15, w16;
      var len = bytes3.length();
      while (len >= 128) {
        for (i = 0; i < 16; ++i) {
          w[i][0] = bytes3.getInt32() >>> 0;
          w[i][1] = bytes3.getInt32() >>> 0;
        }
        for (; i < 80; ++i) {
          w2 = w[i - 2];
          hi = w2[0];
          lo = w2[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w[i - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w[i - 7];
          w16 = w[i - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w[i][1] = lo >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i = 0; i < 80; ++i) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s[0][1] + a_lo;
        s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[0][1] = lo >>> 0;
        lo = s[1][1] + b_lo;
        s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[1][1] = lo >>> 0;
        lo = s[2][1] + c_lo;
        s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[2][1] = lo >>> 0;
        lo = s[3][1] + d_lo;
        s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[3][1] = lo >>> 0;
        lo = s[4][1] + e_lo;
        s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[4][1] = lo >>> 0;
        lo = s[5][1] + f_lo;
        s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[5][1] = lo >>> 0;
        lo = s[6][1] + g_lo;
        s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[6][1] = lo >>> 0;
        lo = s[7][1] + h_lo;
        s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[7][1] = lo >>> 0;
        len -= 128;
      }
    }
  }
});

// node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = __commonJS({
  "node_modules/node-forge/lib/asn1-validator.js"(exports2) {
    init_node_globals();
    var forge = require_forge();
    require_asn1();
    var asn1 = forge.asn1;
    exports2.privateKeyValidator = {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    exports2.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [
        {
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        },
        {
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          composed: true,
          captureBitStringValue: "ed25519PublicKey"
        }
      ]
    };
  }
});

// node_modules/node-forge/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/node-forge/lib/ed25519.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_jsbn();
    require_random();
    require_sha512();
    require_util();
    var asn1Validator = require_asn1_validator();
    var publicKeyValidator = asn1Validator.publicKeyValidator;
    var privateKeyValidator = asn1Validator.privateKeyValidator;
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var ByteBuffer = forge.util.ByteBuffer;
    var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
    forge.pki = forge.pki || {};
    module2.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
    var ed25519 = forge.ed25519;
    ed25519.constants = {};
    ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
    ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
    ed25519.constants.SEED_BYTE_LENGTH = 32;
    ed25519.constants.SIGN_BYTE_LENGTH = 64;
    ed25519.constants.HASH_BYTE_LENGTH = 64;
    ed25519.generateKeyPair = function(options) {
      options = options || {};
      var seed = options.seed;
      if (seed === void 0) {
        seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
      } else if (typeof seed === "string") {
        if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
          throw new TypeError('"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length.");
        }
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
      }
      seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      for (var i = 0; i < 32; ++i) {
        sk[i] = seed[i];
      }
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, privateKey: sk };
    };
    ed25519.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors2);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors2;
        throw error;
      }
      var oid = forge.asn1.derToOid(capture.privateKeyOid);
      var ed25519Oid = forge.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var privateKey = capture.privateKey;
      var privateKeyBytes = messageToNativeBuffer({
        message: forge.asn1.fromDer(privateKey).value,
        encoding: "binary"
      });
      return { privateKeyBytes };
    };
    ed25519.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors2);
      if (!valid) {
        var error = new Error("Invalid Key.");
        error.errors = errors2;
        throw error;
      }
      var oid = forge.asn1.derToOid(capture.publicKeyOid);
      var ed25519Oid = forge.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var publicKeyBytes = capture.ed25519PublicKey;
      if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new Error("Key length is invalid.");
      }
      return messageToNativeBuffer({
        message: publicKeyBytes,
        encoding: "binary"
      });
    };
    ed25519.publicKeyFromPrivateKey = function(options) {
      options = options || {};
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      }
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      for (var i = 0; i < pk.length; ++i) {
        pk[i] = privateKey[32 + i];
      }
      return pk;
    };
    ed25519.sign = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
        var keyPair = ed25519.generateKeyPair({ seed: privateKey });
        privateKey = keyPair.privateKey;
      } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      }
      var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      crypto_sign(signedMsg, msg, msg.length, privateKey);
      var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
      for (var i = 0; i < sig.length; ++i) {
        sig[i] = signedMsg[i];
      }
      return sig;
    };
    ed25519.verify = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      if (options.signature === void 0) {
        throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
      }
      var sig = messageToNativeBuffer({
        message: options.signature,
        encoding: "binary"
      });
      if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
        throw new TypeError('"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH);
      }
      var publicKey = messageToNativeBuffer({
        message: options.publicKey,
        encoding: "binary"
      });
      if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new TypeError('"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      }
      var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var i;
      for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
        sm[i] = sig[i];
      }
      for (i = 0; i < msg.length; ++i) {
        sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
      }
      return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
    };
    function messageToNativeBuffer(options) {
      var message = options.message;
      if (message instanceof Uint8Array || message instanceof NativeBuffer) {
        return message;
      }
      var encoding = options.encoding;
      if (message === void 0) {
        if (options.md) {
          message = options.md.digest().getBytes();
          encoding = "binary";
        } else {
          throw new TypeError('"options.message" or "options.md" not specified.');
        }
      }
      if (typeof message === "string" && !encoding) {
        throw new TypeError('"options.encoding" must be "binary" or "utf8".');
      }
      if (typeof message === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(message, encoding);
        }
        message = new ByteBuffer(message, encoding);
      } else if (!(message instanceof ByteBuffer)) {
        throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
      }
      var buffer2 = new NativeBuffer(message.length());
      for (var i = 0; i < buffer2.length; ++i) {
        buffer2[i] = message.at(i);
      }
      return buffer2;
    }
    var gf0 = gf();
    var gf1 = gf([1]);
    var D = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D2 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    var I = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function sha5122(msg, msgLen) {
      var md = forge.md.sha512.create();
      var buffer2 = new ByteBuffer(msg);
      md.update(buffer2.getBytes(msgLen), "binary");
      var hash2 = md.digest().getBytes();
      if (typeof Buffer !== "undefined") {
        return Buffer.from(hash2, "binary");
      }
      var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
      for (var i = 0; i < 64; ++i) {
        out[i] = hash2.charCodeAt(i);
      }
      return out;
    }
    function crypto_sign_keypair(pk, sk) {
      var p = [gf(), gf(), gf(), gf()];
      var i;
      var d = sha5122(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      scalarbase(p, d);
      pack(pk, p);
      for (i = 0; i < 32; ++i) {
        sk[i + 32] = pk[i];
      }
      return 0;
    }
    function crypto_sign(sm, m, n, sk) {
      var i, j, x = new Float64Array(64);
      var p = [gf(), gf(), gf(), gf()];
      var d = sha5122(sk, 32);
      d[0] &= 248;
      d[31] &= 127;
      d[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; ++i) {
        sm[64 + i] = m[i];
      }
      for (i = 0; i < 32; ++i) {
        sm[32 + i] = d[32 + i];
      }
      var r = sha5122(sm.subarray(32), n + 32);
      reduce2(r);
      scalarbase(p, r);
      pack(sm, p);
      for (i = 32; i < 64; ++i) {
        sm[i] = sk[i];
      }
      var h = sha5122(sm, n + 64);
      reduce2(h);
      for (i = 32; i < 64; ++i) {
        x[i] = 0;
      }
      for (i = 0; i < 32; ++i) {
        x[i] = r[i];
      }
      for (i = 0; i < 32; ++i) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h[i] * d[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    function crypto_sign_open(m, sm, n, pk) {
      var i, mlen;
      var t = new NativeBuffer(32);
      var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n < 64) {
        return -1;
      }
      if (unpackneg(q, pk)) {
        return -1;
      }
      for (i = 0; i < n; ++i) {
        m[i] = sm[i];
      }
      for (i = 0; i < 32; ++i) {
        m[i + 32] = pk[i];
      }
      var h = sha5122(m, n);
      reduce2(h);
      scalarmult(p, q, h);
      scalarbase(q, sm.subarray(32));
      add(p, q);
      pack(t, p);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; ++i) {
          m[i] = 0;
        }
        return -1;
      }
      for (i = 0; i < n; ++i) {
        m[i] = sm[i + 64];
      }
      mlen = n;
      return mlen;
    }
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; ++j) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; ++j) {
        x[j] -= carry * L[j];
      }
      for (i = 0; i < 32; ++i) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function reduce2(r) {
      var x = new Float64Array(64);
      for (var i = 0; i < 64; ++i) {
        x[i] = r[i];
        r[i] = 0;
      }
      modL(r, x);
    }
    function add(p, q) {
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }
    function cswap(p, q, b) {
      for (var i = 0; i < 4; ++i) {
        sel25519(p[i], q[i], b);
      }
    }
    function pack(r, p) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function pack25519(o, n) {
      var i, j, b;
      var m = gf(), t = gf();
      for (i = 0; i < 16; ++i) {
        t[i] = n[i];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; ++j) {
        m[0] = t[0] - 65517;
        for (i = 1; i < 15; ++i) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function unpackneg(r, p) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p);
      S(num, r[1]);
      M(den, num, D);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S(den2, den);
      S(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) {
        M(r[0], r[0], I);
      }
      S(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r[0]) === p[31] >> 7) {
        Z(r[0], gf0, r[0]);
      }
      M(r[3], r[0], r[1]);
      return 0;
    }
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; ++i) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }
      o[15] &= 32767;
    }
    function pow2523(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; ++a) {
        c[a] = i[a];
      }
      for (a = 250; a >= 0; --a) {
        S(c, c);
        if (a !== 1) {
          M(c, c, i);
        }
      }
      for (a = 0; a < 16; ++a) {
        o[a] = c[a];
      }
    }
    function neq25519(a, b) {
      var c = new NativeBuffer(32);
      var d = new NativeBuffer(32);
      pack25519(c, a);
      pack25519(d, b);
      return crypto_verify_32(c, 0, d, 0);
    }
    function crypto_verify_32(x, xi, y, yi) {
      return vn(x, xi, y, yi, 32);
    }
    function vn(x, xi, y, yi, n) {
      var i, d = 0;
      for (i = 0; i < n; ++i) {
        d |= x[xi + i] ^ y[yi + i];
      }
      return (1 & d - 1 >>> 8) - 1;
    }
    function par25519(a) {
      var d = new NativeBuffer(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function scalarmult(p, q, s) {
      var b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
      }
    }
    function scalarbase(p, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }
    function set25519(r, a) {
      var i;
      for (i = 0; i < 16; i++) {
        r[i] = a[i] | 0;
      }
    }
    function inv25519(o, i) {
      var c = gf();
      var a;
      for (a = 0; a < 16; ++a) {
        c[a] = i[a];
      }
      for (a = 253; a >= 0; --a) {
        S(c, c);
        if (a !== 2 && a !== 4) {
          M(c, c, i);
        }
      }
      for (a = 0; a < 16; ++a) {
        o[a] = c[a];
      }
    }
    function car25519(o) {
      var i, v, c = 1;
      for (i = 0; i < 16; ++i) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      var t, c = ~(b - 1);
      for (var i = 0; i < 16; ++i) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    function gf(init) {
      var i, r = new Float64Array(16);
      if (init) {
        for (i = 0; i < init.length; ++i) {
          r[i] = init[i];
        }
      }
      return r;
    }
    function A(o, a, b) {
      for (var i = 0; i < 16; ++i) {
        o[i] = a[i] + b[i];
      }
    }
    function Z(o, a, b) {
      for (var i = 0; i < 16; ++i) {
        o[i] = a[i] - b[i];
      }
    }
    function S(o, a) {
      M(o, a, a);
    }
    function M(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
  }
});

// node_modules/iso-random-stream/src/random.browser.js
var require_random_browser = __commonJS({
  "node_modules/iso-random-stream/src/random.browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var MAX_BYTES = 65536;
    function randomBytes(size) {
      const bytes3 = new Uint8Array(size);
      let generated = 0;
      if (size > 0) {
        if (size > MAX_BYTES) {
          while (generated < size) {
            if (generated + MAX_BYTES > size) {
              crypto.getRandomValues(bytes3.subarray(generated, generated + (size - generated)));
              generated += size - generated;
            } else {
              crypto.getRandomValues(bytes3.subarray(generated, generated + MAX_BYTES));
              generated += MAX_BYTES;
            }
          }
        } else {
          crypto.getRandomValues(bytes3);
        }
      }
      return bytes3;
    }
    module2.exports = randomBytes;
  }
});

// node_modules/libp2p-crypto/src/random-bytes.js
var require_random_bytes = __commonJS({
  "node_modules/libp2p-crypto/src/random-bytes.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var randomBytes = require_random_browser();
    var errcode7 = require_err_code();
    module2.exports = function(length4) {
      if (isNaN(length4) || length4 <= 0) {
        throw errcode7(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
      }
      return randomBytes(length4);
    };
  }
});

// node_modules/libp2p-crypto/src/util.js
var require_util2 = __commonJS({
  "node_modules/libp2p-crypto/src/util.js"(exports2) {
    init_node_globals();
    "use strict";
    require_util();
    require_jsbn();
    var forge = require_forge();
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
    exports2.bigIntegerToUintBase64url = (num, len) => {
      let buf2 = Uint8Array.from(num.abs().toByteArray());
      buf2 = buf2[0] === 0 ? buf2.slice(1) : buf2;
      if (len != null) {
        if (buf2.length > len)
          throw new Error("byte array longer than desired length");
        buf2 = uint8ArrayConcat([new Uint8Array(len - buf2.length), buf2]);
      }
      return uint8ArrayToString(buf2, "base64url");
    };
    exports2.base64urlToBigInteger = (str) => {
      const buf2 = exports2.base64urlToBuffer(str);
      return new forge.jsbn.BigInteger(uint8ArrayToString(buf2, "base16"), 16);
    };
    exports2.base64urlToBuffer = (str, len) => {
      let buf2 = uint8ArrayFromString(str, "base64urlpad");
      if (len != null) {
        if (buf2.length > len)
          throw new Error("byte array longer than desired length");
        buf2 = uint8ArrayConcat([new Uint8Array(len - buf2.length), buf2]);
      }
      return buf2;
    };
  }
});

// node_modules/libp2p-crypto/src/keys/rsa-utils.js
var require_rsa_utils = __commonJS({
  "node_modules/libp2p-crypto/src/keys/rsa-utils.js"(exports2) {
    init_node_globals();
    "use strict";
    require_asn1();
    require_rsa();
    var forge = require_forge();
    var { bigIntegerToUintBase64url, base64urlToBigInteger } = require_util2();
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    exports2.pkcs1ToJwk = function(bytes3) {
      const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes3, "ascii"));
      const privateKey = forge.pki.privateKeyFromAsn1(asn1);
      return {
        kty: "RSA",
        n: bigIntegerToUintBase64url(privateKey.n),
        e: bigIntegerToUintBase64url(privateKey.e),
        d: bigIntegerToUintBase64url(privateKey.d),
        p: bigIntegerToUintBase64url(privateKey.p),
        q: bigIntegerToUintBase64url(privateKey.q),
        dp: bigIntegerToUintBase64url(privateKey.dP),
        dq: bigIntegerToUintBase64url(privateKey.dQ),
        qi: bigIntegerToUintBase64url(privateKey.qInv),
        alg: "RS256",
        kid: "2011-04-29"
      };
    };
    exports2.jwkToPkcs1 = function(jwk) {
      const asn1 = forge.pki.privateKeyToAsn1({
        n: base64urlToBigInteger(jwk.n),
        e: base64urlToBigInteger(jwk.e),
        d: base64urlToBigInteger(jwk.d),
        p: base64urlToBigInteger(jwk.p),
        q: base64urlToBigInteger(jwk.q),
        dP: base64urlToBigInteger(jwk.dp),
        dQ: base64urlToBigInteger(jwk.dq),
        qInv: base64urlToBigInteger(jwk.qi)
      });
      return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), "ascii");
    };
    exports2.pkixToJwk = function(bytes3) {
      const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes3, "ascii"));
      const publicKey = forge.pki.publicKeyFromAsn1(asn1);
      return {
        kty: "RSA",
        n: bigIntegerToUintBase64url(publicKey.n),
        e: bigIntegerToUintBase64url(publicKey.e),
        alg: "RS256",
        kid: "2011-04-29"
      };
    };
    exports2.jwkToPkix = function(jwk) {
      const asn1 = forge.pki.publicKeyToAsn1({
        n: base64urlToBigInteger(jwk.n),
        e: base64urlToBigInteger(jwk.e)
      });
      return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), "ascii");
    };
  }
});

// node_modules/libp2p-crypto/src/keys/jwk2pem.js
var require_jwk2pem = __commonJS({
  "node_modules/libp2p-crypto/src/keys/jwk2pem.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    require_rsa();
    var forge = require_forge();
    var { base64urlToBigInteger } = require_util2();
    function convert(key, types2) {
      return types2.map((t) => base64urlToBigInteger(key[t]));
    }
    function jwk2priv(key) {
      return forge.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
    }
    function jwk2pub(key) {
      return forge.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
    }
    module2.exports = {
      jwk2pub,
      jwk2priv
    };
  }
});

// node_modules/libp2p-crypto/src/keys/rsa-browser.js
var require_rsa_browser = __commonJS({
  "node_modules/libp2p-crypto/src/keys/rsa-browser.js"(exports2) {
    init_node_globals();
    "use strict";
    var webcrypto = require_webcrypto();
    var randomBytes = require_random_bytes();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    exports2.utils = require_rsa_utils();
    exports2.generateKey = async function(bits) {
      const pair = await webcrypto.get().subtle.generateKey({
        name: "RSASSA-PKCS1-v1_5",
        modulusLength: bits,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: { name: "SHA-256" }
      }, true, ["sign", "verify"]);
      const keys = await exportKey(pair);
      return {
        privateKey: keys[0],
        publicKey: keys[1]
      };
    };
    exports2.unmarshalPrivateKey = async function(key) {
      const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, true, ["sign"]);
      const pair = [
        privateKey,
        await derivePublicFromPrivate(key)
      ];
      const keys = await exportKey({
        privateKey: pair[0],
        publicKey: pair[1]
      });
      return {
        privateKey: keys[0],
        publicKey: keys[1]
      };
    };
    exports2.getRandomValues = randomBytes;
    exports2.hashAndSign = async function(key, msg) {
      const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, false, ["sign"]);
      const sig = await webcrypto.get().subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, Uint8Array.from(msg));
      return new Uint8Array(sig, sig.byteOffset, sig.byteLength);
    };
    exports2.hashAndVerify = async function(key, sig, msg) {
      const publicKey = await webcrypto.get().subtle.importKey("jwk", key, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, false, ["verify"]);
      return webcrypto.get().subtle.verify({ name: "RSASSA-PKCS1-v1_5" }, publicKey, sig, msg);
    };
    function exportKey(pair) {
      return Promise.all([
        webcrypto.get().subtle.exportKey("jwk", pair.privateKey),
        webcrypto.get().subtle.exportKey("jwk", pair.publicKey)
      ]);
    }
    function derivePublicFromPrivate(jwKey) {
      return webcrypto.get().subtle.importKey("jwk", {
        kty: jwKey.kty,
        n: jwKey.n,
        e: jwKey.e
      }, {
        name: "RSASSA-PKCS1-v1_5",
        hash: { name: "SHA-256" }
      }, true, ["verify"]);
    }
    var { jwk2pub, jwk2priv } = require_jwk2pem();
    function convertKey(key, pub, msg, handle) {
      const fkey = pub ? jwk2pub(key) : jwk2priv(key);
      const fmsg = uint8ArrayToString(Uint8Array.from(msg), "ascii");
      const fomsg = handle(fmsg, fkey);
      return uint8ArrayFromString(fomsg, "ascii");
    }
    exports2.encrypt = function(key, msg) {
      return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
    };
    exports2.decrypt = function(key, msg) {
      return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
    };
  }
});

// node_modules/libp2p-crypto/src/keys/exporter.js
var require_exporter = __commonJS({
  "node_modules/libp2p-crypto/src/keys/exporter.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { base64: base642 } = (init_base64(), base64_exports);
    var ciphers = require_aes_gcm_browser();
    module2.exports = {
      export: async function(privateKey, password) {
        const cipher = ciphers.create();
        const encryptedKey = await cipher.encrypt(privateKey, password);
        return base642.encode(encryptedKey);
      }
    };
  }
});

// node_modules/libp2p-crypto/src/keys/rsa-class.js
var require_rsa_class = __commonJS({
  "node_modules/libp2p-crypto/src/keys/rsa-class.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
    var errcode7 = require_err_code();
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    require_sha512();
    require_ed25519();
    var forge = require_forge();
    var crypto3 = require_rsa_browser();
    var pbm = require_keys();
    var exporter2 = require_exporter();
    var RsaPublicKey = class {
      constructor(key) {
        this._key = key;
      }
      async verify(data, sig) {
        return crypto3.hashAndVerify(this._key, sig, data);
      }
      marshal() {
        return crypto3.utils.jwkToPkix(this._key);
      }
      get bytes() {
        return pbm.PublicKey.encode({
          Type: pbm.KeyType.RSA,
          Data: this.marshal()
        }).finish();
      }
      encrypt(bytes3) {
        return crypto3.encrypt(this._key, bytes3);
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes: bytes3 } = await sha2562.digest(this.bytes);
        return bytes3;
      }
    };
    var RsaPrivateKey = class {
      constructor(key, publicKey) {
        this._key = key;
        this._publicKey = publicKey;
      }
      genSecret() {
        return crypto3.getRandomValues(16);
      }
      async sign(message) {
        return crypto3.hashAndSign(this._key, message);
      }
      get public() {
        if (!this._publicKey) {
          throw errcode7(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
        }
        return new RsaPublicKey(this._publicKey);
      }
      decrypt(bytes3) {
        return crypto3.decrypt(this._key, bytes3);
      }
      marshal() {
        return crypto3.utils.jwkToPkcs1(this._key);
      }
      get bytes() {
        return pbm.PrivateKey.encode({
          Type: pbm.KeyType.RSA,
          Data: this.marshal()
        }).finish();
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes: bytes3 } = await sha2562.digest(this.bytes);
        return bytes3;
      }
      async id() {
        const hash2 = await this.public.hash();
        return uint8ArrayToString(hash2, "base58btc");
      }
      async export(password, format = "pkcs-8") {
        if (format === "pkcs-8") {
          const buffer2 = new forge.util.ByteBuffer(this.marshal());
          const asn1 = forge.asn1.fromDer(buffer2);
          const privateKey = forge.pki.privateKeyFromAsn1(asn1);
          const options = {
            algorithm: "aes256",
            count: 1e4,
            saltSize: 128 / 8,
            prfAlgorithm: "sha512"
          };
          return forge.pki.encryptRsaPrivateKey(privateKey, password, options);
        } else if (format === "libp2p-key") {
          return exporter2.export(this.bytes, password);
        } else {
          throw errcode7(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
        }
      }
    };
    async function unmarshalRsaPrivateKey(bytes3) {
      const jwk = crypto3.utils.pkcs1ToJwk(bytes3);
      const keys = await crypto3.unmarshalPrivateKey(jwk);
      return new RsaPrivateKey(keys.privateKey, keys.publicKey);
    }
    function unmarshalRsaPublicKey(bytes3) {
      const jwk = crypto3.utils.pkixToJwk(bytes3);
      return new RsaPublicKey(jwk);
    }
    async function fromJwk(jwk) {
      const keys = await crypto3.unmarshalPrivateKey(jwk);
      return new RsaPrivateKey(keys.privateKey, keys.publicKey);
    }
    async function generateKeyPair(bits) {
      const keys = await crypto3.generateKey(bits);
      return new RsaPrivateKey(keys.privateKey, keys.publicKey);
    }
    module2.exports = {
      RsaPublicKey,
      RsaPrivateKey,
      unmarshalRsaPublicKey,
      unmarshalRsaPrivateKey,
      generateKeyPair,
      fromJwk
    };
  }
});

// node_modules/libp2p-crypto/src/keys/ed25519.js
var require_ed255192 = __commonJS({
  "node_modules/libp2p-crypto/src/keys/ed25519.js"(exports2) {
    init_node_globals();
    "use strict";
    require_ed25519();
    var forge = require_forge();
    exports2.publicKeyLength = forge.pki.ed25519.constants.PUBLIC_KEY_BYTE_LENGTH;
    exports2.privateKeyLength = forge.pki.ed25519.constants.PRIVATE_KEY_BYTE_LENGTH;
    exports2.generateKey = async function() {
      return forge.pki.ed25519.generateKeyPair();
    };
    exports2.generateKeyFromSeed = async function(seed) {
      return forge.pki.ed25519.generateKeyPair({ seed });
    };
    exports2.hashAndSign = async function(key, msg) {
      return forge.pki.ed25519.sign({ message: msg, privateKey: key });
    };
    exports2.hashAndVerify = async function(key, sig, msg) {
      return forge.pki.ed25519.verify({ signature: sig, message: msg, publicKey: key });
    };
  }
});

// node_modules/libp2p-crypto/src/keys/ed25519-class.js
var require_ed25519_class = __commonJS({
  "node_modules/libp2p-crypto/src/keys/ed25519-class.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
    var { base58btc: base58btc2 } = (init_base58(), base58_exports);
    var { identity: identity3 } = (init_identity(), identity_exports);
    var crypto3 = require_ed255192();
    var pbm = require_keys();
    var exporter2 = require_exporter();
    var Ed25519PublicKey = class {
      constructor(key) {
        this._key = ensureKey(key, crypto3.publicKeyLength);
      }
      async verify(data, sig) {
        return crypto3.hashAndVerify(this._key, sig, data);
      }
      marshal() {
        return this._key;
      }
      get bytes() {
        return pbm.PublicKey.encode({
          Type: pbm.KeyType.Ed25519,
          Data: this.marshal()
        }).finish();
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes: bytes3 } = await sha2562.digest(this.bytes);
        return bytes3;
      }
    };
    var Ed25519PrivateKey = class {
      constructor(key, publicKey) {
        this._key = ensureKey(key, crypto3.privateKeyLength);
        this._publicKey = ensureKey(publicKey, crypto3.publicKeyLength);
      }
      async sign(message) {
        return crypto3.hashAndSign(this._key, message);
      }
      get public() {
        return new Ed25519PublicKey(this._publicKey);
      }
      marshal() {
        return this._key;
      }
      get bytes() {
        return pbm.PrivateKey.encode({
          Type: pbm.KeyType.Ed25519,
          Data: this.marshal()
        }).finish();
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      async hash() {
        const { bytes: bytes3 } = await sha2562.digest(this.bytes);
        return bytes3;
      }
      async id() {
        const encoding = await identity3.digest(this.public.bytes);
        return base58btc2.encode(encoding.bytes).substring(1);
      }
      async export(password, format = "libp2p-key") {
        if (format === "libp2p-key") {
          return exporter2.export(this.bytes, password);
        } else {
          throw errcode7(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
        }
      }
    };
    function unmarshalEd25519PrivateKey(bytes3) {
      if (bytes3.length > crypto3.privateKeyLength) {
        bytes3 = ensureKey(bytes3, crypto3.privateKeyLength + crypto3.publicKeyLength);
        const privateKeyBytes2 = bytes3.slice(0, crypto3.privateKeyLength);
        const publicKeyBytes2 = bytes3.slice(crypto3.privateKeyLength, bytes3.length);
        return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
      }
      bytes3 = ensureKey(bytes3, crypto3.privateKeyLength);
      const privateKeyBytes = bytes3.slice(0, crypto3.privateKeyLength);
      const publicKeyBytes = bytes3.slice(crypto3.publicKeyLength);
      return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
    }
    function unmarshalEd25519PublicKey(bytes3) {
      bytes3 = ensureKey(bytes3, crypto3.publicKeyLength);
      return new Ed25519PublicKey(bytes3);
    }
    async function generateKeyPair() {
      const { privateKey, publicKey } = await crypto3.generateKey();
      return new Ed25519PrivateKey(privateKey, publicKey);
    }
    async function generateKeyPairFromSeed(seed) {
      const { privateKey, publicKey } = await crypto3.generateKeyFromSeed(seed);
      return new Ed25519PrivateKey(privateKey, publicKey);
    }
    function ensureKey(key, length4) {
      key = Uint8Array.from(key || []);
      if (key.length !== length4) {
        throw errcode7(new Error(`Key must be a Uint8Array of length ${length4}, got ${key.length}`), "ERR_INVALID_KEY_TYPE");
      }
      return key;
    }
    module2.exports = {
      Ed25519PublicKey,
      Ed25519PrivateKey,
      unmarshalEd25519PrivateKey,
      unmarshalEd25519PublicKey,
      generateKeyPair,
      generateKeyPairFromSeed
    };
  }
});

// node_modules/secp256k1/lib/index.js
var require_lib = __commonJS({
  "node_modules/secp256k1/lib/index.js"(exports2, module2) {
    init_node_globals();
    var errors2 = {
      IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
      TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
      TWEAK_MUL: "The tweak was out of range or equal to zero",
      CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
      SECKEY_INVALID: "Private Key is invalid",
      PUBKEY_PARSE: "Public Key could not be parsed",
      PUBKEY_SERIALIZE: "Public Key serialization error",
      PUBKEY_COMBINE: "The sum of the public keys is not valid",
      SIG_PARSE: "Signature could not be parsed",
      SIGN: "The nonce generation function failed, or the private key was invalid",
      RECOVER: "Public key could not be recover",
      ECDH: "Scalar was invalid (zero or overflow)"
    };
    function assert(cond, msg) {
      if (!cond)
        throw new Error(msg);
    }
    function isUint8Array(name5, value, length4) {
      assert(value instanceof Uint8Array, `Expected ${name5} to be an Uint8Array`);
      if (length4 !== void 0) {
        if (Array.isArray(length4)) {
          const numbers = length4.join(", ");
          const msg = `Expected ${name5} to be an Uint8Array with length [${numbers}]`;
          assert(length4.includes(value.length), msg);
        } else {
          const msg = `Expected ${name5} to be an Uint8Array with length ${length4}`;
          assert(value.length === length4, msg);
        }
      }
    }
    function isCompressed(value) {
      assert(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
    }
    function getAssertedOutput(output = (len) => new Uint8Array(len), length4) {
      if (typeof output === "function")
        output = output(length4);
      isUint8Array("output", output, length4);
      return output;
    }
    function toTypeString(value) {
      return Object.prototype.toString.call(value).slice(8, -1);
    }
    module2.exports = (secp256k1) => {
      return {
        contextRandomize(seed) {
          assert(seed === null || seed instanceof Uint8Array, "Expected seed to be an Uint8Array or null");
          if (seed !== null)
            isUint8Array("seed", seed, 32);
          switch (secp256k1.contextRandomize(seed)) {
            case 1:
              throw new Error(errors2.CONTEXT_RANDOMIZE_UNKNOW);
          }
        },
        privateKeyVerify(seckey) {
          isUint8Array("private key", seckey, 32);
          return secp256k1.privateKeyVerify(seckey) === 0;
        },
        privateKeyNegate(seckey) {
          isUint8Array("private key", seckey, 32);
          switch (secp256k1.privateKeyNegate(seckey)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        privateKeyTweakAdd(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors2.TWEAK_ADD);
          }
        },
        privateKeyTweakMul(seckey, tweak) {
          isUint8Array("private key", seckey, 32);
          isUint8Array("tweak", tweak, 32);
          switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
            case 0:
              return seckey;
            case 1:
              throw new Error(errors2.TWEAK_MUL);
          }
        },
        publicKeyVerify(pubkey) {
          isUint8Array("public key", pubkey, [33, 65]);
          return secp256k1.publicKeyVerify(pubkey) === 0;
        },
        publicKeyCreate(seckey, compressed = true, output) {
          isUint8Array("private key", seckey, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCreate(output, seckey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.SECKEY_INVALID);
            case 2:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyConvert(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyConvert(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyNegate(pubkey, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyNegate(output, pubkey)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
            case 3:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyCombine(pubkeys, compressed = true, output) {
          assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
          assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
          for (const pubkey of pubkeys) {
            isUint8Array("public key", pubkey, [33, 65]);
          }
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyCombine(output, pubkeys)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.PUBKEY_COMBINE);
            case 3:
              throw new Error(errors2.PUBKEY_SERIALIZE);
          }
        },
        publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.TWEAK_ADD);
          }
        },
        publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("tweak", tweak, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.TWEAK_MUL);
          }
        },
        signatureNormalize(sig) {
          isUint8Array("signature", sig, 64);
          switch (secp256k1.signatureNormalize(sig)) {
            case 0:
              return sig;
            case 1:
              throw new Error(errors2.SIG_PARSE);
          }
        },
        signatureExport(sig, output) {
          isUint8Array("signature", sig, 64);
          output = getAssertedOutput(output, 72);
          const obj = { output, outputlen: 72 };
          switch (secp256k1.signatureExport(obj, sig)) {
            case 0:
              return output.slice(0, obj.outputlen);
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        signatureImport(sig, output) {
          isUint8Array("signature", sig);
          output = getAssertedOutput(output, 64);
          switch (secp256k1.signatureImport(output, sig)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        ecdsaSign(msg32, seckey, options = {}, output) {
          isUint8Array("message", msg32, 32);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.noncefn !== void 0)
            assert(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
          output = getAssertedOutput(output, 64);
          const obj = { signature: output, recid: null };
          switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
            case 0:
              return obj;
            case 1:
              throw new Error(errors2.SIGN);
            case 2:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        ecdsaVerify(sig, msg32, pubkey) {
          isUint8Array("signature", sig, 64);
          isUint8Array("message", msg32, 32);
          isUint8Array("public key", pubkey, [33, 65]);
          switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
            case 0:
              return true;
            case 3:
              return false;
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.PUBKEY_PARSE);
          }
        },
        ecdsaRecover(sig, recid, msg32, compressed = true, output) {
          isUint8Array("signature", sig, 64);
          assert(toTypeString(recid) === "Number" && recid >= 0 && recid <= 3, "Expected recovery id to be a Number within interval [0, 3]");
          isUint8Array("message", msg32, 32);
          isCompressed(compressed);
          output = getAssertedOutput(output, compressed ? 33 : 65);
          switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.SIG_PARSE);
            case 2:
              throw new Error(errors2.RECOVER);
            case 3:
              throw new Error(errors2.IMPOSSIBLE_CASE);
          }
        },
        ecdh(pubkey, seckey, options = {}, output) {
          isUint8Array("public key", pubkey, [33, 65]);
          isUint8Array("private key", seckey, 32);
          assert(toTypeString(options) === "Object", "Expected options to be an Object");
          if (options.data !== void 0)
            isUint8Array("options.data", options.data);
          if (options.hashfn !== void 0) {
            assert(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
            if (options.xbuf !== void 0)
              isUint8Array("options.xbuf", options.xbuf, 32);
            if (options.ybuf !== void 0)
              isUint8Array("options.ybuf", options.ybuf, 32);
            isUint8Array("output", output);
          } else {
            output = getAssertedOutput(output, 32);
          }
          switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
            case 0:
              return output;
            case 1:
              throw new Error(errors2.PUBKEY_PARSE);
            case 2:
              throw new Error(errors2.ECDH);
          }
        }
      };
    };
  }
});

// node_modules/elliptic/package.json
var require_package = __commonJS({
  "node_modules/elliptic/package.json"(exports2, module2) {
    module2.exports = {
      name: "elliptic",
      version: "6.5.4",
      description: "EC cryptography",
      main: "lib/elliptic.js",
      files: [
        "lib"
      ],
      scripts: {
        lint: "eslint lib test",
        "lint:fix": "npm run lint -- --fix",
        unit: "istanbul test _mocha --reporter=spec test/index.js",
        test: "npm run lint && npm run unit",
        version: "grunt dist && git add dist/"
      },
      repository: {
        type: "git",
        url: "git@github.com:indutny/elliptic"
      },
      keywords: [
        "EC",
        "Elliptic",
        "curve",
        "Cryptography"
      ],
      author: "Fedor Indutny <fedor@indutny.com>",
      license: "MIT",
      bugs: {
        url: "https://github.com/indutny/elliptic/issues"
      },
      homepage: "https://github.com/indutny/elliptic",
      devDependencies: {
        brfs: "^2.0.2",
        coveralls: "^3.1.0",
        eslint: "^7.6.0",
        grunt: "^1.2.1",
        "grunt-browserify": "^5.3.0",
        "grunt-cli": "^1.3.2",
        "grunt-contrib-connect": "^3.0.0",
        "grunt-contrib-copy": "^1.0.0",
        "grunt-contrib-uglify": "^5.0.0",
        "grunt-mocha-istanbul": "^5.0.2",
        "grunt-saucelabs": "^9.0.1",
        istanbul: "^0.4.5",
        mocha: "^8.0.1"
      },
      dependencies: {
        "bn.js": "^4.11.9",
        brorand: "^1.1.0",
        "hash.js": "^1.0.0",
        "hmac-drbg": "^1.0.1",
        inherits: "^2.0.4",
        "minimalistic-assert": "^1.0.1",
        "minimalistic-crypto-utils": "^1.0.1"
      }
    };
  }
});

// (disabled):node_modules/buffer/index.js
var require_buffer2 = __commonJS({
  "(disabled):node_modules/buffer/index.js"() {
    init_node_globals();
  }
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS({
  "node_modules/bn.js/lib/bn.js"(exports2, module2) {
    init_node_globals();
    (function(module3, exports3) {
      "use strict";
      function assert(val, msg) {
        if (!val)
          throw new Error(msg || "Assertion failed");
      }
      function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
      function BN(number, base3, endian) {
        if (BN.isBN(number)) {
          return number;
        }
        this.negative = 0;
        this.words = null;
        this.length = 0;
        this.red = null;
        if (number !== null) {
          if (base3 === "le" || base3 === "be") {
            endian = base3;
            base3 = 10;
          }
          this._init(number || 0, base3 || 10, endian || "be");
        }
      }
      if (typeof module3 === "object") {
        module3.exports = BN;
      } else {
        exports3.BN = BN;
      }
      BN.BN = BN;
      BN.wordSize = 26;
      var Buffer2;
      try {
        if (typeof window !== "undefined" && typeof window.Buffer !== "undefined") {
          Buffer2 = window.Buffer;
        } else {
          Buffer2 = require_buffer2().Buffer;
        }
      } catch (e) {
      }
      BN.isBN = function isBN(num) {
        if (num instanceof BN) {
          return true;
        }
        return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
      };
      BN.max = function max(left, right) {
        if (left.cmp(right) > 0)
          return left;
        return right;
      };
      BN.min = function min(left, right) {
        if (left.cmp(right) < 0)
          return left;
        return right;
      };
      BN.prototype._init = function init(number, base3, endian) {
        if (typeof number === "number") {
          return this._initNumber(number, base3, endian);
        }
        if (typeof number === "object") {
          return this._initArray(number, base3, endian);
        }
        if (base3 === "hex") {
          base3 = 16;
        }
        assert(base3 === (base3 | 0) && base3 >= 2 && base3 <= 36);
        number = number.toString().replace(/\s+/g, "");
        var start = 0;
        if (number[0] === "-") {
          start++;
          this.negative = 1;
        }
        if (start < number.length) {
          if (base3 === 16) {
            this._parseHex(number, start, endian);
          } else {
            this._parseBase(number, base3, start);
            if (endian === "le") {
              this._initArray(this.toArray(), base3, endian);
            }
          }
        }
      };
      BN.prototype._initNumber = function _initNumber(number, base3, endian) {
        if (number < 0) {
          this.negative = 1;
          number = -number;
        }
        if (number < 67108864) {
          this.words = [number & 67108863];
          this.length = 1;
        } else if (number < 4503599627370496) {
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863
          ];
          this.length = 2;
        } else {
          assert(number < 9007199254740992);
          this.words = [
            number & 67108863,
            number / 67108864 & 67108863,
            1
          ];
          this.length = 3;
        }
        if (endian !== "le")
          return;
        this._initArray(this.toArray(), base3, endian);
      };
      BN.prototype._initArray = function _initArray(number, base3, endian) {
        assert(typeof number.length === "number");
        if (number.length <= 0) {
          this.words = [0];
          this.length = 1;
          return this;
        }
        this.length = Math.ceil(number.length / 3);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var j, w;
        var off = 0;
        if (endian === "be") {
          for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
            w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        } else if (endian === "le") {
          for (i = 0, j = 0; i < number.length; i += 3) {
            w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
            this.words[j] |= w << off & 67108863;
            this.words[j + 1] = w >>> 26 - off & 67108863;
            off += 24;
            if (off >= 26) {
              off -= 26;
              j++;
            }
          }
        }
        return this.strip();
      };
      function parseHex4Bits(string3, index) {
        var c = string3.charCodeAt(index);
        if (c >= 65 && c <= 70) {
          return c - 55;
        } else if (c >= 97 && c <= 102) {
          return c - 87;
        } else {
          return c - 48 & 15;
        }
      }
      function parseHexByte(string3, lowerBound, index) {
        var r = parseHex4Bits(string3, index);
        if (index - 1 >= lowerBound) {
          r |= parseHex4Bits(string3, index - 1) << 4;
        }
        return r;
      }
      BN.prototype._parseHex = function _parseHex(number, start, endian) {
        this.length = Math.ceil((number.length - start) / 6);
        this.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          this.words[i] = 0;
        }
        var off = 0;
        var j = 0;
        var w;
        if (endian === "be") {
          for (i = number.length - 1; i >= start; i -= 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        } else {
          var parseLength = number.length - start;
          for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
            w = parseHexByte(number, start, i) << off;
            this.words[j] |= w & 67108863;
            if (off >= 18) {
              off -= 18;
              j += 1;
              this.words[j] |= w >>> 26;
            } else {
              off += 8;
            }
          }
        }
        this.strip();
      };
      function parseBase(str, start, end, mul) {
        var r = 0;
        var len = Math.min(str.length, end);
        for (var i = start; i < len; i++) {
          var c = str.charCodeAt(i) - 48;
          r *= mul;
          if (c >= 49) {
            r += c - 49 + 10;
          } else if (c >= 17) {
            r += c - 17 + 10;
          } else {
            r += c;
          }
        }
        return r;
      }
      BN.prototype._parseBase = function _parseBase(number, base3, start) {
        this.words = [0];
        this.length = 1;
        for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base3) {
          limbLen++;
        }
        limbLen--;
        limbPow = limbPow / base3 | 0;
        var total = number.length - start;
        var mod2 = total % limbLen;
        var end = Math.min(total, total - mod2) + start;
        var word = 0;
        for (var i = start; i < end; i += limbLen) {
          word = parseBase(number, i, i + limbLen, base3);
          this.imuln(limbPow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        if (mod2 !== 0) {
          var pow = 1;
          word = parseBase(number, i, number.length, base3);
          for (i = 0; i < mod2; i++) {
            pow *= base3;
          }
          this.imuln(pow);
          if (this.words[0] + word < 67108864) {
            this.words[0] += word;
          } else {
            this._iaddn(word);
          }
        }
        this.strip();
      };
      BN.prototype.copy = function copy(dest) {
        dest.words = new Array(this.length);
        for (var i = 0; i < this.length; i++) {
          dest.words[i] = this.words[i];
        }
        dest.length = this.length;
        dest.negative = this.negative;
        dest.red = this.red;
      };
      BN.prototype.clone = function clone() {
        var r = new BN(null);
        this.copy(r);
        return r;
      };
      BN.prototype._expand = function _expand(size) {
        while (this.length < size) {
          this.words[this.length++] = 0;
        }
        return this;
      };
      BN.prototype.strip = function strip() {
        while (this.length > 1 && this.words[this.length - 1] === 0) {
          this.length--;
        }
        return this._normSign();
      };
      BN.prototype._normSign = function _normSign() {
        if (this.length === 1 && this.words[0] === 0) {
          this.negative = 0;
        }
        return this;
      };
      BN.prototype.inspect = function inspect() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var zeros = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ];
      var groupSizes = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ];
      var groupBases = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      BN.prototype.toString = function toString4(base3, padding) {
        base3 = base3 || 10;
        padding = padding | 0 || 1;
        var out;
        if (base3 === 16 || base3 === "hex") {
          out = "";
          var off = 0;
          var carry = 0;
          for (var i = 0; i < this.length; i++) {
            var w = this.words[i];
            var word = ((w << off | carry) & 16777215).toString(16);
            carry = w >>> 24 - off & 16777215;
            if (carry !== 0 || i !== this.length - 1) {
              out = zeros[6 - word.length] + word + out;
            } else {
              out = word + out;
            }
            off += 2;
            if (off >= 26) {
              off -= 26;
              i--;
            }
          }
          if (carry !== 0) {
            out = carry.toString(16) + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        if (base3 === (base3 | 0) && base3 >= 2 && base3 <= 36) {
          var groupSize = groupSizes[base3];
          var groupBase = groupBases[base3];
          out = "";
          var c = this.clone();
          c.negative = 0;
          while (!c.isZero()) {
            var r = c.modn(groupBase).toString(base3);
            c = c.idivn(groupBase);
            if (!c.isZero()) {
              out = zeros[groupSize - r.length] + r + out;
            } else {
              out = r + out;
            }
          }
          if (this.isZero()) {
            out = "0" + out;
          }
          while (out.length % padding !== 0) {
            out = "0" + out;
          }
          if (this.negative !== 0) {
            out = "-" + out;
          }
          return out;
        }
        assert(false, "Base should be between 2 and 36");
      };
      BN.prototype.toNumber = function toNumber() {
        var ret = this.words[0];
        if (this.length === 2) {
          ret += this.words[1] * 67108864;
        } else if (this.length === 3 && this.words[2] === 1) {
          ret += 4503599627370496 + this.words[1] * 67108864;
        } else if (this.length > 2) {
          assert(false, "Number can only safely store up to 53 bits");
        }
        return this.negative !== 0 ? -ret : ret;
      };
      BN.prototype.toJSON = function toJSON() {
        return this.toString(16);
      };
      BN.prototype.toBuffer = function toBuffer(endian, length4) {
        assert(typeof Buffer2 !== "undefined");
        return this.toArrayLike(Buffer2, endian, length4);
      };
      BN.prototype.toArray = function toArray(endian, length4) {
        return this.toArrayLike(Array, endian, length4);
      };
      BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length4) {
        var byteLength = this.byteLength();
        var reqLength = length4 || Math.max(1, byteLength);
        assert(byteLength <= reqLength, "byte array longer than desired length");
        assert(reqLength > 0, "Requested array length <= 0");
        this.strip();
        var littleEndian = endian === "le";
        var res = new ArrayType(reqLength);
        var b, i;
        var q = this.clone();
        if (!littleEndian) {
          for (i = 0; i < reqLength - byteLength; i++) {
            res[i] = 0;
          }
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[reqLength - i - 1] = b;
          }
        } else {
          for (i = 0; !q.isZero(); i++) {
            b = q.andln(255);
            q.iushrn(8);
            res[i] = b;
          }
          for (; i < reqLength; i++) {
            res[i] = 0;
          }
        }
        return res;
      };
      if (Math.clz32) {
        BN.prototype._countBits = function _countBits(w) {
          return 32 - Math.clz32(w);
        };
      } else {
        BN.prototype._countBits = function _countBits(w) {
          var t = w;
          var r = 0;
          if (t >= 4096) {
            r += 13;
            t >>>= 13;
          }
          if (t >= 64) {
            r += 7;
            t >>>= 7;
          }
          if (t >= 8) {
            r += 4;
            t >>>= 4;
          }
          if (t >= 2) {
            r += 2;
            t >>>= 2;
          }
          return r + t;
        };
      }
      BN.prototype._zeroBits = function _zeroBits(w) {
        if (w === 0)
          return 26;
        var t = w;
        var r = 0;
        if ((t & 8191) === 0) {
          r += 13;
          t >>>= 13;
        }
        if ((t & 127) === 0) {
          r += 7;
          t >>>= 7;
        }
        if ((t & 15) === 0) {
          r += 4;
          t >>>= 4;
        }
        if ((t & 3) === 0) {
          r += 2;
          t >>>= 2;
        }
        if ((t & 1) === 0) {
          r++;
        }
        return r;
      };
      BN.prototype.bitLength = function bitLength() {
        var w = this.words[this.length - 1];
        var hi = this._countBits(w);
        return (this.length - 1) * 26 + hi;
      };
      function toBitArray(num) {
        var w = new Array(num.bitLength());
        for (var bit = 0; bit < w.length; bit++) {
          var off = bit / 26 | 0;
          var wbit = bit % 26;
          w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
        }
        return w;
      }
      BN.prototype.zeroBits = function zeroBits() {
        if (this.isZero())
          return 0;
        var r = 0;
        for (var i = 0; i < this.length; i++) {
          var b = this._zeroBits(this.words[i]);
          r += b;
          if (b !== 26)
            break;
        }
        return r;
      };
      BN.prototype.byteLength = function byteLength() {
        return Math.ceil(this.bitLength() / 8);
      };
      BN.prototype.toTwos = function toTwos(width) {
        if (this.negative !== 0) {
          return this.abs().inotn(width).iaddn(1);
        }
        return this.clone();
      };
      BN.prototype.fromTwos = function fromTwos(width) {
        if (this.testn(width - 1)) {
          return this.notn(width).iaddn(1).ineg();
        }
        return this.clone();
      };
      BN.prototype.isNeg = function isNeg() {
        return this.negative !== 0;
      };
      BN.prototype.neg = function neg() {
        return this.clone().ineg();
      };
      BN.prototype.ineg = function ineg() {
        if (!this.isZero()) {
          this.negative ^= 1;
        }
        return this;
      };
      BN.prototype.iuor = function iuor(num) {
        while (this.length < num.length) {
          this.words[this.length++] = 0;
        }
        for (var i = 0; i < num.length; i++) {
          this.words[i] = this.words[i] | num.words[i];
        }
        return this.strip();
      };
      BN.prototype.ior = function ior(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuor(num);
      };
      BN.prototype.or = function or(num) {
        if (this.length > num.length)
          return this.clone().ior(num);
        return num.clone().ior(this);
      };
      BN.prototype.uor = function uor(num) {
        if (this.length > num.length)
          return this.clone().iuor(num);
        return num.clone().iuor(this);
      };
      BN.prototype.iuand = function iuand(num) {
        var b;
        if (this.length > num.length) {
          b = num;
        } else {
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = this.words[i] & num.words[i];
        }
        this.length = b.length;
        return this.strip();
      };
      BN.prototype.iand = function iand(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuand(num);
      };
      BN.prototype.and = function and(num) {
        if (this.length > num.length)
          return this.clone().iand(num);
        return num.clone().iand(this);
      };
      BN.prototype.uand = function uand(num) {
        if (this.length > num.length)
          return this.clone().iuand(num);
        return num.clone().iuand(this);
      };
      BN.prototype.iuxor = function iuxor(num) {
        var a;
        var b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        for (var i = 0; i < b.length; i++) {
          this.words[i] = a.words[i] ^ b.words[i];
        }
        if (this !== a) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = a.length;
        return this.strip();
      };
      BN.prototype.ixor = function ixor(num) {
        assert((this.negative | num.negative) === 0);
        return this.iuxor(num);
      };
      BN.prototype.xor = function xor2(num) {
        if (this.length > num.length)
          return this.clone().ixor(num);
        return num.clone().ixor(this);
      };
      BN.prototype.uxor = function uxor(num) {
        if (this.length > num.length)
          return this.clone().iuxor(num);
        return num.clone().iuxor(this);
      };
      BN.prototype.inotn = function inotn(width) {
        assert(typeof width === "number" && width >= 0);
        var bytesNeeded = Math.ceil(width / 26) | 0;
        var bitsLeft = width % 26;
        this._expand(bytesNeeded);
        if (bitsLeft > 0) {
          bytesNeeded--;
        }
        for (var i = 0; i < bytesNeeded; i++) {
          this.words[i] = ~this.words[i] & 67108863;
        }
        if (bitsLeft > 0) {
          this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
        }
        return this.strip();
      };
      BN.prototype.notn = function notn(width) {
        return this.clone().inotn(width);
      };
      BN.prototype.setn = function setn(bit, val) {
        assert(typeof bit === "number" && bit >= 0);
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        this._expand(off + 1);
        if (val) {
          this.words[off] = this.words[off] | 1 << wbit;
        } else {
          this.words[off] = this.words[off] & ~(1 << wbit);
        }
        return this.strip();
      };
      BN.prototype.iadd = function iadd(num) {
        var r;
        if (this.negative !== 0 && num.negative === 0) {
          this.negative = 0;
          r = this.isub(num);
          this.negative ^= 1;
          return this._normSign();
        } else if (this.negative === 0 && num.negative !== 0) {
          num.negative = 0;
          r = this.isub(num);
          num.negative = 1;
          return r._normSign();
        }
        var a, b;
        if (this.length > num.length) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          this.words[i] = r & 67108863;
          carry = r >>> 26;
        }
        this.length = a.length;
        if (carry !== 0) {
          this.words[this.length] = carry;
          this.length++;
        } else if (a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        return this;
      };
      BN.prototype.add = function add(num) {
        var res;
        if (num.negative !== 0 && this.negative === 0) {
          num.negative = 0;
          res = this.sub(num);
          num.negative ^= 1;
          return res;
        } else if (num.negative === 0 && this.negative !== 0) {
          this.negative = 0;
          res = num.sub(this);
          this.negative = 1;
          return res;
        }
        if (this.length > num.length)
          return this.clone().iadd(num);
        return num.clone().iadd(this);
      };
      BN.prototype.isub = function isub(num) {
        if (num.negative !== 0) {
          num.negative = 0;
          var r = this.iadd(num);
          num.negative = 1;
          return r._normSign();
        } else if (this.negative !== 0) {
          this.negative = 0;
          this.iadd(num);
          this.negative = 1;
          return this._normSign();
        }
        var cmp = this.cmp(num);
        if (cmp === 0) {
          this.negative = 0;
          this.length = 1;
          this.words[0] = 0;
          return this;
        }
        var a, b;
        if (cmp > 0) {
          a = this;
          b = num;
        } else {
          a = num;
          b = this;
        }
        var carry = 0;
        for (var i = 0; i < b.length; i++) {
          r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        for (; carry !== 0 && i < a.length; i++) {
          r = (a.words[i] | 0) + carry;
          carry = r >> 26;
          this.words[i] = r & 67108863;
        }
        if (carry === 0 && i < a.length && a !== this) {
          for (; i < a.length; i++) {
            this.words[i] = a.words[i];
          }
        }
        this.length = Math.max(this.length, i);
        if (a !== this) {
          this.negative = 1;
        }
        return this.strip();
      };
      BN.prototype.sub = function sub(num) {
        return this.clone().isub(num);
      };
      function smallMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        var len = self2.length + num.length | 0;
        out.length = len;
        len = len - 1 | 0;
        var a = self2.words[0] | 0;
        var b = num.words[0] | 0;
        var r = a * b;
        var lo = r & 67108863;
        var carry = r / 67108864 | 0;
        out.words[0] = lo;
        for (var k = 1; k < len; k++) {
          var ncarry = carry >>> 26;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j | 0;
            a = self2.words[i] | 0;
            b = num.words[j] | 0;
            r = a * b + rword;
            ncarry += r / 67108864 | 0;
            rword = r & 67108863;
          }
          out.words[k] = rword | 0;
          carry = ncarry | 0;
        }
        if (carry !== 0) {
          out.words[k] = carry | 0;
        } else {
          out.length--;
        }
        return out.strip();
      }
      var comb10MulTo = function comb10MulTo2(self2, num, out) {
        var a = self2.words;
        var b = num.words;
        var o = out.words;
        var c = 0;
        var lo;
        var mid;
        var hi;
        var a0 = a[0] | 0;
        var al0 = a0 & 8191;
        var ah0 = a0 >>> 13;
        var a1 = a[1] | 0;
        var al1 = a1 & 8191;
        var ah1 = a1 >>> 13;
        var a2 = a[2] | 0;
        var al2 = a2 & 8191;
        var ah2 = a2 >>> 13;
        var a3 = a[3] | 0;
        var al3 = a3 & 8191;
        var ah3 = a3 >>> 13;
        var a4 = a[4] | 0;
        var al4 = a4 & 8191;
        var ah4 = a4 >>> 13;
        var a5 = a[5] | 0;
        var al5 = a5 & 8191;
        var ah5 = a5 >>> 13;
        var a6 = a[6] | 0;
        var al6 = a6 & 8191;
        var ah6 = a6 >>> 13;
        var a7 = a[7] | 0;
        var al7 = a7 & 8191;
        var ah7 = a7 >>> 13;
        var a8 = a[8] | 0;
        var al8 = a8 & 8191;
        var ah8 = a8 >>> 13;
        var a9 = a[9] | 0;
        var al9 = a9 & 8191;
        var ah9 = a9 >>> 13;
        var b0 = b[0] | 0;
        var bl0 = b0 & 8191;
        var bh0 = b0 >>> 13;
        var b1 = b[1] | 0;
        var bl1 = b1 & 8191;
        var bh1 = b1 >>> 13;
        var b2 = b[2] | 0;
        var bl2 = b2 & 8191;
        var bh2 = b2 >>> 13;
        var b3 = b[3] | 0;
        var bl3 = b3 & 8191;
        var bh3 = b3 >>> 13;
        var b4 = b[4] | 0;
        var bl4 = b4 & 8191;
        var bh4 = b4 >>> 13;
        var b5 = b[5] | 0;
        var bl5 = b5 & 8191;
        var bh5 = b5 >>> 13;
        var b6 = b[6] | 0;
        var bl6 = b6 & 8191;
        var bh6 = b6 >>> 13;
        var b7 = b[7] | 0;
        var bl7 = b7 & 8191;
        var bh7 = b7 >>> 13;
        var b8 = b[8] | 0;
        var bl8 = b8 & 8191;
        var bh8 = b8 >>> 13;
        var b9 = b[9] | 0;
        var bl9 = b9 & 8191;
        var bh9 = b9 >>> 13;
        out.negative = self2.negative ^ num.negative;
        out.length = 19;
        lo = Math.imul(al0, bl0);
        mid = Math.imul(al0, bh0);
        mid = mid + Math.imul(ah0, bl0) | 0;
        hi = Math.imul(ah0, bh0);
        var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
        w0 &= 67108863;
        lo = Math.imul(al1, bl0);
        mid = Math.imul(al1, bh0);
        mid = mid + Math.imul(ah1, bl0) | 0;
        hi = Math.imul(ah1, bh0);
        lo = lo + Math.imul(al0, bl1) | 0;
        mid = mid + Math.imul(al0, bh1) | 0;
        mid = mid + Math.imul(ah0, bl1) | 0;
        hi = hi + Math.imul(ah0, bh1) | 0;
        var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
        w1 &= 67108863;
        lo = Math.imul(al2, bl0);
        mid = Math.imul(al2, bh0);
        mid = mid + Math.imul(ah2, bl0) | 0;
        hi = Math.imul(ah2, bh0);
        lo = lo + Math.imul(al1, bl1) | 0;
        mid = mid + Math.imul(al1, bh1) | 0;
        mid = mid + Math.imul(ah1, bl1) | 0;
        hi = hi + Math.imul(ah1, bh1) | 0;
        lo = lo + Math.imul(al0, bl2) | 0;
        mid = mid + Math.imul(al0, bh2) | 0;
        mid = mid + Math.imul(ah0, bl2) | 0;
        hi = hi + Math.imul(ah0, bh2) | 0;
        var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
        w2 &= 67108863;
        lo = Math.imul(al3, bl0);
        mid = Math.imul(al3, bh0);
        mid = mid + Math.imul(ah3, bl0) | 0;
        hi = Math.imul(ah3, bh0);
        lo = lo + Math.imul(al2, bl1) | 0;
        mid = mid + Math.imul(al2, bh1) | 0;
        mid = mid + Math.imul(ah2, bl1) | 0;
        hi = hi + Math.imul(ah2, bh1) | 0;
        lo = lo + Math.imul(al1, bl2) | 0;
        mid = mid + Math.imul(al1, bh2) | 0;
        mid = mid + Math.imul(ah1, bl2) | 0;
        hi = hi + Math.imul(ah1, bh2) | 0;
        lo = lo + Math.imul(al0, bl3) | 0;
        mid = mid + Math.imul(al0, bh3) | 0;
        mid = mid + Math.imul(ah0, bl3) | 0;
        hi = hi + Math.imul(ah0, bh3) | 0;
        var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
        w3 &= 67108863;
        lo = Math.imul(al4, bl0);
        mid = Math.imul(al4, bh0);
        mid = mid + Math.imul(ah4, bl0) | 0;
        hi = Math.imul(ah4, bh0);
        lo = lo + Math.imul(al3, bl1) | 0;
        mid = mid + Math.imul(al3, bh1) | 0;
        mid = mid + Math.imul(ah3, bl1) | 0;
        hi = hi + Math.imul(ah3, bh1) | 0;
        lo = lo + Math.imul(al2, bl2) | 0;
        mid = mid + Math.imul(al2, bh2) | 0;
        mid = mid + Math.imul(ah2, bl2) | 0;
        hi = hi + Math.imul(ah2, bh2) | 0;
        lo = lo + Math.imul(al1, bl3) | 0;
        mid = mid + Math.imul(al1, bh3) | 0;
        mid = mid + Math.imul(ah1, bl3) | 0;
        hi = hi + Math.imul(ah1, bh3) | 0;
        lo = lo + Math.imul(al0, bl4) | 0;
        mid = mid + Math.imul(al0, bh4) | 0;
        mid = mid + Math.imul(ah0, bl4) | 0;
        hi = hi + Math.imul(ah0, bh4) | 0;
        var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
        w4 &= 67108863;
        lo = Math.imul(al5, bl0);
        mid = Math.imul(al5, bh0);
        mid = mid + Math.imul(ah5, bl0) | 0;
        hi = Math.imul(ah5, bh0);
        lo = lo + Math.imul(al4, bl1) | 0;
        mid = mid + Math.imul(al4, bh1) | 0;
        mid = mid + Math.imul(ah4, bl1) | 0;
        hi = hi + Math.imul(ah4, bh1) | 0;
        lo = lo + Math.imul(al3, bl2) | 0;
        mid = mid + Math.imul(al3, bh2) | 0;
        mid = mid + Math.imul(ah3, bl2) | 0;
        hi = hi + Math.imul(ah3, bh2) | 0;
        lo = lo + Math.imul(al2, bl3) | 0;
        mid = mid + Math.imul(al2, bh3) | 0;
        mid = mid + Math.imul(ah2, bl3) | 0;
        hi = hi + Math.imul(ah2, bh3) | 0;
        lo = lo + Math.imul(al1, bl4) | 0;
        mid = mid + Math.imul(al1, bh4) | 0;
        mid = mid + Math.imul(ah1, bl4) | 0;
        hi = hi + Math.imul(ah1, bh4) | 0;
        lo = lo + Math.imul(al0, bl5) | 0;
        mid = mid + Math.imul(al0, bh5) | 0;
        mid = mid + Math.imul(ah0, bl5) | 0;
        hi = hi + Math.imul(ah0, bh5) | 0;
        var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
        w5 &= 67108863;
        lo = Math.imul(al6, bl0);
        mid = Math.imul(al6, bh0);
        mid = mid + Math.imul(ah6, bl0) | 0;
        hi = Math.imul(ah6, bh0);
        lo = lo + Math.imul(al5, bl1) | 0;
        mid = mid + Math.imul(al5, bh1) | 0;
        mid = mid + Math.imul(ah5, bl1) | 0;
        hi = hi + Math.imul(ah5, bh1) | 0;
        lo = lo + Math.imul(al4, bl2) | 0;
        mid = mid + Math.imul(al4, bh2) | 0;
        mid = mid + Math.imul(ah4, bl2) | 0;
        hi = hi + Math.imul(ah4, bh2) | 0;
        lo = lo + Math.imul(al3, bl3) | 0;
        mid = mid + Math.imul(al3, bh3) | 0;
        mid = mid + Math.imul(ah3, bl3) | 0;
        hi = hi + Math.imul(ah3, bh3) | 0;
        lo = lo + Math.imul(al2, bl4) | 0;
        mid = mid + Math.imul(al2, bh4) | 0;
        mid = mid + Math.imul(ah2, bl4) | 0;
        hi = hi + Math.imul(ah2, bh4) | 0;
        lo = lo + Math.imul(al1, bl5) | 0;
        mid = mid + Math.imul(al1, bh5) | 0;
        mid = mid + Math.imul(ah1, bl5) | 0;
        hi = hi + Math.imul(ah1, bh5) | 0;
        lo = lo + Math.imul(al0, bl6) | 0;
        mid = mid + Math.imul(al0, bh6) | 0;
        mid = mid + Math.imul(ah0, bl6) | 0;
        hi = hi + Math.imul(ah0, bh6) | 0;
        var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
        w6 &= 67108863;
        lo = Math.imul(al7, bl0);
        mid = Math.imul(al7, bh0);
        mid = mid + Math.imul(ah7, bl0) | 0;
        hi = Math.imul(ah7, bh0);
        lo = lo + Math.imul(al6, bl1) | 0;
        mid = mid + Math.imul(al6, bh1) | 0;
        mid = mid + Math.imul(ah6, bl1) | 0;
        hi = hi + Math.imul(ah6, bh1) | 0;
        lo = lo + Math.imul(al5, bl2) | 0;
        mid = mid + Math.imul(al5, bh2) | 0;
        mid = mid + Math.imul(ah5, bl2) | 0;
        hi = hi + Math.imul(ah5, bh2) | 0;
        lo = lo + Math.imul(al4, bl3) | 0;
        mid = mid + Math.imul(al4, bh3) | 0;
        mid = mid + Math.imul(ah4, bl3) | 0;
        hi = hi + Math.imul(ah4, bh3) | 0;
        lo = lo + Math.imul(al3, bl4) | 0;
        mid = mid + Math.imul(al3, bh4) | 0;
        mid = mid + Math.imul(ah3, bl4) | 0;
        hi = hi + Math.imul(ah3, bh4) | 0;
        lo = lo + Math.imul(al2, bl5) | 0;
        mid = mid + Math.imul(al2, bh5) | 0;
        mid = mid + Math.imul(ah2, bl5) | 0;
        hi = hi + Math.imul(ah2, bh5) | 0;
        lo = lo + Math.imul(al1, bl6) | 0;
        mid = mid + Math.imul(al1, bh6) | 0;
        mid = mid + Math.imul(ah1, bl6) | 0;
        hi = hi + Math.imul(ah1, bh6) | 0;
        lo = lo + Math.imul(al0, bl7) | 0;
        mid = mid + Math.imul(al0, bh7) | 0;
        mid = mid + Math.imul(ah0, bl7) | 0;
        hi = hi + Math.imul(ah0, bh7) | 0;
        var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
        w7 &= 67108863;
        lo = Math.imul(al8, bl0);
        mid = Math.imul(al8, bh0);
        mid = mid + Math.imul(ah8, bl0) | 0;
        hi = Math.imul(ah8, bh0);
        lo = lo + Math.imul(al7, bl1) | 0;
        mid = mid + Math.imul(al7, bh1) | 0;
        mid = mid + Math.imul(ah7, bl1) | 0;
        hi = hi + Math.imul(ah7, bh1) | 0;
        lo = lo + Math.imul(al6, bl2) | 0;
        mid = mid + Math.imul(al6, bh2) | 0;
        mid = mid + Math.imul(ah6, bl2) | 0;
        hi = hi + Math.imul(ah6, bh2) | 0;
        lo = lo + Math.imul(al5, bl3) | 0;
        mid = mid + Math.imul(al5, bh3) | 0;
        mid = mid + Math.imul(ah5, bl3) | 0;
        hi = hi + Math.imul(ah5, bh3) | 0;
        lo = lo + Math.imul(al4, bl4) | 0;
        mid = mid + Math.imul(al4, bh4) | 0;
        mid = mid + Math.imul(ah4, bl4) | 0;
        hi = hi + Math.imul(ah4, bh4) | 0;
        lo = lo + Math.imul(al3, bl5) | 0;
        mid = mid + Math.imul(al3, bh5) | 0;
        mid = mid + Math.imul(ah3, bl5) | 0;
        hi = hi + Math.imul(ah3, bh5) | 0;
        lo = lo + Math.imul(al2, bl6) | 0;
        mid = mid + Math.imul(al2, bh6) | 0;
        mid = mid + Math.imul(ah2, bl6) | 0;
        hi = hi + Math.imul(ah2, bh6) | 0;
        lo = lo + Math.imul(al1, bl7) | 0;
        mid = mid + Math.imul(al1, bh7) | 0;
        mid = mid + Math.imul(ah1, bl7) | 0;
        hi = hi + Math.imul(ah1, bh7) | 0;
        lo = lo + Math.imul(al0, bl8) | 0;
        mid = mid + Math.imul(al0, bh8) | 0;
        mid = mid + Math.imul(ah0, bl8) | 0;
        hi = hi + Math.imul(ah0, bh8) | 0;
        var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
        w8 &= 67108863;
        lo = Math.imul(al9, bl0);
        mid = Math.imul(al9, bh0);
        mid = mid + Math.imul(ah9, bl0) | 0;
        hi = Math.imul(ah9, bh0);
        lo = lo + Math.imul(al8, bl1) | 0;
        mid = mid + Math.imul(al8, bh1) | 0;
        mid = mid + Math.imul(ah8, bl1) | 0;
        hi = hi + Math.imul(ah8, bh1) | 0;
        lo = lo + Math.imul(al7, bl2) | 0;
        mid = mid + Math.imul(al7, bh2) | 0;
        mid = mid + Math.imul(ah7, bl2) | 0;
        hi = hi + Math.imul(ah7, bh2) | 0;
        lo = lo + Math.imul(al6, bl3) | 0;
        mid = mid + Math.imul(al6, bh3) | 0;
        mid = mid + Math.imul(ah6, bl3) | 0;
        hi = hi + Math.imul(ah6, bh3) | 0;
        lo = lo + Math.imul(al5, bl4) | 0;
        mid = mid + Math.imul(al5, bh4) | 0;
        mid = mid + Math.imul(ah5, bl4) | 0;
        hi = hi + Math.imul(ah5, bh4) | 0;
        lo = lo + Math.imul(al4, bl5) | 0;
        mid = mid + Math.imul(al4, bh5) | 0;
        mid = mid + Math.imul(ah4, bl5) | 0;
        hi = hi + Math.imul(ah4, bh5) | 0;
        lo = lo + Math.imul(al3, bl6) | 0;
        mid = mid + Math.imul(al3, bh6) | 0;
        mid = mid + Math.imul(ah3, bl6) | 0;
        hi = hi + Math.imul(ah3, bh6) | 0;
        lo = lo + Math.imul(al2, bl7) | 0;
        mid = mid + Math.imul(al2, bh7) | 0;
        mid = mid + Math.imul(ah2, bl7) | 0;
        hi = hi + Math.imul(ah2, bh7) | 0;
        lo = lo + Math.imul(al1, bl8) | 0;
        mid = mid + Math.imul(al1, bh8) | 0;
        mid = mid + Math.imul(ah1, bl8) | 0;
        hi = hi + Math.imul(ah1, bh8) | 0;
        lo = lo + Math.imul(al0, bl9) | 0;
        mid = mid + Math.imul(al0, bh9) | 0;
        mid = mid + Math.imul(ah0, bl9) | 0;
        hi = hi + Math.imul(ah0, bh9) | 0;
        var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
        w9 &= 67108863;
        lo = Math.imul(al9, bl1);
        mid = Math.imul(al9, bh1);
        mid = mid + Math.imul(ah9, bl1) | 0;
        hi = Math.imul(ah9, bh1);
        lo = lo + Math.imul(al8, bl2) | 0;
        mid = mid + Math.imul(al8, bh2) | 0;
        mid = mid + Math.imul(ah8, bl2) | 0;
        hi = hi + Math.imul(ah8, bh2) | 0;
        lo = lo + Math.imul(al7, bl3) | 0;
        mid = mid + Math.imul(al7, bh3) | 0;
        mid = mid + Math.imul(ah7, bl3) | 0;
        hi = hi + Math.imul(ah7, bh3) | 0;
        lo = lo + Math.imul(al6, bl4) | 0;
        mid = mid + Math.imul(al6, bh4) | 0;
        mid = mid + Math.imul(ah6, bl4) | 0;
        hi = hi + Math.imul(ah6, bh4) | 0;
        lo = lo + Math.imul(al5, bl5) | 0;
        mid = mid + Math.imul(al5, bh5) | 0;
        mid = mid + Math.imul(ah5, bl5) | 0;
        hi = hi + Math.imul(ah5, bh5) | 0;
        lo = lo + Math.imul(al4, bl6) | 0;
        mid = mid + Math.imul(al4, bh6) | 0;
        mid = mid + Math.imul(ah4, bl6) | 0;
        hi = hi + Math.imul(ah4, bh6) | 0;
        lo = lo + Math.imul(al3, bl7) | 0;
        mid = mid + Math.imul(al3, bh7) | 0;
        mid = mid + Math.imul(ah3, bl7) | 0;
        hi = hi + Math.imul(ah3, bh7) | 0;
        lo = lo + Math.imul(al2, bl8) | 0;
        mid = mid + Math.imul(al2, bh8) | 0;
        mid = mid + Math.imul(ah2, bl8) | 0;
        hi = hi + Math.imul(ah2, bh8) | 0;
        lo = lo + Math.imul(al1, bl9) | 0;
        mid = mid + Math.imul(al1, bh9) | 0;
        mid = mid + Math.imul(ah1, bl9) | 0;
        hi = hi + Math.imul(ah1, bh9) | 0;
        var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
        w10 &= 67108863;
        lo = Math.imul(al9, bl2);
        mid = Math.imul(al9, bh2);
        mid = mid + Math.imul(ah9, bl2) | 0;
        hi = Math.imul(ah9, bh2);
        lo = lo + Math.imul(al8, bl3) | 0;
        mid = mid + Math.imul(al8, bh3) | 0;
        mid = mid + Math.imul(ah8, bl3) | 0;
        hi = hi + Math.imul(ah8, bh3) | 0;
        lo = lo + Math.imul(al7, bl4) | 0;
        mid = mid + Math.imul(al7, bh4) | 0;
        mid = mid + Math.imul(ah7, bl4) | 0;
        hi = hi + Math.imul(ah7, bh4) | 0;
        lo = lo + Math.imul(al6, bl5) | 0;
        mid = mid + Math.imul(al6, bh5) | 0;
        mid = mid + Math.imul(ah6, bl5) | 0;
        hi = hi + Math.imul(ah6, bh5) | 0;
        lo = lo + Math.imul(al5, bl6) | 0;
        mid = mid + Math.imul(al5, bh6) | 0;
        mid = mid + Math.imul(ah5, bl6) | 0;
        hi = hi + Math.imul(ah5, bh6) | 0;
        lo = lo + Math.imul(al4, bl7) | 0;
        mid = mid + Math.imul(al4, bh7) | 0;
        mid = mid + Math.imul(ah4, bl7) | 0;
        hi = hi + Math.imul(ah4, bh7) | 0;
        lo = lo + Math.imul(al3, bl8) | 0;
        mid = mid + Math.imul(al3, bh8) | 0;
        mid = mid + Math.imul(ah3, bl8) | 0;
        hi = hi + Math.imul(ah3, bh8) | 0;
        lo = lo + Math.imul(al2, bl9) | 0;
        mid = mid + Math.imul(al2, bh9) | 0;
        mid = mid + Math.imul(ah2, bl9) | 0;
        hi = hi + Math.imul(ah2, bh9) | 0;
        var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
        w11 &= 67108863;
        lo = Math.imul(al9, bl3);
        mid = Math.imul(al9, bh3);
        mid = mid + Math.imul(ah9, bl3) | 0;
        hi = Math.imul(ah9, bh3);
        lo = lo + Math.imul(al8, bl4) | 0;
        mid = mid + Math.imul(al8, bh4) | 0;
        mid = mid + Math.imul(ah8, bl4) | 0;
        hi = hi + Math.imul(ah8, bh4) | 0;
        lo = lo + Math.imul(al7, bl5) | 0;
        mid = mid + Math.imul(al7, bh5) | 0;
        mid = mid + Math.imul(ah7, bl5) | 0;
        hi = hi + Math.imul(ah7, bh5) | 0;
        lo = lo + Math.imul(al6, bl6) | 0;
        mid = mid + Math.imul(al6, bh6) | 0;
        mid = mid + Math.imul(ah6, bl6) | 0;
        hi = hi + Math.imul(ah6, bh6) | 0;
        lo = lo + Math.imul(al5, bl7) | 0;
        mid = mid + Math.imul(al5, bh7) | 0;
        mid = mid + Math.imul(ah5, bl7) | 0;
        hi = hi + Math.imul(ah5, bh7) | 0;
        lo = lo + Math.imul(al4, bl8) | 0;
        mid = mid + Math.imul(al4, bh8) | 0;
        mid = mid + Math.imul(ah4, bl8) | 0;
        hi = hi + Math.imul(ah4, bh8) | 0;
        lo = lo + Math.imul(al3, bl9) | 0;
        mid = mid + Math.imul(al3, bh9) | 0;
        mid = mid + Math.imul(ah3, bl9) | 0;
        hi = hi + Math.imul(ah3, bh9) | 0;
        var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
        w12 &= 67108863;
        lo = Math.imul(al9, bl4);
        mid = Math.imul(al9, bh4);
        mid = mid + Math.imul(ah9, bl4) | 0;
        hi = Math.imul(ah9, bh4);
        lo = lo + Math.imul(al8, bl5) | 0;
        mid = mid + Math.imul(al8, bh5) | 0;
        mid = mid + Math.imul(ah8, bl5) | 0;
        hi = hi + Math.imul(ah8, bh5) | 0;
        lo = lo + Math.imul(al7, bl6) | 0;
        mid = mid + Math.imul(al7, bh6) | 0;
        mid = mid + Math.imul(ah7, bl6) | 0;
        hi = hi + Math.imul(ah7, bh6) | 0;
        lo = lo + Math.imul(al6, bl7) | 0;
        mid = mid + Math.imul(al6, bh7) | 0;
        mid = mid + Math.imul(ah6, bl7) | 0;
        hi = hi + Math.imul(ah6, bh7) | 0;
        lo = lo + Math.imul(al5, bl8) | 0;
        mid = mid + Math.imul(al5, bh8) | 0;
        mid = mid + Math.imul(ah5, bl8) | 0;
        hi = hi + Math.imul(ah5, bh8) | 0;
        lo = lo + Math.imul(al4, bl9) | 0;
        mid = mid + Math.imul(al4, bh9) | 0;
        mid = mid + Math.imul(ah4, bl9) | 0;
        hi = hi + Math.imul(ah4, bh9) | 0;
        var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
        w13 &= 67108863;
        lo = Math.imul(al9, bl5);
        mid = Math.imul(al9, bh5);
        mid = mid + Math.imul(ah9, bl5) | 0;
        hi = Math.imul(ah9, bh5);
        lo = lo + Math.imul(al8, bl6) | 0;
        mid = mid + Math.imul(al8, bh6) | 0;
        mid = mid + Math.imul(ah8, bl6) | 0;
        hi = hi + Math.imul(ah8, bh6) | 0;
        lo = lo + Math.imul(al7, bl7) | 0;
        mid = mid + Math.imul(al7, bh7) | 0;
        mid = mid + Math.imul(ah7, bl7) | 0;
        hi = hi + Math.imul(ah7, bh7) | 0;
        lo = lo + Math.imul(al6, bl8) | 0;
        mid = mid + Math.imul(al6, bh8) | 0;
        mid = mid + Math.imul(ah6, bl8) | 0;
        hi = hi + Math.imul(ah6, bh8) | 0;
        lo = lo + Math.imul(al5, bl9) | 0;
        mid = mid + Math.imul(al5, bh9) | 0;
        mid = mid + Math.imul(ah5, bl9) | 0;
        hi = hi + Math.imul(ah5, bh9) | 0;
        var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
        w14 &= 67108863;
        lo = Math.imul(al9, bl6);
        mid = Math.imul(al9, bh6);
        mid = mid + Math.imul(ah9, bl6) | 0;
        hi = Math.imul(ah9, bh6);
        lo = lo + Math.imul(al8, bl7) | 0;
        mid = mid + Math.imul(al8, bh7) | 0;
        mid = mid + Math.imul(ah8, bl7) | 0;
        hi = hi + Math.imul(ah8, bh7) | 0;
        lo = lo + Math.imul(al7, bl8) | 0;
        mid = mid + Math.imul(al7, bh8) | 0;
        mid = mid + Math.imul(ah7, bl8) | 0;
        hi = hi + Math.imul(ah7, bh8) | 0;
        lo = lo + Math.imul(al6, bl9) | 0;
        mid = mid + Math.imul(al6, bh9) | 0;
        mid = mid + Math.imul(ah6, bl9) | 0;
        hi = hi + Math.imul(ah6, bh9) | 0;
        var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
        w15 &= 67108863;
        lo = Math.imul(al9, bl7);
        mid = Math.imul(al9, bh7);
        mid = mid + Math.imul(ah9, bl7) | 0;
        hi = Math.imul(ah9, bh7);
        lo = lo + Math.imul(al8, bl8) | 0;
        mid = mid + Math.imul(al8, bh8) | 0;
        mid = mid + Math.imul(ah8, bl8) | 0;
        hi = hi + Math.imul(ah8, bh8) | 0;
        lo = lo + Math.imul(al7, bl9) | 0;
        mid = mid + Math.imul(al7, bh9) | 0;
        mid = mid + Math.imul(ah7, bl9) | 0;
        hi = hi + Math.imul(ah7, bh9) | 0;
        var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
        w16 &= 67108863;
        lo = Math.imul(al9, bl8);
        mid = Math.imul(al9, bh8);
        mid = mid + Math.imul(ah9, bl8) | 0;
        hi = Math.imul(ah9, bh8);
        lo = lo + Math.imul(al8, bl9) | 0;
        mid = mid + Math.imul(al8, bh9) | 0;
        mid = mid + Math.imul(ah8, bl9) | 0;
        hi = hi + Math.imul(ah8, bh9) | 0;
        var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
        w17 &= 67108863;
        lo = Math.imul(al9, bl9);
        mid = Math.imul(al9, bh9);
        mid = mid + Math.imul(ah9, bl9) | 0;
        hi = Math.imul(ah9, bh9);
        var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
        c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
        w18 &= 67108863;
        o[0] = w0;
        o[1] = w1;
        o[2] = w2;
        o[3] = w3;
        o[4] = w4;
        o[5] = w5;
        o[6] = w6;
        o[7] = w7;
        o[8] = w8;
        o[9] = w9;
        o[10] = w10;
        o[11] = w11;
        o[12] = w12;
        o[13] = w13;
        o[14] = w14;
        o[15] = w15;
        o[16] = w16;
        o[17] = w17;
        o[18] = w18;
        if (c !== 0) {
          o[19] = c;
          out.length++;
        }
        return out;
      };
      if (!Math.imul) {
        comb10MulTo = smallMulTo;
      }
      function bigMulTo(self2, num, out) {
        out.negative = num.negative ^ self2.negative;
        out.length = self2.length + num.length;
        var carry = 0;
        var hncarry = 0;
        for (var k = 0; k < out.length - 1; k++) {
          var ncarry = hncarry;
          hncarry = 0;
          var rword = carry & 67108863;
          var maxJ = Math.min(k, num.length - 1);
          for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
            var i = k - j;
            var a = self2.words[i] | 0;
            var b = num.words[j] | 0;
            var r = a * b;
            var lo = r & 67108863;
            ncarry = ncarry + (r / 67108864 | 0) | 0;
            lo = lo + rword | 0;
            rword = lo & 67108863;
            ncarry = ncarry + (lo >>> 26) | 0;
            hncarry += ncarry >>> 26;
            ncarry &= 67108863;
          }
          out.words[k] = rword;
          carry = ncarry;
          ncarry = hncarry;
        }
        if (carry !== 0) {
          out.words[k] = carry;
        } else {
          out.length--;
        }
        return out.strip();
      }
      function jumboMulTo(self2, num, out) {
        var fftm = new FFTM();
        return fftm.mulp(self2, num, out);
      }
      BN.prototype.mulTo = function mulTo(num, out) {
        var res;
        var len = this.length + num.length;
        if (this.length === 10 && num.length === 10) {
          res = comb10MulTo(this, num, out);
        } else if (len < 63) {
          res = smallMulTo(this, num, out);
        } else if (len < 1024) {
          res = bigMulTo(this, num, out);
        } else {
          res = jumboMulTo(this, num, out);
        }
        return res;
      };
      function FFTM(x, y) {
        this.x = x;
        this.y = y;
      }
      FFTM.prototype.makeRBT = function makeRBT(N) {
        var t = new Array(N);
        var l = BN.prototype._countBits(N) - 1;
        for (var i = 0; i < N; i++) {
          t[i] = this.revBin(i, l, N);
        }
        return t;
      };
      FFTM.prototype.revBin = function revBin(x, l, N) {
        if (x === 0 || x === N - 1)
          return x;
        var rb = 0;
        for (var i = 0; i < l; i++) {
          rb |= (x & 1) << l - i - 1;
          x >>= 1;
        }
        return rb;
      };
      FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
        for (var i = 0; i < N; i++) {
          rtws[i] = rws[rbt[i]];
          itws[i] = iws[rbt[i]];
        }
      };
      FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
        this.permute(rbt, rws, iws, rtws, itws, N);
        for (var s = 1; s < N; s <<= 1) {
          var l = s << 1;
          var rtwdf = Math.cos(2 * Math.PI / l);
          var itwdf = Math.sin(2 * Math.PI / l);
          for (var p = 0; p < N; p += l) {
            var rtwdf_ = rtwdf;
            var itwdf_ = itwdf;
            for (var j = 0; j < s; j++) {
              var re = rtws[p + j];
              var ie = itws[p + j];
              var ro = rtws[p + j + s];
              var io = itws[p + j + s];
              var rx = rtwdf_ * ro - itwdf_ * io;
              io = rtwdf_ * io + itwdf_ * ro;
              ro = rx;
              rtws[p + j] = re + ro;
              itws[p + j] = ie + io;
              rtws[p + j + s] = re - ro;
              itws[p + j + s] = ie - io;
              if (j !== l) {
                rx = rtwdf * rtwdf_ - itwdf * itwdf_;
                itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
                rtwdf_ = rx;
              }
            }
          }
        }
      };
      FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
        var N = Math.max(m, n) | 1;
        var odd = N & 1;
        var i = 0;
        for (N = N / 2 | 0; N; N = N >>> 1) {
          i++;
        }
        return 1 << i + 1 + odd;
      };
      FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
        if (N <= 1)
          return;
        for (var i = 0; i < N / 2; i++) {
          var t = rws[i];
          rws[i] = rws[N - i - 1];
          rws[N - i - 1] = t;
          t = iws[i];
          iws[i] = -iws[N - i - 1];
          iws[N - i - 1] = -t;
        }
      };
      FFTM.prototype.normalize13b = function normalize13b(ws, N) {
        var carry = 0;
        for (var i = 0; i < N / 2; i++) {
          var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
          ws[i] = w & 67108863;
          if (w < 67108864) {
            carry = 0;
          } else {
            carry = w / 67108864 | 0;
          }
        }
        return ws;
      };
      FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
        var carry = 0;
        for (var i = 0; i < len; i++) {
          carry = carry + (ws[i] | 0);
          rws[2 * i] = carry & 8191;
          carry = carry >>> 13;
          rws[2 * i + 1] = carry & 8191;
          carry = carry >>> 13;
        }
        for (i = 2 * len; i < N; ++i) {
          rws[i] = 0;
        }
        assert(carry === 0);
        assert((carry & ~8191) === 0);
      };
      FFTM.prototype.stub = function stub(N) {
        var ph = new Array(N);
        for (var i = 0; i < N; i++) {
          ph[i] = 0;
        }
        return ph;
      };
      FFTM.prototype.mulp = function mulp(x, y, out) {
        var N = 2 * this.guessLen13b(x.length, y.length);
        var rbt = this.makeRBT(N);
        var _ = this.stub(N);
        var rws = new Array(N);
        var rwst = new Array(N);
        var iwst = new Array(N);
        var nrws = new Array(N);
        var nrwst = new Array(N);
        var niwst = new Array(N);
        var rmws = out.words;
        rmws.length = N;
        this.convert13b(x.words, x.length, rws, N);
        this.convert13b(y.words, y.length, nrws, N);
        this.transform(rws, _, rwst, iwst, N, rbt);
        this.transform(nrws, _, nrwst, niwst, N, rbt);
        for (var i = 0; i < N; i++) {
          var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
          iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
          rwst[i] = rx;
        }
        this.conjugate(rwst, iwst, N);
        this.transform(rwst, iwst, rmws, _, N, rbt);
        this.conjugate(rmws, _, N);
        this.normalize13b(rmws, N);
        out.negative = x.negative ^ y.negative;
        out.length = x.length + y.length;
        return out.strip();
      };
      BN.prototype.mul = function mul(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return this.mulTo(num, out);
      };
      BN.prototype.mulf = function mulf(num) {
        var out = new BN(null);
        out.words = new Array(this.length + num.length);
        return jumboMulTo(this, num, out);
      };
      BN.prototype.imul = function imul(num) {
        return this.clone().mulTo(num, this);
      };
      BN.prototype.imuln = function imuln(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = (this.words[i] | 0) * num;
          var lo = (w & 67108863) + (carry & 67108863);
          carry >>= 26;
          carry += w / 67108864 | 0;
          carry += lo >>> 26;
          this.words[i] = lo & 67108863;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.muln = function muln(num) {
        return this.clone().imuln(num);
      };
      BN.prototype.sqr = function sqr() {
        return this.mul(this);
      };
      BN.prototype.isqr = function isqr() {
        return this.imul(this.clone());
      };
      BN.prototype.pow = function pow(num) {
        var w = toBitArray(num);
        if (w.length === 0)
          return new BN(1);
        var res = this;
        for (var i = 0; i < w.length; i++, res = res.sqr()) {
          if (w[i] !== 0)
            break;
        }
        if (++i < w.length) {
          for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
            if (w[i] === 0)
              continue;
            res = res.mul(q);
          }
        }
        return res;
      };
      BN.prototype.iushln = function iushln(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        var carryMask = 67108863 >>> 26 - r << 26 - r;
        var i;
        if (r !== 0) {
          var carry = 0;
          for (i = 0; i < this.length; i++) {
            var newCarry = this.words[i] & carryMask;
            var c = (this.words[i] | 0) - newCarry << r;
            this.words[i] = c | carry;
            carry = newCarry >>> 26 - r;
          }
          if (carry) {
            this.words[i] = carry;
            this.length++;
          }
        }
        if (s !== 0) {
          for (i = this.length - 1; i >= 0; i--) {
            this.words[i + s] = this.words[i];
          }
          for (i = 0; i < s; i++) {
            this.words[i] = 0;
          }
          this.length += s;
        }
        return this.strip();
      };
      BN.prototype.ishln = function ishln(bits) {
        assert(this.negative === 0);
        return this.iushln(bits);
      };
      BN.prototype.iushrn = function iushrn(bits, hint, extended) {
        assert(typeof bits === "number" && bits >= 0);
        var h;
        if (hint) {
          h = (hint - hint % 26) / 26;
        } else {
          h = 0;
        }
        var r = bits % 26;
        var s = Math.min((bits - r) / 26, this.length);
        var mask = 67108863 ^ 67108863 >>> r << r;
        var maskedWords = extended;
        h -= s;
        h = Math.max(0, h);
        if (maskedWords) {
          for (var i = 0; i < s; i++) {
            maskedWords.words[i] = this.words[i];
          }
          maskedWords.length = s;
        }
        if (s === 0) {
        } else if (this.length > s) {
          this.length -= s;
          for (i = 0; i < this.length; i++) {
            this.words[i] = this.words[i + s];
          }
        } else {
          this.words[0] = 0;
          this.length = 1;
        }
        var carry = 0;
        for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
          var word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
        if (maskedWords && carry !== 0) {
          maskedWords.words[maskedWords.length++] = carry;
        }
        if (this.length === 0) {
          this.words[0] = 0;
          this.length = 1;
        }
        return this.strip();
      };
      BN.prototype.ishrn = function ishrn(bits, hint, extended) {
        assert(this.negative === 0);
        return this.iushrn(bits, hint, extended);
      };
      BN.prototype.shln = function shln(bits) {
        return this.clone().ishln(bits);
      };
      BN.prototype.ushln = function ushln(bits) {
        return this.clone().iushln(bits);
      };
      BN.prototype.shrn = function shrn(bits) {
        return this.clone().ishrn(bits);
      };
      BN.prototype.ushrn = function ushrn(bits) {
        return this.clone().iushrn(bits);
      };
      BN.prototype.testn = function testn(bit) {
        assert(typeof bit === "number" && bit >= 0);
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s)
          return false;
        var w = this.words[s];
        return !!(w & q);
      };
      BN.prototype.imaskn = function imaskn(bits) {
        assert(typeof bits === "number" && bits >= 0);
        var r = bits % 26;
        var s = (bits - r) / 26;
        assert(this.negative === 0, "imaskn works only with positive numbers");
        if (this.length <= s) {
          return this;
        }
        if (r !== 0) {
          s++;
        }
        this.length = Math.min(s, this.length);
        if (r !== 0) {
          var mask = 67108863 ^ 67108863 >>> r << r;
          this.words[this.length - 1] &= mask;
        }
        return this.strip();
      };
      BN.prototype.maskn = function maskn(bits) {
        return this.clone().imaskn(bits);
      };
      BN.prototype.iaddn = function iaddn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.isubn(-num);
        if (this.negative !== 0) {
          if (this.length === 1 && (this.words[0] | 0) < num) {
            this.words[0] = num - (this.words[0] | 0);
            this.negative = 0;
            return this;
          }
          this.negative = 0;
          this.isubn(num);
          this.negative = 1;
          return this;
        }
        return this._iaddn(num);
      };
      BN.prototype._iaddn = function _iaddn(num) {
        this.words[0] += num;
        for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
          this.words[i] -= 67108864;
          if (i === this.length - 1) {
            this.words[i + 1] = 1;
          } else {
            this.words[i + 1]++;
          }
        }
        this.length = Math.max(this.length, i + 1);
        return this;
      };
      BN.prototype.isubn = function isubn(num) {
        assert(typeof num === "number");
        assert(num < 67108864);
        if (num < 0)
          return this.iaddn(-num);
        if (this.negative !== 0) {
          this.negative = 0;
          this.iaddn(num);
          this.negative = 1;
          return this;
        }
        this.words[0] -= num;
        if (this.length === 1 && this.words[0] < 0) {
          this.words[0] = -this.words[0];
          this.negative = 1;
        } else {
          for (var i = 0; i < this.length && this.words[i] < 0; i++) {
            this.words[i] += 67108864;
            this.words[i + 1] -= 1;
          }
        }
        return this.strip();
      };
      BN.prototype.addn = function addn(num) {
        return this.clone().iaddn(num);
      };
      BN.prototype.subn = function subn(num) {
        return this.clone().isubn(num);
      };
      BN.prototype.iabs = function iabs() {
        this.negative = 0;
        return this;
      };
      BN.prototype.abs = function abs() {
        return this.clone().iabs();
      };
      BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
        var len = num.length + shift;
        var i;
        this._expand(len);
        var w;
        var carry = 0;
        for (i = 0; i < num.length; i++) {
          w = (this.words[i + shift] | 0) + carry;
          var right = (num.words[i] | 0) * mul;
          w -= right & 67108863;
          carry = (w >> 26) - (right / 67108864 | 0);
          this.words[i + shift] = w & 67108863;
        }
        for (; i < this.length - shift; i++) {
          w = (this.words[i + shift] | 0) + carry;
          carry = w >> 26;
          this.words[i + shift] = w & 67108863;
        }
        if (carry === 0)
          return this.strip();
        assert(carry === -1);
        carry = 0;
        for (i = 0; i < this.length; i++) {
          w = -(this.words[i] | 0) + carry;
          carry = w >> 26;
          this.words[i] = w & 67108863;
        }
        this.negative = 1;
        return this.strip();
      };
      BN.prototype._wordDiv = function _wordDiv(num, mode) {
        var shift = this.length - num.length;
        var a = this.clone();
        var b = num;
        var bhi = b.words[b.length - 1] | 0;
        var bhiBits = this._countBits(bhi);
        shift = 26 - bhiBits;
        if (shift !== 0) {
          b = b.ushln(shift);
          a.iushln(shift);
          bhi = b.words[b.length - 1] | 0;
        }
        var m = a.length - b.length;
        var q;
        if (mode !== "mod") {
          q = new BN(null);
          q.length = m + 1;
          q.words = new Array(q.length);
          for (var i = 0; i < q.length; i++) {
            q.words[i] = 0;
          }
        }
        var diff = a.clone()._ishlnsubmul(b, 1, m);
        if (diff.negative === 0) {
          a = diff;
          if (q) {
            q.words[m] = 1;
          }
        }
        for (var j = m - 1; j >= 0; j--) {
          var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
          qj = Math.min(qj / bhi | 0, 67108863);
          a._ishlnsubmul(b, qj, j);
          while (a.negative !== 0) {
            qj--;
            a.negative = 0;
            a._ishlnsubmul(b, 1, j);
            if (!a.isZero()) {
              a.negative ^= 1;
            }
          }
          if (q) {
            q.words[j] = qj;
          }
        }
        if (q) {
          q.strip();
        }
        a.strip();
        if (mode !== "div" && shift !== 0) {
          a.iushrn(shift);
        }
        return {
          div: q || null,
          mod: a
        };
      };
      BN.prototype.divmod = function divmod(num, mode, positive) {
        assert(!num.isZero());
        if (this.isZero()) {
          return {
            div: new BN(0),
            mod: new BN(0)
          };
        }
        var div, mod2, res;
        if (this.negative !== 0 && num.negative === 0) {
          res = this.neg().divmod(num, mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.iadd(num);
            }
          }
          return {
            div,
            mod: mod2
          };
        }
        if (this.negative === 0 && num.negative !== 0) {
          res = this.divmod(num.neg(), mode);
          if (mode !== "mod") {
            div = res.div.neg();
          }
          return {
            div,
            mod: res.mod
          };
        }
        if ((this.negative & num.negative) !== 0) {
          res = this.neg().divmod(num.neg(), mode);
          if (mode !== "div") {
            mod2 = res.mod.neg();
            if (positive && mod2.negative !== 0) {
              mod2.isub(num);
            }
          }
          return {
            div: res.div,
            mod: mod2
          };
        }
        if (num.length > this.length || this.cmp(num) < 0) {
          return {
            div: new BN(0),
            mod: this
          };
        }
        if (num.length === 1) {
          if (mode === "div") {
            return {
              div: this.divn(num.words[0]),
              mod: null
            };
          }
          if (mode === "mod") {
            return {
              div: null,
              mod: new BN(this.modn(num.words[0]))
            };
          }
          return {
            div: this.divn(num.words[0]),
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return this._wordDiv(num, mode);
      };
      BN.prototype.div = function div(num) {
        return this.divmod(num, "div", false).div;
      };
      BN.prototype.mod = function mod2(num) {
        return this.divmod(num, "mod", false).mod;
      };
      BN.prototype.umod = function umod(num) {
        return this.divmod(num, "mod", true).mod;
      };
      BN.prototype.divRound = function divRound(num) {
        var dm = this.divmod(num);
        if (dm.mod.isZero())
          return dm.div;
        var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
        var half = num.ushrn(1);
        var r2 = num.andln(1);
        var cmp = mod2.cmp(half);
        if (cmp < 0 || r2 === 1 && cmp === 0)
          return dm.div;
        return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
      };
      BN.prototype.modn = function modn(num) {
        assert(num <= 67108863);
        var p = (1 << 26) % num;
        var acc = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          acc = (p * acc + (this.words[i] | 0)) % num;
        }
        return acc;
      };
      BN.prototype.idivn = function idivn(num) {
        assert(num <= 67108863);
        var carry = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var w = (this.words[i] | 0) + carry * 67108864;
          this.words[i] = w / num | 0;
          carry = w % num;
        }
        return this.strip();
      };
      BN.prototype.divn = function divn(num) {
        return this.clone().idivn(num);
      };
      BN.prototype.egcd = function egcd(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var x = this;
        var y = p.clone();
        if (x.negative !== 0) {
          x = x.umod(p);
        } else {
          x = x.clone();
        }
        var A = new BN(1);
        var B = new BN(0);
        var C = new BN(0);
        var D = new BN(1);
        var g = 0;
        while (x.isEven() && y.isEven()) {
          x.iushrn(1);
          y.iushrn(1);
          ++g;
        }
        var yp = y.clone();
        var xp = x.clone();
        while (!x.isZero()) {
          for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            x.iushrn(i);
            while (i-- > 0) {
              if (A.isOdd() || B.isOdd()) {
                A.iadd(yp);
                B.isub(xp);
              }
              A.iushrn(1);
              B.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            y.iushrn(j);
            while (j-- > 0) {
              if (C.isOdd() || D.isOdd()) {
                C.iadd(yp);
                D.isub(xp);
              }
              C.iushrn(1);
              D.iushrn(1);
            }
          }
          if (x.cmp(y) >= 0) {
            x.isub(y);
            A.isub(C);
            B.isub(D);
          } else {
            y.isub(x);
            C.isub(A);
            D.isub(B);
          }
        }
        return {
          a: C,
          b: D,
          gcd: y.iushln(g)
        };
      };
      BN.prototype._invmp = function _invmp(p) {
        assert(p.negative === 0);
        assert(!p.isZero());
        var a = this;
        var b = p.clone();
        if (a.negative !== 0) {
          a = a.umod(p);
        } else {
          a = a.clone();
        }
        var x1 = new BN(1);
        var x2 = new BN(0);
        var delta = b.clone();
        while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
          for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
            ;
          if (i > 0) {
            a.iushrn(i);
            while (i-- > 0) {
              if (x1.isOdd()) {
                x1.iadd(delta);
              }
              x1.iushrn(1);
            }
          }
          for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
            ;
          if (j > 0) {
            b.iushrn(j);
            while (j-- > 0) {
              if (x2.isOdd()) {
                x2.iadd(delta);
              }
              x2.iushrn(1);
            }
          }
          if (a.cmp(b) >= 0) {
            a.isub(b);
            x1.isub(x2);
          } else {
            b.isub(a);
            x2.isub(x1);
          }
        }
        var res;
        if (a.cmpn(1) === 0) {
          res = x1;
        } else {
          res = x2;
        }
        if (res.cmpn(0) < 0) {
          res.iadd(p);
        }
        return res;
      };
      BN.prototype.gcd = function gcd(num) {
        if (this.isZero())
          return num.abs();
        if (num.isZero())
          return this.abs();
        var a = this.clone();
        var b = num.clone();
        a.negative = 0;
        b.negative = 0;
        for (var shift = 0; a.isEven() && b.isEven(); shift++) {
          a.iushrn(1);
          b.iushrn(1);
        }
        do {
          while (a.isEven()) {
            a.iushrn(1);
          }
          while (b.isEven()) {
            b.iushrn(1);
          }
          var r = a.cmp(b);
          if (r < 0) {
            var t = a;
            a = b;
            b = t;
          } else if (r === 0 || b.cmpn(1) === 0) {
            break;
          }
          a.isub(b);
        } while (true);
        return b.iushln(shift);
      };
      BN.prototype.invm = function invm(num) {
        return this.egcd(num).a.umod(num);
      };
      BN.prototype.isEven = function isEven() {
        return (this.words[0] & 1) === 0;
      };
      BN.prototype.isOdd = function isOdd() {
        return (this.words[0] & 1) === 1;
      };
      BN.prototype.andln = function andln(num) {
        return this.words[0] & num;
      };
      BN.prototype.bincn = function bincn(bit) {
        assert(typeof bit === "number");
        var r = bit % 26;
        var s = (bit - r) / 26;
        var q = 1 << r;
        if (this.length <= s) {
          this._expand(s + 1);
          this.words[s] |= q;
          return this;
        }
        var carry = q;
        for (var i = s; carry !== 0 && i < this.length; i++) {
          var w = this.words[i] | 0;
          w += carry;
          carry = w >>> 26;
          w &= 67108863;
          this.words[i] = w;
        }
        if (carry !== 0) {
          this.words[i] = carry;
          this.length++;
        }
        return this;
      };
      BN.prototype.isZero = function isZero() {
        return this.length === 1 && this.words[0] === 0;
      };
      BN.prototype.cmpn = function cmpn(num) {
        var negative = num < 0;
        if (this.negative !== 0 && !negative)
          return -1;
        if (this.negative === 0 && negative)
          return 1;
        this.strip();
        var res;
        if (this.length > 1) {
          res = 1;
        } else {
          if (negative) {
            num = -num;
          }
          assert(num <= 67108863, "Number is too big");
          var w = this.words[0] | 0;
          res = w === num ? 0 : w < num ? -1 : 1;
        }
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.cmp = function cmp(num) {
        if (this.negative !== 0 && num.negative === 0)
          return -1;
        if (this.negative === 0 && num.negative !== 0)
          return 1;
        var res = this.ucmp(num);
        if (this.negative !== 0)
          return -res | 0;
        return res;
      };
      BN.prototype.ucmp = function ucmp(num) {
        if (this.length > num.length)
          return 1;
        if (this.length < num.length)
          return -1;
        var res = 0;
        for (var i = this.length - 1; i >= 0; i--) {
          var a = this.words[i] | 0;
          var b = num.words[i] | 0;
          if (a === b)
            continue;
          if (a < b) {
            res = -1;
          } else if (a > b) {
            res = 1;
          }
          break;
        }
        return res;
      };
      BN.prototype.gtn = function gtn(num) {
        return this.cmpn(num) === 1;
      };
      BN.prototype.gt = function gt(num) {
        return this.cmp(num) === 1;
      };
      BN.prototype.gten = function gten(num) {
        return this.cmpn(num) >= 0;
      };
      BN.prototype.gte = function gte(num) {
        return this.cmp(num) >= 0;
      };
      BN.prototype.ltn = function ltn(num) {
        return this.cmpn(num) === -1;
      };
      BN.prototype.lt = function lt(num) {
        return this.cmp(num) === -1;
      };
      BN.prototype.lten = function lten(num) {
        return this.cmpn(num) <= 0;
      };
      BN.prototype.lte = function lte(num) {
        return this.cmp(num) <= 0;
      };
      BN.prototype.eqn = function eqn(num) {
        return this.cmpn(num) === 0;
      };
      BN.prototype.eq = function eq(num) {
        return this.cmp(num) === 0;
      };
      BN.red = function red(num) {
        return new Red(num);
      };
      BN.prototype.toRed = function toRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        assert(this.negative === 0, "red works only with positives");
        return ctx.convertTo(this)._forceRed(ctx);
      };
      BN.prototype.fromRed = function fromRed() {
        assert(this.red, "fromRed works only with numbers in reduction context");
        return this.red.convertFrom(this);
      };
      BN.prototype._forceRed = function _forceRed(ctx) {
        this.red = ctx;
        return this;
      };
      BN.prototype.forceRed = function forceRed(ctx) {
        assert(!this.red, "Already a number in reduction context");
        return this._forceRed(ctx);
      };
      BN.prototype.redAdd = function redAdd(num) {
        assert(this.red, "redAdd works only with red numbers");
        return this.red.add(this, num);
      };
      BN.prototype.redIAdd = function redIAdd(num) {
        assert(this.red, "redIAdd works only with red numbers");
        return this.red.iadd(this, num);
      };
      BN.prototype.redSub = function redSub(num) {
        assert(this.red, "redSub works only with red numbers");
        return this.red.sub(this, num);
      };
      BN.prototype.redISub = function redISub(num) {
        assert(this.red, "redISub works only with red numbers");
        return this.red.isub(this, num);
      };
      BN.prototype.redShl = function redShl(num) {
        assert(this.red, "redShl works only with red numbers");
        return this.red.shl(this, num);
      };
      BN.prototype.redMul = function redMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.mul(this, num);
      };
      BN.prototype.redIMul = function redIMul(num) {
        assert(this.red, "redMul works only with red numbers");
        this.red._verify2(this, num);
        return this.red.imul(this, num);
      };
      BN.prototype.redSqr = function redSqr() {
        assert(this.red, "redSqr works only with red numbers");
        this.red._verify1(this);
        return this.red.sqr(this);
      };
      BN.prototype.redISqr = function redISqr() {
        assert(this.red, "redISqr works only with red numbers");
        this.red._verify1(this);
        return this.red.isqr(this);
      };
      BN.prototype.redSqrt = function redSqrt() {
        assert(this.red, "redSqrt works only with red numbers");
        this.red._verify1(this);
        return this.red.sqrt(this);
      };
      BN.prototype.redInvm = function redInvm() {
        assert(this.red, "redInvm works only with red numbers");
        this.red._verify1(this);
        return this.red.invm(this);
      };
      BN.prototype.redNeg = function redNeg() {
        assert(this.red, "redNeg works only with red numbers");
        this.red._verify1(this);
        return this.red.neg(this);
      };
      BN.prototype.redPow = function redPow(num) {
        assert(this.red && !num.red, "redPow(normalNum)");
        this.red._verify1(this);
        return this.red.pow(this, num);
      };
      var primes = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function MPrime(name5, p) {
        this.name = name5;
        this.p = new BN(p, 16);
        this.n = this.p.bitLength();
        this.k = new BN(1).iushln(this.n).isub(this.p);
        this.tmp = this._tmp();
      }
      MPrime.prototype._tmp = function _tmp() {
        var tmp = new BN(null);
        tmp.words = new Array(Math.ceil(this.n / 13));
        return tmp;
      };
      MPrime.prototype.ireduce = function ireduce(num) {
        var r = num;
        var rlen;
        do {
          this.split(r, this.tmp);
          r = this.imulK(r);
          r = r.iadd(this.tmp);
          rlen = r.bitLength();
        } while (rlen > this.n);
        var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
        if (cmp === 0) {
          r.words[0] = 0;
          r.length = 1;
        } else if (cmp > 0) {
          r.isub(this.p);
        } else {
          if (r.strip !== void 0) {
            r.strip();
          } else {
            r._strip();
          }
        }
        return r;
      };
      MPrime.prototype.split = function split(input, out) {
        input.iushrn(this.n, 0, out);
      };
      MPrime.prototype.imulK = function imulK(num) {
        return num.imul(this.k);
      };
      function K256() {
        MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
      }
      inherits(K256, MPrime);
      K256.prototype.split = function split(input, output) {
        var mask = 4194303;
        var outLen = Math.min(input.length, 9);
        for (var i = 0; i < outLen; i++) {
          output.words[i] = input.words[i];
        }
        output.length = outLen;
        if (input.length <= 9) {
          input.words[0] = 0;
          input.length = 1;
          return;
        }
        var prev = input.words[9];
        output.words[output.length++] = prev & mask;
        for (i = 10; i < input.length; i++) {
          var next = input.words[i] | 0;
          input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
          prev = next;
        }
        prev >>>= 22;
        input.words[i - 10] = prev;
        if (prev === 0 && input.length > 10) {
          input.length -= 10;
        } else {
          input.length -= 9;
        }
      };
      K256.prototype.imulK = function imulK(num) {
        num.words[num.length] = 0;
        num.words[num.length + 1] = 0;
        num.length += 2;
        var lo = 0;
        for (var i = 0; i < num.length; i++) {
          var w = num.words[i] | 0;
          lo += w * 977;
          num.words[i] = lo & 67108863;
          lo = w * 64 + (lo / 67108864 | 0);
        }
        if (num.words[num.length - 1] === 0) {
          num.length--;
          if (num.words[num.length - 1] === 0) {
            num.length--;
          }
        }
        return num;
      };
      function P224() {
        MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
      }
      inherits(P224, MPrime);
      function P192() {
        MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
      }
      inherits(P192, MPrime);
      function P25519() {
        MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
      }
      inherits(P25519, MPrime);
      P25519.prototype.imulK = function imulK(num) {
        var carry = 0;
        for (var i = 0; i < num.length; i++) {
          var hi = (num.words[i] | 0) * 19 + carry;
          var lo = hi & 67108863;
          hi >>>= 26;
          num.words[i] = lo;
          carry = hi;
        }
        if (carry !== 0) {
          num.words[num.length++] = carry;
        }
        return num;
      };
      BN._prime = function prime(name5) {
        if (primes[name5])
          return primes[name5];
        var prime2;
        if (name5 === "k256") {
          prime2 = new K256();
        } else if (name5 === "p224") {
          prime2 = new P224();
        } else if (name5 === "p192") {
          prime2 = new P192();
        } else if (name5 === "p25519") {
          prime2 = new P25519();
        } else {
          throw new Error("Unknown prime " + name5);
        }
        primes[name5] = prime2;
        return prime2;
      };
      function Red(m) {
        if (typeof m === "string") {
          var prime = BN._prime(m);
          this.m = prime.p;
          this.prime = prime;
        } else {
          assert(m.gtn(1), "modulus must be greater than 1");
          this.m = m;
          this.prime = null;
        }
      }
      Red.prototype._verify1 = function _verify1(a) {
        assert(a.negative === 0, "red works only with positives");
        assert(a.red, "red works only with red numbers");
      };
      Red.prototype._verify2 = function _verify2(a, b) {
        assert((a.negative | b.negative) === 0, "red works only with positives");
        assert(a.red && a.red === b.red, "red works only with red numbers");
      };
      Red.prototype.imod = function imod(a) {
        if (this.prime)
          return this.prime.ireduce(a)._forceRed(this);
        return a.umod(this.m)._forceRed(this);
      };
      Red.prototype.neg = function neg(a) {
        if (a.isZero()) {
          return a.clone();
        }
        return this.m.sub(a)._forceRed(this);
      };
      Red.prototype.add = function add(a, b) {
        this._verify2(a, b);
        var res = a.add(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.iadd = function iadd(a, b) {
        this._verify2(a, b);
        var res = a.iadd(b);
        if (res.cmp(this.m) >= 0) {
          res.isub(this.m);
        }
        return res;
      };
      Red.prototype.sub = function sub(a, b) {
        this._verify2(a, b);
        var res = a.sub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Red.prototype.isub = function isub(a, b) {
        this._verify2(a, b);
        var res = a.isub(b);
        if (res.cmpn(0) < 0) {
          res.iadd(this.m);
        }
        return res;
      };
      Red.prototype.shl = function shl(a, num) {
        this._verify1(a);
        return this.imod(a.ushln(num));
      };
      Red.prototype.imul = function imul(a, b) {
        this._verify2(a, b);
        return this.imod(a.imul(b));
      };
      Red.prototype.mul = function mul(a, b) {
        this._verify2(a, b);
        return this.imod(a.mul(b));
      };
      Red.prototype.isqr = function isqr(a) {
        return this.imul(a, a.clone());
      };
      Red.prototype.sqr = function sqr(a) {
        return this.mul(a, a);
      };
      Red.prototype.sqrt = function sqrt(a) {
        if (a.isZero())
          return a.clone();
        var mod3 = this.m.andln(3);
        assert(mod3 % 2 === 1);
        if (mod3 === 3) {
          var pow = this.m.add(new BN(1)).iushrn(2);
          return this.pow(a, pow);
        }
        var q = this.m.subn(1);
        var s = 0;
        while (!q.isZero() && q.andln(1) === 0) {
          s++;
          q.iushrn(1);
        }
        assert(!q.isZero());
        var one = new BN(1).toRed(this);
        var nOne = one.redNeg();
        var lpow = this.m.subn(1).iushrn(1);
        var z = this.m.bitLength();
        z = new BN(2 * z * z).toRed(this);
        while (this.pow(z, lpow).cmp(nOne) !== 0) {
          z.redIAdd(nOne);
        }
        var c = this.pow(z, q);
        var r = this.pow(a, q.addn(1).iushrn(1));
        var t = this.pow(a, q);
        var m = s;
        while (t.cmp(one) !== 0) {
          var tmp = t;
          for (var i = 0; tmp.cmp(one) !== 0; i++) {
            tmp = tmp.redSqr();
          }
          assert(i < m);
          var b = this.pow(c, new BN(1).iushln(m - i - 1));
          r = r.redMul(b);
          c = b.redSqr();
          t = t.redMul(c);
          m = i;
        }
        return r;
      };
      Red.prototype.invm = function invm(a) {
        var inv = a._invmp(this.m);
        if (inv.negative !== 0) {
          inv.negative = 0;
          return this.imod(inv).redNeg();
        } else {
          return this.imod(inv);
        }
      };
      Red.prototype.pow = function pow(a, num) {
        if (num.isZero())
          return new BN(1).toRed(this);
        if (num.cmpn(1) === 0)
          return a.clone();
        var windowSize = 4;
        var wnd = new Array(1 << windowSize);
        wnd[0] = new BN(1).toRed(this);
        wnd[1] = a;
        for (var i = 2; i < wnd.length; i++) {
          wnd[i] = this.mul(wnd[i - 1], a);
        }
        var res = wnd[0];
        var current = 0;
        var currentLen = 0;
        var start = num.bitLength() % 26;
        if (start === 0) {
          start = 26;
        }
        for (i = num.length - 1; i >= 0; i--) {
          var word = num.words[i];
          for (var j = start - 1; j >= 0; j--) {
            var bit = word >> j & 1;
            if (res !== wnd[0]) {
              res = this.sqr(res);
            }
            if (bit === 0 && current === 0) {
              currentLen = 0;
              continue;
            }
            current <<= 1;
            current |= bit;
            currentLen++;
            if (currentLen !== windowSize && (i !== 0 || j !== 0))
              continue;
            res = this.mul(res, wnd[current]);
            currentLen = 0;
            current = 0;
          }
          start = 26;
        }
        return res;
      };
      Red.prototype.convertTo = function convertTo(num) {
        var r = num.umod(this.m);
        return r === num ? r.clone() : r;
      };
      Red.prototype.convertFrom = function convertFrom(num) {
        var res = num.clone();
        res.red = null;
        return res;
      };
      BN.mont = function mont(num) {
        return new Mont(num);
      };
      function Mont(m) {
        Red.call(this, m);
        this.shift = this.m.bitLength();
        if (this.shift % 26 !== 0) {
          this.shift += 26 - this.shift % 26;
        }
        this.r = new BN(1).iushln(this.shift);
        this.r2 = this.imod(this.r.sqr());
        this.rinv = this.r._invmp(this.m);
        this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
        this.minv = this.minv.umod(this.r);
        this.minv = this.r.sub(this.minv);
      }
      inherits(Mont, Red);
      Mont.prototype.convertTo = function convertTo(num) {
        return this.imod(num.ushln(this.shift));
      };
      Mont.prototype.convertFrom = function convertFrom(num) {
        var r = this.imod(num.mul(this.rinv));
        r.red = null;
        return r;
      };
      Mont.prototype.imul = function imul(a, b) {
        if (a.isZero() || b.isZero()) {
          a.words[0] = 0;
          a.length = 1;
          return a;
        }
        var t = a.imul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.mul = function mul(a, b) {
        if (a.isZero() || b.isZero())
          return new BN(0)._forceRed(this);
        var t = a.mul(b);
        var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
        var u = t.isub(c).iushrn(this.shift);
        var res = u;
        if (u.cmp(this.m) >= 0) {
          res = u.isub(this.m);
        } else if (u.cmpn(0) < 0) {
          res = u.iadd(this.m);
        }
        return res._forceRed(this);
      };
      Mont.prototype.invm = function invm(a) {
        var res = this.imod(a._invmp(this.m).mul(this.r2));
        return res._forceRed(this);
      };
    })(typeof module2 === "undefined" || module2, exports2);
  }
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "node_modules/minimalistic-assert/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/minimalistic-crypto-utils/lib/utils.js"(exports2) {
    init_node_globals();
    "use strict";
    var utils = exports2;
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg !== "string") {
        for (var i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
        return res;
      }
      if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (var i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      } else {
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          var hi = c >> 8;
          var lo = c & 255;
          if (hi)
            res.push(hi, lo);
          else
            res.push(lo);
        }
      }
      return res;
    }
    utils.toArray = toArray;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    utils.zero2 = zero2;
    function toHex2(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    utils.toHex = toHex2;
    utils.encode = function encode10(arr, enc) {
      if (enc === "hex")
        return toHex2(arr);
      else
        return arr;
    };
  }
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils3 = __commonJS({
  "node_modules/elliptic/lib/elliptic/utils.js"(exports2) {
    init_node_globals();
    "use strict";
    var utils = exports2;
    var BN = require_bn();
    var minAssert = require_minimalistic_assert();
    var minUtils = require_utils2();
    utils.assert = minAssert;
    utils.toArray = minUtils.toArray;
    utils.zero2 = minUtils.zero2;
    utils.toHex = minUtils.toHex;
    utils.encode = minUtils.encode;
    function getNAF(num, w, bits) {
      var naf = new Array(Math.max(num.bitLength(), bits) + 1);
      naf.fill(0);
      var ws = 1 << w + 1;
      var k = num.clone();
      for (var i = 0; i < naf.length; i++) {
        var z;
        var mod2 = k.andln(ws - 1);
        if (k.isOdd()) {
          if (mod2 > (ws >> 1) - 1)
            z = (ws >> 1) - mod2;
          else
            z = mod2;
          k.isubn(z);
        } else {
          z = 0;
        }
        naf[i] = z;
        k.iushrn(1);
      }
      return naf;
    }
    utils.getNAF = getNAF;
    function getJSF(k1, k2) {
      var jsf = [
        [],
        []
      ];
      k1 = k1.clone();
      k2 = k2.clone();
      var d1 = 0;
      var d2 = 0;
      var m8;
      while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
        var m14 = k1.andln(3) + d1 & 3;
        var m24 = k2.andln(3) + d2 & 3;
        if (m14 === 3)
          m14 = -1;
        if (m24 === 3)
          m24 = -1;
        var u1;
        if ((m14 & 1) === 0) {
          u1 = 0;
        } else {
          m8 = k1.andln(7) + d1 & 7;
          if ((m8 === 3 || m8 === 5) && m24 === 2)
            u1 = -m14;
          else
            u1 = m14;
        }
        jsf[0].push(u1);
        var u2;
        if ((m24 & 1) === 0) {
          u2 = 0;
        } else {
          m8 = k2.andln(7) + d2 & 7;
          if ((m8 === 3 || m8 === 5) && m14 === 2)
            u2 = -m24;
          else
            u2 = m24;
        }
        jsf[1].push(u2);
        if (2 * d1 === u1 + 1)
          d1 = 1 - d1;
        if (2 * d2 === u2 + 1)
          d2 = 1 - d2;
        k1.iushrn(1);
        k2.iushrn(1);
      }
      return jsf;
    }
    utils.getJSF = getJSF;
    function cachedProperty(obj, name5, computer) {
      var key = "_" + name5;
      obj.prototype[name5] = function cachedProperty2() {
        return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
      };
    }
    utils.cachedProperty = cachedProperty;
    function parseBytes(bytes3) {
      return typeof bytes3 === "string" ? utils.toArray(bytes3, "hex") : bytes3;
    }
    utils.parseBytes = parseBytes;
    function intFromLE(bytes3) {
      return new BN(bytes3, "hex", "le");
    }
    utils.intFromLE = intFromLE;
  }
});

// node_modules/brorand/index.js
var require_brorand = __commonJS({
  "node_modules/brorand/index.js"(exports2, module2) {
    init_node_globals();
    var r;
    module2.exports = function rand(len) {
      if (!r)
        r = new Rand(null);
      return r.generate(len);
    };
    function Rand(rand) {
      this.rand = rand;
    }
    module2.exports.Rand = Rand;
    Rand.prototype.generate = function generate(len) {
      return this._rand(len);
    };
    Rand.prototype._rand = function _rand(n) {
      if (this.rand.getBytes)
        return this.rand.getBytes(n);
      var res = new Uint8Array(n);
      for (var i = 0; i < res.length; i++)
        res[i] = this.rand.getByte();
      return res;
    };
    if (typeof self === "object") {
      if (self.crypto && self.crypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.crypto.getRandomValues(arr);
          return arr;
        };
      } else if (self.msCrypto && self.msCrypto.getRandomValues) {
        Rand.prototype._rand = function _rand(n) {
          var arr = new Uint8Array(n);
          self.msCrypto.getRandomValues(arr);
          return arr;
        };
      } else if (typeof window === "object") {
        Rand.prototype._rand = function() {
          throw new Error("Not implemented yet");
        };
      }
    } else {
      try {
        crypto3 = require_crypto();
        if (typeof crypto3.randomBytes !== "function")
          throw new Error("Not supported");
        Rand.prototype._rand = function _rand(n) {
          return crypto3.randomBytes(n);
        };
      } catch (e) {
      }
    }
    var crypto3;
  }
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/base.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var getNAF = utils.getNAF;
    var getJSF = utils.getJSF;
    var assert = utils.assert;
    function BaseCurve(type, conf) {
      this.type = type;
      this.p = new BN(conf.p, 16);
      this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.n = conf.n && new BN(conf.n, 16);
      this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
      this._wnafT1 = new Array(4);
      this._wnafT2 = new Array(4);
      this._wnafT3 = new Array(4);
      this._wnafT4 = new Array(4);
      this._bitLength = this.n ? this.n.bitLength() : 0;
      var adjustCount = this.n && this.p.div(this.n);
      if (!adjustCount || adjustCount.cmpn(100) > 0) {
        this.redN = null;
      } else {
        this._maxwellTrick = true;
        this.redN = this.n.toRed(this.red);
      }
    }
    module2.exports = BaseCurve;
    BaseCurve.prototype.point = function point() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype.validate = function validate3() {
      throw new Error("Not implemented");
    };
    BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
      assert(p.precomputed);
      var doubles = p._getDoubles();
      var naf = getNAF(k, 1, this._bitLength);
      var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
      I /= 3;
      var repr = [];
      var j;
      var nafW;
      for (j = 0; j < naf.length; j += doubles.step) {
        nafW = 0;
        for (var l = j + doubles.step - 1; l >= j; l--)
          nafW = (nafW << 1) + naf[l];
        repr.push(nafW);
      }
      var a = this.jpoint(null, null, null);
      var b = this.jpoint(null, null, null);
      for (var i = I; i > 0; i--) {
        for (j = 0; j < repr.length; j++) {
          nafW = repr[j];
          if (nafW === i)
            b = b.mixedAdd(doubles.points[j]);
          else if (nafW === -i)
            b = b.mixedAdd(doubles.points[j].neg());
        }
        a = a.add(b);
      }
      return a.toP();
    };
    BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
      var w = 4;
      var nafPoints = p._getNAFPoints(w);
      w = nafPoints.wnd;
      var wnd = nafPoints.points;
      var naf = getNAF(k, w, this._bitLength);
      var acc = this.jpoint(null, null, null);
      for (var i = naf.length - 1; i >= 0; i--) {
        for (var l = 0; i >= 0 && naf[i] === 0; i--)
          l++;
        if (i >= 0)
          l++;
        acc = acc.dblp(l);
        if (i < 0)
          break;
        var z = naf[i];
        assert(z !== 0);
        if (p.type === "affine") {
          if (z > 0)
            acc = acc.mixedAdd(wnd[z - 1 >> 1]);
          else
            acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
        } else {
          if (z > 0)
            acc = acc.add(wnd[z - 1 >> 1]);
          else
            acc = acc.add(wnd[-z - 1 >> 1].neg());
        }
      }
      return p.type === "affine" ? acc.toP() : acc;
    };
    BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
      var wndWidth = this._wnafT1;
      var wnd = this._wnafT2;
      var naf = this._wnafT3;
      var max = 0;
      var i;
      var j;
      var p;
      for (i = 0; i < len; i++) {
        p = points[i];
        var nafPoints = p._getNAFPoints(defW);
        wndWidth[i] = nafPoints.wnd;
        wnd[i] = nafPoints.points;
      }
      for (i = len - 1; i >= 1; i -= 2) {
        var a = i - 1;
        var b = i;
        if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
          naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
          naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
          max = Math.max(naf[a].length, max);
          max = Math.max(naf[b].length, max);
          continue;
        }
        var comb = [
          points[a],
          null,
          null,
          points[b]
        ];
        if (points[a].y.cmp(points[b].y) === 0) {
          comb[1] = points[a].add(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].add(points[b].neg());
        } else {
          comb[1] = points[a].toJ().mixedAdd(points[b]);
          comb[2] = points[a].toJ().mixedAdd(points[b].neg());
        }
        var index = [
          -3,
          -1,
          -5,
          -7,
          0,
          7,
          5,
          1,
          3
        ];
        var jsf = getJSF(coeffs[a], coeffs[b]);
        max = Math.max(jsf[0].length, max);
        naf[a] = new Array(max);
        naf[b] = new Array(max);
        for (j = 0; j < max; j++) {
          var ja = jsf[0][j] | 0;
          var jb = jsf[1][j] | 0;
          naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
          naf[b][j] = 0;
          wnd[a] = comb;
        }
      }
      var acc = this.jpoint(null, null, null);
      var tmp = this._wnafT4;
      for (i = max; i >= 0; i--) {
        var k = 0;
        while (i >= 0) {
          var zero = true;
          for (j = 0; j < len; j++) {
            tmp[j] = naf[j][i] | 0;
            if (tmp[j] !== 0)
              zero = false;
          }
          if (!zero)
            break;
          k++;
          i--;
        }
        if (i >= 0)
          k++;
        acc = acc.dblp(k);
        if (i < 0)
          break;
        for (j = 0; j < len; j++) {
          var z = tmp[j];
          p;
          if (z === 0)
            continue;
          else if (z > 0)
            p = wnd[j][z - 1 >> 1];
          else if (z < 0)
            p = wnd[j][-z - 1 >> 1].neg();
          if (p.type === "affine")
            acc = acc.mixedAdd(p);
          else
            acc = acc.add(p);
        }
      }
      for (i = 0; i < len; i++)
        wnd[i] = null;
      if (jacobianResult)
        return acc;
      else
        return acc.toP();
    };
    function BasePoint(curve, type) {
      this.curve = curve;
      this.type = type;
      this.precomputed = null;
    }
    BaseCurve.BasePoint = BasePoint;
    BasePoint.prototype.eq = function eq() {
      throw new Error("Not implemented");
    };
    BasePoint.prototype.validate = function validate3() {
      return this.curve.validate(this);
    };
    BaseCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
      bytes3 = utils.toArray(bytes3, enc);
      var len = this.p.byteLength();
      if ((bytes3[0] === 4 || bytes3[0] === 6 || bytes3[0] === 7) && bytes3.length - 1 === 2 * len) {
        if (bytes3[0] === 6)
          assert(bytes3[bytes3.length - 1] % 2 === 0);
        else if (bytes3[0] === 7)
          assert(bytes3[bytes3.length - 1] % 2 === 1);
        var res = this.point(bytes3.slice(1, 1 + len), bytes3.slice(1 + len, 1 + 2 * len));
        return res;
      } else if ((bytes3[0] === 2 || bytes3[0] === 3) && bytes3.length - 1 === len) {
        return this.pointFromX(bytes3.slice(1, 1 + len), bytes3[0] === 3);
      }
      throw new Error("Unknown point format");
    };
    BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
      return this.encode(enc, true);
    };
    BasePoint.prototype._encode = function _encode(compact) {
      var len = this.curve.p.byteLength();
      var x = this.getX().toArray("be", len);
      if (compact)
        return [this.getY().isEven() ? 2 : 3].concat(x);
      return [4].concat(x, this.getY().toArray("be", len));
    };
    BasePoint.prototype.encode = function encode10(enc, compact) {
      return utils.encode(this._encode(compact), enc);
    };
    BasePoint.prototype.precompute = function precompute(power) {
      if (this.precomputed)
        return this;
      var precomputed = {
        doubles: null,
        naf: null,
        beta: null
      };
      precomputed.naf = this._getNAFPoints(8);
      precomputed.doubles = this._getDoubles(4, power);
      precomputed.beta = this._getBeta();
      this.precomputed = precomputed;
      return this;
    };
    BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
      if (!this.precomputed)
        return false;
      var doubles = this.precomputed.doubles;
      if (!doubles)
        return false;
      return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
    };
    BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
      if (this.precomputed && this.precomputed.doubles)
        return this.precomputed.doubles;
      var doubles = [this];
      var acc = this;
      for (var i = 0; i < power; i += step) {
        for (var j = 0; j < step; j++)
          acc = acc.dbl();
        doubles.push(acc);
      }
      return {
        step,
        points: doubles
      };
    };
    BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
      if (this.precomputed && this.precomputed.naf)
        return this.precomputed.naf;
      var res = [this];
      var max = (1 << wnd) - 1;
      var dbl = max === 1 ? null : this.dbl();
      for (var i = 1; i < max; i++)
        res[i] = res[i - 1].add(dbl);
      return {
        wnd,
        points: res
      };
    };
    BasePoint.prototype._getBeta = function _getBeta() {
      return null;
    };
    BasePoint.prototype.dblp = function dblp(k) {
      var r = this;
      for (var i = 0; i < k; i++)
        r = r.dbl();
      return r;
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    init_node_globals();
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      };
    }
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/short.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function ShortCurve(conf) {
      Base.call(this, "short", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.tinv = this.two.redInvm();
      this.zeroA = this.a.fromRed().cmpn(0) === 0;
      this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
      this.endo = this._getEndomorphism(conf);
      this._endoWnafT1 = new Array(4);
      this._endoWnafT2 = new Array(4);
    }
    inherits(ShortCurve, Base);
    module2.exports = ShortCurve;
    ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
      if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
        return;
      var beta;
      var lambda;
      if (conf.beta) {
        beta = new BN(conf.beta, 16).toRed(this.red);
      } else {
        var betas = this._getEndoRoots(this.p);
        beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
        beta = beta.toRed(this.red);
      }
      if (conf.lambda) {
        lambda = new BN(conf.lambda, 16);
      } else {
        var lambdas = this._getEndoRoots(this.n);
        if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
          lambda = lambdas[0];
        } else {
          lambda = lambdas[1];
          assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
        }
      }
      var basis;
      if (conf.basis) {
        basis = conf.basis.map(function(vec) {
          return {
            a: new BN(vec.a, 16),
            b: new BN(vec.b, 16)
          };
        });
      } else {
        basis = this._getEndoBasis(lambda);
      }
      return {
        beta,
        lambda,
        basis
      };
    };
    ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
      var red = num === this.p ? this.red : BN.mont(num);
      var tinv = new BN(2).toRed(red).redInvm();
      var ntinv = tinv.redNeg();
      var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
      var l1 = ntinv.redAdd(s).fromRed();
      var l2 = ntinv.redSub(s).fromRed();
      return [l1, l2];
    };
    ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
      var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
      var u = lambda;
      var v = this.n.clone();
      var x1 = new BN(1);
      var y1 = new BN(0);
      var x2 = new BN(0);
      var y2 = new BN(1);
      var a0;
      var b0;
      var a1;
      var b1;
      var a2;
      var b2;
      var prevR;
      var i = 0;
      var r;
      var x;
      while (u.cmpn(0) !== 0) {
        var q = v.div(u);
        r = v.sub(q.mul(u));
        x = x2.sub(q.mul(x1));
        var y = y2.sub(q.mul(y1));
        if (!a1 && r.cmp(aprxSqrt) < 0) {
          a0 = prevR.neg();
          b0 = x1;
          a1 = r.neg();
          b1 = x;
        } else if (a1 && ++i === 2) {
          break;
        }
        prevR = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
      }
      a2 = r.neg();
      b2 = x;
      var len1 = a1.sqr().add(b1.sqr());
      var len2 = a2.sqr().add(b2.sqr());
      if (len2.cmp(len1) >= 0) {
        a2 = a0;
        b2 = b0;
      }
      if (a1.negative) {
        a1 = a1.neg();
        b1 = b1.neg();
      }
      if (a2.negative) {
        a2 = a2.neg();
        b2 = b2.neg();
      }
      return [
        { a: a1, b: b1 },
        { a: a2, b: b2 }
      ];
    };
    ShortCurve.prototype._endoSplit = function _endoSplit(k) {
      var basis = this.endo.basis;
      var v1 = basis[0];
      var v2 = basis[1];
      var c1 = v2.b.mul(k).divRound(this.n);
      var c2 = v1.b.neg().mul(k).divRound(this.n);
      var p1 = c1.mul(v1.a);
      var p2 = c2.mul(v2.a);
      var q1 = c1.mul(v1.b);
      var q2 = c2.mul(v2.b);
      var k1 = k.sub(p1).sub(p2);
      var k2 = q1.add(q2).neg();
      return { k1, k2 };
    };
    ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    ShortCurve.prototype.validate = function validate3(point) {
      if (point.inf)
        return true;
      var x = point.x;
      var y = point.y;
      var ax = this.a.redMul(x);
      var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
      return y.redSqr().redISub(rhs).cmpn(0) === 0;
    };
    ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();
        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }
        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };
    function Point(curve, x, y, isRed) {
      Base.BasePoint.call(this, curve, "affine");
      if (x === null && y === null) {
        this.x = null;
        this.y = null;
        this.inf = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        if (isRed) {
          this.x.forceRed(this.curve.red);
          this.y.forceRed(this.curve.red);
        }
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        this.inf = false;
      }
    }
    inherits(Point, Base.BasePoint);
    ShortCurve.prototype.point = function point(x, y, isRed) {
      return new Point(this, x, y, isRed);
    };
    ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
      return Point.fromJSON(this, obj, red);
    };
    Point.prototype._getBeta = function _getBeta() {
      if (!this.curve.endo)
        return;
      var pre = this.precomputed;
      if (pre && pre.beta)
        return pre.beta;
      var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (pre) {
        var curve = this.curve;
        var endoMul = function(p) {
          return curve.point(p.x.redMul(curve.endo.beta), p.y);
        };
        pre.beta = beta;
        beta.precomputed = {
          beta: null,
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(endoMul)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(endoMul)
          }
        };
      }
      return beta;
    };
    Point.prototype.toJSON = function toJSON() {
      if (!this.precomputed)
        return [this.x, this.y];
      return [this.x, this.y, this.precomputed && {
        doubles: this.precomputed.doubles && {
          step: this.precomputed.doubles.step,
          points: this.precomputed.doubles.points.slice(1)
        },
        naf: this.precomputed.naf && {
          wnd: this.precomputed.naf.wnd,
          points: this.precomputed.naf.points.slice(1)
        }
      }];
    };
    Point.fromJSON = function fromJSON(curve, obj, red) {
      if (typeof obj === "string")
        obj = JSON.parse(obj);
      var res = curve.point(obj[0], obj[1], red);
      if (!obj[2])
        return res;
      function obj2point(obj2) {
        return curve.point(obj2[0], obj2[1], red);
      }
      var pre = obj[2];
      res.precomputed = {
        beta: null,
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: [res].concat(pre.doubles.points.map(obj2point))
        },
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: [res].concat(pre.naf.points.map(obj2point))
        }
      };
      return res;
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.inf;
    };
    Point.prototype.add = function add(p) {
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.eq(p))
        return this.dbl();
      if (this.neg().eq(p))
        return this.curve.point(null, null);
      if (this.x.cmp(p.x) === 0)
        return this.curve.point(null, null);
      var c = this.y.redSub(p.y);
      if (c.cmpn(0) !== 0)
        c = c.redMul(this.x.redSub(p.x).redInvm());
      var nx = c.redSqr().redISub(this.x).redISub(p.x);
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.dbl = function dbl() {
      if (this.inf)
        return this;
      var ys1 = this.y.redAdd(this.y);
      if (ys1.cmpn(0) === 0)
        return this.curve.point(null, null);
      var a = this.curve.a;
      var x2 = this.x.redSqr();
      var dyinv = ys1.redInvm();
      var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
      var nx = c.redSqr().redISub(this.x.redAdd(this.x));
      var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    };
    Point.prototype.getX = function getX() {
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      return this.y.fromRed();
    };
    Point.prototype.mul = function mul(k) {
      k = new BN(k, 16);
      if (this.isInfinity())
        return this;
      else if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else if (this.curve.endo)
        return this.curve._endoWnafMulAdd([this], [k]);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
      var points = [this, p2];
      var coeffs = [k1, k2];
      if (this.curve.endo)
        return this.curve._endoWnafMulAdd(points, coeffs, true);
      else
        return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
    };
    Point.prototype.eq = function eq(p) {
      return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
    };
    Point.prototype.neg = function neg(_precompute) {
      if (this.inf)
        return this;
      var res = this.curve.point(this.x, this.y.redNeg());
      if (_precompute && this.precomputed) {
        var pre = this.precomputed;
        var negate = function(p) {
          return p.neg();
        };
        res.precomputed = {
          naf: pre.naf && {
            wnd: pre.naf.wnd,
            points: pre.naf.points.map(negate)
          },
          doubles: pre.doubles && {
            step: pre.doubles.step,
            points: pre.doubles.points.map(negate)
          }
        };
      }
      return res;
    };
    Point.prototype.toJ = function toJ() {
      if (this.inf)
        return this.curve.jpoint(null, null, null);
      var res = this.curve.jpoint(this.x, this.y, this.curve.one);
      return res;
    };
    function JPoint(curve, x, y, z) {
      Base.BasePoint.call(this, curve, "jacobian");
      if (x === null && y === null && z === null) {
        this.x = this.curve.one;
        this.y = this.curve.one;
        this.z = new BN(0);
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = new BN(z, 16);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
    }
    inherits(JPoint, Base.BasePoint);
    ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    };
    JPoint.prototype.toP = function toP() {
      if (this.isInfinity())
        return this.curve.point(null, null);
      var zinv = this.z.redInvm();
      var zinv2 = zinv.redSqr();
      var ax = this.x.redMul(zinv2);
      var ay = this.y.redMul(zinv2).redMul(zinv);
      return this.curve.point(ax, ay);
    };
    JPoint.prototype.neg = function neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    };
    JPoint.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      var pz2 = p.z.redSqr();
      var z2 = this.z.redSqr();
      var u1 = this.x.redMul(pz2);
      var u2 = p.x.redMul(z2);
      var s1 = this.y.redMul(pz2.redMul(p.z));
      var s2 = p.y.redMul(z2.redMul(this.z));
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mixedAdd = function mixedAdd(p) {
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      var z2 = this.z.redSqr();
      var u1 = this.x;
      var u2 = p.x.redMul(z2);
      var s1 = this.y;
      var s2 = p.y.redMul(z2).redMul(this.z);
      var h = u1.redSub(u2);
      var r = s1.redSub(s2);
      if (h.cmpn(0) === 0) {
        if (r.cmpn(0) !== 0)
          return this.curve.jpoint(null, null, null);
        else
          return this.dbl();
      }
      var h2 = h.redSqr();
      var h3 = h2.redMul(h);
      var v = u1.redMul(h2);
      var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
      var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
      var nz = this.z.redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.dblp = function dblp(pow) {
      if (pow === 0)
        return this;
      if (this.isInfinity())
        return this;
      if (!pow)
        return this.dbl();
      var i;
      if (this.curve.zeroA || this.curve.threeA) {
        var r = this;
        for (i = 0; i < pow; i++)
          r = r.dbl();
        return r;
      }
      var a = this.curve.a;
      var tinv = this.curve.tinv;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jyd = jy.redAdd(jy);
      for (i = 0; i < pow; i++) {
        var jx2 = jx.redSqr();
        var jyd2 = jyd.redSqr();
        var jyd4 = jyd2.redSqr();
        var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
        var t1 = jx.redMul(jyd2);
        var nx = c.redSqr().redISub(t1.redAdd(t1));
        var t2 = t1.redISub(nx);
        var dny = c.redMul(t2);
        dny = dny.redIAdd(dny).redISub(jyd4);
        var nz = jyd.redMul(jz);
        if (i + 1 < pow)
          jz4 = jz4.redMul(jyd4);
        jx = nx;
        jz = nz;
        jyd = dny;
      }
      return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
    };
    JPoint.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.zeroA)
        return this._zeroDbl();
      else if (this.curve.threeA)
        return this._threeDbl();
      else
        return this._dbl();
    };
    JPoint.prototype._zeroDbl = function _zeroDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx);
        var t = m.redSqr().redISub(s).redISub(s);
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        nx = t;
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var a = this.x.redSqr();
        var b = this.y.redSqr();
        var c = b.redSqr();
        var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
        d = d.redIAdd(d);
        var e = a.redAdd(a).redIAdd(a);
        var f = e.redSqr();
        var c8 = c.redIAdd(c);
        c8 = c8.redIAdd(c8);
        c8 = c8.redIAdd(c8);
        nx = f.redISub(d).redISub(d);
        ny = e.redMul(d.redISub(nx)).redISub(c8);
        nz = this.y.redMul(this.z);
        nz = nz.redIAdd(nz);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._threeDbl = function _threeDbl() {
      var nx;
      var ny;
      var nz;
      if (this.zOne) {
        var xx = this.x.redSqr();
        var yy = this.y.redSqr();
        var yyyy = yy.redSqr();
        var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
        s = s.redIAdd(s);
        var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
        var t = m.redSqr().redISub(s).redISub(s);
        nx = t;
        var yyyy8 = yyyy.redIAdd(yyyy);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        yyyy8 = yyyy8.redIAdd(yyyy8);
        ny = m.redMul(s.redISub(t)).redISub(yyyy8);
        nz = this.y.redAdd(this.y);
      } else {
        var delta = this.z.redSqr();
        var gamma = this.y.redSqr();
        var beta = this.x.redMul(gamma);
        var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
        alpha = alpha.redAdd(alpha).redIAdd(alpha);
        var beta4 = beta.redIAdd(beta);
        beta4 = beta4.redIAdd(beta4);
        var beta8 = beta4.redAdd(beta4);
        nx = alpha.redSqr().redISub(beta8);
        nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
        var ggamma8 = gamma.redSqr();
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ggamma8 = ggamma8.redIAdd(ggamma8);
        ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
      }
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype._dbl = function _dbl() {
      var a = this.curve.a;
      var jx = this.x;
      var jy = this.y;
      var jz = this.z;
      var jz4 = jz.redSqr().redSqr();
      var jx2 = jx.redSqr();
      var jy2 = jy.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var jxd4 = jx.redAdd(jx);
      jxd4 = jxd4.redIAdd(jxd4);
      var t1 = jxd4.redMul(jy2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var jyd8 = jy2.redSqr();
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      jyd8 = jyd8.redIAdd(jyd8);
      var ny = c.redMul(t2).redISub(jyd8);
      var nz = jy.redAdd(jy).redMul(jz);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.trpl = function trpl() {
      if (!this.curve.zeroA)
        return this.dbl().add(this);
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var zz = this.z.redSqr();
      var yyyy = yy.redSqr();
      var m = xx.redAdd(xx).redIAdd(xx);
      var mm = m.redSqr();
      var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      e = e.redIAdd(e);
      e = e.redAdd(e).redIAdd(e);
      e = e.redISub(mm);
      var ee = e.redSqr();
      var t = yyyy.redIAdd(yyyy);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      t = t.redIAdd(t);
      var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
      var yyu4 = yy.redMul(u);
      yyu4 = yyu4.redIAdd(yyu4);
      yyu4 = yyu4.redIAdd(yyu4);
      var nx = this.x.redMul(ee).redISub(yyu4);
      nx = nx.redIAdd(nx);
      nx = nx.redIAdd(nx);
      var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      ny = ny.redIAdd(ny);
      var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
      return this.curve.jpoint(nx, ny, nz);
    };
    JPoint.prototype.mul = function mul(k, kbase) {
      k = new BN(k, kbase);
      return this.curve._wnafMul(this, k);
    };
    JPoint.prototype.eq = function eq(p) {
      if (p.type === "affine")
        return this.eq(p.toJ());
      if (this === p)
        return true;
      var z2 = this.z.redSqr();
      var pz2 = p.z.redSqr();
      if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
        return false;
      var z3 = z2.redMul(this.z);
      var pz3 = pz2.redMul(p.z);
      return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
    };
    JPoint.prototype.eqXToP = function eqXToP(x) {
      var zs = this.z.redSqr();
      var rx = x.toRed(this.curve.red).redMul(zs);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(zs);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    JPoint.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC JPoint Infinity>";
      return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
    };
    JPoint.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/mont.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var utils = require_utils3();
    function MontCurve(conf) {
      Base.call(this, "mont", conf);
      this.a = new BN(conf.a, 16).toRed(this.red);
      this.b = new BN(conf.b, 16).toRed(this.red);
      this.i4 = new BN(4).toRed(this.red).redInvm();
      this.two = new BN(2).toRed(this.red);
      this.a24 = this.i4.redMul(this.a.redAdd(this.two));
    }
    inherits(MontCurve, Base);
    module2.exports = MontCurve;
    MontCurve.prototype.validate = function validate3(point) {
      var x = point.normalize().x;
      var x2 = x.redSqr();
      var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
      var y = rhs.redSqrt();
      return y.redSqr().cmp(rhs) === 0;
    };
    function Point(curve, x, z) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && z === null) {
        this.x = this.curve.one;
        this.z = this.curve.zero;
      } else {
        this.x = new BN(x, 16);
        this.z = new BN(z, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
      }
    }
    inherits(Point, Base.BasePoint);
    MontCurve.prototype.decodePoint = function decodePoint(bytes3, enc) {
      return this.point(utils.toArray(bytes3, enc), 1);
    };
    MontCurve.prototype.point = function point(x, z) {
      return new Point(this, x, z);
    };
    MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    Point.prototype.precompute = function precompute() {
    };
    Point.prototype._encode = function _encode() {
      return this.getX().toArray("be", this.curve.p.byteLength());
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1] || curve.one);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.z.cmpn(0) === 0;
    };
    Point.prototype.dbl = function dbl() {
      var a = this.x.redAdd(this.z);
      var aa = a.redSqr();
      var b = this.x.redSub(this.z);
      var bb = b.redSqr();
      var c = aa.redSub(bb);
      var nx = aa.redMul(bb);
      var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
      return this.curve.point(nx, nz);
    };
    Point.prototype.add = function add() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.diffAdd = function diffAdd(p, diff) {
      var a = this.x.redAdd(this.z);
      var b = this.x.redSub(this.z);
      var c = p.x.redAdd(p.z);
      var d = p.x.redSub(p.z);
      var da = d.redMul(a);
      var cb = c.redMul(b);
      var nx = diff.z.redMul(da.redAdd(cb).redSqr());
      var nz = diff.x.redMul(da.redISub(cb).redSqr());
      return this.curve.point(nx, nz);
    };
    Point.prototype.mul = function mul(k) {
      var t = k.clone();
      var a = this;
      var b = this.curve.point(null, null);
      var c = this;
      for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
        bits.push(t.andln(1));
      for (var i = bits.length - 1; i >= 0; i--) {
        if (bits[i] === 0) {
          a = a.diffAdd(b, c);
          b = b.dbl();
        } else {
          b = a.diffAdd(b, c);
          a = a.dbl();
        }
      }
      return b;
    };
    Point.prototype.mulAdd = function mulAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.jumlAdd = function jumlAdd() {
      throw new Error("Not supported on Montgomery curve");
    };
    Point.prototype.eq = function eq(other) {
      return this.getX().cmp(other.getX()) === 0;
    };
    Point.prototype.normalize = function normalize() {
      this.x = this.x.redMul(this.z.redInvm());
      this.z = this.curve.one;
      return this;
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/edwards.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils3();
    var BN = require_bn();
    var inherits = require_inherits_browser();
    var Base = require_base();
    var assert = utils.assert;
    function EdwardsCurve(conf) {
      this.twisted = (conf.a | 0) !== 1;
      this.mOneA = this.twisted && (conf.a | 0) === -1;
      this.extended = this.mOneA;
      Base.call(this, "edwards", conf);
      this.a = new BN(conf.a, 16).umod(this.red.m);
      this.a = this.a.toRed(this.red);
      this.c = new BN(conf.c, 16).toRed(this.red);
      this.c2 = this.c.redSqr();
      this.d = new BN(conf.d, 16).toRed(this.red);
      this.dd = this.d.redAdd(this.d);
      assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
      this.oneC = (conf.c | 0) === 1;
    }
    inherits(EdwardsCurve, Base);
    module2.exports = EdwardsCurve;
    EdwardsCurve.prototype._mulA = function _mulA(num) {
      if (this.mOneA)
        return num.redNeg();
      else
        return this.a.redMul(num);
    };
    EdwardsCurve.prototype._mulC = function _mulC(num) {
      if (this.oneC)
        return num;
      else
        return this.c.redMul(num);
    };
    EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
      return this.point(x, y, z, t);
    };
    EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
      x = new BN(x, 16);
      if (!x.red)
        x = x.toRed(this.red);
      var x2 = x.redSqr();
      var rhs = this.c2.redSub(this.a.redMul(x2));
      var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
      var y2 = rhs.redMul(lhs.redInvm());
      var y = y2.redSqrt();
      if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      var isOdd = y.fromRed().isOdd();
      if (odd && !isOdd || !odd && isOdd)
        y = y.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
      y = new BN(y, 16);
      if (!y.red)
        y = y.toRed(this.red);
      var y2 = y.redSqr();
      var lhs = y2.redSub(this.c2);
      var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
      var x2 = lhs.redMul(rhs.redInvm());
      if (x2.cmp(this.zero) === 0) {
        if (odd)
          throw new Error("invalid point");
        else
          return this.point(this.zero, y);
      }
      var x = x2.redSqrt();
      if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
        throw new Error("invalid point");
      if (x.fromRed().isOdd() !== odd)
        x = x.redNeg();
      return this.point(x, y);
    };
    EdwardsCurve.prototype.validate = function validate3(point) {
      if (point.isInfinity())
        return true;
      point.normalize();
      var x2 = point.x.redSqr();
      var y2 = point.y.redSqr();
      var lhs = x2.redMul(this.a).redAdd(y2);
      var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
      return lhs.cmp(rhs) === 0;
    };
    function Point(curve, x, y, z, t) {
      Base.BasePoint.call(this, curve, "projective");
      if (x === null && y === null && z === null) {
        this.x = this.curve.zero;
        this.y = this.curve.one;
        this.z = this.curve.one;
        this.t = this.curve.zero;
        this.zOne = true;
      } else {
        this.x = new BN(x, 16);
        this.y = new BN(y, 16);
        this.z = z ? new BN(z, 16) : this.curve.one;
        this.t = t && new BN(t, 16);
        if (!this.x.red)
          this.x = this.x.toRed(this.curve.red);
        if (!this.y.red)
          this.y = this.y.toRed(this.curve.red);
        if (!this.z.red)
          this.z = this.z.toRed(this.curve.red);
        if (this.t && !this.t.red)
          this.t = this.t.toRed(this.curve.red);
        this.zOne = this.z === this.curve.one;
        if (this.curve.extended && !this.t) {
          this.t = this.x.redMul(this.y);
          if (!this.zOne)
            this.t = this.t.redMul(this.z.redInvm());
        }
      }
    }
    inherits(Point, Base.BasePoint);
    EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
      return Point.fromJSON(this, obj);
    };
    EdwardsCurve.prototype.point = function point(x, y, z, t) {
      return new Point(this, x, y, z, t);
    };
    Point.fromJSON = function fromJSON(curve, obj) {
      return new Point(curve, obj[0], obj[1], obj[2]);
    };
    Point.prototype.inspect = function inspect() {
      if (this.isInfinity())
        return "<EC Point Infinity>";
      return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
    };
    Point.prototype.isInfinity = function isInfinity() {
      return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
    };
    Point.prototype._extDbl = function _extDbl() {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = this.z.redSqr();
      c = c.redIAdd(c);
      var d = this.curve._mulA(a);
      var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      var g = d.redAdd(b);
      var f = g.redSub(c);
      var h = d.redSub(b);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projDbl = function _projDbl() {
      var b = this.x.redAdd(this.y).redSqr();
      var c = this.x.redSqr();
      var d = this.y.redSqr();
      var nx;
      var ny;
      var nz;
      var e;
      var h;
      var j;
      if (this.curve.twisted) {
        e = this.curve._mulA(c);
        var f = e.redAdd(d);
        if (this.zOne) {
          nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
          ny = f.redMul(e.redSub(d));
          nz = f.redSqr().redSub(f).redSub(f);
        } else {
          h = this.z.redSqr();
          j = f.redSub(h).redISub(h);
          nx = b.redSub(c).redISub(d).redMul(j);
          ny = f.redMul(e.redSub(d));
          nz = f.redMul(j);
        }
      } else {
        e = c.redAdd(d);
        h = this.curve._mulC(this.z).redSqr();
        j = e.redSub(h).redSub(h);
        nx = this.curve._mulC(b.redISub(e)).redMul(j);
        ny = this.curve._mulC(e).redMul(c.redISub(d));
        nz = e.redMul(j);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.dbl = function dbl() {
      if (this.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extDbl();
      else
        return this._projDbl();
    };
    Point.prototype._extAdd = function _extAdd(p) {
      var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      var c = this.t.redMul(this.curve.dd).redMul(p.t);
      var d = this.z.redMul(p.z.redAdd(p.z));
      var e = b.redSub(a);
      var f = d.redSub(c);
      var g = d.redAdd(c);
      var h = b.redAdd(a);
      var nx = e.redMul(f);
      var ny = g.redMul(h);
      var nt = e.redMul(h);
      var nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    };
    Point.prototype._projAdd = function _projAdd(p) {
      var a = this.z.redMul(p.z);
      var b = a.redSqr();
      var c = this.x.redMul(p.x);
      var d = this.y.redMul(p.y);
      var e = this.curve.d.redMul(c).redMul(d);
      var f = b.redSub(e);
      var g = b.redAdd(e);
      var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
      var nx = a.redMul(f).redMul(tmp);
      var ny;
      var nz;
      if (this.curve.twisted) {
        ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
        nz = f.redMul(g);
      } else {
        ny = a.redMul(g).redMul(d.redSub(c));
        nz = this.curve._mulC(f).redMul(g);
      }
      return this.curve.point(nx, ny, nz);
    };
    Point.prototype.add = function add(p) {
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.curve.extended)
        return this._extAdd(p);
      else
        return this._projAdd(p);
    };
    Point.prototype.mul = function mul(k) {
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      else
        return this.curve._wnafMul(this, k);
    };
    Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
    };
    Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
      return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
    };
    Point.prototype.normalize = function normalize() {
      if (this.zOne)
        return this;
      var zi = this.z.redInvm();
      this.x = this.x.redMul(zi);
      this.y = this.y.redMul(zi);
      if (this.t)
        this.t = this.t.redMul(zi);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    };
    Point.prototype.neg = function neg() {
      return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
    };
    Point.prototype.getX = function getX() {
      this.normalize();
      return this.x.fromRed();
    };
    Point.prototype.getY = function getY() {
      this.normalize();
      return this.y.fromRed();
    };
    Point.prototype.eq = function eq(other) {
      return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
    };
    Point.prototype.eqXToP = function eqXToP(x) {
      var rx = x.toRed(this.curve.red).redMul(this.z);
      if (this.x.cmp(rx) === 0)
        return true;
      var xc = x.clone();
      var t = this.curve.redN.redMul(this.z);
      for (; ; ) {
        xc.iadd(this.curve.n);
        if (xc.cmp(this.curve.p) >= 0)
          return false;
        rx.redIAdd(t);
        if (this.x.cmp(rx) === 0)
          return true;
      }
    };
    Point.prototype.toP = Point.prototype.normalize;
    Point.prototype.mixedAdd = Point.prototype.add;
  }
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS({
  "node_modules/elliptic/lib/elliptic/curve/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var curve = exports2;
    curve.base = require_base();
    curve.short = require_short();
    curve.mont = require_mont();
    curve.edwards = require_edwards();
  }
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils4 = __commonJS({
  "node_modules/hash.js/lib/hash/utils.js"(exports2) {
    init_node_globals();
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits_browser();
    exports2.inherits = inherits;
    function isSurrogatePair(msg, i) {
      if ((msg.charCodeAt(i) & 64512) !== 55296) {
        return false;
      }
      if (i < 0 || i + 1 >= msg.length) {
        return false;
      }
      return (msg.charCodeAt(i + 1) & 64512) === 56320;
    }
    function toArray(msg, enc) {
      if (Array.isArray(msg))
        return msg.slice();
      if (!msg)
        return [];
      var res = [];
      if (typeof msg === "string") {
        if (!enc) {
          var p = 0;
          for (var i = 0; i < msg.length; i++) {
            var c = msg.charCodeAt(i);
            if (c < 128) {
              res[p++] = c;
            } else if (c < 2048) {
              res[p++] = c >> 6 | 192;
              res[p++] = c & 63 | 128;
            } else if (isSurrogatePair(msg, i)) {
              c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
              res[p++] = c >> 18 | 240;
              res[p++] = c >> 12 & 63 | 128;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            } else {
              res[p++] = c >> 12 | 224;
              res[p++] = c >> 6 & 63 | 128;
              res[p++] = c & 63 | 128;
            }
          }
        } else if (enc === "hex") {
          msg = msg.replace(/[^a-z0-9]+/ig, "");
          if (msg.length % 2 !== 0)
            msg = "0" + msg;
          for (i = 0; i < msg.length; i += 2)
            res.push(parseInt(msg[i] + msg[i + 1], 16));
        }
      } else {
        for (i = 0; i < msg.length; i++)
          res[i] = msg[i] | 0;
      }
      return res;
    }
    exports2.toArray = toArray;
    function toHex2(msg) {
      var res = "";
      for (var i = 0; i < msg.length; i++)
        res += zero2(msg[i].toString(16));
      return res;
    }
    exports2.toHex = toHex2;
    function htonl(w) {
      var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
      return res >>> 0;
    }
    exports2.htonl = htonl;
    function toHex32(msg, endian) {
      var res = "";
      for (var i = 0; i < msg.length; i++) {
        var w = msg[i];
        if (endian === "little")
          w = htonl(w);
        res += zero8(w.toString(16));
      }
      return res;
    }
    exports2.toHex32 = toHex32;
    function zero2(word) {
      if (word.length === 1)
        return "0" + word;
      else
        return word;
    }
    exports2.zero2 = zero2;
    function zero8(word) {
      if (word.length === 7)
        return "0" + word;
      else if (word.length === 6)
        return "00" + word;
      else if (word.length === 5)
        return "000" + word;
      else if (word.length === 4)
        return "0000" + word;
      else if (word.length === 3)
        return "00000" + word;
      else if (word.length === 2)
        return "000000" + word;
      else if (word.length === 1)
        return "0000000" + word;
      else
        return word;
    }
    exports2.zero8 = zero8;
    function join32(msg, start, end, endian) {
      var len = end - start;
      assert(len % 4 === 0);
      var res = new Array(len / 4);
      for (var i = 0, k = start; i < res.length; i++, k += 4) {
        var w;
        if (endian === "big")
          w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
        else
          w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
        res[i] = w >>> 0;
      }
      return res;
    }
    exports2.join32 = join32;
    function split32(msg, endian) {
      var res = new Array(msg.length * 4);
      for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
        var m = msg[i];
        if (endian === "big") {
          res[k] = m >>> 24;
          res[k + 1] = m >>> 16 & 255;
          res[k + 2] = m >>> 8 & 255;
          res[k + 3] = m & 255;
        } else {
          res[k + 3] = m >>> 24;
          res[k + 2] = m >>> 16 & 255;
          res[k + 1] = m >>> 8 & 255;
          res[k] = m & 255;
        }
      }
      return res;
    }
    exports2.split32 = split32;
    function rotr32(w, b) {
      return w >>> b | w << 32 - b;
    }
    exports2.rotr32 = rotr32;
    function rotl32(w, b) {
      return w << b | w >>> 32 - b;
    }
    exports2.rotl32 = rotl32;
    function sum32(a, b) {
      return a + b >>> 0;
    }
    exports2.sum32 = sum32;
    function sum32_3(a, b, c) {
      return a + b + c >>> 0;
    }
    exports2.sum32_3 = sum32_3;
    function sum32_4(a, b, c, d) {
      return a + b + c + d >>> 0;
    }
    exports2.sum32_4 = sum32_4;
    function sum32_5(a, b, c, d, e) {
      return a + b + c + d + e >>> 0;
    }
    exports2.sum32_5 = sum32_5;
    function sum64(buf2, pos, ah, al) {
      var bh = buf2[pos];
      var bl = buf2[pos + 1];
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      buf2[pos] = hi >>> 0;
      buf2[pos + 1] = lo;
    }
    exports2.sum64 = sum64;
    function sum64_hi(ah, al, bh, bl) {
      var lo = al + bl >>> 0;
      var hi = (lo < al ? 1 : 0) + ah + bh;
      return hi >>> 0;
    }
    exports2.sum64_hi = sum64_hi;
    function sum64_lo(ah, al, bh, bl) {
      var lo = al + bl;
      return lo >>> 0;
    }
    exports2.sum64_lo = sum64_lo;
    function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      var hi = ah + bh + ch + dh + carry;
      return hi >>> 0;
    }
    exports2.sum64_4_hi = sum64_4_hi;
    function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
      var lo = al + bl + cl + dl;
      return lo >>> 0;
    }
    exports2.sum64_4_lo = sum64_4_lo;
    function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var carry = 0;
      var lo = al;
      lo = lo + bl >>> 0;
      carry += lo < al ? 1 : 0;
      lo = lo + cl >>> 0;
      carry += lo < cl ? 1 : 0;
      lo = lo + dl >>> 0;
      carry += lo < dl ? 1 : 0;
      lo = lo + el >>> 0;
      carry += lo < el ? 1 : 0;
      var hi = ah + bh + ch + dh + eh + carry;
      return hi >>> 0;
    }
    exports2.sum64_5_hi = sum64_5_hi;
    function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
      var lo = al + bl + cl + dl + el;
      return lo >>> 0;
    }
    exports2.sum64_5_lo = sum64_5_lo;
    function rotr64_hi(ah, al, num) {
      var r = al << 32 - num | ah >>> num;
      return r >>> 0;
    }
    exports2.rotr64_hi = rotr64_hi;
    function rotr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.rotr64_lo = rotr64_lo;
    function shr64_hi(ah, al, num) {
      return ah >>> num;
    }
    exports2.shr64_hi = shr64_hi;
    function shr64_lo(ah, al, num) {
      var r = ah << 32 - num | al >>> num;
      return r >>> 0;
    }
    exports2.shr64_lo = shr64_lo;
  }
});

// node_modules/hash.js/lib/hash/common.js
var require_common2 = __commonJS({
  "node_modules/hash.js/lib/hash/common.js"(exports2) {
    init_node_globals();
    "use strict";
    var utils = require_utils4();
    var assert = require_minimalistic_assert();
    function BlockHash() {
      this.pending = null;
      this.pendingTotal = 0;
      this.blockSize = this.constructor.blockSize;
      this.outSize = this.constructor.outSize;
      this.hmacStrength = this.constructor.hmacStrength;
      this.padLength = this.constructor.padLength / 8;
      this.endian = "big";
      this._delta8 = this.blockSize / 8;
      this._delta32 = this.blockSize / 32;
    }
    exports2.BlockHash = BlockHash;
    BlockHash.prototype.update = function update(msg, enc) {
      msg = utils.toArray(msg, enc);
      if (!this.pending)
        this.pending = msg;
      else
        this.pending = this.pending.concat(msg);
      this.pendingTotal += msg.length;
      if (this.pending.length >= this._delta8) {
        msg = this.pending;
        var r = msg.length % this._delta8;
        this.pending = msg.slice(msg.length - r, msg.length);
        if (this.pending.length === 0)
          this.pending = null;
        msg = utils.join32(msg, 0, msg.length - r, this.endian);
        for (var i = 0; i < msg.length; i += this._delta32)
          this._update(msg, i, i + this._delta32);
      }
      return this;
    };
    BlockHash.prototype.digest = function digest(enc) {
      this.update(this._pad());
      assert(this.pending === null);
      return this._digest(enc);
    };
    BlockHash.prototype._pad = function pad() {
      var len = this.pendingTotal;
      var bytes3 = this._delta8;
      var k = bytes3 - (len + this.padLength) % bytes3;
      var res = new Array(k + this.padLength);
      res[0] = 128;
      for (var i = 1; i < k; i++)
        res[i] = 0;
      len <<= 3;
      if (this.endian === "big") {
        for (var t = 8; t < this.padLength; t++)
          res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = len >>> 24 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len & 255;
      } else {
        res[i++] = len & 255;
        res[i++] = len >>> 8 & 255;
        res[i++] = len >>> 16 & 255;
        res[i++] = len >>> 24 & 255;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        res[i++] = 0;
        for (t = 8; t < this.padLength; t++)
          res[i++] = 0;
      }
      return res;
    };
  }
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/common.js"(exports2) {
    init_node_globals();
    "use strict";
    var utils = require_utils4();
    var rotr32 = utils.rotr32;
    function ft_1(s, x, y, z) {
      if (s === 0)
        return ch32(x, y, z);
      if (s === 1 || s === 3)
        return p32(x, y, z);
      if (s === 2)
        return maj32(x, y, z);
    }
    exports2.ft_1 = ft_1;
    function ch32(x, y, z) {
      return x & y ^ ~x & z;
    }
    exports2.ch32 = ch32;
    function maj32(x, y, z) {
      return x & y ^ x & z ^ y & z;
    }
    exports2.maj32 = maj32;
    function p32(x, y, z) {
      return x ^ y ^ z;
    }
    exports2.p32 = p32;
    function s0_256(x) {
      return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
    }
    exports2.s0_256 = s0_256;
    function s1_256(x) {
      return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
    }
    exports2.s1_256 = s1_256;
    function g0_256(x) {
      return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
    }
    exports2.g0_256 = g0_256;
    function g1_256(x) {
      return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
    }
    exports2.g1_256 = g1_256;
  }
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS({
  "node_modules/hash.js/lib/hash/sha/1.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils4();
    var common = require_common2();
    var shaCommon = require_common3();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_5 = utils.sum32_5;
    var ft_1 = shaCommon.ft_1;
    var BlockHash = common.BlockHash;
    var sha1_K = [
      1518500249,
      1859775393,
      2400959708,
      3395469782
    ];
    function SHA1() {
      if (!(this instanceof SHA1))
        return new SHA1();
      BlockHash.call(this);
      this.h = [
        1732584193,
        4023233417,
        2562383102,
        271733878,
        3285377520
      ];
      this.W = new Array(80);
    }
    utils.inherits(SHA1, BlockHash);
    module2.exports = SHA1;
    SHA1.blockSize = 512;
    SHA1.outSize = 160;
    SHA1.hmacStrength = 80;
    SHA1.padLength = 64;
    SHA1.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      for (i = 0; i < W.length; i++) {
        var s = ~~(i / 20);
        var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
        e = d;
        d = c;
        c = rotl32(b, 30);
        b = a;
        a = t;
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
    };
    SHA1.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/256.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils4();
    var common = require_common2();
    var shaCommon = require_common3();
    var assert = require_minimalistic_assert();
    var sum32 = utils.sum32;
    var sum32_4 = utils.sum32_4;
    var sum32_5 = utils.sum32_5;
    var ch32 = shaCommon.ch32;
    var maj32 = shaCommon.maj32;
    var s0_256 = shaCommon.s0_256;
    var s1_256 = shaCommon.s1_256;
    var g0_256 = shaCommon.g0_256;
    var g1_256 = shaCommon.g1_256;
    var BlockHash = common.BlockHash;
    var sha256_K = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    function SHA256() {
      if (!(this instanceof SHA256))
        return new SHA256();
      BlockHash.call(this);
      this.h = [
        1779033703,
        3144134277,
        1013904242,
        2773480762,
        1359893119,
        2600822924,
        528734635,
        1541459225
      ];
      this.k = sha256_K;
      this.W = new Array(64);
    }
    utils.inherits(SHA256, BlockHash);
    module2.exports = SHA256;
    SHA256.blockSize = 512;
    SHA256.outSize = 256;
    SHA256.hmacStrength = 192;
    SHA256.padLength = 64;
    SHA256.prototype._update = function _update(msg, start) {
      var W = this.W;
      for (var i = 0; i < 16; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i++)
        W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
      var a = this.h[0];
      var b = this.h[1];
      var c = this.h[2];
      var d = this.h[3];
      var e = this.h[4];
      var f = this.h[5];
      var g = this.h[6];
      var h = this.h[7];
      assert(this.k.length === W.length);
      for (i = 0; i < W.length; i++) {
        var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
        var T2 = sum32(s0_256(a), maj32(a, b, c));
        h = g;
        g = f;
        f = e;
        e = sum32(d, T1);
        d = c;
        c = b;
        b = a;
        a = sum32(T1, T2);
      }
      this.h[0] = sum32(this.h[0], a);
      this.h[1] = sum32(this.h[1], b);
      this.h[2] = sum32(this.h[2], c);
      this.h[3] = sum32(this.h[3], d);
      this.h[4] = sum32(this.h[4], e);
      this.h[5] = sum32(this.h[5], f);
      this.h[6] = sum32(this.h[6], g);
      this.h[7] = sum32(this.h[7], h);
    };
    SHA256.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/224.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils4();
    var SHA256 = require__2();
    function SHA224() {
      if (!(this instanceof SHA224))
        return new SHA224();
      SHA256.call(this);
      this.h = [
        3238371032,
        914150663,
        812702999,
        4144912697,
        4290775857,
        1750603025,
        1694076839,
        3204075428
      ];
    }
    utils.inherits(SHA224, SHA256);
    module2.exports = SHA224;
    SHA224.blockSize = 512;
    SHA224.outSize = 224;
    SHA224.hmacStrength = 192;
    SHA224.padLength = 64;
    SHA224.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 7), "big");
      else
        return utils.split32(this.h.slice(0, 7), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/512.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils4();
    var common = require_common2();
    var assert = require_minimalistic_assert();
    var rotr64_hi = utils.rotr64_hi;
    var rotr64_lo = utils.rotr64_lo;
    var shr64_hi = utils.shr64_hi;
    var shr64_lo = utils.shr64_lo;
    var sum64 = utils.sum64;
    var sum64_hi = utils.sum64_hi;
    var sum64_lo = utils.sum64_lo;
    var sum64_4_hi = utils.sum64_4_hi;
    var sum64_4_lo = utils.sum64_4_lo;
    var sum64_5_hi = utils.sum64_5_hi;
    var sum64_5_lo = utils.sum64_5_lo;
    var BlockHash = common.BlockHash;
    var sha512_K = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function SHA512() {
      if (!(this instanceof SHA512))
        return new SHA512();
      BlockHash.call(this);
      this.h = [
        1779033703,
        4089235720,
        3144134277,
        2227873595,
        1013904242,
        4271175723,
        2773480762,
        1595750129,
        1359893119,
        2917565137,
        2600822924,
        725511199,
        528734635,
        4215389547,
        1541459225,
        327033209
      ];
      this.k = sha512_K;
      this.W = new Array(160);
    }
    utils.inherits(SHA512, BlockHash);
    module2.exports = SHA512;
    SHA512.blockSize = 1024;
    SHA512.outSize = 512;
    SHA512.hmacStrength = 192;
    SHA512.padLength = 128;
    SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
      var W = this.W;
      for (var i = 0; i < 32; i++)
        W[i] = msg[start + i];
      for (; i < W.length; i += 2) {
        var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
        var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
        var c1_hi = W[i - 14];
        var c1_lo = W[i - 13];
        var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
        var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
        var c3_hi = W[i - 32];
        var c3_lo = W[i - 31];
        W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
        W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      }
    };
    SHA512.prototype._update = function _update(msg, start) {
      this._prepareBlock(msg, start);
      var W = this.W;
      var ah = this.h[0];
      var al = this.h[1];
      var bh = this.h[2];
      var bl = this.h[3];
      var ch = this.h[4];
      var cl = this.h[5];
      var dh = this.h[6];
      var dl = this.h[7];
      var eh = this.h[8];
      var el = this.h[9];
      var fh = this.h[10];
      var fl = this.h[11];
      var gh = this.h[12];
      var gl = this.h[13];
      var hh = this.h[14];
      var hl = this.h[15];
      assert(this.k.length === W.length);
      for (var i = 0; i < W.length; i += 2) {
        var c0_hi = hh;
        var c0_lo = hl;
        var c1_hi = s1_512_hi(eh, el);
        var c1_lo = s1_512_lo(eh, el);
        var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
        var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
        var c3_hi = this.k[i];
        var c3_lo = this.k[i + 1];
        var c4_hi = W[i];
        var c4_lo = W[i + 1];
        var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
        c0_hi = s0_512_hi(ah, al);
        c0_lo = s0_512_lo(ah, al);
        c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
        c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
        var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
        var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
        hh = gh;
        hl = gl;
        gh = fh;
        gl = fl;
        fh = eh;
        fl = el;
        eh = sum64_hi(dh, dl, T1_hi, T1_lo);
        el = sum64_lo(dl, dl, T1_hi, T1_lo);
        dh = ch;
        dl = cl;
        ch = bh;
        cl = bl;
        bh = ah;
        bl = al;
        ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
        al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
      }
      sum64(this.h, 0, ah, al);
      sum64(this.h, 2, bh, bl);
      sum64(this.h, 4, ch, cl);
      sum64(this.h, 6, dh, dl);
      sum64(this.h, 8, eh, el);
      sum64(this.h, 10, fh, fl);
      sum64(this.h, 12, gh, gl);
      sum64(this.h, 14, hh, hl);
    };
    SHA512.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "big");
      else
        return utils.split32(this.h, "big");
    };
    function ch64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ ~xh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function ch64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ ~xl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_hi(xh, xl, yh, yl, zh) {
      var r = xh & yh ^ xh & zh ^ yh & zh;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function maj64_lo(xh, xl, yh, yl, zh, zl) {
      var r = xl & yl ^ xl & zl ^ yl & zl;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 28);
      var c1_hi = rotr64_hi(xl, xh, 2);
      var c2_hi = rotr64_hi(xl, xh, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 28);
      var c1_lo = rotr64_lo(xl, xh, 2);
      var c2_lo = rotr64_lo(xl, xh, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 14);
      var c1_hi = rotr64_hi(xh, xl, 18);
      var c2_hi = rotr64_hi(xl, xh, 9);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function s1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 14);
      var c1_lo = rotr64_lo(xh, xl, 18);
      var c2_lo = rotr64_lo(xl, xh, 9);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 1);
      var c1_hi = rotr64_hi(xh, xl, 8);
      var c2_hi = shr64_hi(xh, xl, 7);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g0_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 1);
      var c1_lo = rotr64_lo(xh, xl, 8);
      var c2_lo = shr64_lo(xh, xl, 7);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_hi(xh, xl) {
      var c0_hi = rotr64_hi(xh, xl, 19);
      var c1_hi = rotr64_hi(xl, xh, 29);
      var c2_hi = shr64_hi(xh, xl, 6);
      var r = c0_hi ^ c1_hi ^ c2_hi;
      if (r < 0)
        r += 4294967296;
      return r;
    }
    function g1_512_lo(xh, xl) {
      var c0_lo = rotr64_lo(xh, xl, 19);
      var c1_lo = rotr64_lo(xl, xh, 29);
      var c2_lo = shr64_lo(xh, xl, 6);
      var r = c0_lo ^ c1_lo ^ c2_lo;
      if (r < 0)
        r += 4294967296;
      return r;
    }
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS({
  "node_modules/hash.js/lib/hash/sha/384.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils4();
    var SHA512 = require__4();
    function SHA384() {
      if (!(this instanceof SHA384))
        return new SHA384();
      SHA512.call(this);
      this.h = [
        3418070365,
        3238371032,
        1654270250,
        914150663,
        2438529370,
        812702999,
        355462360,
        4144912697,
        1731405415,
        4290775857,
        2394180231,
        1750603025,
        3675008525,
        1694076839,
        1203062813,
        3204075428
      ];
    }
    utils.inherits(SHA384, SHA512);
    module2.exports = SHA384;
    SHA384.blockSize = 1024;
    SHA384.outSize = 384;
    SHA384.hmacStrength = 192;
    SHA384.padLength = 128;
    SHA384.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h.slice(0, 12), "big");
      else
        return utils.split32(this.h.slice(0, 12), "big");
    };
  }
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS({
  "node_modules/hash.js/lib/hash/sha.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.sha1 = require__();
    exports2.sha224 = require__3();
    exports2.sha256 = require__2();
    exports2.sha384 = require__5();
    exports2.sha512 = require__4();
  }
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS({
  "node_modules/hash.js/lib/hash/ripemd.js"(exports2) {
    init_node_globals();
    "use strict";
    var utils = require_utils4();
    var common = require_common2();
    var rotl32 = utils.rotl32;
    var sum32 = utils.sum32;
    var sum32_3 = utils.sum32_3;
    var sum32_4 = utils.sum32_4;
    var BlockHash = common.BlockHash;
    function RIPEMD160() {
      if (!(this instanceof RIPEMD160))
        return new RIPEMD160();
      BlockHash.call(this);
      this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      this.endian = "little";
    }
    utils.inherits(RIPEMD160, BlockHash);
    exports2.ripemd160 = RIPEMD160;
    RIPEMD160.blockSize = 512;
    RIPEMD160.outSize = 160;
    RIPEMD160.hmacStrength = 192;
    RIPEMD160.padLength = 64;
    RIPEMD160.prototype._update = function update(msg, start) {
      var A = this.h[0];
      var B = this.h[1];
      var C = this.h[2];
      var D = this.h[3];
      var E = this.h[4];
      var Ah = A;
      var Bh = B;
      var Ch = C;
      var Dh = D;
      var Eh = E;
      for (var j = 0; j < 80; j++) {
        var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
        A = E;
        E = D;
        D = rotl32(C, 10);
        C = B;
        B = T;
        T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
        Ah = Eh;
        Eh = Dh;
        Dh = rotl32(Ch, 10);
        Ch = Bh;
        Bh = T;
      }
      T = sum32_3(this.h[1], C, Dh);
      this.h[1] = sum32_3(this.h[2], D, Eh);
      this.h[2] = sum32_3(this.h[3], E, Ah);
      this.h[3] = sum32_3(this.h[4], A, Bh);
      this.h[4] = sum32_3(this.h[0], B, Ch);
      this.h[0] = T;
    };
    RIPEMD160.prototype._digest = function digest(enc) {
      if (enc === "hex")
        return utils.toHex32(this.h, "little");
      else
        return utils.split32(this.h, "little");
    };
    function f(j, x, y, z) {
      if (j <= 15)
        return x ^ y ^ z;
      else if (j <= 31)
        return x & y | ~x & z;
      else if (j <= 47)
        return (x | ~y) ^ z;
      else if (j <= 63)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    function K(j) {
      if (j <= 15)
        return 0;
      else if (j <= 31)
        return 1518500249;
      else if (j <= 47)
        return 1859775393;
      else if (j <= 63)
        return 2400959708;
      else
        return 2840853838;
    }
    function Kh(j) {
      if (j <= 15)
        return 1352829926;
      else if (j <= 31)
        return 1548603684;
      else if (j <= 47)
        return 1836072691;
      else if (j <= 63)
        return 2053994217;
      else
        return 0;
    }
    var r = [
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      7,
      4,
      13,
      1,
      10,
      6,
      15,
      3,
      12,
      0,
      9,
      5,
      2,
      14,
      11,
      8,
      3,
      10,
      14,
      4,
      9,
      15,
      8,
      1,
      2,
      7,
      0,
      6,
      13,
      11,
      5,
      12,
      1,
      9,
      11,
      10,
      0,
      8,
      12,
      4,
      13,
      3,
      7,
      15,
      14,
      5,
      6,
      2,
      4,
      0,
      5,
      9,
      7,
      12,
      2,
      10,
      14,
      1,
      3,
      8,
      11,
      6,
      15,
      13
    ];
    var rh = [
      5,
      14,
      7,
      0,
      9,
      2,
      11,
      4,
      13,
      6,
      15,
      8,
      1,
      10,
      3,
      12,
      6,
      11,
      3,
      7,
      0,
      13,
      5,
      10,
      14,
      15,
      8,
      12,
      4,
      9,
      1,
      2,
      15,
      5,
      1,
      3,
      7,
      14,
      6,
      9,
      11,
      8,
      12,
      2,
      10,
      0,
      4,
      13,
      8,
      6,
      4,
      1,
      3,
      11,
      15,
      0,
      5,
      12,
      2,
      13,
      9,
      7,
      10,
      14,
      12,
      15,
      10,
      4,
      1,
      5,
      8,
      7,
      6,
      2,
      13,
      14,
      0,
      3,
      9,
      11
    ];
    var s = [
      11,
      14,
      15,
      12,
      5,
      8,
      7,
      9,
      11,
      13,
      14,
      15,
      6,
      7,
      9,
      8,
      7,
      6,
      8,
      13,
      11,
      9,
      7,
      15,
      7,
      12,
      15,
      9,
      11,
      7,
      13,
      12,
      11,
      13,
      6,
      7,
      14,
      9,
      13,
      15,
      14,
      8,
      13,
      6,
      5,
      12,
      7,
      5,
      11,
      12,
      14,
      15,
      14,
      15,
      9,
      8,
      9,
      14,
      5,
      6,
      8,
      6,
      5,
      12,
      9,
      15,
      5,
      11,
      6,
      8,
      13,
      12,
      5,
      12,
      13,
      14,
      11,
      8,
      5,
      6
    ];
    var sh = [
      8,
      9,
      9,
      11,
      13,
      15,
      15,
      5,
      7,
      7,
      8,
      11,
      14,
      14,
      12,
      6,
      9,
      13,
      15,
      7,
      12,
      8,
      9,
      11,
      7,
      7,
      12,
      7,
      6,
      15,
      13,
      11,
      9,
      7,
      15,
      11,
      8,
      6,
      6,
      14,
      12,
      13,
      5,
      14,
      13,
      13,
      7,
      5,
      15,
      5,
      8,
      11,
      14,
      14,
      6,
      14,
      6,
      9,
      12,
      9,
      12,
      5,
      15,
      8,
      8,
      5,
      12,
      9,
      12,
      5,
      14,
      6,
      8,
      13,
      6,
      5,
      15,
      13,
      11,
      11
    ];
  }
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/hash.js/lib/hash/hmac.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils4();
    var assert = require_minimalistic_assert();
    function Hmac(hash2, key, enc) {
      if (!(this instanceof Hmac))
        return new Hmac(hash2, key, enc);
      this.Hash = hash2;
      this.blockSize = hash2.blockSize / 8;
      this.outSize = hash2.outSize / 8;
      this.inner = null;
      this.outer = null;
      this._init(utils.toArray(key, enc));
    }
    module2.exports = Hmac;
    Hmac.prototype._init = function init(key) {
      if (key.length > this.blockSize)
        key = new this.Hash().update(key).digest();
      assert(key.length <= this.blockSize);
      for (var i = key.length; i < this.blockSize; i++)
        key.push(0);
      for (i = 0; i < key.length; i++)
        key[i] ^= 54;
      this.inner = new this.Hash().update(key);
      for (i = 0; i < key.length; i++)
        key[i] ^= 106;
      this.outer = new this.Hash().update(key);
    };
    Hmac.prototype.update = function update(msg, enc) {
      this.inner.update(msg, enc);
      return this;
    };
    Hmac.prototype.digest = function digest(enc) {
      this.outer.update(this.inner.digest());
      return this.outer.digest(enc);
    };
  }
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS({
  "node_modules/hash.js/lib/hash.js"(exports2) {
    init_node_globals();
    var hash2 = exports2;
    hash2.utils = require_utils4();
    hash2.common = require_common2();
    hash2.sha = require_sha();
    hash2.ripemd = require_ripemd();
    hash2.hmac = require_hmac2();
    hash2.sha1 = hash2.sha.sha1;
    hash2.sha256 = hash2.sha.sha256;
    hash2.sha224 = hash2.sha.sha224;
    hash2.sha384 = hash2.sha.sha384;
    hash2.sha512 = hash2.sha.sha512;
    hash2.ripemd160 = hash2.ripemd.ripemd160;
  }
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js"(exports2, module2) {
    init_node_globals();
    module2.exports = {
      doubles: {
        step: 4,
        points: [
          [
            "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
            "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
          ],
          [
            "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
            "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
          ],
          [
            "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
            "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
          ],
          [
            "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
            "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
          ],
          [
            "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
            "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
          ],
          [
            "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
            "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
          ],
          [
            "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
            "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
          ],
          [
            "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
            "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
          ],
          [
            "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
            "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
          ],
          [
            "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
            "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
          ],
          [
            "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
            "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
          ],
          [
            "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
            "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
          ],
          [
            "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
            "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
          ],
          [
            "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
            "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
          ],
          [
            "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
            "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
          ],
          [
            "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
            "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
          ],
          [
            "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
            "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
          ],
          [
            "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
            "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
          ],
          [
            "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
            "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
          ],
          [
            "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
            "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
          ],
          [
            "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
            "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
          ],
          [
            "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
            "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
          ],
          [
            "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
            "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
          ],
          [
            "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
            "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
          ],
          [
            "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
            "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
          ],
          [
            "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
            "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
          ],
          [
            "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
            "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
          ],
          [
            "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
            "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
          ],
          [
            "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
            "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
          ],
          [
            "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
            "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
          ],
          [
            "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
            "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
          ],
          [
            "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
            "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
          ],
          [
            "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
            "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
          ],
          [
            "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
            "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
          ],
          [
            "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
            "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
          ],
          [
            "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
            "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
          ],
          [
            "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
            "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
          ],
          [
            "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
            "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
          ],
          [
            "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
            "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
          ],
          [
            "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
            "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
          ],
          [
            "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
            "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
          ],
          [
            "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
            "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
          ],
          [
            "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
            "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
          ],
          [
            "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
            "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
          ],
          [
            "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
            "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
          ],
          [
            "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
            "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
          ],
          [
            "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
            "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
          ],
          [
            "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
            "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
          ],
          [
            "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
            "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
          ],
          [
            "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
            "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
          ],
          [
            "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
            "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
          ],
          [
            "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
            "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
          ],
          [
            "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
            "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
          ],
          [
            "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
            "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
          ],
          [
            "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
            "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
          ],
          [
            "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
            "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
          ],
          [
            "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
            "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
          ],
          [
            "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
            "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
          ],
          [
            "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
            "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
          ],
          [
            "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
            "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
          ],
          [
            "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
            "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
          ],
          [
            "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
            "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
          ],
          [
            "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
            "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
          ],
          [
            "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
            "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
          ],
          [
            "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
            "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
          ]
        ]
      },
      naf: {
        wnd: 7,
        points: [
          [
            "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
            "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
          ],
          [
            "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
            "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
          ],
          [
            "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
            "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
          ],
          [
            "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
            "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
          ],
          [
            "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
            "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
          ],
          [
            "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
            "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
          ],
          [
            "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
            "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
          ],
          [
            "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
            "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
          ],
          [
            "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
            "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
          ],
          [
            "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
            "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
          ],
          [
            "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
            "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
          ],
          [
            "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
            "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
          ],
          [
            "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
            "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
          ],
          [
            "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
            "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
          ],
          [
            "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
            "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
          ],
          [
            "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
            "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
          ],
          [
            "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
            "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
          ],
          [
            "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
            "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
          ],
          [
            "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
            "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
          ],
          [
            "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
            "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
          ],
          [
            "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
            "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
          ],
          [
            "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
            "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
          ],
          [
            "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
            "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
          ],
          [
            "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
            "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
          ],
          [
            "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
            "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
          ],
          [
            "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
            "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
          ],
          [
            "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
            "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
          ],
          [
            "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
            "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
          ],
          [
            "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
            "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
          ],
          [
            "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
            "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
          ],
          [
            "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
            "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
          ],
          [
            "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
            "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
          ],
          [
            "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
            "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
          ],
          [
            "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
            "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
          ],
          [
            "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
            "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
          ],
          [
            "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
            "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
          ],
          [
            "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
            "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
          ],
          [
            "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
            "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
          ],
          [
            "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
            "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
          ],
          [
            "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
            "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
          ],
          [
            "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
            "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
          ],
          [
            "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
            "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
          ],
          [
            "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
            "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
          ],
          [
            "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
            "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
          ],
          [
            "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
            "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
          ],
          [
            "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
            "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
          ],
          [
            "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
            "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
          ],
          [
            "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
            "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
          ],
          [
            "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
            "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
          ],
          [
            "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
            "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
          ],
          [
            "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
            "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
          ],
          [
            "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
            "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
          ],
          [
            "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
            "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
          ],
          [
            "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
            "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
          ],
          [
            "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
            "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
          ],
          [
            "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
            "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
          ],
          [
            "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
            "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
          ],
          [
            "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
            "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
          ],
          [
            "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
            "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
          ],
          [
            "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
            "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
          ],
          [
            "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
            "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
          ],
          [
            "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
            "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
          ],
          [
            "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
            "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
          ],
          [
            "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
            "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
          ],
          [
            "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
            "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
          ],
          [
            "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
            "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
          ],
          [
            "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
            "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
          ],
          [
            "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
            "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
          ],
          [
            "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
            "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
          ],
          [
            "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
            "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
          ],
          [
            "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
            "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
          ],
          [
            "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
            "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
          ],
          [
            "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
            "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
          ],
          [
            "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
            "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
          ],
          [
            "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
            "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
          ],
          [
            "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
            "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
          ],
          [
            "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
            "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
          ],
          [
            "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
            "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
          ],
          [
            "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
            "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
          ],
          [
            "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
            "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
          ],
          [
            "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
            "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
          ],
          [
            "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
            "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
          ],
          [
            "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
            "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
          ],
          [
            "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
            "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
          ],
          [
            "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
            "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
          ],
          [
            "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
            "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
          ],
          [
            "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
            "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
          ],
          [
            "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
            "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
          ],
          [
            "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
            "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
          ],
          [
            "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
            "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
          ],
          [
            "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
            "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
          ],
          [
            "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
            "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
          ],
          [
            "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
            "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
          ],
          [
            "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
            "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
          ],
          [
            "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
            "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
          ],
          [
            "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
            "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
          ],
          [
            "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
            "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
          ],
          [
            "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
            "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
          ],
          [
            "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
            "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
          ],
          [
            "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
            "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
          ],
          [
            "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
            "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
          ],
          [
            "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
            "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
          ],
          [
            "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
            "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
          ],
          [
            "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
            "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
          ],
          [
            "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
            "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
          ],
          [
            "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
            "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
          ],
          [
            "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
            "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
          ],
          [
            "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
            "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
          ],
          [
            "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
            "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
          ],
          [
            "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
            "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
          ],
          [
            "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
            "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
          ],
          [
            "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
            "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
          ],
          [
            "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
            "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
          ],
          [
            "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
            "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
          ],
          [
            "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
            "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
          ],
          [
            "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
            "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
          ],
          [
            "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
            "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
          ],
          [
            "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
            "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
          ],
          [
            "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
            "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
          ],
          [
            "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
            "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
          ],
          [
            "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
            "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
          ],
          [
            "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
            "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
          ],
          [
            "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
            "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
          ],
          [
            "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
            "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
          ],
          [
            "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
            "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
          ],
          [
            "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
            "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
          ],
          [
            "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
            "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
          ]
        ]
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS({
  "node_modules/elliptic/lib/elliptic/curves.js"(exports2) {
    init_node_globals();
    "use strict";
    var curves = exports2;
    var hash2 = require_hash();
    var curve = require_curve();
    var utils = require_utils3();
    var assert = utils.assert;
    function PresetCurve(options) {
      if (options.type === "short")
        this.curve = new curve.short(options);
      else if (options.type === "edwards")
        this.curve = new curve.edwards(options);
      else
        this.curve = new curve.mont(options);
      this.g = this.curve.g;
      this.n = this.curve.n;
      this.hash = options.hash;
      assert(this.g.validate(), "Invalid curve");
      assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    curves.PresetCurve = PresetCurve;
    function defineCurve(name5, options) {
      Object.defineProperty(curves, name5, {
        configurable: true,
        enumerable: true,
        get: function() {
          var curve2 = new PresetCurve(options);
          Object.defineProperty(curves, name5, {
            configurable: true,
            enumerable: true,
            value: curve2
          });
          return curve2;
        }
      });
    }
    defineCurve("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    });
    defineCurve("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    });
    defineCurve("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    });
    defineCurve("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: hash2.sha384,
      gRed: false,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    });
    defineCurve("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: hash2.sha512,
      gRed: false,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    });
    defineCurve("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "9"
      ]
    });
    defineCurve("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: hash2.sha256,
      gRed: false,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var pre;
    try {
      pre = require_secp256k1();
    } catch (e) {
      pre = void 0;
    }
    defineCurve("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: hash2.sha256,
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: false,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        pre
      ]
    });
  }
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS({
  "node_modules/hmac-drbg/lib/hmac-drbg.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var hash2 = require_hash();
    var utils = require_utils2();
    var assert = require_minimalistic_assert();
    function HmacDRBG(options) {
      if (!(this instanceof HmacDRBG))
        return new HmacDRBG(options);
      this.hash = options.hash;
      this.predResist = !!options.predResist;
      this.outLen = this.hash.outSize;
      this.minEntropy = options.minEntropy || this.hash.hmacStrength;
      this._reseed = null;
      this.reseedInterval = null;
      this.K = null;
      this.V = null;
      var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
      var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
      var pers = utils.toArray(options.pers, options.persEnc || "hex");
      assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
      this._init(entropy, nonce, pers);
    }
    module2.exports = HmacDRBG;
    HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
      var seed = entropy.concat(nonce).concat(pers);
      this.K = new Array(this.outLen / 8);
      this.V = new Array(this.outLen / 8);
      for (var i = 0; i < this.V.length; i++) {
        this.K[i] = 0;
        this.V[i] = 1;
      }
      this._update(seed);
      this._reseed = 1;
      this.reseedInterval = 281474976710656;
    };
    HmacDRBG.prototype._hmac = function hmac() {
      return new hash2.hmac(this.hash, this.K);
    };
    HmacDRBG.prototype._update = function update(seed) {
      var kmac = this._hmac().update(this.V).update([0]);
      if (seed)
        kmac = kmac.update(seed);
      this.K = kmac.digest();
      this.V = this._hmac().update(this.V).digest();
      if (!seed)
        return;
      this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
      this.V = this._hmac().update(this.V).digest();
    };
    HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
      if (typeof entropyEnc !== "string") {
        addEnc = add;
        add = entropyEnc;
        entropyEnc = null;
      }
      entropy = utils.toArray(entropy, entropyEnc);
      add = utils.toArray(add, addEnc);
      assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
      this._update(entropy.concat(add || []));
      this._reseed = 1;
    };
    HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
      if (this._reseed > this.reseedInterval)
        throw new Error("Reseed is required");
      if (typeof enc !== "string") {
        addEnc = add;
        add = enc;
        enc = null;
      }
      if (add) {
        add = utils.toArray(add, addEnc || "hex");
        this._update(add);
      }
      var temp = [];
      while (temp.length < len) {
        this.V = this._hmac().update(this.V).digest();
        temp = temp.concat(this.V);
      }
      var res = temp.slice(0, len);
      this._update(add);
      this._reseed++;
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/key.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    function KeyPair(ec, options) {
      this.ec = ec;
      this.priv = null;
      this.pub = null;
      if (options.priv)
        this._importPrivate(options.priv, options.privEnc);
      if (options.pub)
        this._importPublic(options.pub, options.pubEnc);
    }
    module2.exports = KeyPair;
    KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(ec, {
        pub,
        pubEnc: enc
      });
    };
    KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
      if (priv instanceof KeyPair)
        return priv;
      return new KeyPair(ec, {
        priv,
        privEnc: enc
      });
    };
    KeyPair.prototype.validate = function validate3() {
      var pub = this.getPublic();
      if (pub.isInfinity())
        return { result: false, reason: "Invalid public key" };
      if (!pub.validate())
        return { result: false, reason: "Public key is not a point" };
      if (!pub.mul(this.ec.curve.n).isInfinity())
        return { result: false, reason: "Public key * N != O" };
      return { result: true, reason: null };
    };
    KeyPair.prototype.getPublic = function getPublic(compact, enc) {
      if (typeof compact === "string") {
        enc = compact;
        compact = null;
      }
      if (!this.pub)
        this.pub = this.ec.g.mul(this.priv);
      if (!enc)
        return this.pub;
      return this.pub.encode(enc, compact);
    };
    KeyPair.prototype.getPrivate = function getPrivate(enc) {
      if (enc === "hex")
        return this.priv.toString(16, 2);
      else
        return this.priv;
    };
    KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
      this.priv = new BN(key, enc || 16);
      this.priv = this.priv.umod(this.ec.curve.n);
    };
    KeyPair.prototype._importPublic = function _importPublic(key, enc) {
      if (key.x || key.y) {
        if (this.ec.curve.type === "mont") {
          assert(key.x, "Need x coordinate");
        } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
          assert(key.x && key.y, "Need both x and y coordinate");
        }
        this.pub = this.ec.curve.point(key.x, key.y);
        return;
      }
      this.pub = this.ec.curve.decodePoint(key, enc);
    };
    KeyPair.prototype.derive = function derive(pub) {
      if (!pub.validate()) {
        assert(pub.validate(), "public point not validated");
      }
      return pub.mul(this.priv).getX();
    };
    KeyPair.prototype.sign = function sign2(msg, enc, options) {
      return this.ec.sign(msg, this, enc, options);
    };
    KeyPair.prototype.verify = function verify(msg, signature) {
      return this.ec.verify(msg, signature, this);
    };
    KeyPair.prototype.inspect = function inspect() {
      return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/signature.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    function Signature(options, enc) {
      if (options instanceof Signature)
        return options;
      if (this._importDER(options, enc))
        return;
      assert(options.r && options.s, "Signature without r or s");
      this.r = new BN(options.r, 16);
      this.s = new BN(options.s, 16);
      if (options.recoveryParam === void 0)
        this.recoveryParam = null;
      else
        this.recoveryParam = options.recoveryParam;
    }
    module2.exports = Signature;
    function Position() {
      this.place = 0;
    }
    function getLength(buf2, p) {
      var initial = buf2[p.place++];
      if (!(initial & 128)) {
        return initial;
      }
      var octetLen = initial & 15;
      if (octetLen === 0 || octetLen > 4) {
        return false;
      }
      var val = 0;
      for (var i = 0, off = p.place; i < octetLen; i++, off++) {
        val <<= 8;
        val |= buf2[off];
        val >>>= 0;
      }
      if (val <= 127) {
        return false;
      }
      p.place = off;
      return val;
    }
    function rmPadding(buf2) {
      var i = 0;
      var len = buf2.length - 1;
      while (!buf2[i] && !(buf2[i + 1] & 128) && i < len) {
        i++;
      }
      if (i === 0) {
        return buf2;
      }
      return buf2.slice(i);
    }
    Signature.prototype._importDER = function _importDER(data, enc) {
      data = utils.toArray(data, enc);
      var p = new Position();
      if (data[p.place++] !== 48) {
        return false;
      }
      var len = getLength(data, p);
      if (len === false) {
        return false;
      }
      if (len + p.place !== data.length) {
        return false;
      }
      if (data[p.place++] !== 2) {
        return false;
      }
      var rlen = getLength(data, p);
      if (rlen === false) {
        return false;
      }
      var r = data.slice(p.place, rlen + p.place);
      p.place += rlen;
      if (data[p.place++] !== 2) {
        return false;
      }
      var slen = getLength(data, p);
      if (slen === false) {
        return false;
      }
      if (data.length !== slen + p.place) {
        return false;
      }
      var s = data.slice(p.place, slen + p.place);
      if (r[0] === 0) {
        if (r[1] & 128) {
          r = r.slice(1);
        } else {
          return false;
        }
      }
      if (s[0] === 0) {
        if (s[1] & 128) {
          s = s.slice(1);
        } else {
          return false;
        }
      }
      this.r = new BN(r);
      this.s = new BN(s);
      this.recoveryParam = null;
      return true;
    };
    function constructLength(arr, len) {
      if (len < 128) {
        arr.push(len);
        return;
      }
      var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
      arr.push(octets | 128);
      while (--octets) {
        arr.push(len >>> (octets << 3) & 255);
      }
      arr.push(len);
    }
    Signature.prototype.toDER = function toDER(enc) {
      var r = this.r.toArray();
      var s = this.s.toArray();
      if (r[0] & 128)
        r = [0].concat(r);
      if (s[0] & 128)
        s = [0].concat(s);
      r = rmPadding(r);
      s = rmPadding(s);
      while (!s[0] && !(s[1] & 128)) {
        s = s.slice(1);
      }
      var arr = [2];
      constructLength(arr, r.length);
      arr = arr.concat(r);
      arr.push(2);
      constructLength(arr, s.length);
      var backHalf = arr.concat(s);
      var res = [48];
      constructLength(res, backHalf.length);
      res = res.concat(backHalf);
      return utils.encode(res, enc);
    };
  }
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS({
  "node_modules/elliptic/lib/elliptic/ec/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var BN = require_bn();
    var HmacDRBG = require_hmac_drbg();
    var utils = require_utils3();
    var curves = require_curves();
    var rand = require_brorand();
    var assert = utils.assert;
    var KeyPair = require_key();
    var Signature = require_signature();
    function EC(options) {
      if (!(this instanceof EC))
        return new EC(options);
      if (typeof options === "string") {
        assert(Object.prototype.hasOwnProperty.call(curves, options), "Unknown curve " + options);
        options = curves[options];
      }
      if (options instanceof curves.PresetCurve)
        options = { curve: options };
      this.curve = options.curve.curve;
      this.n = this.curve.n;
      this.nh = this.n.ushrn(1);
      this.g = this.curve.g;
      this.g = options.curve.g;
      this.g.precompute(options.curve.n.bitLength() + 1);
      this.hash = options.hash || options.curve.hash;
    }
    module2.exports = EC;
    EC.prototype.keyPair = function keyPair(options) {
      return new KeyPair(this, options);
    };
    EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
      return KeyPair.fromPrivate(this, priv, enc);
    };
    EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
      return KeyPair.fromPublic(this, pub, enc);
    };
    EC.prototype.genKeyPair = function genKeyPair(options) {
      if (!options)
        options = {};
      var drbg = new HmacDRBG({
        hash: this.hash,
        pers: options.pers,
        persEnc: options.persEnc || "utf8",
        entropy: options.entropy || rand(this.hash.hmacStrength),
        entropyEnc: options.entropy && options.entropyEnc || "utf8",
        nonce: this.n.toArray()
      });
      var bytes3 = this.n.byteLength();
      var ns2 = this.n.sub(new BN(2));
      for (; ; ) {
        var priv = new BN(drbg.generate(bytes3));
        if (priv.cmp(ns2) > 0)
          continue;
        priv.iaddn(1);
        return this.keyFromPrivate(priv);
      }
    };
    EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
      var delta = msg.byteLength() * 8 - this.n.bitLength();
      if (delta > 0)
        msg = msg.ushrn(delta);
      if (!truncOnly && msg.cmp(this.n) >= 0)
        return msg.sub(this.n);
      else
        return msg;
    };
    EC.prototype.sign = function sign2(msg, key, enc, options) {
      if (typeof enc === "object") {
        options = enc;
        enc = null;
      }
      if (!options)
        options = {};
      key = this.keyFromPrivate(key, enc);
      msg = this._truncateToN(new BN(msg, 16));
      var bytes3 = this.n.byteLength();
      var bkey = key.getPrivate().toArray("be", bytes3);
      var nonce = msg.toArray("be", bytes3);
      var drbg = new HmacDRBG({
        hash: this.hash,
        entropy: bkey,
        nonce,
        pers: options.pers,
        persEnc: options.persEnc || "utf8"
      });
      var ns1 = this.n.sub(new BN(1));
      for (var iter = 0; ; iter++) {
        var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
        k = this._truncateToN(k, true);
        if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
          continue;
        var kp = this.g.mul(k);
        if (kp.isInfinity())
          continue;
        var kpX = kp.getX();
        var r = kpX.umod(this.n);
        if (r.cmpn(0) === 0)
          continue;
        var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
        s = s.umod(this.n);
        if (s.cmpn(0) === 0)
          continue;
        var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
        if (options.canonical && s.cmp(this.nh) > 0) {
          s = this.n.sub(s);
          recoveryParam ^= 1;
        }
        return new Signature({ r, s, recoveryParam });
      }
    };
    EC.prototype.verify = function verify(msg, signature, key, enc) {
      msg = this._truncateToN(new BN(msg, 16));
      key = this.keyFromPublic(key, enc);
      signature = new Signature(signature, "hex");
      var r = signature.r;
      var s = signature.s;
      if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
        return false;
      if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
        return false;
      var sinv = s.invm(this.n);
      var u1 = sinv.mul(msg).umod(this.n);
      var u2 = sinv.mul(r).umod(this.n);
      var p;
      if (!this.curve._maxwellTrick) {
        p = this.g.mulAdd(u1, key.getPublic(), u2);
        if (p.isInfinity())
          return false;
        return p.getX().umod(this.n).cmp(r) === 0;
      }
      p = this.g.jmulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.eqXToP(r);
    };
    EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
      assert((3 & j) === j, "The recovery param is more than two bits");
      signature = new Signature(signature, enc);
      var n = this.n;
      var e = new BN(msg);
      var r = signature.r;
      var s = signature.s;
      var isYOdd = j & 1;
      var isSecondKey = j >> 1;
      if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
        throw new Error("Unable to find sencond key candinate");
      if (isSecondKey)
        r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
      else
        r = this.curve.pointFromX(r, isYOdd);
      var rInv = signature.r.invm(n);
      var s1 = n.sub(e).mul(rInv).umod(n);
      var s2 = s.mul(rInv).umod(n);
      return this.g.mulAdd(s1, r, s2);
    };
    EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
      signature = new Signature(signature, enc);
      if (signature.recoveryParam !== null)
        return signature.recoveryParam;
      for (var i = 0; i < 4; i++) {
        var Qprime;
        try {
          Qprime = this.recoverPubKey(e, signature, i);
        } catch (e2) {
          continue;
        }
        if (Qprime.eq(Q))
          return i;
      }
      throw new Error("Unable to find valid recovery factor");
    };
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/key.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var cachedProperty = utils.cachedProperty;
    function KeyPair(eddsa, params) {
      this.eddsa = eddsa;
      this._secret = parseBytes(params.secret);
      if (eddsa.isPoint(params.pub))
        this._pub = params.pub;
      else
        this._pubBytes = parseBytes(params.pub);
    }
    KeyPair.fromPublic = function fromPublic(eddsa, pub) {
      if (pub instanceof KeyPair)
        return pub;
      return new KeyPair(eddsa, { pub });
    };
    KeyPair.fromSecret = function fromSecret(eddsa, secret) {
      if (secret instanceof KeyPair)
        return secret;
      return new KeyPair(eddsa, { secret });
    };
    KeyPair.prototype.secret = function secret() {
      return this._secret;
    };
    cachedProperty(KeyPair, "pubBytes", function pubBytes() {
      return this.eddsa.encodePoint(this.pub());
    });
    cachedProperty(KeyPair, "pub", function pub() {
      if (this._pubBytes)
        return this.eddsa.decodePoint(this._pubBytes);
      return this.eddsa.g.mul(this.priv());
    });
    cachedProperty(KeyPair, "privBytes", function privBytes() {
      var eddsa = this.eddsa;
      var hash2 = this.hash();
      var lastIx = eddsa.encodingLength - 1;
      var a = hash2.slice(0, eddsa.encodingLength);
      a[0] &= 248;
      a[lastIx] &= 127;
      a[lastIx] |= 64;
      return a;
    });
    cachedProperty(KeyPair, "priv", function priv() {
      return this.eddsa.decodeInt(this.privBytes());
    });
    cachedProperty(KeyPair, "hash", function hash2() {
      return this.eddsa.hash().update(this.secret()).digest();
    });
    cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
      return this.hash().slice(this.eddsa.encodingLength);
    });
    KeyPair.prototype.sign = function sign2(message) {
      assert(this._secret, "KeyPair can only verify");
      return this.eddsa.sign(message, this);
    };
    KeyPair.prototype.verify = function verify(message, sig) {
      return this.eddsa.verify(message, sig, this);
    };
    KeyPair.prototype.getSecret = function getSecret(enc) {
      assert(this._secret, "KeyPair is public only");
      return utils.encode(this.secret(), enc);
    };
    KeyPair.prototype.getPublic = function getPublic(enc) {
      return utils.encode(this.pubBytes(), enc);
    };
    module2.exports = KeyPair;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/signature.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var BN = require_bn();
    var utils = require_utils3();
    var assert = utils.assert;
    var cachedProperty = utils.cachedProperty;
    var parseBytes = utils.parseBytes;
    function Signature(eddsa, sig) {
      this.eddsa = eddsa;
      if (typeof sig !== "object")
        sig = parseBytes(sig);
      if (Array.isArray(sig)) {
        sig = {
          R: sig.slice(0, eddsa.encodingLength),
          S: sig.slice(eddsa.encodingLength)
        };
      }
      assert(sig.R && sig.S, "Signature without R or S");
      if (eddsa.isPoint(sig.R))
        this._R = sig.R;
      if (sig.S instanceof BN)
        this._S = sig.S;
      this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
      this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
    }
    cachedProperty(Signature, "S", function S() {
      return this.eddsa.decodeInt(this.Sencoded());
    });
    cachedProperty(Signature, "R", function R() {
      return this.eddsa.decodePoint(this.Rencoded());
    });
    cachedProperty(Signature, "Rencoded", function Rencoded() {
      return this.eddsa.encodePoint(this.R());
    });
    cachedProperty(Signature, "Sencoded", function Sencoded() {
      return this.eddsa.encodeInt(this.S());
    });
    Signature.prototype.toBytes = function toBytes2() {
      return this.Rencoded().concat(this.Sencoded());
    };
    Signature.prototype.toHex = function toHex2() {
      return utils.encode(this.toBytes(), "hex").toUpperCase();
    };
    module2.exports = Signature;
  }
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS({
  "node_modules/elliptic/lib/elliptic/eddsa/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var hash2 = require_hash();
    var curves = require_curves();
    var utils = require_utils3();
    var assert = utils.assert;
    var parseBytes = utils.parseBytes;
    var KeyPair = require_key2();
    var Signature = require_signature2();
    function EDDSA(curve) {
      assert(curve === "ed25519", "only tested with ed25519 so far");
      if (!(this instanceof EDDSA))
        return new EDDSA(curve);
      curve = curves[curve].curve;
      this.curve = curve;
      this.g = curve.g;
      this.g.precompute(curve.n.bitLength() + 1);
      this.pointClass = curve.point().constructor;
      this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
      this.hash = hash2.sha512;
    }
    module2.exports = EDDSA;
    EDDSA.prototype.sign = function sign2(message, secret) {
      message = parseBytes(message);
      var key = this.keyFromSecret(secret);
      var r = this.hashInt(key.messagePrefix(), message);
      var R = this.g.mul(r);
      var Rencoded = this.encodePoint(R);
      var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
      var S = r.add(s_).umod(this.curve.n);
      return this.makeSignature({ R, S, Rencoded });
    };
    EDDSA.prototype.verify = function verify(message, sig, pub) {
      message = parseBytes(message);
      sig = this.makeSignature(sig);
      var key = this.keyFromPublic(pub);
      var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
      var SG = this.g.mul(sig.S());
      var RplusAh = sig.R().add(key.pub().mul(h));
      return RplusAh.eq(SG);
    };
    EDDSA.prototype.hashInt = function hashInt() {
      var hash3 = this.hash();
      for (var i = 0; i < arguments.length; i++)
        hash3.update(arguments[i]);
      return utils.intFromLE(hash3.digest()).umod(this.curve.n);
    };
    EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
      return KeyPair.fromPublic(this, pub);
    };
    EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
      return KeyPair.fromSecret(this, secret);
    };
    EDDSA.prototype.makeSignature = function makeSignature(sig) {
      if (sig instanceof Signature)
        return sig;
      return new Signature(this, sig);
    };
    EDDSA.prototype.encodePoint = function encodePoint(point) {
      var enc = point.getY().toArray("le", this.encodingLength);
      enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
      return enc;
    };
    EDDSA.prototype.decodePoint = function decodePoint(bytes3) {
      bytes3 = utils.parseBytes(bytes3);
      var lastIx = bytes3.length - 1;
      var normed = bytes3.slice(0, lastIx).concat(bytes3[lastIx] & ~128);
      var xIsOdd = (bytes3[lastIx] & 128) !== 0;
      var y = utils.intFromLE(normed);
      return this.curve.pointFromY(y, xIsOdd);
    };
    EDDSA.prototype.encodeInt = function encodeInt(num) {
      return num.toArray("le", this.encodingLength);
    };
    EDDSA.prototype.decodeInt = function decodeInt(bytes3) {
      return utils.intFromLE(bytes3);
    };
    EDDSA.prototype.isPoint = function isPoint(val) {
      return val instanceof this.pointClass;
    };
  }
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS({
  "node_modules/elliptic/lib/elliptic.js"(exports2) {
    init_node_globals();
    "use strict";
    var elliptic = exports2;
    elliptic.version = require_package().version;
    elliptic.utils = require_utils3();
    elliptic.rand = require_brorand();
    elliptic.curve = require_curve();
    elliptic.curves = require_curves();
    elliptic.ec = require_ec();
    elliptic.eddsa = require_eddsa();
  }
});

// node_modules/secp256k1/lib/elliptic.js
var require_elliptic2 = __commonJS({
  "node_modules/secp256k1/lib/elliptic.js"(exports2, module2) {
    init_node_globals();
    var EC = require_elliptic().ec;
    var ec = new EC("secp256k1");
    var ecparams = ec.curve;
    var BN = ecparams.n.constructor;
    function loadCompressedPublicKey(first3, xbuf) {
      let x = new BN(xbuf);
      if (x.cmp(ecparams.p) >= 0)
        return null;
      x = x.toRed(ecparams.red);
      let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
      if (first3 === 3 !== y.isOdd())
        y = y.redNeg();
      return ec.keyPair({ pub: { x, y } });
    }
    function loadUncompressedPublicKey(first3, xbuf, ybuf) {
      let x = new BN(xbuf);
      let y = new BN(ybuf);
      if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0)
        return null;
      x = x.toRed(ecparams.red);
      y = y.toRed(ecparams.red);
      if ((first3 === 6 || first3 === 7) && y.isOdd() !== (first3 === 7))
        return null;
      const x3 = x.redSqr().redIMul(x);
      if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero())
        return null;
      return ec.keyPair({ pub: { x, y } });
    }
    function loadPublicKey(pubkey) {
      const first3 = pubkey[0];
      switch (first3) {
        case 2:
        case 3:
          if (pubkey.length !== 33)
            return null;
          return loadCompressedPublicKey(first3, pubkey.subarray(1, 33));
        case 4:
        case 6:
        case 7:
          if (pubkey.length !== 65)
            return null;
          return loadUncompressedPublicKey(first3, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
        default:
          return null;
      }
    }
    function savePublicKey(output, point) {
      const pubkey = point.encode(null, output.length === 33);
      for (let i = 0; i < output.length; ++i)
        output[i] = pubkey[i];
    }
    module2.exports = {
      contextRandomize() {
        return 0;
      },
      privateKeyVerify(seckey) {
        const bn = new BN(seckey);
        return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
      },
      privateKeyNegate(seckey) {
        const bn = new BN(seckey);
        const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
        seckey.set(negate);
        return 0;
      },
      privateKeyTweakAdd(seckey, tweak) {
        const bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0)
          return 1;
        bn.iadd(new BN(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn.isub(ecparams.n);
        if (bn.isZero())
          return 1;
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      privateKeyTweakMul(seckey, tweak) {
        let bn = new BN(tweak);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        bn.imul(new BN(seckey));
        if (bn.cmp(ecparams.n) >= 0)
          bn = bn.umod(ecparams.n);
        const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
        seckey.set(tweaked);
        return 0;
      },
      publicKeyVerify(pubkey) {
        const pair = loadPublicKey(pubkey);
        return pair === null ? 1 : 0;
      },
      publicKeyCreate(output, seckey) {
        const bn = new BN(seckey);
        if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
          return 1;
        const point = ec.keyFromPrivate(seckey).getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyConvert(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyNegate(output, pubkey) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const point = pair.getPublic();
        point.y = point.y.redNeg();
        savePublicKey(output, point);
        return 0;
      },
      publicKeyCombine(output, pubkeys) {
        const pairs = new Array(pubkeys.length);
        for (let i = 0; i < pubkeys.length; ++i) {
          pairs[i] = loadPublicKey(pubkeys[i]);
          if (pairs[i] === null)
            return 1;
        }
        let point = pairs[0].getPublic();
        for (let i = 1; i < pairs.length; ++i)
          point = point.add(pairs[i].pub);
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakAdd(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0)
          return 2;
        const point = pair.getPublic().add(ecparams.g.mul(tweak));
        if (point.isInfinity())
          return 2;
        savePublicKey(output, point);
        return 0;
      },
      publicKeyTweakMul(output, pubkey, tweak) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        tweak = new BN(tweak);
        if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
          return 2;
        const point = pair.getPublic().mul(tweak);
        savePublicKey(output, point);
        return 0;
      },
      signatureNormalize(sig) {
        const r = new BN(sig.subarray(0, 32));
        const s = new BN(sig.subarray(32, 64));
        if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0)
          return 1;
        if (s.cmp(ec.nh) === 1) {
          sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, "be", 32), 32);
        }
        return 0;
      },
      signatureExport(obj, sig) {
        const sigR = sig.subarray(0, 32);
        const sigS = sig.subarray(32, 64);
        if (new BN(sigR).cmp(ecparams.n) >= 0)
          return 1;
        if (new BN(sigS).cmp(ecparams.n) >= 0)
          return 1;
        const { output } = obj;
        let r = output.subarray(4, 4 + 33);
        r[0] = 0;
        r.set(sigR, 1);
        let lenR = 33;
        let posR = 0;
        for (; lenR > 1 && r[posR] === 0 && !(r[posR + 1] & 128); --lenR, ++posR)
          ;
        r = r.subarray(posR);
        if (r[0] & 128)
          return 1;
        if (lenR > 1 && r[0] === 0 && !(r[1] & 128))
          return 1;
        let s = output.subarray(6 + 33, 6 + 33 + 33);
        s[0] = 0;
        s.set(sigS, 1);
        let lenS = 33;
        let posS = 0;
        for (; lenS > 1 && s[posS] === 0 && !(s[posS + 1] & 128); --lenS, ++posS)
          ;
        s = s.subarray(posS);
        if (s[0] & 128)
          return 1;
        if (lenS > 1 && s[0] === 0 && !(s[1] & 128))
          return 1;
        obj.outputlen = 6 + lenR + lenS;
        output[0] = 48;
        output[1] = obj.outputlen - 2;
        output[2] = 2;
        output[3] = r.length;
        output.set(r, 4);
        output[4 + lenR] = 2;
        output[5 + lenR] = s.length;
        output.set(s, 6 + lenR);
        return 0;
      },
      signatureImport(output, sig) {
        if (sig.length < 8)
          return 1;
        if (sig.length > 72)
          return 1;
        if (sig[0] !== 48)
          return 1;
        if (sig[1] !== sig.length - 2)
          return 1;
        if (sig[2] !== 2)
          return 1;
        const lenR = sig[3];
        if (lenR === 0)
          return 1;
        if (5 + lenR >= sig.length)
          return 1;
        if (sig[4 + lenR] !== 2)
          return 1;
        const lenS = sig[5 + lenR];
        if (lenS === 0)
          return 1;
        if (6 + lenR + lenS !== sig.length)
          return 1;
        if (sig[4] & 128)
          return 1;
        if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
          return 1;
        if (sig[lenR + 6] & 128)
          return 1;
        if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
          return 1;
        let sigR = sig.subarray(4, 4 + lenR);
        if (sigR.length === 33 && sigR[0] === 0)
          sigR = sigR.subarray(1);
        if (sigR.length > 32)
          return 1;
        let sigS = sig.subarray(6 + lenR);
        if (sigS.length === 33 && sigS[0] === 0)
          sigS = sigS.slice(1);
        if (sigS.length > 32)
          throw new Error("S length is too long");
        let r = new BN(sigR);
        if (r.cmp(ecparams.n) >= 0)
          r = new BN(0);
        let s = new BN(sig.subarray(6 + lenR));
        if (s.cmp(ecparams.n) >= 0)
          s = new BN(0);
        output.set(r.toArrayLike(Uint8Array, "be", 32), 0);
        output.set(s.toArrayLike(Uint8Array, "be", 32), 32);
        return 0;
      },
      ecdsaSign(obj, message, seckey, data, noncefn) {
        if (noncefn) {
          const _noncefn = noncefn;
          noncefn = (counter) => {
            const nonce = _noncefn(message, seckey, null, data, counter);
            const isValid = nonce instanceof Uint8Array && nonce.length === 32;
            if (!isValid)
              throw new Error("This is the way");
            return new BN(nonce);
          };
        }
        const d = new BN(seckey);
        if (d.cmp(ecparams.n) >= 0 || d.isZero())
          return 1;
        let sig;
        try {
          sig = ec.sign(message, seckey, { canonical: true, k: noncefn, pers: data });
        } catch (err) {
          return 1;
        }
        obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
        obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
        obj.recid = sig.recoveryParam;
        return 0;
      },
      ecdsaVerify(sig, msg32, pubkey) {
        const sigObj = { r: sig.subarray(0, 32), s: sig.subarray(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero())
          return 3;
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 2;
        const point = pair.getPublic();
        const isValid = ec.verify(msg32, sigObj, point);
        return isValid ? 0 : 3;
      },
      ecdsaRecover(output, sig, recid, msg32) {
        const sigObj = { r: sig.slice(0, 32), s: sig.slice(32, 64) };
        const sigr = new BN(sigObj.r);
        const sigs = new BN(sigObj.s);
        if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
          return 1;
        if (sigr.isZero() || sigs.isZero())
          return 2;
        let point;
        try {
          point = ec.recoverPubKey(msg32, sigObj, recid);
        } catch (err) {
          return 2;
        }
        savePublicKey(output, point);
        return 0;
      },
      ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
        const pair = loadPublicKey(pubkey);
        if (pair === null)
          return 1;
        const scalar = new BN(seckey);
        if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
          return 2;
        const point = pair.getPublic().mul(scalar);
        if (hashfn === void 0) {
          const data2 = point.encode(null, true);
          const sha2562 = ec.hash().update(data2).digest();
          for (let i = 0; i < 32; ++i)
            output[i] = sha2562[i];
        } else {
          if (!xbuf)
            xbuf = new Uint8Array(32);
          const x = point.getX().toArray("be", 32);
          for (let i = 0; i < 32; ++i)
            xbuf[i] = x[i];
          if (!ybuf)
            ybuf = new Uint8Array(32);
          const y = point.getY().toArray("be", 32);
          for (let i = 0; i < 32; ++i)
            ybuf[i] = y[i];
          const hash2 = hashfn(xbuf, ybuf, data);
          const isValid = hash2 instanceof Uint8Array && hash2.length === output.length;
          if (!isValid)
            return 2;
          output.set(hash2);
        }
        return 0;
      }
    };
  }
});

// node_modules/secp256k1/elliptic.js
var require_elliptic3 = __commonJS({
  "node_modules/secp256k1/elliptic.js"(exports2, module2) {
    init_node_globals();
    module2.exports = require_lib()(require_elliptic2());
  }
});

// node_modules/libp2p-crypto/src/keys/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/libp2p-crypto/src/keys/secp256k1.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var secp256k1 = require_elliptic3();
    var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
    module2.exports = (randomBytes) => {
      const privateKeyLength = 32;
      function generateKey() {
        let privateKey;
        do {
          privateKey = randomBytes(32);
        } while (!secp256k1.privateKeyVerify(privateKey));
        return privateKey;
      }
      async function hashAndSign(key, msg) {
        const { digest } = await sha2562.digest(msg);
        const sig = secp256k1.ecdsaSign(digest, key);
        return secp256k1.signatureExport(sig.signature);
      }
      async function hashAndVerify(key, sig, msg) {
        const { digest } = await sha2562.digest(msg);
        sig = secp256k1.signatureImport(sig);
        return secp256k1.ecdsaVerify(sig, digest, key);
      }
      function compressPublicKey(key) {
        if (!secp256k1.publicKeyVerify(key)) {
          throw new Error("Invalid public key");
        }
        return secp256k1.publicKeyConvert(key, true);
      }
      function decompressPublicKey(key) {
        return secp256k1.publicKeyConvert(key, false);
      }
      function validatePrivateKey(key) {
        if (!secp256k1.privateKeyVerify(key)) {
          throw new Error("Invalid private key");
        }
      }
      function validatePublicKey(key) {
        if (!secp256k1.publicKeyVerify(key)) {
          throw new Error("Invalid public key");
        }
      }
      function computePublicKey(privateKey) {
        validatePrivateKey(privateKey);
        return secp256k1.publicKeyCreate(privateKey);
      }
      return {
        generateKey,
        privateKeyLength,
        hashAndSign,
        hashAndVerify,
        compressPublicKey,
        decompressPublicKey,
        validatePrivateKey,
        validatePublicKey,
        computePublicKey
      };
    };
  }
});

// node_modules/libp2p-crypto/src/keys/secp256k1-class.js
var require_secp256k1_class = __commonJS({
  "node_modules/libp2p-crypto/src/keys/secp256k1-class.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
    var errcode7 = require_err_code();
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var exporter2 = require_exporter();
    module2.exports = (keysProtobuf, randomBytes, crypto3) => {
      crypto3 = crypto3 || require_secp256k12()(randomBytes);
      class Secp256k1PublicKey {
        constructor(key) {
          crypto3.validatePublicKey(key);
          this._key = key;
        }
        verify(data, sig) {
          return crypto3.hashAndVerify(this._key, sig, data);
        }
        marshal() {
          return crypto3.compressPublicKey(this._key);
        }
        get bytes() {
          return keysProtobuf.PublicKey.encode({
            Type: keysProtobuf.KeyType.Secp256k1,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes: bytes3 } = await sha2562.digest(this.bytes);
          return bytes3;
        }
      }
      class Secp256k1PrivateKey {
        constructor(key, publicKey) {
          this._key = key;
          this._publicKey = publicKey || crypto3.computePublicKey(key);
          crypto3.validatePrivateKey(this._key);
          crypto3.validatePublicKey(this._publicKey);
        }
        sign(message) {
          return crypto3.hashAndSign(this._key, message);
        }
        get public() {
          return new Secp256k1PublicKey(this._publicKey);
        }
        marshal() {
          return this._key;
        }
        get bytes() {
          return keysProtobuf.PrivateKey.encode({
            Type: keysProtobuf.KeyType.Secp256k1,
            Data: this.marshal()
          }).finish();
        }
        equals(key) {
          return uint8ArrayEquals(this.bytes, key.bytes);
        }
        async hash() {
          const { bytes: bytes3 } = await sha2562.digest(this.bytes);
          return bytes3;
        }
        async id() {
          const hash2 = await this.public.hash();
          return uint8ArrayToString(hash2, "base58btc");
        }
        async export(password, format = "libp2p-key") {
          if (format === "libp2p-key") {
            return exporter2.export(this.bytes, password);
          } else {
            throw errcode7(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
          }
        }
      }
      function unmarshalSecp256k1PrivateKey(bytes3) {
        return new Secp256k1PrivateKey(bytes3);
      }
      function unmarshalSecp256k1PublicKey(bytes3) {
        return new Secp256k1PublicKey(bytes3);
      }
      async function generateKeyPair() {
        const privateKeyBytes = await crypto3.generateKey();
        return new Secp256k1PrivateKey(privateKeyBytes);
      }
      return {
        Secp256k1PublicKey,
        Secp256k1PrivateKey,
        unmarshalSecp256k1PrivateKey,
        unmarshalSecp256k1PublicKey,
        generateKeyPair
      };
    };
  }
});

// node_modules/libp2p-crypto/src/hmac/lengths.js
var require_lengths = __commonJS({
  "node_modules/libp2p-crypto/src/hmac/lengths.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {
      SHA1: 20,
      SHA256: 32,
      SHA512: 64
    };
  }
});

// node_modules/libp2p-crypto/src/hmac/index-browser.js
var require_index_browser = __commonJS({
  "node_modules/libp2p-crypto/src/hmac/index-browser.js"(exports2) {
    init_node_globals();
    "use strict";
    var webcrypto = require_webcrypto();
    var lengths = require_lengths();
    var hashTypes = {
      SHA1: "SHA-1",
      SHA256: "SHA-256",
      SHA512: "SHA-512"
    };
    var sign2 = async (key, data) => {
      const buf2 = await webcrypto.get().subtle.sign({ name: "HMAC" }, key, data);
      return new Uint8Array(buf2, buf2.byteOffset, buf2.byteLength);
    };
    exports2.create = async function(hashType, secret) {
      const hash2 = hashTypes[hashType];
      const key = await webcrypto.get().subtle.importKey("raw", secret, {
        name: "HMAC",
        hash: { name: hash2 }
      }, false, ["sign"]);
      return {
        async digest(data) {
          return sign2(key, data);
        },
        length: lengths[hashType]
      };
    };
  }
});

// node_modules/libp2p-crypto/src/keys/key-stretcher.js
var require_key_stretcher = __commonJS({
  "node_modules/libp2p-crypto/src/keys/key-stretcher.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var hmac = require_index_browser();
    var cipherMap = {
      "AES-128": {
        ivSize: 16,
        keySize: 16
      },
      "AES-256": {
        ivSize: 16,
        keySize: 32
      },
      Blowfish: {
        ivSize: 8,
        cipherKeySize: 32
      }
    };
    module2.exports = async (cipherType, hash2, secret) => {
      const cipher = cipherMap[cipherType];
      if (!cipher) {
        const allowed = Object.keys(cipherMap).join(" / ");
        throw errcode7(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), "ERR_INVALID_CIPHER_TYPE");
      }
      if (!hash2) {
        throw errcode7(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE");
      }
      const cipherKeySize = cipher.keySize;
      const ivSize = cipher.ivSize;
      const hmacKeySize = 20;
      const seed = uint8ArrayFromString("key expansion");
      const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
      const m = await hmac.create(hash2, secret);
      let a = await m.digest(seed);
      const result = [];
      let j = 0;
      while (j < resultLength) {
        const b = await m.digest(uint8ArrayConcat([a, seed]));
        let todo = b.length;
        if (j + todo > resultLength) {
          todo = resultLength - j;
        }
        result.push(b);
        j += todo;
        a = await m.digest(a);
      }
      const half = resultLength / 2;
      const resultBuffer = uint8ArrayConcat(result);
      const r1 = resultBuffer.slice(0, half);
      const r2 = resultBuffer.slice(half, resultLength);
      const createKey2 = (res) => ({
        iv: res.slice(0, ivSize),
        cipherKey: res.slice(ivSize, ivSize + cipherKeySize),
        macKey: res.slice(ivSize + cipherKeySize)
      });
      return {
        k1: createKey2(r1),
        k2: createKey2(r2)
      };
    };
  }
});

// node_modules/libp2p-crypto/src/keys/validate-curve-type.js
var require_validate_curve_type = __commonJS({
  "node_modules/libp2p-crypto/src/keys/validate-curve-type.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    module2.exports = function(curveTypes, type) {
      if (!curveTypes.includes(type)) {
        const names = curveTypes.join(" / ");
        throw errcode7(new Error(`Unknown curve: ${type}. Must be ${names}`), "ERR_INVALID_CURVE");
      }
    };
  }
});

// node_modules/libp2p-crypto/src/keys/ecdh-browser.js
var require_ecdh_browser = __commonJS({
  "node_modules/libp2p-crypto/src/keys/ecdh-browser.js"(exports2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var webcrypto = require_webcrypto();
    var { base64urlToBuffer } = require_util2();
    var validateCurveType = require_validate_curve_type();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var bits = {
      "P-256": 256,
      "P-384": 384,
      "P-521": 521
    };
    exports2.generateEphmeralKeyPair = async function(curve) {
      validateCurveType(Object.keys(bits), curve);
      const pair = await webcrypto.get().subtle.generateKey({
        name: "ECDH",
        namedCurve: curve
      }, true, ["deriveBits"]);
      const genSharedKey = async (theirPub, forcePrivate) => {
        let privateKey;
        if (forcePrivate) {
          privateKey = await webcrypto.get().subtle.importKey("jwk", unmarshalPrivateKey(curve, forcePrivate), {
            name: "ECDH",
            namedCurve: curve
          }, false, ["deriveBits"]);
        } else {
          privateKey = pair.privateKey;
        }
        const keys = [
          await webcrypto.get().subtle.importKey("jwk", unmarshalPublicKey(curve, theirPub), {
            name: "ECDH",
            namedCurve: curve
          }, false, []),
          privateKey
        ];
        const buffer2 = await webcrypto.get().subtle.deriveBits({
          name: "ECDH",
          namedCurve: curve,
          public: keys[0]
        }, keys[1], bits[curve]);
        return new Uint8Array(buffer2, buffer2.byteOffset, buffer2.byteLength);
      };
      const publicKey = await webcrypto.get().subtle.exportKey("jwk", pair.publicKey);
      return {
        key: marshalPublicKey(publicKey),
        genSharedKey
      };
    };
    var curveLengths = {
      "P-256": 32,
      "P-384": 48,
      "P-521": 66
    };
    function marshalPublicKey(jwk) {
      const byteLen = curveLengths[jwk.crv];
      return uint8ArrayConcat([
        Uint8Array.from([4]),
        base64urlToBuffer(jwk.x, byteLen),
        base64urlToBuffer(jwk.y, byteLen)
      ], 1 + byteLen * 2);
    }
    function unmarshalPublicKey(curve, key) {
      const byteLen = curveLengths[curve];
      if (uint8ArrayEquals(!key.slice(0, 1), Uint8Array.from([4]))) {
        throw errcode7(new Error("Cannot unmarshal public key - invalid key format"), "ERR_INVALID_KEY_FORMAT");
      }
      return {
        kty: "EC",
        crv: curve,
        x: uint8ArrayToString(key.slice(1, byteLen + 1), "base64url"),
        y: uint8ArrayToString(key.slice(1 + byteLen), "base64url"),
        ext: true
      };
    }
    var unmarshalPrivateKey = (curve, key) => ({
      ...unmarshalPublicKey(curve, key.public),
      d: uint8ArrayToString(key.private, "base64url")
    });
  }
});

// node_modules/libp2p-crypto/src/keys/ephemeral-keys.js
var require_ephemeral_keys = __commonJS({
  "node_modules/libp2p-crypto/src/keys/ephemeral-keys.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var ecdh = require_ecdh_browser();
    module2.exports = async (curve) => ecdh.generateEphmeralKeyPair(curve);
  }
});

// node_modules/libp2p-crypto/src/keys/index.js
var require_keys2 = __commonJS({
  "node_modules/libp2p-crypto/src/keys/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var keysPBM = require_keys();
    require_asn1();
    require_pbe();
    var forge = require_forge();
    var errcode7 = require_err_code();
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var importer2 = require_importer();
    var supportedKeys = {
      rsa: require_rsa_class(),
      ed25519: require_ed25519_class(),
      secp256k1: require_secp256k1_class()(keysPBM, require_random_bytes())
    };
    var ErrMissingSecp256K1 = {
      message: "secp256k1 support requires libp2p-crypto-secp256k1 package",
      code: "ERR_MISSING_PACKAGE"
    };
    function typeToKey(type) {
      const key = supportedKeys[type.toLowerCase()];
      if (!key) {
        const supported = Object.keys(supportedKeys).join(" / ");
        throw errcode7(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), "ERR_UNSUPPORTED_KEY_TYPE");
      }
      return key;
    }
    var generateKeyPair = async (type, bits) => {
      return typeToKey(type).generateKeyPair(bits);
    };
    var generateKeyPairFromSeed = async (type, seed, bits) => {
      const key = typeToKey(type);
      if (type.toLowerCase() !== "ed25519") {
        throw errcode7(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
      }
      return key.generateKeyPairFromSeed(seed, bits);
    };
    var unmarshalPublicKey = (buf2) => {
      const decoded = keysPBM.PublicKey.decode(buf2);
      const data = decoded.Data;
      switch (decoded.Type) {
        case keysPBM.KeyType.RSA:
          return supportedKeys.rsa.unmarshalRsaPublicKey(data);
        case keysPBM.KeyType.Ed25519:
          return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
        case keysPBM.KeyType.Secp256k1:
          if (supportedKeys.secp256k1) {
            return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
          } else {
            throw errcode7(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
          }
        default:
          typeToKey(decoded.Type);
      }
    };
    var marshalPublicKey = (key, type) => {
      type = (type || "rsa").toLowerCase();
      typeToKey(type);
      return key.bytes;
    };
    var unmarshalPrivateKey = async (buf2) => {
      const decoded = keysPBM.PrivateKey.decode(buf2);
      const data = decoded.Data;
      switch (decoded.Type) {
        case keysPBM.KeyType.RSA:
          return supportedKeys.rsa.unmarshalRsaPrivateKey(data);
        case keysPBM.KeyType.Ed25519:
          return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
        case keysPBM.KeyType.Secp256k1:
          if (supportedKeys.secp256k1) {
            return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
          } else {
            throw errcode7(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
          }
        default:
          typeToKey(decoded.Type);
      }
    };
    var marshalPrivateKey = (key, type) => {
      type = (type || "rsa").toLowerCase();
      typeToKey(type);
      return key.bytes;
    };
    var importKey = async (encryptedKey, password) => {
      try {
        const key2 = await importer2.import(encryptedKey, password);
        return unmarshalPrivateKey(key2);
      } catch (_) {
      }
      const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);
      if (key === null) {
        throw errcode7(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
      }
      let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));
      der = uint8ArrayFromString(der.getBytes(), "ascii");
      return supportedKeys.rsa.unmarshalRsaPrivateKey(der);
    };
    module2.exports = {
      supportedKeys,
      keysPBM,
      keyStretcher: require_key_stretcher(),
      generateEphemeralKeyPair: require_ephemeral_keys(),
      generateKeyPair,
      generateKeyPairFromSeed,
      unmarshalPublicKey,
      marshalPublicKey,
      unmarshalPrivateKey,
      marshalPrivateKey,
      import: importKey
    };
  }
});

// node_modules/class-is/index.js
var require_class_is = __commonJS({
  "node_modules/class-is/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function withIs(Class, { className, symbolName }) {
      const symbol = Symbol.for(symbolName);
      const ClassIsWrapper = {
        [className]: class extends Class {
          constructor(...args) {
            super(...args);
            Object.defineProperty(this, symbol, { value: true });
          }
          get [Symbol.toStringTag]() {
            return className;
          }
        }
      }[className];
      ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);
      return ClassIsWrapper;
    }
    function withIsProto(Class, { className, symbolName, withoutNew }) {
      const symbol = Symbol.for(symbolName);
      const ClassIsWrapper = {
        [className]: function(...args) {
          if (withoutNew && !(this instanceof ClassIsWrapper)) {
            return new ClassIsWrapper(...args);
          }
          const _this = Class.call(this, ...args) || this;
          if (_this && !_this[symbol]) {
            Object.defineProperty(_this, symbol, { value: true });
          }
          return _this;
        }
      }[className];
      ClassIsWrapper.prototype = Object.create(Class.prototype);
      ClassIsWrapper.prototype.constructor = ClassIsWrapper;
      Object.defineProperty(ClassIsWrapper.prototype, Symbol.toStringTag, {
        get() {
          return className;
        }
      });
      ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);
      return ClassIsWrapper;
    }
    module2.exports = withIs;
    module2.exports.proto = withIsProto;
  }
});

// node_modules/peer-id/src/proto.js
var require_proto = __commonJS({
  "node_modules/peer-id/src/proto.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var $protobuf5 = require_minimal2();
    var $Reader5 = $protobuf5.Reader;
    var $Writer5 = $protobuf5.Writer;
    var $util5 = $protobuf5.util;
    var $root5 = $protobuf5.roots["libp2p-peer-id"] || ($protobuf5.roots["libp2p-peer-id"] = {});
    $root5.PeerIdProto = function() {
      function PeerIdProto(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      PeerIdProto.prototype.id = $util5.newBuffer([]);
      PeerIdProto.prototype.pubKey = $util5.newBuffer([]);
      PeerIdProto.prototype.privKey = $util5.newBuffer([]);
      PeerIdProto.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        w.uint32(10).bytes(m.id);
        if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
          w.uint32(18).bytes(m.pubKey);
        if (m.privKey != null && Object.hasOwnProperty.call(m, "privKey"))
          w.uint32(26).bytes(m.privKey);
        return w;
      };
      PeerIdProto.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.PeerIdProto();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.id = r.bytes();
              break;
            case 2:
              m.pubKey = r.bytes();
              break;
            case 3:
              m.privKey = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        if (!m.hasOwnProperty("id"))
          throw $util5.ProtocolError("missing required 'id'", { instance: m });
        return m;
      };
      PeerIdProto.fromObject = function fromObject(d) {
        if (d instanceof $root5.PeerIdProto)
          return d;
        var m = new $root5.PeerIdProto();
        if (d.id != null) {
          if (typeof d.id === "string")
            $util5.base64.decode(d.id, m.id = $util5.newBuffer($util5.base64.length(d.id)), 0);
          else if (d.id.length)
            m.id = d.id;
        }
        if (d.pubKey != null) {
          if (typeof d.pubKey === "string")
            $util5.base64.decode(d.pubKey, m.pubKey = $util5.newBuffer($util5.base64.length(d.pubKey)), 0);
          else if (d.pubKey.length)
            m.pubKey = d.pubKey;
        }
        if (d.privKey != null) {
          if (typeof d.privKey === "string")
            $util5.base64.decode(d.privKey, m.privKey = $util5.newBuffer($util5.base64.length(d.privKey)), 0);
          else if (d.privKey.length)
            m.privKey = d.privKey;
        }
        return m;
      };
      PeerIdProto.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.id = "";
          else {
            d.id = [];
            if (o.bytes !== Array)
              d.id = $util5.newBuffer(d.id);
          }
          if (o.bytes === String)
            d.pubKey = "";
          else {
            d.pubKey = [];
            if (o.bytes !== Array)
              d.pubKey = $util5.newBuffer(d.pubKey);
          }
          if (o.bytes === String)
            d.privKey = "";
          else {
            d.privKey = [];
            if (o.bytes !== Array)
              d.privKey = $util5.newBuffer(d.privKey);
          }
        }
        if (m.id != null && m.hasOwnProperty("id")) {
          d.id = o.bytes === String ? $util5.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;
        }
        if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
          d.pubKey = o.bytes === String ? $util5.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
        }
        if (m.privKey != null && m.hasOwnProperty("privKey")) {
          d.privKey = o.bytes === String ? $util5.base64.encode(m.privKey, 0, m.privKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.privKey) : m.privKey;
        }
        return d;
      };
      PeerIdProto.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      return PeerIdProto;
    }();
    module2.exports = $root5;
  }
});

// node_modules/peer-id/src/index.js
var require_src6 = __commonJS({
  "node_modules/peer-id/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { CID: CID2 } = (init_cid(), cid_exports);
    var b32 = (init_base32(), base32_exports);
    var b36 = (init_base36(), base36_exports);
    var b58 = (init_base58(), base58_exports);
    var b64 = (init_base64(), base64_exports);
    var { base58btc: base58btc2 } = (init_base58(), base58_exports);
    var { base32: base322 } = (init_base32(), base32_exports);
    var { base16: base162 } = (init_base16(), base16_exports);
    var Digest9 = (init_digest(), digest_exports);
    var cryptoKeys = require_keys2();
    var withIs = require_class_is();
    var { PeerIdProto } = require_proto();
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { identity: identity3 } = (init_identity(), identity_exports);
    var bases2 = {
      ...b32,
      ...b36,
      ...b58,
      ...b64
    };
    var baseDecoder = Object.keys(bases2).reduce((acc, curr) => acc.or(bases2[curr]), base322.decoder);
    var DAG_PB_CODE2 = 112;
    var LIBP2P_KEY_CODE = 114;
    var PeerId2 = class {
      constructor(id, privKey, pubKey) {
        if (!(id instanceof Uint8Array)) {
          throw new Error("invalid id provided");
        }
        if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {
          throw new Error("inconsistent arguments");
        }
        this._id = id;
        this._idB58String = base58btc2.encode(this.id).substring(1);
        this._privKey = privKey;
        this._pubKey = pubKey;
      }
      get id() {
        return this._id;
      }
      set id(val) {
        throw new Error("Id is immutable");
      }
      get privKey() {
        return this._privKey;
      }
      set privKey(privKey) {
        this._privKey = privKey;
      }
      get pubKey() {
        if (this._pubKey) {
          return this._pubKey;
        }
        if (this._privKey) {
          return this._privKey.public;
        }
        try {
          const decoded = Digest9.decode(this.id);
          if (decoded.code === identity3.code) {
            this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);
          }
        } catch (_) {
        }
        return this._pubKey;
      }
      set pubKey(pubKey) {
        this._pubKey = pubKey;
      }
      marshalPubKey() {
        if (this.pubKey) {
          return cryptoKeys.marshalPublicKey(this.pubKey);
        }
      }
      marshalPrivKey() {
        if (this.privKey) {
          return cryptoKeys.marshalPrivateKey(this.privKey);
        }
      }
      marshal(excludePriv) {
        return PeerIdProto.encode({
          id: this.toBytes(),
          pubKey: this.marshalPubKey(),
          privKey: excludePriv ? null : this.marshalPrivKey()
        }).finish();
      }
      toPrint() {
        let pid = this.toB58String();
        if (pid.startsWith("Qm")) {
          pid = pid.slice(2);
        }
        let maxRunes = 6;
        if (pid.length < maxRunes) {
          maxRunes = pid.length;
        }
        return "<peer.ID " + pid.substr(0, maxRunes) + ">";
      }
      toJSON() {
        return {
          id: this.toB58String(),
          privKey: toB64Opt(this.marshalPrivKey()),
          pubKey: toB64Opt(this.marshalPubKey())
        };
      }
      toHexString() {
        return base162.encode(this.id).substring(1);
      }
      toBytes() {
        return this.id;
      }
      toB58String() {
        return this._idB58String;
      }
      toString() {
        if (!this._idCIDString) {
          const cid = CID2.createV1(LIBP2P_KEY_CODE, Digest9.decode(this.id));
          Object.defineProperty(this, "_idCIDString", {
            value: cid.toString(),
            enumerable: false
          });
        }
        return this._idCIDString;
      }
      equals(id) {
        if (id instanceof Uint8Array) {
          return uint8ArrayEquals(this.id, id);
        } else if (id.id) {
          return uint8ArrayEquals(this.id, id.id);
        } else {
          throw new Error("not valid Id");
        }
      }
      isEqual(id) {
        return this.equals(id);
      }
      isValid() {
        return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes));
      }
      hasInlinePublicKey() {
        try {
          const decoded = Digest9.decode(this.id);
          if (decoded.code === identity3.code) {
            return true;
          }
        } catch (_) {
        }
        return false;
      }
    };
    var PeerIdWithIs = withIs(PeerId2, {
      className: "PeerId",
      symbolName: "@libp2p/js-peer-id/PeerId"
    });
    exports2 = module2.exports = PeerIdWithIs;
    var computeDigest = (pubKey) => {
      if (pubKey.bytes.length <= 42) {
        return Digest9.create(identity3.code, pubKey.bytes).bytes;
      } else {
        return pubKey.hash();
      }
    };
    var computePeerId = async (privKey, pubKey) => {
      const digest = await computeDigest(pubKey);
      return new PeerIdWithIs(digest, privKey, pubKey);
    };
    exports2.create = async (opts) => {
      opts = opts || {};
      opts.bits = opts.bits || 2048;
      opts.keyType = opts.keyType || "RSA";
      const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits);
      return computePeerId(key, key.public);
    };
    exports2.createFromHexString = (str) => {
      return new PeerIdWithIs(base162.decode("f" + str));
    };
    exports2.createFromBytes = (buf2) => {
      try {
        const cid = CID2.decode(buf2);
        if (!validMulticodec(cid)) {
          throw new Error("Supplied PeerID CID is invalid");
        }
        return exports2.createFromCID(cid);
      } catch {
        const digest = Digest9.decode(buf2);
        if (digest.code !== identity3.code) {
          throw new Error("Supplied PeerID CID is invalid");
        }
        return new PeerIdWithIs(buf2);
      }
    };
    exports2.createFromB58String = (str) => {
      return exports2.createFromBytes(base58btc2.decode("z" + str));
    };
    var validMulticodec = (cid) => {
      return cid.code === LIBP2P_KEY_CODE || cid.code === DAG_PB_CODE2;
    };
    exports2.createFromCID = (cid) => {
      cid = CID2.asCID(cid);
      if (!cid || !validMulticodec(cid)) {
        throw new Error("Supplied PeerID CID is invalid");
      }
      return new PeerIdWithIs(cid.multihash.bytes);
    };
    exports2.createFromPubKey = async (key) => {
      let buf2 = key;
      if (typeof buf2 === "string") {
        buf2 = uint8ArrayFromString(key, "base64pad");
      }
      if (!(buf2 instanceof Uint8Array)) {
        throw new Error("Supplied key is neither a base64 string nor a Uint8Array");
      }
      const pubKey = await cryptoKeys.unmarshalPublicKey(buf2);
      return computePeerId(void 0, pubKey);
    };
    exports2.createFromPrivKey = async (key) => {
      if (typeof key === "string") {
        key = uint8ArrayFromString(key, "base64pad");
      }
      if (!(key instanceof Uint8Array)) {
        throw new Error("Supplied key is neither a base64 string nor a Uint8Array");
      }
      const privKey = await cryptoKeys.unmarshalPrivateKey(key);
      return computePeerId(privKey, privKey.public);
    };
    exports2.createFromJSON = async (obj) => {
      const id = base58btc2.decode("z" + obj.id);
      const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, "base64pad");
      const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, "base64pad");
      const pub = rawPubKey && await cryptoKeys.unmarshalPublicKey(rawPubKey);
      if (!rawPrivKey) {
        return new PeerIdWithIs(id, void 0, pub);
      }
      const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey);
      const privDigest = await computeDigest(privKey.public);
      let pubDigest;
      if (pub) {
        pubDigest = await computeDigest(pub);
      }
      if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {
        throw new Error("Public and private key do not match");
      }
      if (id && !uint8ArrayEquals(privDigest, id)) {
        throw new Error("Id and private key do not match");
      }
      return new PeerIdWithIs(id, privKey, pub);
    };
    exports2.createFromProtobuf = async (buf2) => {
      if (typeof buf2 === "string") {
        buf2 = uint8ArrayFromString(buf2, "base16");
      }
      let { id, privKey, pubKey } = PeerIdProto.decode(buf2);
      privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false;
      pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false;
      let pubDigest;
      let privDigest;
      if (privKey) {
        privDigest = await computeDigest(privKey.public);
      }
      if (pubKey) {
        pubDigest = await computeDigest(pubKey);
      }
      if (privKey) {
        if (pubKey) {
          if (!uint8ArrayEquals(privDigest, pubDigest)) {
            throw new Error("Public and private key do not match");
          }
        }
        return new PeerIdWithIs(privDigest, privKey, privKey.public);
      }
      if (pubKey) {
        return new PeerIdWithIs(pubDigest, void 0, pubKey);
      }
      if (id) {
        return new PeerIdWithIs(id);
      }
      throw new Error("Protobuf did not contain any usable key material");
    };
    exports2.parse = (str) => {
      if (str.charAt(0) === "1" || str.charAt(0) === "Q") {
        str = `z${str}`;
      }
      return exports2.createFromBytes(baseDecoder.decode(str));
    };
    exports2.isPeerId = (peerId) => {
      return Boolean(typeof peerId === "object" && peerId._id && peerId._idB58String);
    };
    function toB64Opt(val) {
      if (val) {
        return uint8ArrayToString(val, "base64pad");
      }
    }
  }
});

// node_modules/ipfs-core/cjs/src/components/resolve.js
var require_resolve = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/resolve.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isIpfs = require_src3();
    var cid = (init_cid(), cid_exports);
    var PeerId2 = require_src6();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var utils = require_utils();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var isIpfs__default = /* @__PURE__ */ _interopDefaultLegacy(isIpfs);
    var PeerId__default = /* @__PURE__ */ _interopDefaultLegacy(PeerId2);
    function createResolve4({ repo, codecs: codecs2, bases: bases2, name: name5 }) {
      async function resolve6(path, opts = {}) {
        if (!isIpfs__default["default"].path(path)) {
          throw new Error("invalid argument " + path);
        }
        if (isIpfs__default["default"].ipnsPath(path)) {
          for await (const resolvedPath of name5.resolve(path, opts)) {
            path = resolvedPath;
          }
        }
        const [, schema, hash2, ...rest] = path.split("/");
        const base3 = opts.cidBase ? await bases2.getBase(opts.cidBase) : void 0;
        const bytes3 = parseBytes(hash2);
        if (rest.length === 0) {
          const str = base3 ? base3.encoder.encode(bytes3) : hash2;
          return `/${schema}/${str}`;
        }
        const cid$1 = cid.CID.decode(bytes3);
        path = rest.join("/");
        const results = utils.resolve(cid$1, path, codecs2, repo, opts);
        let value = cid$1;
        let remainderPath = path;
        for await (const result of results) {
          if (cid.CID.asCID(result.value)) {
            value = result.value;
            remainderPath = result.remainderPath;
          }
        }
        return `/ipfs/${value.toString(base3 && base3.encoder)}${remainderPath ? "/" + remainderPath : ""}`;
      }
      return withTimeoutOption2.withTimeoutOption(resolve6);
    }
    function parseBytes(str) {
      try {
        return PeerId__default["default"].parse(str).toBytes();
      } catch {
        return cid.CID.parse(str).bytes;
      }
    }
    exports2.createResolve = createResolve4;
  }
});

// node_modules/it-last/index.js
var require_it_last = __commonJS({
  "node_modules/it-last/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var last6 = async (source) => {
      let res;
      for await (const entry of source) {
        res = entry;
      }
      return res;
    };
    module2.exports = last6;
  }
});

// node_modules/ipfs-core/cjs/src/components/pin/add.js
var require_add = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/pin/add.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var last6 = require_it_last();
    var cid = (init_cid(), cid_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var last__default = /* @__PURE__ */ _interopDefaultLegacy(last6);
    function createAdd6({ addAll }) {
      return (path, options = {}) => {
        let iter;
        const cid$1 = cid.CID.asCID(path);
        if (cid$1) {
          iter = addAll([{
            cid: cid$1,
            ...options
          }], options);
        } else {
          iter = addAll([{
            path: path.toString(),
            ...options
          }], options);
        }
        return last__default["default"](iter);
      };
    }
    exports2.createAdd = createAdd6;
  }
});

// node_modules/ipfs-core-utils/esm/src/pins/normalise-input.js
var normalise_input_exports = {};
__export(normalise_input_exports, {
  normaliseInput: () => normaliseInput
});
async function* normaliseInput(input) {
  if (input === null || input === void 0) {
    throw (0, import_err_code3.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  const cid = CID.asCID(input);
  if (cid) {
    yield toPin({ cid });
    return;
  }
  if (input instanceof String || typeof input === "string") {
    yield toPin({ path: input });
    return;
  }
  if (input.cid != null || input.path != null) {
    return yield toPin(input);
  }
  if (Symbol.iterator in input) {
    const iterator = input[Symbol.iterator]();
    const first3 = iterator.next();
    if (first3.done)
      return iterator;
    if (CID.asCID(first3.value) || first3.value instanceof String || typeof first3.value === "string") {
      yield toPin({ cid: first3.value });
      for (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first3.value.cid != null || first3.value.path != null) {
      yield toPin(first3.value);
      for (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code3.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  if (Symbol.asyncIterator in input) {
    const iterator = input[Symbol.asyncIterator]();
    const first3 = await iterator.next();
    if (first3.done)
      return iterator;
    if (CID.asCID(first3.value) || first3.value instanceof String || typeof first3.value === "string") {
      yield toPin({ cid: first3.value });
      for await (const cid2 of iterator) {
        yield toPin({ cid: cid2 });
      }
      return;
    }
    if (first3.value.cid != null || first3.value.path != null) {
      yield toPin(first3.value);
      for await (const obj of iterator) {
        yield toPin(obj);
      }
      return;
    }
    throw (0, import_err_code3.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  }
  throw (0, import_err_code3.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
function toPin(input) {
  const path = input.cid || `${input.path}`;
  if (!path) {
    throw (0, import_err_code3.default)(new Error("Unexpected input: Please path either a CID or an IPFS path"), "ERR_UNEXPECTED_INPUT");
  }
  const pin = {
    path,
    recursive: input.recursive !== false
  };
  if (input.metadata != null) {
    pin.metadata = input.metadata;
  }
  return pin;
}
var import_err_code3;
var init_normalise_input = __esm({
  "node_modules/ipfs-core-utils/esm/src/pins/normalise-input.js"() {
    init_node_globals();
    import_err_code3 = __toModule(require_err_code());
    init_cid();
  }
});

// node_modules/ipfs-repo/esm/src/pin-types.js
var pin_types_exports = {};
__export(pin_types_exports, {
  PinTypes: () => PinTypes
});
var PinTypes;
var init_pin_types = __esm({
  "node_modules/ipfs-repo/esm/src/pin-types.js"() {
    init_node_globals();
    PinTypes = {
      direct: "direct",
      recursive: "recursive",
      indirect: "indirect",
      all: "all"
    };
  }
});

// node_modules/ipfs-core/cjs/src/components/pin/add-all.js
var require_add_all = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/pin/add-all.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var normaliseInput4 = (init_normalise_input(), normalise_input_exports);
    var pinTypes = (init_pin_types(), pin_types_exports);
    function createAddAll3({ repo, codecs: codecs2 }) {
      async function* addAll(source, options = {}) {
        const pinAdd = async function* () {
          for await (const { path, recursive: recursive2, metadata } of normaliseInput4.normaliseInput(source)) {
            const { cid } = await utils.resolvePath(repo, codecs2, path);
            const { reason } = await repo.pins.isPinnedWithType(cid, [
              pinTypes.PinTypes.recursive,
              pinTypes.PinTypes.direct
            ]);
            if (reason === "recursive" && !recursive2) {
              throw new Error(`${cid} already pinned recursively`);
            }
            if (recursive2) {
              await repo.pins.pinRecursively(cid, { metadata });
            } else {
              await repo.pins.pinDirectly(cid, { metadata });
            }
            yield cid;
          }
        };
        const lock2 = Boolean(options.lock);
        if (!lock2) {
          yield* pinAdd();
          return;
        }
        const release = await repo.gcLock.readLock();
        try {
          yield* pinAdd();
        } finally {
          release();
        }
      }
      return withTimeoutOption2.withTimeoutOption(addAll);
    }
    exports2.createAddAll = createAddAll3;
  }
});

// node_modules/ipfs-core/cjs/src/components/pin/ls.js
var require_ls = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/pin/ls.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var normaliseInput4 = (init_normalise_input(), normalise_input_exports);
    var utils = require_utils();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var errCode32 = require_err_code();
    var pinTypes = (init_pin_types(), pin_types_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    function toPin3(type, cid, metadata) {
      const output = {
        type,
        cid
      };
      if (metadata) {
        output.metadata = metadata;
      }
      return output;
    }
    function createLs8({ repo, codecs: codecs2 }) {
      async function* ls(options = {}) {
        let type = pinTypes.PinTypes.all;
        if (options.type) {
          type = options.type;
          if (!Object.keys(pinTypes.PinTypes).includes(type)) {
            throw errCode__default["default"](new Error("Invalid pin type"), "ERR_INVALID_PIN_TYPE");
          }
        }
        if (options.paths) {
          let matched = false;
          for await (const { path } of normaliseInput4.normaliseInput(options.paths)) {
            const { cid } = await utils.resolvePath(repo, codecs2, path);
            const { reason, pinned, parent: parent2, metadata } = await repo.pins.isPinnedWithType(cid, type);
            if (!pinned) {
              throw errCode__default["default"](new Error(`path '${path}' is not pinned`), "ERR_NOT_PINNED");
            }
            switch (reason) {
              case pinTypes.PinTypes.direct:
              case pinTypes.PinTypes.recursive:
                matched = true;
                yield toPin3(reason, cid, metadata);
                break;
              default:
                matched = true;
                yield toPin3(`${pinTypes.PinTypes.indirect} through ${parent2}`, cid, metadata);
            }
          }
          if (!matched) {
            throw new Error("No match found");
          }
          return;
        }
        if (type === pinTypes.PinTypes.recursive || type === pinTypes.PinTypes.all) {
          for await (const { cid, metadata } of repo.pins.recursiveKeys()) {
            yield toPin3(pinTypes.PinTypes.recursive, cid, metadata);
          }
        }
        if (type === pinTypes.PinTypes.indirect || type === pinTypes.PinTypes.all) {
          for await (const cid of repo.pins.indirectKeys(options)) {
            yield toPin3(pinTypes.PinTypes.indirect, cid);
          }
        }
        if (type === pinTypes.PinTypes.direct || type === pinTypes.PinTypes.all) {
          for await (const { cid, metadata } of repo.pins.directKeys()) {
            yield toPin3(pinTypes.PinTypes.direct, cid, metadata);
          }
        }
      }
      return withTimeoutOption2.withTimeoutOption(ls);
    }
    exports2.createLs = createLs8;
  }
});

// node_modules/ipfs-core/cjs/src/components/pin/rm.js
var require_rm = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/pin/rm.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var last6 = require_it_last();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var last__default = /* @__PURE__ */ _interopDefaultLegacy(last6);
    function createRm8({ rmAll }) {
      async function rm(path, options = {}) {
        const cid = await last__default["default"](rmAll([{
          path,
          ...options
        }], options));
        if (!cid) {
          throw new Error("CID expected");
        }
        return cid;
      }
      return rm;
    }
    exports2.createRm = createRm8;
  }
});

// node_modules/ipfs-core/cjs/src/components/pin/rm-all.js
var require_rm_all = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/pin/rm-all.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var normaliseInput4 = (init_normalise_input(), normalise_input_exports);
    var utils = require_utils();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var pinTypes = (init_pin_types(), pin_types_exports);
    function createRmAll3({ repo, codecs: codecs2 }) {
      async function* rmAll(source, _options = {}) {
        const release = await repo.gcLock.readLock();
        try {
          for await (const { path, recursive: recursive2 } of normaliseInput4.normaliseInput(source)) {
            const { cid } = await utils.resolvePath(repo, codecs2, path);
            const { pinned, reason } = await repo.pins.isPinnedWithType(cid, pinTypes.PinTypes.all);
            if (!pinned) {
              throw new Error(`${cid} is not pinned`);
            }
            switch (reason) {
              case pinTypes.PinTypes.recursive:
                if (!recursive2) {
                  throw new Error(`${cid} is pinned recursively`);
                }
                await repo.pins.unpin(cid);
                yield cid;
                break;
              case pinTypes.PinTypes.direct:
                await repo.pins.unpin(cid);
                yield cid;
                break;
              default:
                throw new Error(`${cid} is pinned indirectly under ${reason}`);
            }
          }
        } finally {
          release();
        }
      }
      return withTimeoutOption2.withTimeoutOption(rmAll);
    }
    exports2.createRmAll = createRmAll3;
  }
});

// node_modules/ipfs-core/cjs/src/components/pin/index.js
var require_pin = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/pin/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var add = require_add();
    var addAll = require_add_all();
    var ls = require_ls();
    var rm = require_rm();
    var rmAll = require_rm_all();
    var PinAPI = class {
      constructor({ codecs: codecs2, repo }) {
        const addAll$1 = addAll.createAddAll({
          codecs: codecs2,
          repo
        });
        this.addAll = addAll$1;
        this.add = add.createAdd({ addAll: addAll$1 });
        const rmAll$1 = rmAll.createRmAll({
          codecs: codecs2,
          repo
        });
        this.rmAll = rmAll$1;
        this.rm = rm.createRm({ rmAll: rmAll$1 });
        this.ls = ls.createLs({
          codecs: codecs2,
          repo
        });
        this.remote = {
          add: (cid, options = {}) => Promise.reject(new Error("Not implemented")),
          ls: async function* (query, options = {}) {
            return Promise.reject(new Error("Not implemented"));
          },
          rm: (query, options = {}) => Promise.reject(new Error("Not implemented")),
          rmAll: (query, options = {}) => Promise.reject(new Error("Not implemented")),
          service: {
            add: (name5, credentials) => Promise.reject(new Error("Not implemented")),
            rm: (name5, options = {}) => Promise.reject(new Error("Not implemented")),
            ls: (options = {}) => Promise.reject(new Error("Not implemented"))
          }
        };
      }
    };
    exports2.PinAPI = PinAPI;
  }
});

// node_modules/datastore-core/esm/src/errors.js
var errors_exports = {};
__export(errors_exports, {
  abortedError: () => abortedError,
  dbDeleteFailedError: () => dbDeleteFailedError,
  dbOpenFailedError: () => dbOpenFailedError,
  dbWriteFailedError: () => dbWriteFailedError,
  notFoundError: () => notFoundError
});
function dbOpenFailedError(err) {
  err = err || new Error("Cannot open database");
  return (0, import_err_code4.default)(err, "ERR_DB_OPEN_FAILED");
}
function dbDeleteFailedError(err) {
  err = err || new Error("Delete failed");
  return (0, import_err_code4.default)(err, "ERR_DB_DELETE_FAILED");
}
function dbWriteFailedError(err) {
  err = err || new Error("Write failed");
  return (0, import_err_code4.default)(err, "ERR_DB_WRITE_FAILED");
}
function notFoundError(err) {
  err = err || new Error("Not Found");
  return (0, import_err_code4.default)(err, "ERR_NOT_FOUND");
}
function abortedError(err) {
  err = err || new Error("Aborted");
  return (0, import_err_code4.default)(err, "ERR_ABORTED");
}
var import_err_code4;
var init_errors2 = __esm({
  "node_modules/datastore-core/esm/src/errors.js"() {
    init_node_globals();
    import_err_code4 = __toModule(require_err_code());
  }
});

// node_modules/timestamp-nano/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/timestamp-nano/timestamp.js"(exports2, module2) {
    init_node_globals();
    var Timestamp = function() {
      if (typeof module2 !== "undefined")
        module2.exports = Timestamp2;
      var SEC_DAY = 24 * 3600;
      var YEAR_SLOT = 3200;
      var DAY_SLOT = (365 * 400 + 97) * YEAR_SLOT / 400;
      var SEC_SLOT = SEC_DAY * DAY_SLOT;
      var MSEC_SLOT = SEC_SLOT * 1e3;
      var MAX_MSEC = 1e3 * 1e4 * 1e4 * SEC_DAY;
      var BIT24 = 16777216;
      var BIT32 = 65536 * 65536;
      var DEC6 = 1e3 * 1e3;
      var DEC9 = 1e3 * 1e3 * 1e3;
      var ZERO9 = "000000000";
      var trunc = Math.trunc || Math_trunc;
      var P = Timestamp2.prototype;
      Timestamp2.fromDate = fromDate;
      Timestamp2.fromInt64BE = buildFromInt64(0, 1, 2, 3, 0, 4);
      Timestamp2.fromInt64LE = buildFromInt64(3, 2, 1, 0, 4, 0);
      Timestamp2.fromString = fromString4;
      Timestamp2.fromTimeT = fromTimeT;
      P.year = 0;
      P.time = 0;
      P.nano = 0;
      P.addNano = addNano;
      P.getNano = getNano;
      P.getTimeT = getTimeT;
      P.getYear = getYear;
      P.toDate = toDate;
      P.toJSON = toJSON;
      P.toString = toString4;
      P.writeInt64BE = buildWriteInt64(0, 1, 2, 3, 0, 4);
      P.writeInt64LE = buildWriteInt64(3, 2, 1, 0, 4, 0);
      var FMT_JSON = "%Y-%m-%dT%H:%M:%S.%NZ";
      var FMT_MONTH = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec"
      ];
      var FMT_DAY = [
        "Sun",
        "Mon",
        "Tue",
        "Wed",
        "Thu",
        "Fri",
        "Sat"
      ];
      var FMT_STRING = {
        "%": "%",
        F: "%Y-%m-%d",
        n: "\n",
        R: "%H:%M",
        T: "%H:%M:%S",
        t: "	",
        X: "%T",
        Z: "GMT",
        z: "+0000"
      };
      return Timestamp2;
      function Timestamp2(time, nano, year) {
        var ts = this;
        if (!(ts instanceof Timestamp2))
          return new Timestamp2(time, nano, year);
        ts.time = +time || 0;
        ts.nano = +nano || 0;
        ts.year = +year || 0;
        normalize(ts);
      }
      function getYear() {
        var year = this.toDate().getUTCFullYear();
        return year + this.year;
      }
      function normalize(ts) {
        var year = ts.year;
        var time = ts.time;
        var nano = ts.nano;
        var changed;
        var slot;
        if (nano < 0 || DEC6 <= nano) {
          var n = Math.floor(nano / DEC6);
          nano -= n * DEC6;
          time += n;
          changed = 1;
        }
        var y = year % YEAR_SLOT;
        if (time < -MAX_MSEC || MAX_MSEC < time || y) {
          slot = trunc(time / MSEC_SLOT);
          if (slot) {
            year += slot * YEAR_SLOT;
            time -= slot * MSEC_SLOT;
          }
          var dt = newDate(time);
          dt.setUTCFullYear(y + dt.getUTCFullYear());
          year -= y;
          time = +dt;
          slot = trunc(year / YEAR_SLOT);
          var total = time + slot * MSEC_SLOT;
          if (slot && -MAX_MSEC <= total && total <= MAX_MSEC) {
            year -= slot * YEAR_SLOT;
            time = total;
          }
          changed = 1;
        }
        if (changed) {
          ts.year = year;
          ts.time = time;
          ts.nano = nano;
        }
        return ts;
      }
      function toDate() {
        var ts = normalize(this);
        return newDate(ts.time);
      }
      function newDate(time) {
        var dt = new Date(0);
        dt.setTime(time);
        return dt;
      }
      function addNano(nano) {
        this.nano += +nano || 0;
        return this;
      }
      function getNano() {
        var ts = normalize(this);
        return (ts.time % 1e3 * DEC6 + +ts.nano + DEC9) % DEC9;
      }
      function fromString4(string3) {
        var time;
        var ts = new Timestamp2();
        string3 += "";
        var array2 = string3.replace(/^\s*[+\-]?\d+/, function(match) {
          var year = +match;
          var y = 1970 + (year - 1970) % 400;
          ts.year = year - y;
          return y;
        }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(match, hour, min) {
          if (hour < 0)
            min *= -1;
          time = (+hour * 60 + +min) * 6e4;
          return "";
        }).replace(/\.\d+$/, function(match) {
          ts.nano = +(match + ZERO9).substr(1, 9);
          return "";
        }).split(/\D+/);
        if (array2.length > 1) {
          array2[1]--;
        } else {
          array2[1] = 0;
        }
        ts.time = time = Date.UTC.apply(Date, array2) - (time || 0);
        if (isNaN(time)) {
          throw new TypeError("Invalid Date");
        }
        return normalize(ts);
      }
      function fromDate(date) {
        return new Timestamp2(+date);
      }
      function fromTimeT(time) {
        return fromTime(time, 0);
      }
      function fromTime(low, high) {
        high |= 0;
        high *= BIT32;
        low = +low || 0;
        var slot = trunc(high / SEC_SLOT) + trunc(low / SEC_SLOT);
        var second = high % SEC_SLOT + low % SEC_SLOT;
        var offset = trunc(second / SEC_SLOT);
        if (offset) {
          slot += offset;
          second -= offset * SEC_SLOT;
        }
        return new Timestamp2(second * 1e3, 0, slot * YEAR_SLOT);
      }
      function getTimeT() {
        var ts = normalize(this);
        var time = Math.floor(ts.time / 1e3);
        var year = ts.year;
        if (year)
          time += year * DAY_SLOT * SEC_DAY / YEAR_SLOT;
        return time;
      }
      function toJSON() {
        return this.toString().replace(/0{1,6}Z$/, "Z");
      }
      function toString4(format) {
        var ts = this;
        var dt = ts.toDate();
        var map8 = {
          H,
          L,
          M,
          N,
          S,
          Y,
          a,
          b,
          d,
          e,
          m
        };
        return strftime(format || FMT_JSON);
        function strftime(format2) {
          return format2.replace(/%./g, function(match) {
            var m2 = match[1];
            var c = FMT_STRING[m2];
            var f = map8[m2];
            return c ? strftime(c) : f ? f() : match;
          });
        }
        function Y() {
          var year = ts.getYear();
          if (year > 999999) {
            return "+" + year;
          } else if (year > 9999) {
            return "+" + pad(year, 6);
          } else if (year >= 0) {
            return pad(year, 4);
          } else if (year >= -999999) {
            return "-" + pad(-year, 6);
          } else {
            return year;
          }
        }
        function m() {
          return pad2(dt.getUTCMonth() + 1);
        }
        function d() {
          return pad2(dt.getUTCDate());
        }
        function e() {
          return padS(dt.getUTCDate());
        }
        function H() {
          return pad2(dt.getUTCHours());
        }
        function M() {
          return pad2(dt.getUTCMinutes());
        }
        function S() {
          return pad2(dt.getUTCSeconds());
        }
        function L() {
          return pad(dt.getUTCMilliseconds(), 3);
        }
        function N() {
          return pad(ts.getNano(), 9);
        }
        function a() {
          return FMT_DAY[dt.getUTCDay()];
        }
        function b() {
          return FMT_MONTH[dt.getUTCMonth()];
        }
      }
      function buildWriteInt64(pos0, pos1, pos2, pos3, posH, posL) {
        return writeInt64;
        function writeInt64(buffer2, offset) {
          var ts = normalize(this);
          if (!buffer2)
            buffer2 = new Array(8);
          checkRange(buffer2, offset |= 0);
          var second = Math.floor(ts.time / 1e3);
          var day = ts.year * (DAY_SLOT * SEC_DAY / YEAR_SLOT);
          var high = trunc(day / BIT32) + trunc(second / BIT32);
          var low = day % BIT32 + second % BIT32;
          var slot = Math.floor(low / BIT32);
          if (slot) {
            high += slot;
            low -= slot * BIT32;
          }
          writeUint32(buffer2, offset + posH, high);
          writeUint32(buffer2, offset + posL, low);
          return buffer2;
        }
        function writeUint32(buffer2, offset, value) {
          buffer2[offset + pos0] = value >> 24 & 255;
          buffer2[offset + pos1] = value >> 16 & 255;
          buffer2[offset + pos2] = value >> 8 & 255;
          buffer2[offset + pos3] = value & 255;
        }
      }
      function buildFromInt64(pos0, pos1, pos2, pos3, posH, posL) {
        return fromInt64;
        function fromInt64(buffer2, offset) {
          checkRange(buffer2, offset |= 0);
          var high = readUint322(buffer2, offset + posH);
          var low = readUint322(buffer2, offset + posL);
          return fromTime(low, high);
        }
        function readUint322(buffer2, offset) {
          return buffer2[offset + pos0] * BIT24 + (buffer2[offset + pos1] << 16 | buffer2[offset + pos2] << 8 | buffer2[offset + pos3]);
        }
      }
      function checkRange(buffer2, offset) {
        var last6 = buffer2 && buffer2.length;
        if (last6 == null)
          throw new TypeError("Invalid Buffer");
        if (last6 < offset + 8)
          throw new RangeError("Out of range");
      }
      function Math_trunc(x) {
        var n = x - x % 1;
        return n === 0 && (x < 0 || x === 0 && 1 / x !== 1 / 0) ? -0 : n;
      }
      function padS(v) {
        return (v > 9 ? "" : " ") + (v | 0);
      }
      function pad2(v) {
        return (v > 9 ? "" : "0") + (v | 0);
      }
      function pad(v, len) {
        return (ZERO9 + (v | 0)).substr(-len);
      }
    }();
  }
});

// node_modules/libp2p-crypto/src/aes/ciphers-browser.js
var require_ciphers_browser = __commonJS({
  "node_modules/libp2p-crypto/src/aes/ciphers-browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    require_aes();
    var forge = require_forge();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    module2.exports = {
      createCipheriv: (mode, key, iv) => {
        const cipher2 = forge.cipher.createCipher("AES-CTR", uint8ArrayToString(key, "ascii"));
        cipher2.start({ iv: uint8ArrayToString(iv, "ascii") });
        return {
          update: (data) => {
            cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, "ascii")));
            return uint8ArrayFromString(cipher2.output.getBytes(), "ascii");
          }
        };
      },
      createDecipheriv: (mode, key, iv) => {
        const cipher2 = forge.cipher.createDecipher("AES-CTR", uint8ArrayToString(key, "ascii"));
        cipher2.start({ iv: uint8ArrayToString(iv, "ascii") });
        return {
          update: (data) => {
            cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, "ascii")));
            return uint8ArrayFromString(cipher2.output.getBytes(), "ascii");
          }
        };
      }
    };
  }
});

// node_modules/libp2p-crypto/src/aes/cipher-mode.js
var require_cipher_mode = __commonJS({
  "node_modules/libp2p-crypto/src/aes/cipher-mode.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var CIPHER_MODES = {
      16: "aes-128-ctr",
      32: "aes-256-ctr"
    };
    module2.exports = function(key) {
      const mode = CIPHER_MODES[key.length];
      if (!mode) {
        const modes = Object.entries(CIPHER_MODES).map(([k, v]) => `${k} (${v})`).join(" / ");
        throw errcode7(new Error(`Invalid key length ${key.length} bytes. Must be ${modes}`), "ERR_INVALID_KEY_LENGTH");
      }
      return mode;
    };
  }
});

// node_modules/libp2p-crypto/src/aes/index.js
var require_aes2 = __commonJS({
  "node_modules/libp2p-crypto/src/aes/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var ciphers = require_ciphers_browser();
    var cipherMode = require_cipher_mode();
    exports2.create = async function(key, iv) {
      const mode = cipherMode(key);
      const cipher = ciphers.createCipheriv(mode, key, iv);
      const decipher = ciphers.createDecipheriv(mode, key, iv);
      const res = {
        async encrypt(data) {
          return cipher.update(data);
        },
        async decrypt(data) {
          return decipher.update(data);
        }
      };
      return res;
    };
  }
});

// node_modules/libp2p-crypto/src/pbkdf2.js
var require_pbkdf22 = __commonJS({
  "node_modules/libp2p-crypto/src/pbkdf2.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var forgePbkdf2 = require_pbkdf2();
    var forgeUtil = require_util();
    var errcode7 = require_err_code();
    var hashName = {
      sha1: "sha1",
      "sha2-256": "sha256",
      "sha2-512": "sha512"
    };
    function pbkdf2(password, salt, iterations, keySize, hash2) {
      const hasher = hashName[hash2];
      if (!hasher) {
        const types2 = Object.keys(hashName).join(" / ");
        throw errcode7(new Error(`Hash '${hash2}' is unknown or not supported. Must be ${types2}`), "ERR_UNSUPPORTED_HASH_TYPE");
      }
      const dek = forgePbkdf2(password, salt, iterations, keySize, hasher);
      return forgeUtil.encode64(dek);
    }
    module2.exports = pbkdf2;
  }
});

// node_modules/libp2p-crypto/src/index.js
var require_src7 = __commonJS({
  "node_modules/libp2p-crypto/src/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var hmac = require_index_browser();
    var aes = require_aes2();
    var keys = require_keys2();
    exports2.aes = aes;
    exports2.hmac = hmac;
    exports2.keys = keys;
    exports2.randomBytes = require_random_bytes();
    exports2.pbkdf2 = require_pbkdf22();
  }
});

// node_modules/long/src/long.js
var require_long = __commonJS({
  "node_modules/long/src/long.js"(exports2, module2) {
    init_node_globals();
    module2.exports = Long2;
    var wasm = null;
    try {
      wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
        0,
        97,
        115,
        109,
        1,
        0,
        0,
        0,
        1,
        13,
        2,
        96,
        0,
        1,
        127,
        96,
        4,
        127,
        127,
        127,
        127,
        1,
        127,
        3,
        7,
        6,
        0,
        1,
        1,
        1,
        1,
        1,
        6,
        6,
        1,
        127,
        1,
        65,
        0,
        11,
        7,
        50,
        6,
        3,
        109,
        117,
        108,
        0,
        1,
        5,
        100,
        105,
        118,
        95,
        115,
        0,
        2,
        5,
        100,
        105,
        118,
        95,
        117,
        0,
        3,
        5,
        114,
        101,
        109,
        95,
        115,
        0,
        4,
        5,
        114,
        101,
        109,
        95,
        117,
        0,
        5,
        8,
        103,
        101,
        116,
        95,
        104,
        105,
        103,
        104,
        0,
        0,
        10,
        191,
        1,
        6,
        4,
        0,
        35,
        0,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        126,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        127,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        128,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        129,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11,
        36,
        1,
        1,
        126,
        32,
        0,
        173,
        32,
        1,
        173,
        66,
        32,
        134,
        132,
        32,
        2,
        173,
        32,
        3,
        173,
        66,
        32,
        134,
        132,
        130,
        34,
        4,
        66,
        32,
        135,
        167,
        36,
        0,
        32,
        4,
        167,
        11
      ])), {}).exports;
    } catch (e) {
    }
    function Long2(low, high, unsigned) {
      this.low = low | 0;
      this.high = high | 0;
      this.unsigned = !!unsigned;
    }
    Long2.prototype.__isLong__;
    Object.defineProperty(Long2.prototype, "__isLong__", { value: true });
    function isLong(obj) {
      return (obj && obj["__isLong__"]) === true;
    }
    Long2.isLong = isLong;
    var INT_CACHE = {};
    var UINT_CACHE = {};
    function fromInt(value, unsigned) {
      var obj, cachedObj, cache2;
      if (unsigned) {
        value >>>= 0;
        if (cache2 = 0 <= value && value < 256) {
          cachedObj = UINT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);
        if (cache2)
          UINT_CACHE[value] = obj;
        return obj;
      } else {
        value |= 0;
        if (cache2 = -128 <= value && value < 128) {
          cachedObj = INT_CACHE[value];
          if (cachedObj)
            return cachedObj;
        }
        obj = fromBits(value, value < 0 ? -1 : 0, false);
        if (cache2)
          INT_CACHE[value] = obj;
        return obj;
      }
    }
    Long2.fromInt = fromInt;
    function fromNumber(value, unsigned) {
      if (isNaN(value))
        return unsigned ? UZERO : ZERO;
      if (unsigned) {
        if (value < 0)
          return UZERO;
        if (value >= TWO_PWR_64_DBL)
          return MAX_UNSIGNED_VALUE;
      } else {
        if (value <= -TWO_PWR_63_DBL)
          return MIN_VALUE;
        if (value + 1 >= TWO_PWR_63_DBL)
          return MAX_VALUE;
      }
      if (value < 0)
        return fromNumber(-value, unsigned).neg();
      return fromBits(value % TWO_PWR_32_DBL | 0, value / TWO_PWR_32_DBL | 0, unsigned);
    }
    Long2.fromNumber = fromNumber;
    function fromBits(lowBits, highBits, unsigned) {
      return new Long2(lowBits, highBits, unsigned);
    }
    Long2.fromBits = fromBits;
    var pow_dbl = Math.pow;
    function fromString4(str, unsigned, radix) {
      if (str.length === 0)
        throw Error("empty string");
      if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity")
        return ZERO;
      if (typeof unsigned === "number") {
        radix = unsigned, unsigned = false;
      } else {
        unsigned = !!unsigned;
      }
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      var p;
      if ((p = str.indexOf("-")) > 0)
        throw Error("interior hyphen");
      else if (p === 0) {
        return fromString4(str.substring(1), unsigned, radix).neg();
      }
      var radixToPower = fromNumber(pow_dbl(radix, 8));
      var result = ZERO;
      for (var i = 0; i < str.length; i += 8) {
        var size = Math.min(8, str.length - i), value = parseInt(str.substring(i, i + size), radix);
        if (size < 8) {
          var power = fromNumber(pow_dbl(radix, size));
          result = result.mul(power).add(fromNumber(value));
        } else {
          result = result.mul(radixToPower);
          result = result.add(fromNumber(value));
        }
      }
      result.unsigned = unsigned;
      return result;
    }
    Long2.fromString = fromString4;
    function fromValue(val, unsigned) {
      if (typeof val === "number")
        return fromNumber(val, unsigned);
      if (typeof val === "string")
        return fromString4(val, unsigned);
      return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
    }
    Long2.fromValue = fromValue;
    var TWO_PWR_16_DBL = 1 << 16;
    var TWO_PWR_24_DBL = 1 << 24;
    var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
    var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
    var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
    var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
    var ZERO = fromInt(0);
    Long2.ZERO = ZERO;
    var UZERO = fromInt(0, true);
    Long2.UZERO = UZERO;
    var ONE = fromInt(1);
    Long2.ONE = ONE;
    var UONE = fromInt(1, true);
    Long2.UONE = UONE;
    var NEG_ONE = fromInt(-1);
    Long2.NEG_ONE = NEG_ONE;
    var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
    Long2.MAX_VALUE = MAX_VALUE;
    var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
    Long2.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
    var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
    Long2.MIN_VALUE = MIN_VALUE;
    var LongPrototype = Long2.prototype;
    LongPrototype.toInt = function toInt() {
      return this.unsigned ? this.low >>> 0 : this.low;
    };
    LongPrototype.toNumber = function toNumber() {
      if (this.unsigned)
        return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
      return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
    };
    LongPrototype.toString = function toString4(radix) {
      radix = radix || 10;
      if (radix < 2 || 36 < radix)
        throw RangeError("radix");
      if (this.isZero())
        return "0";
      if (this.isNegative()) {
        if (this.eq(MIN_VALUE)) {
          var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
          return div.toString(radix) + rem1.toInt().toString(radix);
        } else
          return "-" + this.neg().toString(radix);
      }
      var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
      var result = "";
      while (true) {
        var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
        rem = remDiv;
        if (rem.isZero())
          return digits + result;
        else {
          while (digits.length < 6)
            digits = "0" + digits;
          result = "" + digits + result;
        }
      }
    };
    LongPrototype.getHighBits = function getHighBits() {
      return this.high;
    };
    LongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {
      return this.high >>> 0;
    };
    LongPrototype.getLowBits = function getLowBits() {
      return this.low;
    };
    LongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {
      return this.low >>> 0;
    };
    LongPrototype.getNumBitsAbs = function getNumBitsAbs() {
      if (this.isNegative())
        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
      var val = this.high != 0 ? this.high : this.low;
      for (var bit = 31; bit > 0; bit--)
        if ((val & 1 << bit) != 0)
          break;
      return this.high != 0 ? bit + 33 : bit + 1;
    };
    LongPrototype.isZero = function isZero() {
      return this.high === 0 && this.low === 0;
    };
    LongPrototype.eqz = LongPrototype.isZero;
    LongPrototype.isNegative = function isNegative() {
      return !this.unsigned && this.high < 0;
    };
    LongPrototype.isPositive = function isPositive() {
      return this.unsigned || this.high >= 0;
    };
    LongPrototype.isOdd = function isOdd() {
      return (this.low & 1) === 1;
    };
    LongPrototype.isEven = function isEven() {
      return (this.low & 1) === 0;
    };
    LongPrototype.equals = function equals4(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1)
        return false;
      return this.high === other.high && this.low === other.low;
    };
    LongPrototype.eq = LongPrototype.equals;
    LongPrototype.notEquals = function notEquals(other) {
      return !this.eq(other);
    };
    LongPrototype.neq = LongPrototype.notEquals;
    LongPrototype.ne = LongPrototype.notEquals;
    LongPrototype.lessThan = function lessThan(other) {
      return this.comp(other) < 0;
    };
    LongPrototype.lt = LongPrototype.lessThan;
    LongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {
      return this.comp(other) <= 0;
    };
    LongPrototype.lte = LongPrototype.lessThanOrEqual;
    LongPrototype.le = LongPrototype.lessThanOrEqual;
    LongPrototype.greaterThan = function greaterThan(other) {
      return this.comp(other) > 0;
    };
    LongPrototype.gt = LongPrototype.greaterThan;
    LongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {
      return this.comp(other) >= 0;
    };
    LongPrototype.gte = LongPrototype.greaterThanOrEqual;
    LongPrototype.ge = LongPrototype.greaterThanOrEqual;
    LongPrototype.compare = function compare3(other) {
      if (!isLong(other))
        other = fromValue(other);
      if (this.eq(other))
        return 0;
      var thisNeg = this.isNegative(), otherNeg = other.isNegative();
      if (thisNeg && !otherNeg)
        return -1;
      if (!thisNeg && otherNeg)
        return 1;
      if (!this.unsigned)
        return this.sub(other).isNegative() ? -1 : 1;
      return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
    };
    LongPrototype.comp = LongPrototype.compare;
    LongPrototype.negate = function negate() {
      if (!this.unsigned && this.eq(MIN_VALUE))
        return MIN_VALUE;
      return this.not().add(ONE);
    };
    LongPrototype.neg = LongPrototype.negate;
    LongPrototype.add = function add(addend) {
      if (!isLong(addend))
        addend = fromValue(addend);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = addend.high >>> 16;
      var b32 = addend.high & 65535;
      var b16 = addend.low >>> 16;
      var b00 = addend.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 + b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 + b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 + b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 + b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.subtract = function subtract(subtrahend) {
      if (!isLong(subtrahend))
        subtrahend = fromValue(subtrahend);
      return this.add(subtrahend.neg());
    };
    LongPrototype.sub = LongPrototype.subtract;
    LongPrototype.multiply = function multiply(multiplier) {
      if (this.isZero())
        return ZERO;
      if (!isLong(multiplier))
        multiplier = fromValue(multiplier);
      if (wasm) {
        var low = wasm.mul(this.low, this.high, multiplier.low, multiplier.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (multiplier.isZero())
        return ZERO;
      if (this.eq(MIN_VALUE))
        return multiplier.isOdd() ? MIN_VALUE : ZERO;
      if (multiplier.eq(MIN_VALUE))
        return this.isOdd() ? MIN_VALUE : ZERO;
      if (this.isNegative()) {
        if (multiplier.isNegative())
          return this.neg().mul(multiplier.neg());
        else
          return this.neg().mul(multiplier).neg();
      } else if (multiplier.isNegative())
        return this.mul(multiplier.neg()).neg();
      if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))
        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
      var a48 = this.high >>> 16;
      var a32 = this.high & 65535;
      var a16 = this.low >>> 16;
      var a00 = this.low & 65535;
      var b48 = multiplier.high >>> 16;
      var b32 = multiplier.high & 65535;
      var b16 = multiplier.low >>> 16;
      var b00 = multiplier.low & 65535;
      var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
      c00 += a00 * b00;
      c16 += c00 >>> 16;
      c00 &= 65535;
      c16 += a16 * b00;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c16 += a00 * b16;
      c32 += c16 >>> 16;
      c16 &= 65535;
      c32 += a32 * b00;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a16 * b16;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c32 += a00 * b32;
      c48 += c32 >>> 16;
      c32 &= 65535;
      c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
      c48 &= 65535;
      return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
    };
    LongPrototype.mul = LongPrototype.multiply;
    LongPrototype.divide = function divide(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (divisor.isZero())
        throw Error("division by zero");
      if (wasm) {
        if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
          return this;
        }
        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      if (this.isZero())
        return this.unsigned ? UZERO : ZERO;
      var approx, rem, res;
      if (!this.unsigned) {
        if (this.eq(MIN_VALUE)) {
          if (divisor.eq(ONE) || divisor.eq(NEG_ONE))
            return MIN_VALUE;
          else if (divisor.eq(MIN_VALUE))
            return ONE;
          else {
            var halfThis = this.shr(1);
            approx = halfThis.div(divisor).shl(1);
            if (approx.eq(ZERO)) {
              return divisor.isNegative() ? ONE : NEG_ONE;
            } else {
              rem = this.sub(divisor.mul(approx));
              res = approx.add(rem.div(divisor));
              return res;
            }
          }
        } else if (divisor.eq(MIN_VALUE))
          return this.unsigned ? UZERO : ZERO;
        if (this.isNegative()) {
          if (divisor.isNegative())
            return this.neg().div(divisor.neg());
          return this.neg().div(divisor).neg();
        } else if (divisor.isNegative())
          return this.div(divisor.neg()).neg();
        res = ZERO;
      } else {
        if (!divisor.unsigned)
          divisor = divisor.toUnsigned();
        if (divisor.gt(this))
          return UZERO;
        if (divisor.gt(this.shru(1)))
          return UONE;
        res = UZERO;
      }
      rem = this;
      while (rem.gte(divisor)) {
        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
        var log22 = Math.ceil(Math.log(approx) / Math.LN2), delta = log22 <= 48 ? 1 : pow_dbl(2, log22 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
        while (approxRem.isNegative() || approxRem.gt(rem)) {
          approx -= delta;
          approxRes = fromNumber(approx, this.unsigned);
          approxRem = approxRes.mul(divisor);
        }
        if (approxRes.isZero())
          approxRes = ONE;
        res = res.add(approxRes);
        rem = rem.sub(approxRem);
      }
      return res;
    };
    LongPrototype.div = LongPrototype.divide;
    LongPrototype.modulo = function modulo(divisor) {
      if (!isLong(divisor))
        divisor = fromValue(divisor);
      if (wasm) {
        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(this.low, this.high, divisor.low, divisor.high);
        return fromBits(low, wasm.get_high(), this.unsigned);
      }
      return this.sub(this.div(divisor).mul(divisor));
    };
    LongPrototype.mod = LongPrototype.modulo;
    LongPrototype.rem = LongPrototype.modulo;
    LongPrototype.not = function not() {
      return fromBits(~this.low, ~this.high, this.unsigned);
    };
    LongPrototype.and = function and(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
    };
    LongPrototype.or = function or(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
    };
    LongPrototype.xor = function xor2(other) {
      if (!isLong(other))
        other = fromValue(other);
      return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
    };
    LongPrototype.shiftLeft = function shiftLeft(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
      else
        return fromBits(0, this.low << numBits - 32, this.unsigned);
    };
    LongPrototype.shl = LongPrototype.shiftLeft;
    LongPrototype.shiftRight = function shiftRight(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      if ((numBits &= 63) === 0)
        return this;
      else if (numBits < 32)
        return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
      else
        return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
    };
    LongPrototype.shr = LongPrototype.shiftRight;
    LongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {
      if (isLong(numBits))
        numBits = numBits.toInt();
      numBits &= 63;
      if (numBits === 0)
        return this;
      else {
        var high = this.high;
        if (numBits < 32) {
          var low = this.low;
          return fromBits(low >>> numBits | high << 32 - numBits, high >>> numBits, this.unsigned);
        } else if (numBits === 32)
          return fromBits(high, 0, this.unsigned);
        else
          return fromBits(high >>> numBits - 32, 0, this.unsigned);
      }
    };
    LongPrototype.shru = LongPrototype.shiftRightUnsigned;
    LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
    LongPrototype.toSigned = function toSigned() {
      if (!this.unsigned)
        return this;
      return fromBits(this.low, this.high, false);
    };
    LongPrototype.toUnsigned = function toUnsigned() {
      if (this.unsigned)
        return this;
      return fromBits(this.low, this.high, true);
    };
    LongPrototype.toBytes = function toBytes2(le) {
      return le ? this.toBytesLE() : this.toBytesBE();
    };
    LongPrototype.toBytesLE = function toBytesLE() {
      var hi = this.high, lo = this.low;
      return [
        lo & 255,
        lo >>> 8 & 255,
        lo >>> 16 & 255,
        lo >>> 24,
        hi & 255,
        hi >>> 8 & 255,
        hi >>> 16 & 255,
        hi >>> 24
      ];
    };
    LongPrototype.toBytesBE = function toBytesBE() {
      var hi = this.high, lo = this.low;
      return [
        hi >>> 24,
        hi >>> 16 & 255,
        hi >>> 8 & 255,
        hi & 255,
        lo >>> 24,
        lo >>> 16 & 255,
        lo >>> 8 & 255,
        lo & 255
      ];
    };
    Long2.fromBytes = function fromBytes2(bytes3, unsigned, le) {
      return le ? Long2.fromBytesLE(bytes3, unsigned) : Long2.fromBytesBE(bytes3, unsigned);
    };
    Long2.fromBytesLE = function fromBytesLE(bytes3, unsigned) {
      return new Long2(bytes3[0] | bytes3[1] << 8 | bytes3[2] << 16 | bytes3[3] << 24, bytes3[4] | bytes3[5] << 8 | bytes3[6] << 16 | bytes3[7] << 24, unsigned);
    };
    Long2.fromBytesBE = function fromBytesBE(bytes3, unsigned) {
      return new Long2(bytes3[4] << 24 | bytes3[5] << 16 | bytes3[6] << 8 | bytes3[7], bytes3[0] << 24 | bytes3[1] << 16 | bytes3[2] << 8 | bytes3[3], unsigned);
    };
  }
});

// node_modules/ipns/esm/src/pb/ipns.js
var import_minimal2, $Reader2, $Writer2, $util2, $root2, IpnsEntry;
var init_ipns = __esm({
  "node_modules/ipns/esm/src/pb/ipns.js"() {
    init_node_globals();
    import_minimal2 = __toModule(require_minimal2());
    $Reader2 = import_minimal2.default.Reader;
    $Writer2 = import_minimal2.default.Writer;
    $util2 = import_minimal2.default.util;
    $root2 = import_minimal2.default.roots["ipfs-ipns"] || (import_minimal2.default.roots["ipfs-ipns"] = {});
    IpnsEntry = $root2.IpnsEntry = (() => {
      function IpnsEntry2(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      IpnsEntry2.prototype.value = $util2.newBuffer([]);
      IpnsEntry2.prototype.signature = $util2.newBuffer([]);
      IpnsEntry2.prototype.validityType = 0;
      IpnsEntry2.prototype.validity = $util2.newBuffer([]);
      IpnsEntry2.prototype.sequence = $util2.Long ? $util2.Long.fromBits(0, 0, true) : 0;
      IpnsEntry2.prototype.ttl = $util2.Long ? $util2.Long.fromBits(0, 0, true) : 0;
      IpnsEntry2.prototype.pubKey = $util2.newBuffer([]);
      IpnsEntry2.prototype.signatureV2 = $util2.newBuffer([]);
      IpnsEntry2.prototype.data = $util2.newBuffer([]);
      IpnsEntry2.encode = function encode10(m, w) {
        if (!w)
          w = $Writer2.create();
        if (m.value != null && Object.hasOwnProperty.call(m, "value"))
          w.uint32(10).bytes(m.value);
        if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
          w.uint32(18).bytes(m.signature);
        if (m.validityType != null && Object.hasOwnProperty.call(m, "validityType"))
          w.uint32(24).int32(m.validityType);
        if (m.validity != null && Object.hasOwnProperty.call(m, "validity"))
          w.uint32(34).bytes(m.validity);
        if (m.sequence != null && Object.hasOwnProperty.call(m, "sequence"))
          w.uint32(40).uint64(m.sequence);
        if (m.ttl != null && Object.hasOwnProperty.call(m, "ttl"))
          w.uint32(48).uint64(m.ttl);
        if (m.pubKey != null && Object.hasOwnProperty.call(m, "pubKey"))
          w.uint32(58).bytes(m.pubKey);
        if (m.signatureV2 != null && Object.hasOwnProperty.call(m, "signatureV2"))
          w.uint32(66).bytes(m.signatureV2);
        if (m.data != null && Object.hasOwnProperty.call(m, "data"))
          w.uint32(74).bytes(m.data);
        return w;
      };
      IpnsEntry2.decode = function decode12(r, l) {
        if (!(r instanceof $Reader2))
          r = $Reader2.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root2.IpnsEntry();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.value = r.bytes();
              break;
            case 2:
              m.signature = r.bytes();
              break;
            case 3:
              m.validityType = r.int32();
              break;
            case 4:
              m.validity = r.bytes();
              break;
            case 5:
              m.sequence = r.uint64();
              break;
            case 6:
              m.ttl = r.uint64();
              break;
            case 7:
              m.pubKey = r.bytes();
              break;
            case 8:
              m.signatureV2 = r.bytes();
              break;
            case 9:
              m.data = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      IpnsEntry2.fromObject = function fromObject(d) {
        if (d instanceof $root2.IpnsEntry)
          return d;
        var m = new $root2.IpnsEntry();
        if (d.value != null) {
          if (typeof d.value === "string")
            $util2.base64.decode(d.value, m.value = $util2.newBuffer($util2.base64.length(d.value)), 0);
          else if (d.value.length)
            m.value = d.value;
        }
        if (d.signature != null) {
          if (typeof d.signature === "string")
            $util2.base64.decode(d.signature, m.signature = $util2.newBuffer($util2.base64.length(d.signature)), 0);
          else if (d.signature.length)
            m.signature = d.signature;
        }
        switch (d.validityType) {
          case "EOL":
          case 0:
            m.validityType = 0;
            break;
        }
        if (d.validity != null) {
          if (typeof d.validity === "string")
            $util2.base64.decode(d.validity, m.validity = $util2.newBuffer($util2.base64.length(d.validity)), 0);
          else if (d.validity.length)
            m.validity = d.validity;
        }
        if (d.sequence != null) {
          if ($util2.Long)
            (m.sequence = $util2.Long.fromValue(d.sequence)).unsigned = true;
          else if (typeof d.sequence === "string")
            m.sequence = parseInt(d.sequence, 10);
          else if (typeof d.sequence === "number")
            m.sequence = d.sequence;
          else if (typeof d.sequence === "object")
            m.sequence = new $util2.LongBits(d.sequence.low >>> 0, d.sequence.high >>> 0).toNumber(true);
        }
        if (d.ttl != null) {
          if ($util2.Long)
            (m.ttl = $util2.Long.fromValue(d.ttl)).unsigned = true;
          else if (typeof d.ttl === "string")
            m.ttl = parseInt(d.ttl, 10);
          else if (typeof d.ttl === "number")
            m.ttl = d.ttl;
          else if (typeof d.ttl === "object")
            m.ttl = new $util2.LongBits(d.ttl.low >>> 0, d.ttl.high >>> 0).toNumber(true);
        }
        if (d.pubKey != null) {
          if (typeof d.pubKey === "string")
            $util2.base64.decode(d.pubKey, m.pubKey = $util2.newBuffer($util2.base64.length(d.pubKey)), 0);
          else if (d.pubKey.length)
            m.pubKey = d.pubKey;
        }
        if (d.signatureV2 != null) {
          if (typeof d.signatureV2 === "string")
            $util2.base64.decode(d.signatureV2, m.signatureV2 = $util2.newBuffer($util2.base64.length(d.signatureV2)), 0);
          else if (d.signatureV2.length)
            m.signatureV2 = d.signatureV2;
        }
        if (d.data != null) {
          if (typeof d.data === "string")
            $util2.base64.decode(d.data, m.data = $util2.newBuffer($util2.base64.length(d.data)), 0);
          else if (d.data.length)
            m.data = d.data;
        }
        return m;
      };
      IpnsEntry2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.value = "";
          else {
            d.value = [];
            if (o.bytes !== Array)
              d.value = $util2.newBuffer(d.value);
          }
          if (o.bytes === String)
            d.signature = "";
          else {
            d.signature = [];
            if (o.bytes !== Array)
              d.signature = $util2.newBuffer(d.signature);
          }
          d.validityType = o.enums === String ? "EOL" : 0;
          if (o.bytes === String)
            d.validity = "";
          else {
            d.validity = [];
            if (o.bytes !== Array)
              d.validity = $util2.newBuffer(d.validity);
          }
          if ($util2.Long) {
            var n = new $util2.Long(0, 0, true);
            d.sequence = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.sequence = o.longs === String ? "0" : 0;
          if ($util2.Long) {
            var n = new $util2.Long(0, 0, true);
            d.ttl = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.ttl = o.longs === String ? "0" : 0;
          if (o.bytes === String)
            d.pubKey = "";
          else {
            d.pubKey = [];
            if (o.bytes !== Array)
              d.pubKey = $util2.newBuffer(d.pubKey);
          }
          if (o.bytes === String)
            d.signatureV2 = "";
          else {
            d.signatureV2 = [];
            if (o.bytes !== Array)
              d.signatureV2 = $util2.newBuffer(d.signatureV2);
          }
          if (o.bytes === String)
            d.data = "";
          else {
            d.data = [];
            if (o.bytes !== Array)
              d.data = $util2.newBuffer(d.data);
          }
        }
        if (m.value != null && m.hasOwnProperty("value")) {
          d.value = o.bytes === String ? $util2.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
        }
        if (m.signature != null && m.hasOwnProperty("signature")) {
          d.signature = o.bytes === String ? $util2.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
        }
        if (m.validityType != null && m.hasOwnProperty("validityType")) {
          d.validityType = o.enums === String ? $root2.IpnsEntry.ValidityType[m.validityType] : m.validityType;
        }
        if (m.validity != null && m.hasOwnProperty("validity")) {
          d.validity = o.bytes === String ? $util2.base64.encode(m.validity, 0, m.validity.length) : o.bytes === Array ? Array.prototype.slice.call(m.validity) : m.validity;
        }
        if (m.sequence != null && m.hasOwnProperty("sequence")) {
          if (typeof m.sequence === "number")
            d.sequence = o.longs === String ? String(m.sequence) : m.sequence;
          else
            d.sequence = o.longs === String ? $util2.Long.prototype.toString.call(m.sequence) : o.longs === Number ? new $util2.LongBits(m.sequence.low >>> 0, m.sequence.high >>> 0).toNumber(true) : m.sequence;
        }
        if (m.ttl != null && m.hasOwnProperty("ttl")) {
          if (typeof m.ttl === "number")
            d.ttl = o.longs === String ? String(m.ttl) : m.ttl;
          else
            d.ttl = o.longs === String ? $util2.Long.prototype.toString.call(m.ttl) : o.longs === Number ? new $util2.LongBits(m.ttl.low >>> 0, m.ttl.high >>> 0).toNumber(true) : m.ttl;
        }
        if (m.pubKey != null && m.hasOwnProperty("pubKey")) {
          d.pubKey = o.bytes === String ? $util2.base64.encode(m.pubKey, 0, m.pubKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.pubKey) : m.pubKey;
        }
        if (m.signatureV2 != null && m.hasOwnProperty("signatureV2")) {
          d.signatureV2 = o.bytes === String ? $util2.base64.encode(m.signatureV2, 0, m.signatureV2.length) : o.bytes === Array ? Array.prototype.slice.call(m.signatureV2) : m.signatureV2;
        }
        if (m.data != null && m.hasOwnProperty("data")) {
          d.data = o.bytes === String ? $util2.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
        }
        return d;
      };
      IpnsEntry2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal2.default.util.toJSONOptions);
      };
      IpnsEntry2.ValidityType = function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "EOL"] = 0;
        return values;
      }();
      return IpnsEntry2;
    })();
  }
});

// node_modules/ipns/esm/src/utils.js
function parseRFC3339(time) {
  const rfc3339Matcher = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z");
  const m = String(time).trim().match(rfc3339Matcher);
  if (!m) {
    throw new Error("Invalid format");
  }
  const year = parseInt(m[1], 10);
  const month = parseInt(m[2], 10) - 1;
  const date = parseInt(m[3], 10);
  const hour = parseInt(m[4], 10);
  const minute = parseInt(m[5], 10);
  const second = parseInt(m[6], 10);
  const millisecond = parseInt(m[7].slice(0, -6), 10);
  return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond));
}
var init_utils = __esm({
  "node_modules/ipns/esm/src/utils.js"() {
    init_node_globals();
  }
});

// node_modules/ipns/esm/src/errors.js
var ERR_IPNS_EXPIRED_RECORD, ERR_UNRECOGNIZED_VALIDITY, ERR_SIGNATURE_CREATION, ERR_SIGNATURE_VERIFICATION, ERR_UNRECOGNIZED_FORMAT, ERR_PEER_ID_FROM_PUBLIC_KEY, ERR_PUBLIC_KEY_FROM_ID, ERR_UNDEFINED_PARAMETER, ERR_INVALID_RECORD_DATA, ERR_INVALID_EMBEDDED_KEY;
var init_errors3 = __esm({
  "node_modules/ipns/esm/src/errors.js"() {
    init_node_globals();
    ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD";
    ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY";
    ERR_SIGNATURE_CREATION = "ERR_SIGNATURE_CREATION";
    ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION";
    ERR_UNRECOGNIZED_FORMAT = "ERR_UNRECOGNIZED_FORMAT";
    ERR_PEER_ID_FROM_PUBLIC_KEY = "ERR_PEER_ID_FROM_PUBLIC_KEY";
    ERR_PUBLIC_KEY_FROM_ID = "ERR_PUBLIC_KEY_FROM_ID";
    ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER";
    ERR_INVALID_RECORD_DATA = "ERR_INVALID_RECORD_DATA";
    ERR_INVALID_EMBEDDED_KEY = "ERR_INVALID_EMBEDDED_KEY";
  }
});

// node_modules/ipns/esm/src/index.js
var src_exports3 = {};
__export(src_exports3, {
  create: () => create2,
  createWithExpiration: () => createWithExpiration,
  embedPublicKey: () => embedPublicKey,
  extractPublicKey: () => extractPublicKey,
  getIdKeys: () => getIdKeys,
  getLocalKey: () => getLocalKey,
  marshal: () => marshal,
  namespace: () => namespace,
  namespaceLength: () => namespaceLength,
  unmarshal: () => unmarshal,
  validate: () => validate2,
  validator: () => validator
});
var import_timestamp_nano, import_libp2p_crypto, import_peer_id, import_err_code5, import_long, import_debug, log, ID_MULTIHASH_CODE, IPNS_PREFIX, namespace, namespaceLength, create2, createWithExpiration, _create, createCborData, validate2, validateCborDataMatchesPbData, embedPublicKey, extractPublicKey, rawStdEncoding, getLocalKey, getIdKeys, sign, getValidityType, ipnsEntryDataForV1Sig, ipnsEntryDataForV2Sig, extractPublicKeyFromId, marshal, unmarshal, validator;
var init_src4 = __esm({
  "node_modules/ipns/esm/src/index.js"() {
    init_node_globals();
    import_timestamp_nano = __toModule(require_timestamp());
    init_key();
    import_libp2p_crypto = __toModule(require_src7());
    import_peer_id = __toModule(require_src6());
    init_digest();
    init_identity();
    import_err_code5 = __toModule(require_err_code());
    init_base32();
    init_from_string();
    init_to_string();
    init_concat();
    init_equals();
    init_cborg();
    import_long = __toModule(require_long());
    import_debug = __toModule(require_browser2());
    init_ipns();
    init_utils();
    init_errors3();
    log = Object.assign((0, import_debug.default)("jsipns"), { error: (0, import_debug.default)("jsipns:error") });
    ID_MULTIHASH_CODE = identity.code;
    IPNS_PREFIX = fromString3("/ipns/");
    namespace = "/ipns/";
    namespaceLength = namespace.length;
    create2 = (privateKey, value, seq, lifetime) => {
      const expirationDate = new import_timestamp_nano.default(Date.now() + Number(lifetime));
      const validityType = IpnsEntry.ValidityType.EOL;
      const [ms, ns] = lifetime.toString().split(".");
      const lifetimeNs = BigInt(ms) * BigInt(1e5) + BigInt(ns || 0);
      return _create(privateKey, value, seq, validityType, expirationDate, lifetimeNs);
    };
    createWithExpiration = (privateKey, value, seq, expiration) => {
      const expirationDate = import_timestamp_nano.default.fromString(expiration);
      const validityType = IpnsEntry.ValidityType.EOL;
      const ttlMs = expirationDate.toDate().getTime() - Date.now();
      const ttlNs = BigInt(ttlMs) * BigInt(1e5) + BigInt(expirationDate.getNano());
      return _create(privateKey, value, seq, validityType, expirationDate, ttlNs);
    };
    _create = async (privateKey, value, seq, validityType, expirationDate, ttl2) => {
      seq = BigInt(seq);
      const isoValidity = fromString3(expirationDate.toString());
      const signatureV1 = await sign(privateKey, value, validityType, isoValidity);
      const data = createCborData(value, isoValidity, validityType, seq, ttl2);
      const sigData = ipnsEntryDataForV2Sig(data);
      const signatureV2 = await privateKey.sign(sigData);
      const entry = {
        value,
        signature: signatureV1,
        validityType,
        validity: isoValidity,
        sequence: seq,
        ttl: ttl2,
        signatureV2,
        data
      };
      log(`ipns entry for ${value} created`);
      return entry;
    };
    createCborData = (value, validity, validityType, sequence, ttl2) => {
      const data = {
        Value: value,
        Validity: validity,
        ValidityType: validityType,
        Sequence: sequence,
        TTL: ttl2
      };
      return encode4(data);
    };
    validate2 = async (publicKey, entry) => {
      const { value, validityType, validity } = entry;
      let dataForSignature;
      let signature;
      if (entry.signatureV2 && entry.data) {
        signature = entry.signatureV2;
        dataForSignature = ipnsEntryDataForV2Sig(entry.data);
        validateCborDataMatchesPbData(entry);
      } else {
        signature = entry.signature;
        dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);
      }
      let isValid;
      try {
        isValid = await publicKey.verify(dataForSignature, signature);
      } catch (err) {
        isValid = false;
      }
      if (!isValid) {
        log.error("record signature verification failed");
        throw (0, import_err_code5.default)(new Error("record signature verification failed"), ERR_SIGNATURE_VERIFICATION);
      }
      if (validityType === IpnsEntry.ValidityType.EOL) {
        let validityDate;
        try {
          validityDate = parseRFC3339(toString3(validity));
        } catch (e) {
          log.error("unrecognized validity format (not an rfc3339 format)");
          throw (0, import_err_code5.default)(new Error("unrecognized validity format (not an rfc3339 format)"), ERR_UNRECOGNIZED_FORMAT);
        }
        if (validityDate.getTime() < Date.now()) {
          log.error("record has expired");
          throw (0, import_err_code5.default)(new Error("record has expired"), ERR_IPNS_EXPIRED_RECORD);
        }
      } else if (validityType) {
        log.error("unrecognized validity type");
        throw (0, import_err_code5.default)(new Error("unrecognized validity type"), ERR_UNRECOGNIZED_VALIDITY);
      }
      log(`ipns entry for ${value} is valid`);
    };
    validateCborDataMatchesPbData = (entry) => {
      if (!entry.data) {
        throw (0, import_err_code5.default)(new Error("Record data is missing"), ERR_INVALID_RECORD_DATA);
      }
      const data = decode6(entry.data);
      if (Number.isInteger(data.Sequence)) {
        data.Sequence = BigInt(data.Sequence);
      }
      if (Number.isInteger(data.TTL)) {
        data.TTL = BigInt(data.TTL);
      }
      if (!equals3(data.Value, entry.value)) {
        throw (0, import_err_code5.default)(new Error('Field "value" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
      }
      if (!equals3(data.Validity, entry.validity)) {
        throw (0, import_err_code5.default)(new Error('Field "validity" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
      }
      if (data.ValidityType !== entry.validityType) {
        throw (0, import_err_code5.default)(new Error('Field "validityType" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
      }
      if (data.Sequence !== entry.sequence) {
        throw (0, import_err_code5.default)(new Error('Field "sequence" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
      }
      if (data.TTL !== entry.ttl) {
        throw (0, import_err_code5.default)(new Error('Field "ttl" did not match between protobuf and CBOR'), ERR_SIGNATURE_VERIFICATION);
      }
    };
    embedPublicKey = async (publicKey, entry) => {
      if (!publicKey || !publicKey.bytes || !entry) {
        const error = new Error("one or more of the provided parameters are not defined");
        log.error(error);
        throw (0, import_err_code5.default)(error, ERR_UNDEFINED_PARAMETER);
      }
      let peerId;
      try {
        peerId = await import_peer_id.default.createFromPubKey(publicKey.bytes);
      } catch (err) {
        throw (0, import_err_code5.default)(err, ERR_PEER_ID_FROM_PUBLIC_KEY);
      }
      let extractedPublicKey;
      try {
        extractedPublicKey = extractPublicKeyFromId(peerId);
      } catch (err) {
        log.error(err);
        throw (0, import_err_code5.default)(err, ERR_PUBLIC_KEY_FROM_ID);
      }
      if (extractedPublicKey) {
        return null;
      }
      try {
        entry.pubKey = import_libp2p_crypto.default.keys.marshalPublicKey(publicKey);
      } catch (err) {
        log.error(err);
        throw err;
      }
      return entry;
    };
    extractPublicKey = async (peerId, entry) => {
      if (!entry || !peerId) {
        const error = new Error("one or more of the provided parameters are not defined");
        log.error(error);
        throw (0, import_err_code5.default)(error, ERR_UNDEFINED_PARAMETER);
      }
      let pubKey;
      if (entry.pubKey) {
        try {
          pubKey = import_libp2p_crypto.default.keys.unmarshalPublicKey(entry.pubKey);
        } catch (err) {
          log.error(err);
          throw err;
        }
        const otherId = await import_peer_id.default.createFromPubKey(entry.pubKey);
        if (!otherId.equals(peerId)) {
          throw (0, import_err_code5.default)(new Error("Embedded public key did not match PeerID"), ERR_INVALID_EMBEDDED_KEY);
        }
      } else if (peerId.pubKey) {
        pubKey = peerId.pubKey;
      }
      if (pubKey) {
        return pubKey;
      }
      throw (0, import_err_code5.default)(new Error("no public key is available"), ERR_UNDEFINED_PARAMETER);
    };
    rawStdEncoding = (key) => base32upper.encode(key).slice(1);
    getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`);
    getIdKeys = (pid) => {
      const pkBuffer = fromString3("/pk/");
      const ipnsBuffer = fromString3("/ipns/");
      return {
        routingPubKey: new Key(concat2([
          pkBuffer,
          pid
        ]), false),
        pkKey: new Key(rawStdEncoding(concat2([
          pkBuffer,
          pid
        ]))),
        routingKey: new Key(concat2([
          ipnsBuffer,
          pid
        ]), false),
        ipnsKey: new Key(rawStdEncoding(concat2([
          ipnsBuffer,
          pid
        ])))
      };
    };
    sign = (privateKey, value, validityType, validity) => {
      try {
        const dataForSignature = ipnsEntryDataForV1Sig(value, validityType, validity);
        return privateKey.sign(dataForSignature);
      } catch (error) {
        log.error("record signature creation failed");
        throw (0, import_err_code5.default)(new Error("record signature creation failed: " + error.message), ERR_SIGNATURE_CREATION);
      }
    };
    getValidityType = (validityType) => {
      if (validityType.toString() === "0") {
        return "EOL";
      }
      const error = new Error(`unrecognized validity type ${validityType.toString()}`);
      log.error(error);
      throw (0, import_err_code5.default)(error, ERR_UNRECOGNIZED_VALIDITY);
    };
    ipnsEntryDataForV1Sig = (value, validityType, validity) => {
      const validityTypeBuffer = fromString3(getValidityType(validityType));
      return concat2([
        value,
        validity,
        validityTypeBuffer
      ]);
    };
    ipnsEntryDataForV2Sig = (data) => {
      const entryData = fromString3("ipns-signature:");
      return concat2([
        entryData,
        data
      ]);
    };
    extractPublicKeyFromId = (peerId) => {
      const digest = decode3(peerId.id);
      if (digest.code !== ID_MULTIHASH_CODE) {
        return null;
      }
      return import_libp2p_crypto.default.keys.unmarshalPublicKey(digest.digest);
    };
    marshal = (obj) => {
      return IpnsEntry.encode({
        ...obj,
        sequence: import_long.default.fromString(obj.sequence.toString()),
        ttl: obj.ttl == null ? void 0 : import_long.default.fromString(obj.ttl.toString())
      }).finish();
    };
    unmarshal = (buf2) => {
      const message = IpnsEntry.decode(buf2);
      const object = IpnsEntry.toObject(message, {
        defaults: false,
        arrays: true,
        objects: false
      });
      return {
        value: object.value,
        signature: object.signature,
        validityType: object.validityType,
        validity: object.validity,
        sequence: Object.hasOwnProperty.call(object, "sequence") ? BigInt(`${object.sequence}`) : 0,
        pubKey: object.pubKey,
        ttl: Object.hasOwnProperty.call(object, "ttl") ? BigInt(`${object.ttl}`) : void 0,
        signatureV2: object.signatureV2,
        data: object.data
      };
    };
    validator = {
      validate: async (marshalledData, key) => {
        const receivedEntry = unmarshal(marshalledData);
        const bufferId = key.slice(IPNS_PREFIX.length);
        const peerId = import_peer_id.default.createFromBytes(bufferId);
        const pubKey = await extractPublicKey(peerId, receivedEntry);
        await validate2(pubKey, receivedEntry);
      },
      select: (dataA, dataB) => {
        const entryA = unmarshal(dataA);
        const entryB = unmarshal(dataB);
        if (entryA.signatureV2 && !entryB.signatureV2) {
          return 0;
        } else if (entryB.signatureV2 && !entryA.signatureV2) {
          return 1;
        }
        if (entryA.sequence > entryB.sequence) {
          return 0;
        } else if (entryA.sequence < entryB.sequence) {
          return 1;
        }
        const entryAValidityDate = parseRFC3339(toString3(entryA.validity));
        const entryBValidityDate = parseRFC3339(toString3(entryB.validity));
        return entryBValidityDate.getTime() > entryAValidityDate.getTime() ? 1 : 0;
      }
    };
  }
});

// node_modules/ipfs-core/cjs/src/ipns/publisher.js
var require_publisher = __commonJS({
  "node_modules/ipfs-core/cjs/src/ipns/publisher.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PeerId2 = require_src6();
    var key = (init_key(), key_exports);
    var Errors8 = (init_errors2(), errors_exports);
    var errCode32 = require_err_code();
    var debug17 = require_browser2();
    var toString4 = (init_to_string(), to_string_exports);
    var equals4 = (init_equals(), equals_exports);
    var ipns2 = (init_src4(), src_exports3);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var PeerId__default = /* @__PURE__ */ _interopDefaultLegacy(PeerId2);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var ipns__namespace = /* @__PURE__ */ _interopNamespace(ipns2);
    var log15 = Object.assign(debug__default["default"]("ipfs:ipns:publisher"), { error: debug__default["default"]("ipfs:ipns:publisher:error") });
    var ERR_NOT_FOUND2 = Errors8.notFoundError().code;
    var defaultRecordLifetime = 60 * 60 * 1e3;
    var IpnsPublisher = class {
      constructor(routing, datastore) {
        this._routing = routing;
        this._datastore = datastore;
      }
      async publishWithEOL(privKey, value, lifetime) {
        if (!privKey || !privKey.bytes) {
          throw errCode__default["default"](new Error("invalid private key"), "ERR_INVALID_PRIVATE_KEY");
        }
        const peerId = await PeerId__default["default"].createFromPrivKey(privKey.bytes);
        const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId);
        return this._putRecordToRouting(record, peerId);
      }
      publish(privKey, value) {
        return this.publishWithEOL(privKey, value, defaultRecordLifetime);
      }
      async _putRecordToRouting(record, peerId) {
        if (!PeerId__default["default"].isPeerId(peerId)) {
          const errMsg = "peerId received is not valid";
          log15.error(errMsg);
          throw errCode__default["default"](new Error(errMsg), "ERR_INVALID_PEER_ID");
        }
        const publicKey = peerId._pubKey;
        const embedPublicKeyRecord = await ipns__namespace.embedPublicKey(publicKey, record);
        const keys = ipns__namespace.getIdKeys(peerId.toBytes());
        await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record);
        await this._publishPublicKey(keys.routingPubKey, publicKey);
        return embedPublicKeyRecord || record;
      }
      async _publishEntry(key$1, entry) {
        const k = key.Key.asKey(key$1);
        if (!k) {
          const errMsg = "datastore key does not have a valid format";
          log15.error(errMsg);
          throw errCode__default["default"](new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
        }
        let entryData;
        try {
          entryData = ipns__namespace.marshal(entry);
        } catch (err) {
          log15.error(err);
          throw err;
        }
        try {
          const res = await this._routing.put(k.uint8Array(), entryData);
          log15(`ipns record for ${toString4.toString(k.uint8Array(), "base64")} was stored in the routing`);
          return res;
        } catch (err) {
          const errMsg = `ipns record for ${toString4.toString(k.uint8Array(), "base64")} could not be stored in the routing`;
          log15.error(errMsg);
          log15.error(err);
          throw errCode__default["default"](new Error(errMsg), "ERR_PUTTING_TO_ROUTING");
        }
      }
      async _publishPublicKey(key$1, publicKey) {
        const k = key.Key.asKey(key$1);
        if (!k) {
          const errMsg = "datastore key does not have a valid format";
          log15.error(errMsg);
          throw errCode__default["default"](new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
        }
        if (!publicKey || !publicKey.bytes) {
          const errMsg = "one or more of the provided parameters are not defined";
          log15.error(errMsg);
          throw errCode__default["default"](new Error(errMsg), "ERR_UNDEFINED_PARAMETER");
        }
        try {
          const res = await this._routing.put(k.uint8Array(), publicKey.bytes);
          log15(`public key for ${toString4.toString(k.uint8Array(), "base64")} was stored in the routing`);
          return res;
        } catch (err) {
          const errMsg = `public key for ${toString4.toString(k.uint8Array(), "base64")} could not be stored in the routing`;
          log15.error(errMsg);
          log15.error(err);
          throw errCode__default["default"](new Error(errMsg), "ERR_PUTTING_TO_ROUTING");
        }
      }
      async _getPublished(peerId, options = {}) {
        if (!PeerId__default["default"].isPeerId(peerId)) {
          const errMsg = "peerId received is not valid";
          log15.error(errMsg);
          throw errCode__default["default"](new Error(errMsg), "ERR_INVALID_PEER_ID");
        }
        const checkRouting = options.checkRouting !== false;
        try {
          const dsVal = await this._datastore.get(ipns__namespace.getLocalKey(peerId.id));
          return this._unmarshalData(dsVal);
        } catch (err) {
          if (err.code !== ERR_NOT_FOUND2) {
            const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`;
            log15.error(errMsg);
            throw errCode__default["default"](new Error(errMsg), "ERR_UNEXPECTED_DATASTORE_RESPONSE");
          }
          if (!checkRouting) {
            throw errCode__default["default"](err, "ERR_NOT_FOUND_AND_CHECK_ROUTING_NOT_ENABLED");
          }
          try {
            const keys = ipns__namespace.getIdKeys(peerId.toBytes());
            const res = await this._routing.get(keys.routingKey.uint8Array());
            return this._unmarshalData(res);
          } catch (err2) {
            log15.error(err2);
            throw err2;
          }
        }
      }
      _unmarshalData(data) {
        try {
          return ipns__namespace.unmarshal(data);
        } catch (err) {
          throw errCode__default["default"](err, "ERR_INVALID_RECORD_DATA");
        }
      }
      async _updateOrCreateRecord(privKey, value, lifetime, peerId) {
        if (!PeerId__default["default"].isPeerId(peerId)) {
          const errMsg = "peerId received is not valid";
          log15.error(errMsg);
          throw errCode__default["default"](new Error(errMsg), "ERR_INVALID_PEER_ID");
        }
        const getPublishedOptions = { checkRouting: true };
        let record;
        try {
          record = await this._getPublished(peerId, getPublishedOptions);
        } catch (err) {
          if (err.code !== ERR_NOT_FOUND2) {
            const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`;
            log15.error(errMsg);
            throw errCode__default["default"](new Error(errMsg), "ERR_DETERMINING_PUBLISHED_RECORD");
          }
        }
        let seqNumber = 0;
        if (record && record.sequence !== void 0) {
          seqNumber = !equals4.equals(record.value, value) ? BigInt(record.sequence) + BigInt(1) : BigInt(record.sequence);
        }
        let entryData;
        try {
          entryData = await ipns__namespace.create(privKey, value, seqNumber, lifetime);
        } catch (err) {
          const errMsg = `ipns record for ${value} could not be created`;
          log15.error(err);
          throw errCode__default["default"](new Error(errMsg), "ERR_CREATING_IPNS_RECORD");
        }
        try {
          const data = ipns__namespace.marshal(entryData);
          await this._datastore.put(ipns__namespace.getLocalKey(peerId.id), data);
          log15(`ipns record for ${toString4.toString(value, "base32")} was stored in the datastore`);
          return entryData;
        } catch (err) {
          const errMsg = `ipns record for ${value} could not be stored in the datastore`;
          log15.error(errMsg);
          throw errCode__default["default"](new Error(errMsg), "ERR_STORING_IN_DATASTORE");
        }
      }
    };
    IpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;
    exports2.IpnsPublisher = IpnsPublisher;
  }
});

// node_modules/ipfs-core/cjs/src/ipns/republisher.js
var require_republisher = __commonJS({
  "node_modules/ipfs-core/cjs/src/ipns/republisher.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipns2 = (init_src4(), src_exports3);
    var crypto3 = require_src7();
    var PeerId2 = require_src6();
    var errCode32 = require_err_code();
    var debug17 = require_browser2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var ipns__namespace = /* @__PURE__ */ _interopNamespace(ipns2);
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto3);
    var PeerId__default = /* @__PURE__ */ _interopDefaultLegacy(PeerId2);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = Object.assign(debug__default["default"]("ipfs:ipns:republisher"), { error: debug__default["default"]("ipfs:ipns:republisher:error") });
    var minute = 60 * 1e3;
    var hour = 60 * minute;
    var defaultBroadcastInterval = 4 * hour;
    var defaultRecordLifetime = 24 * hour;
    var IpnsRepublisher = class {
      constructor(publisher, datastore, peerId, keychain, options = { pass: "" }) {
        this._publisher = publisher;
        this._datastore = datastore;
        this._peerId = peerId;
        this._keychain = keychain;
        this._options = options;
        this._republishHandle = null;
      }
      async start() {
        if (this._republishHandle) {
          throw errCode__default["default"](new Error("republisher is already running"), "ERR_REPUBLISH_ALREADY_RUNNING");
        }
        const republishHandle = {
          _task: null,
          _inflightTask: null,
          _timeoutId: null,
          runPeriodically: (period) => {
            republishHandle._timeoutId = setTimeout(async () => {
              republishHandle._timeoutId = null;
              try {
                republishHandle._inflightTask = republishHandle._task();
                await republishHandle._inflightTask;
                if (republishHandle._task) {
                  republishHandle.runPeriodically(period);
                }
              } catch (err) {
                log15.error(err);
              }
            }, period());
          },
          cancel: async () => {
            if (republishHandle._timeoutId != null) {
              clearTimeout(republishHandle._timeoutId);
            }
            republishHandle._task = null;
            await republishHandle._inflightTask;
          }
        };
        const { privKey } = this._peerId;
        const { pass } = this._options;
        let firstRun = true;
        republishHandle._task = () => this._republishEntries(privKey, pass);
        republishHandle.runPeriodically(() => {
          if (firstRun) {
            firstRun = false;
            return this._options.initialBroadcastInterval || minute;
          }
          return this._options.broadcastInterval || defaultBroadcastInterval;
        });
        this._republishHandle = republishHandle;
      }
      async stop() {
        const republishHandle = this._republishHandle;
        if (!republishHandle) {
          throw errCode__default["default"](new Error("republisher is not running"), "ERR_REPUBLISH_NOT_RUNNING");
        }
        this._republishHandle = null;
        await republishHandle.cancel();
      }
      async _republishEntries(privateKey, pass) {
        try {
          await this._republishEntry(privateKey);
        } catch (err) {
          const errMsg = "cannot republish entry for the node's private key";
          log15.error(errMsg);
          return;
        }
        if (pass) {
          try {
            const keys = await this._keychain.listKeys();
            for (const key of keys) {
              if (key.name === "self") {
                continue;
              }
              const pem = await this._keychain.exportKey(key.name, pass);
              const privKey = await crypto__default["default"].keys.import(pem, pass);
              await this._republishEntry(privKey);
            }
          } catch (err) {
            log15.error(err);
          }
        }
      }
      async _republishEntry(privateKey) {
        if (!privateKey || !privateKey.bytes) {
          throw errCode__default["default"](new Error("invalid private key"), "ERR_INVALID_PRIVATE_KEY");
        }
        try {
          const peerId = await PeerId__default["default"].createFromPrivKey(privateKey.bytes);
          const value = await this._getPreviousValue(peerId);
          await this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime);
        } catch (err) {
          if (err.code === "ERR_NO_ENTRY_FOUND") {
            return;
          }
          throw err;
        }
      }
      async _getPreviousValue(peerId) {
        if (!PeerId__default["default"].isPeerId(peerId)) {
          throw errCode__default["default"](new Error("invalid peer ID"), "ERR_INVALID_PEER_ID");
        }
        try {
          const dsVal = await this._datastore.get(ipns__namespace.getLocalKey(peerId.id));
          if (!(dsVal instanceof Uint8Array)) {
            throw errCode__default["default"](new Error("found ipns record that we couldn't process"), "ERR_INVALID_IPNS_RECORD");
          }
          try {
            const record = ipns__namespace.unmarshal(dsVal);
            return record.value;
          } catch (err) {
            log15.error(err);
            throw errCode__default["default"](new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_IPNS_RECORD");
          }
        } catch (err) {
          if (err && err.notFound) {
            throw errCode__default["default"](new Error(`no previous entry for record with id: ${peerId.id}`), "ERR_NO_ENTRY_FOUND");
          }
          throw err;
        }
      }
    };
    exports2.IpnsRepublisher = IpnsRepublisher;
  }
});

// node_modules/ipfs-core/cjs/src/ipns/resolver.js
var require_resolver = __commonJS({
  "node_modules/ipfs-core/cjs/src/ipns/resolver.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipns2 = (init_src4(), src_exports3);
    var PeerId2 = require_src6();
    var errCode32 = require_err_code();
    var debug17 = require_browser2();
    var toString4 = (init_to_string(), to_string_exports);
    var Errors8 = (init_errors2(), errors_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var ipns__namespace = /* @__PURE__ */ _interopNamespace(ipns2);
    var PeerId__default = /* @__PURE__ */ _interopDefaultLegacy(PeerId2);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var Errors__namespace = /* @__PURE__ */ _interopNamespace(Errors8);
    var log15 = Object.assign(debug__default["default"]("ipfs:ipns:resolver"), { error: debug__default["default"]("ipfs:ipns:resolver:error") });
    var ERR_NOT_FOUND2 = Errors__namespace.notFoundError().code;
    var defaultMaximumRecursiveDepth = 32;
    var IpnsResolver = class {
      constructor(routing) {
        this._routing = routing;
      }
      async resolve(name5, options = {}) {
        if (typeof name5 !== "string") {
          throw errCode__default["default"](new Error("invalid name"), "ERR_INVALID_NAME");
        }
        const recursive2 = options.recursive && options.recursive.toString() === "true";
        const nameSegments = name5.split("/");
        if (nameSegments.length !== 3 || nameSegments[0] !== "") {
          throw errCode__default["default"](new Error("invalid name"), "ERR_INVALID_NAME");
        }
        const key = nameSegments[2];
        let depth = Infinity;
        if (recursive2) {
          depth = defaultMaximumRecursiveDepth;
        }
        const res = await this.resolver(key, depth);
        log15(`${name5} was locally resolved correctly`);
        return res;
      }
      async resolver(name5, depth) {
        if (depth === 0) {
          const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;
          log15.error(errMsg);
          throw errCode__default["default"](new Error(errMsg), "ERR_RESOLVE_RECURSION_LIMIT");
        }
        const res = await this._resolveName(name5);
        const nameSegments = res.split("/");
        if (nameSegments[1] === "ipfs" || !depth) {
          return res;
        }
        return this.resolver(nameSegments[2], depth - 1);
      }
      async _resolveName(name5) {
        const peerId = PeerId__default["default"].parse(name5);
        const { routingKey } = ipns__namespace.getIdKeys(peerId.toBytes());
        let record;
        try {
          record = await this._routing.get(routingKey.uint8Array());
        } catch (err) {
          log15.error("could not get record from routing", err);
          if (err.code === ERR_NOT_FOUND2) {
            throw errCode__default["default"](new Error(`record requested for ${name5} was not found in the network`), "ERR_NO_RECORD_FOUND");
          }
          throw errCode__default["default"](new Error(`unexpected error getting the ipns record ${peerId.toString()}`), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
        }
        let ipnsEntry;
        try {
          ipnsEntry = ipns__namespace.unmarshal(record);
        } catch (err) {
          log15.error("could not unmarshal record", err);
          throw errCode__default["default"](new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_RECORD_RECEIVED");
        }
        return this._validateRecord(peerId, ipnsEntry);
      }
      async _validateRecord(peerId, ipnsEntry) {
        const pubKey = await ipns__namespace.extractPublicKey(peerId, ipnsEntry);
        await ipns__namespace.validate(pubKey, ipnsEntry);
        return toString4.toString(ipnsEntry.value);
      }
    };
    exports2.IpnsResolver = IpnsResolver;
  }
});

// node_modules/ipfs-core/cjs/src/utils/tlru.js
var require_tlru = __commonJS({
  "node_modules/ipfs-core/cjs/src/utils/tlru.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hashlru2 = require_hashlru();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var hashlru__default = /* @__PURE__ */ _interopDefaultLegacy(hashlru2);
    var TLRU2 = class {
      constructor(maxSize) {
        this.lru = hashlru__default["default"](maxSize);
      }
      get(key) {
        const value = this.lru.get(key);
        if (value) {
          if (value.expire && value.expire < Date.now()) {
            this.lru.remove(key);
            return void 0;
          }
          return value.value;
        }
        return void 0;
      }
      set(key, value, ttl2) {
        this.lru.set(key, {
          value,
          expire: Date.now() + ttl2
        });
      }
      has(key) {
        const value = this.get(key);
        if (value) {
          return true;
        }
        return false;
      }
      remove(key) {
        this.lru.remove(key);
      }
      clear() {
        this.lru.clear();
      }
    };
    exports2.TLRU = TLRU2;
  }
});

// node_modules/ipfs-core/cjs/src/ipns/index.js
var require_ipns = __commonJS({
  "node_modules/ipfs-core/cjs/src/ipns/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PeerId2 = require_src6();
    var errCode32 = require_err_code();
    var debug17 = require_browser2();
    var publisher = require_publisher();
    var republisher = require_republisher();
    var resolver = require_resolver();
    var tlru = require_tlru();
    var toString4 = (init_to_string(), to_string_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = Object.assign(debug__default["default"]("ipfs:ipns"), { error: debug__default["default"]("ipfs:ipns:error") });
    var defaultRecordTtl = 60 * 1e3;
    var IPNS = class {
      constructor(routing, datastore, peerId, keychain, options) {
        this.publisher = new publisher.IpnsPublisher(routing, datastore);
        this.republisher = new republisher.IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);
        this.resolver = new resolver.IpnsResolver(routing);
        this.cache = new tlru.TLRU(1e3);
        this.routing = routing;
      }
      async publish(privKey, value, lifetime = publisher.IpnsPublisher.defaultRecordLifetime) {
        try {
          const peerId = await PeerId2.createFromPrivKey(privKey.bytes);
          await this.publisher.publishWithEOL(privKey, value, lifetime);
          log15(`IPNS value ${toString4.toString(value, "base32")} was published correctly`);
          const id = peerId.toB58String();
          const ttEol = parseFloat(lifetime);
          const ttl2 = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;
          this.cache.set(id, value, ttl2);
          log15(`IPNS value ${toString4.toString(value, "base32")} was cached correctly`);
          return {
            name: id,
            value
          };
        } catch (err) {
          log15.error(err);
          throw err;
        }
      }
      async resolve(name5, options = {}) {
        if (typeof name5 !== "string") {
          throw errCode__default["default"](new Error("name received is not valid"), "ERR_INVALID_NAME");
        }
        if (!options.nocache && !options.recursive) {
          const id = name5.split("/")[2];
          const result = this.cache.get(id);
          if (result) {
            return result;
          }
        }
        try {
          const result = await this.resolver.resolve(name5, options);
          log15(`IPNS record from ${name5} was resolved correctly`);
          return result;
        } catch (err) {
          log15.error(err);
          throw err;
        }
      }
      async initializeKeyspace(privKey, value) {
        return this.publish(privKey, value, publisher.IpnsPublisher.defaultRecordLifetime);
      }
    };
    exports2.IPNS = IPNS;
  }
});

// node_modules/it-all/index.js
var require_it_all = __commonJS({
  "node_modules/it-all/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var all6 = async (source) => {
      const arr = [];
      for await (const entry of source) {
        arr.push(entry);
      }
      return arr;
    };
    module2.exports = all6;
  }
});

// node_modules/datastore-core/esm/src/utils.js
var import_it_all, sortAll;
var init_utils2 = __esm({
  "node_modules/datastore-core/esm/src/utils.js"() {
    init_node_globals();
    import_it_all = __toModule(require_it_all());
    sortAll = (iterable, sorter) => {
      return async function* () {
        const values = await (0, import_it_all.default)(iterable);
        yield* values.sort(sorter);
      }();
    };
  }
});

// node_modules/it-drain/index.js
var require_it_drain = __commonJS({
  "node_modules/it-drain/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var drain6 = async (source) => {
      for await (const _ of source) {
      }
    };
    module2.exports = drain6;
  }
});

// node_modules/it-filter/index.js
var require_it_filter = __commonJS({
  "node_modules/it-filter/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var filter8 = async function* (source, fn) {
      for await (const entry of source) {
        if (await fn(entry)) {
          yield entry;
        }
      }
    };
    module2.exports = filter8;
  }
});

// node_modules/it-take/index.js
var require_it_take = __commonJS({
  "node_modules/it-take/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var take5 = async function* (source, limit) {
      let items = 0;
      if (limit < 1) {
        return;
      }
      for await (const entry of source) {
        yield entry;
        items++;
        if (items === limit) {
          return;
        }
      }
    };
    module2.exports = take5;
  }
});

// node_modules/datastore-core/esm/src/base.js
var import_it_drain, import_it_filter, import_it_take, BaseDatastore;
var init_base3 = __esm({
  "node_modules/datastore-core/esm/src/base.js"() {
    init_node_globals();
    init_utils2();
    import_it_drain = __toModule(require_it_drain());
    import_it_filter = __toModule(require_it_filter());
    import_it_take = __toModule(require_it_take());
    BaseDatastore = class {
      open() {
        return Promise.reject(new Error(".open is not implemented"));
      }
      close() {
        return Promise.reject(new Error(".close is not implemented"));
      }
      put(key, val, options) {
        return Promise.reject(new Error(".put is not implemented"));
      }
      get(key, options) {
        return Promise.reject(new Error(".get is not implemented"));
      }
      has(key, options) {
        return Promise.reject(new Error(".has is not implemented"));
      }
      delete(key, options) {
        return Promise.reject(new Error(".delete is not implemented"));
      }
      async *putMany(source, options = {}) {
        for await (const { key, value } of source) {
          await this.put(key, value, options);
          yield {
            key,
            value
          };
        }
      }
      async *getMany(source, options = {}) {
        for await (const key of source) {
          yield this.get(key, options);
        }
      }
      async *deleteMany(source, options = {}) {
        for await (const key of source) {
          await this.delete(key, options);
          yield key;
        }
      }
      batch() {
        let puts = [];
        let dels = [];
        return {
          put(key, value) {
            puts.push({
              key,
              value
            });
          },
          delete(key) {
            dels.push(key);
          },
          commit: async (options) => {
            await (0, import_it_drain.default)(this.putMany(puts, options));
            puts = [];
            await (0, import_it_drain.default)(this.deleteMany(dels, options));
            dels = [];
          }
        };
      }
      async *_all(q, options) {
        throw new Error("._all is not implemented");
      }
      async *_allKeys(q, options) {
        throw new Error("._allKeys is not implemented");
      }
      query(q, options) {
        let it = this._all(q, options);
        if (q.prefix != null) {
          it = (0, import_it_filter.default)(it, (e) => e.key.toString().startsWith(q.prefix));
        }
        if (Array.isArray(q.filters)) {
          it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
        }
        if (Array.isArray(q.orders)) {
          it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
        }
        if (q.offset != null) {
          let i = 0;
          it = (0, import_it_filter.default)(it, () => i++ >= q.offset);
        }
        if (q.limit != null) {
          it = (0, import_it_take.default)(it, q.limit);
        }
        return it;
      }
      queryKeys(q, options) {
        let it = this._allKeys(q, options);
        if (q.prefix != null) {
          it = (0, import_it_filter.default)(it, (key) => key.toString().startsWith(q.prefix));
        }
        if (Array.isArray(q.filters)) {
          it = q.filters.reduce((it2, f) => (0, import_it_filter.default)(it2, f), it);
        }
        if (Array.isArray(q.orders)) {
          it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
        }
        if (q.offset != null) {
          let i = 0;
          it = (0, import_it_filter.default)(it, () => i++ >= q.offset);
        }
        if (q.limit != null) {
          it = (0, import_it_take.default)(it, q.limit);
        }
        return it;
      }
    };
  }
});

// node_modules/fast-fifo/fixed-size.js
var require_fixed_size = __commonJS({
  "node_modules/fast-fifo/fixed-size.js"(exports2, module2) {
    init_node_globals();
    module2.exports = class FixedFIFO {
      constructor(hwm) {
        if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
          throw new Error("Max size for a FixedFIFO should be a power of two");
        this.buffer = new Array(hwm);
        this.mask = hwm - 1;
        this.top = 0;
        this.btm = 0;
        this.next = null;
      }
      push(data) {
        if (this.buffer[this.top] !== void 0)
          return false;
        this.buffer[this.top] = data;
        this.top = this.top + 1 & this.mask;
        return true;
      }
      shift() {
        const last6 = this.buffer[this.btm];
        if (last6 === void 0)
          return void 0;
        this.buffer[this.btm] = void 0;
        this.btm = this.btm + 1 & this.mask;
        return last6;
      }
      isEmpty() {
        return this.buffer[this.btm] === void 0;
      }
    };
  }
});

// node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS({
  "node_modules/fast-fifo/index.js"(exports2, module2) {
    init_node_globals();
    var FixedFIFO = require_fixed_size();
    module2.exports = class FastFIFO {
      constructor(hwm) {
        this.hwm = hwm || 16;
        this.head = new FixedFIFO(this.hwm);
        this.tail = this.head;
      }
      push(val) {
        if (!this.head.push(val)) {
          const prev = this.head;
          this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
          this.head.push(val);
        }
      }
      shift() {
        const val = this.tail.shift();
        if (val === void 0 && this.tail.next) {
          const next = this.tail.next;
          this.tail.next = null;
          this.tail = next;
          return this.tail.shift();
        }
        return val;
      }
      isEmpty() {
        return this.head.isEmpty();
      }
    };
  }
});

// node_modules/it-pushable/index.js
var require_it_pushable = __commonJS({
  "node_modules/it-pushable/index.js"(exports2, module2) {
    init_node_globals();
    var FIFO = require_fast_fifo();
    module2.exports = (options) => {
      options = options || {};
      let onEnd;
      if (typeof options === "function") {
        onEnd = options;
        options = {};
      } else {
        onEnd = options.onEnd;
      }
      let buffer2 = new FIFO();
      let pushable4, onNext, ended;
      const waitNext = () => {
        if (!buffer2.isEmpty()) {
          if (options.writev) {
            let next2;
            const values = [];
            while (!buffer2.isEmpty()) {
              next2 = buffer2.shift();
              if (next2.error)
                throw next2.error;
              values.push(next2.value);
            }
            return { done: next2.done, value: values };
          }
          const next = buffer2.shift();
          if (next.error)
            throw next.error;
          return next;
        }
        if (ended)
          return { done: true };
        return new Promise((resolve6, reject) => {
          onNext = (next) => {
            onNext = null;
            if (next.error) {
              reject(next.error);
            } else {
              if (options.writev && !next.done) {
                resolve6({ done: next.done, value: [next.value] });
              } else {
                resolve6(next);
              }
            }
            return pushable4;
          };
        });
      };
      const bufferNext = (next) => {
        if (onNext)
          return onNext(next);
        buffer2.push(next);
        return pushable4;
      };
      const bufferError = (err) => {
        buffer2 = new FIFO();
        if (onNext)
          return onNext({ error: err });
        buffer2.push({ error: err });
        return pushable4;
      };
      const push = (value) => {
        if (ended)
          return pushable4;
        return bufferNext({ done: false, value });
      };
      const end = (err) => {
        if (ended)
          return pushable4;
        ended = true;
        return err ? bufferError(err) : bufferNext({ done: true });
      };
      const _return = () => {
        buffer2 = new FIFO();
        end();
        return { done: true };
      };
      const _throw = (err) => {
        end(err);
        return { done: true };
      };
      pushable4 = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next: waitNext,
        return: _return,
        throw: _throw,
        push,
        end
      };
      if (!onEnd)
        return pushable4;
      const _pushable = pushable4;
      pushable4 = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next() {
          return _pushable.next();
        },
        throw(err) {
          _pushable.throw(err);
          if (onEnd) {
            onEnd(err);
            onEnd = null;
          }
          return { done: true };
        },
        return() {
          _pushable.return();
          if (onEnd) {
            onEnd();
            onEnd = null;
          }
          return { done: true };
        },
        push,
        end(err) {
          _pushable.end(err);
          if (onEnd) {
            onEnd(err);
            onEnd = null;
          }
          return pushable4;
        }
      };
      return pushable4;
    };
  }
});

// node_modules/datastore-core/esm/src/tiered.js
var tiered_exports = {};
__export(tiered_exports, {
  TieredDatastore: () => TieredDatastore
});
var import_debug2, import_it_pushable, import_it_drain2, log2, TieredDatastore;
var init_tiered = __esm({
  "node_modules/datastore-core/esm/src/tiered.js"() {
    init_node_globals();
    init_base3();
    init_errors2();
    import_debug2 = __toModule(require_browser2());
    import_it_pushable = __toModule(require_it_pushable());
    import_it_drain2 = __toModule(require_it_drain());
    log2 = (0, import_debug2.default)("datastore:core:tiered");
    TieredDatastore = class extends BaseDatastore {
      constructor(stores) {
        super();
        this.stores = stores.slice();
      }
      async open() {
        try {
          await Promise.all(this.stores.map((store) => store.open()));
        } catch (err) {
          throw dbOpenFailedError();
        }
      }
      async put(key, value) {
        try {
          await Promise.all(this.stores.map((store) => store.put(key, value)));
        } catch (err) {
          throw dbWriteFailedError();
        }
      }
      async get(key, options) {
        for (const store of this.stores) {
          try {
            const res = await store.get(key, options);
            if (res)
              return res;
          } catch (err) {
            log2(err);
          }
        }
        throw notFoundError();
      }
      async has(key, options) {
        for (const s of this.stores) {
          if (await s.has(key, options)) {
            return true;
          }
        }
        return false;
      }
      async delete(key, options) {
        try {
          await Promise.all(this.stores.map((store) => store.delete(key, options)));
        } catch (err) {
          throw dbDeleteFailedError();
        }
      }
      async *putMany(source, options = {}) {
        let error;
        const pushables = this.stores.map((store) => {
          const source2 = (0, import_it_pushable.default)();
          (0, import_it_drain2.default)(store.putMany(source2, options)).catch((err) => {
            error = err;
          });
          return source2;
        });
        try {
          for await (const pair of source) {
            if (error) {
              throw error;
            }
            pushables.forEach((p) => p.push(pair));
            yield pair;
          }
        } finally {
          pushables.forEach((p) => p.end());
        }
      }
      async *deleteMany(source, options = {}) {
        let error;
        const pushables = this.stores.map((store) => {
          const source2 = (0, import_it_pushable.default)();
          (0, import_it_drain2.default)(store.deleteMany(source2, options)).catch((err) => {
            error = err;
          });
          return source2;
        });
        try {
          for await (const key of source) {
            if (error) {
              throw error;
            }
            pushables.forEach((p) => p.push(key));
            yield key;
          }
        } finally {
          pushables.forEach((p) => p.end());
        }
      }
      async close() {
        await Promise.all(this.stores.map((store) => store.close()));
      }
      batch() {
        const batches = this.stores.map((store) => store.batch());
        return {
          put: (key, value) => {
            batches.forEach((b) => b.put(key, value));
          },
          delete: (key) => {
            batches.forEach((b) => b.delete(key));
          },
          commit: async (options) => {
            for (const batch3 of batches) {
              await batch3.commit(options);
            }
          }
        };
      }
      query(q, options) {
        return this.stores[this.stores.length - 1].query(q, options);
      }
      queryKeys(q, options) {
        return this.stores[this.stores.length - 1].queryKeys(q, options);
      }
    };
  }
});

// node_modules/dlv/dist/dlv.umd.js
var require_dlv_umd = __commonJS({
  "node_modules/dlv/dist/dlv.umd.js"(exports2, module2) {
    init_node_globals();
    !function(t, n) {
      typeof exports2 == "object" && typeof module2 != "undefined" ? module2.exports = function(t2, n2, e, i, o) {
        for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
          t2 = t2 ? t2[n2[i]] : o;
        return t2 === o ? e : t2;
      } : typeof define == "function" && define.amd ? define(function() {
        return function(t2, n2, e, i, o) {
          for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
            t2 = t2 ? t2[n2[i]] : o;
          return t2 === o ? e : t2;
        };
      }) : t.dlv = function(t2, n2, e, i, o) {
        for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
          t2 = t2 ? t2[n2[i]] : o;
        return t2 === o ? e : t2;
      };
    }(exports2);
  }
});

// node_modules/interface-datastore/esm/src/index.js
var init_src5 = __esm({
  "node_modules/interface-datastore/esm/src/index.js"() {
    init_node_globals();
    init_key();
  }
});

// node_modules/datastore-core/esm/src/shard-readme.js
var shard_readme_default;
var init_shard_readme = __esm({
  "node_modules/datastore-core/esm/src/shard-readme.js"() {
    init_node_globals();
    shard_readme_default = `This is a repository of IPLD objects. Each IPLD object is in a single file,
named <base32 encoding of cid>.data. Where <base32 encoding of cid> is the
"base32" encoding of the CID (as specified in
https://github.com/multiformats/multibase) without the 'B' prefix.
All the object files are placed in a tree of directories, based on a
function of the CID. This is a form of sharding similar to
the objects directory in git repositories. Previously, we used
prefixes, we now use the next-to-last two charters.
    func NextToLast(base32cid string) {
      nextToLastLen := 2
      offset := len(base32cid) - nextToLastLen - 1
      return str[offset : offset+nextToLastLen]
    }
For example, an object with a base58 CIDv1 of
    zb2rhYSxw4ZjuzgCnWSt19Q94ERaeFhu9uSqRgjSdx9bsgM6f
has a base32 CIDv1 of
    BAFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA
and will be placed at
    SC/AFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA.data
with 'SC' being the last-to-next two characters and the 'B' at the
beginning of the CIDv1 string is the multibase prefix that is not
stored in the filename.
`;
  }
});

// node_modules/datastore-core/esm/src/shard.js
var shard_exports = {};
__export(shard_exports, {
  NextToLast: () => NextToLast,
  PREFIX: () => PREFIX,
  Prefix: () => Prefix,
  README_FN: () => README_FN,
  SHARDING_FN: () => SHARDING_FN,
  ShardBase: () => ShardBase,
  Suffix: () => Suffix,
  parseShardFun: () => parseShardFun,
  readShardFun: () => readShardFun,
  readme: () => shard_readme_default
});
function parseShardFun(str) {
  str = str.trim();
  if (str.length === 0) {
    throw new Error("empty shard string");
  }
  if (!str.startsWith(PREFIX)) {
    throw new Error(`invalid or no path prefix: ${str}`);
  }
  const parts = str.slice(PREFIX.length).split("/");
  const version3 = parts[0];
  if (version3 !== "v1") {
    throw new Error(`expect 'v1' version, got '${version3}'`);
  }
  const name5 = parts[1];
  if (!parts[2]) {
    throw new Error("missing param");
  }
  const param = parseInt(parts[2], 10);
  switch (name5) {
    case "prefix":
      return new Prefix(param);
    case "suffix":
      return new Suffix(param);
    case "next-to-last":
      return new NextToLast(param);
    default:
      throw new Error(`unkown sharding function: ${name5}`);
  }
}
var PREFIX, SHARDING_FN, README_FN, ShardBase, Prefix, Suffix, NextToLast, readShardFun;
var init_shard = __esm({
  "node_modules/datastore-core/esm/src/shard.js"() {
    init_node_globals();
    init_key();
    init_shard_readme();
    init_shard_readme();
    PREFIX = "/repo/flatfs/shard/";
    SHARDING_FN = "SHARDING";
    README_FN = "_README";
    ShardBase = class {
      constructor(param) {
        this.param = param;
        this.name = "base";
        this._padding = "";
      }
      fun(s) {
        return "implement me";
      }
      toString() {
        return `${PREFIX}v1/${this.name}/${this.param}`;
      }
    };
    Prefix = class extends ShardBase {
      constructor(prefixLen) {
        super(prefixLen);
        this._padding = "".padStart(prefixLen, "_");
        this.name = "prefix";
      }
      fun(noslash) {
        return (noslash + this._padding).slice(0, this.param);
      }
    };
    Suffix = class extends ShardBase {
      constructor(suffixLen) {
        super(suffixLen);
        this._padding = "".padStart(suffixLen, "_");
        this.name = "suffix";
      }
      fun(noslash) {
        const s = this._padding + noslash;
        return s.slice(s.length - this.param);
      }
    };
    NextToLast = class extends ShardBase {
      constructor(suffixLen) {
        super(suffixLen);
        this._padding = "".padStart(suffixLen + 1, "_");
        this.name = "next-to-last";
      }
      fun(noslash) {
        const s = this._padding + noslash;
        const offset = s.length - this.param - 1;
        return s.slice(offset, offset + this.param);
      }
    };
    readShardFun = async (path, store) => {
      const key = new Key(path).child(new Key(SHARDING_FN));
      const get2 = typeof store.getRaw === "function" ? store.getRaw.bind(store) : store.get.bind(store);
      const res = await get2(key);
      return parseShardFun(new TextDecoder().decode(res || "").trim());
    };
  }
});

// node_modules/datastore-core/esm/src/memory.js
var memory_exports = {};
__export(memory_exports, {
  MemoryDatastore: () => MemoryDatastore
});
var MemoryDatastore;
var init_memory = __esm({
  "node_modules/datastore-core/esm/src/memory.js"() {
    init_node_globals();
    init_base3();
    init_key();
    init_errors2();
    MemoryDatastore = class extends BaseDatastore {
      constructor() {
        super();
        this.data = {};
      }
      open() {
        return Promise.resolve();
      }
      close() {
        return Promise.resolve();
      }
      async put(key, val) {
        this.data[key.toString()] = val;
      }
      async get(key) {
        const exists = await this.has(key);
        if (!exists)
          throw notFoundError();
        return this.data[key.toString()];
      }
      async has(key) {
        return this.data[key.toString()] !== void 0;
      }
      async delete(key) {
        delete this.data[key.toString()];
      }
      async *_all() {
        yield* Object.entries(this.data).map(([key, value]) => ({
          key: new Key(key),
          value
        }));
      }
      async *_allKeys() {
        yield* Object.entries(this.data).map(([key]) => new Key(key));
      }
    };
  }
});

// node_modules/it-map/index.js
var require_it_map = __commonJS({
  "node_modules/it-map/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var map8 = async function* (source, func) {
      for await (const val of source) {
        yield func(val);
      }
    };
    module2.exports = map8;
  }
});

// node_modules/it-pipe/index.js
var require_it_pipe = __commonJS({
  "node_modules/it-pipe/index.js"(exports2, module2) {
    init_node_globals();
    var rawPipe = (...fns) => {
      let res;
      while (fns.length) {
        res = fns.shift()(res);
      }
      return res;
    };
    var isIterable2 = (obj) => obj && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
    var isDuplex = (obj) => obj && typeof obj.sink === "function" && isIterable2(obj.source);
    var duplexPipelineFn = (duplex) => (source) => {
      duplex.sink(source);
      return duplex.source;
    };
    var pipe4 = (...fns) => {
      if (isDuplex(fns[0])) {
        const duplex = fns[0];
        fns[0] = () => duplex.source;
      } else if (isIterable2(fns[0])) {
        const source = fns[0];
        fns[0] = () => source;
      }
      if (fns.length > 1) {
        if (isDuplex(fns[fns.length - 1])) {
          fns[fns.length - 1] = fns[fns.length - 1].sink;
        }
      }
      if (fns.length > 2) {
        for (let i = 1; i < fns.length - 1; i++) {
          if (isDuplex(fns[i])) {
            fns[i] = duplexPipelineFn(fns[i]);
          }
        }
      }
      return rawPipe(...fns);
    };
    module2.exports = pipe4;
    module2.exports.pipe = pipe4;
    module2.exports.rawPipe = rawPipe;
    module2.exports.isIterable = isIterable2;
    module2.exports.isDuplex = isDuplex;
  }
});

// node_modules/datastore-core/esm/src/keytransform.js
var import_it_map, import_it_pipe;
var init_keytransform = __esm({
  "node_modules/datastore-core/esm/src/keytransform.js"() {
    init_node_globals();
    init_base3();
    import_it_map = __toModule(require_it_map());
    import_it_pipe = __toModule(require_it_pipe());
  }
});

// node_modules/datastore-core/esm/src/sharding.js
var shardKey, shardReadmeKey;
var init_sharding = __esm({
  "node_modules/datastore-core/esm/src/sharding.js"() {
    init_node_globals();
    init_src5();
    init_shard();
    init_base3();
    init_keytransform();
    init_errors2();
    shardKey = new Key(SHARDING_FN);
    shardReadmeKey = new Key(README_FN);
  }
});

// node_modules/it-merge/index.js
var require_it_merge = __commonJS({
  "node_modules/it-merge/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var pushable4 = require_it_pushable();
    var merge4 = async function* (...sources) {
      const output = pushable4();
      setTimeout(async () => {
        try {
          await Promise.all(sources.map(async (source) => {
            for await (const item of source) {
              output.push(item);
            }
          }));
          output.end();
        } catch (err) {
          output.end(err);
        }
      }, 0);
      yield* output;
    };
    module2.exports = merge4;
  }
});

// node_modules/datastore-core/esm/src/mount.js
var import_it_filter2, import_it_take2, import_it_merge;
var init_mount = __esm({
  "node_modules/datastore-core/esm/src/mount.js"() {
    init_node_globals();
    import_it_filter2 = __toModule(require_it_filter());
    import_it_take2 = __toModule(require_it_take());
    import_it_merge = __toModule(require_it_merge());
    init_base3();
    init_keytransform();
    init_errors2();
    init_utils2();
    init_key();
  }
});

// node_modules/datastore-core/esm/src/namespace.js
var init_namespace = __esm({
  "node_modules/datastore-core/esm/src/namespace.js"() {
    init_node_globals();
    init_src5();
    init_keytransform();
  }
});

// node_modules/datastore-core/esm/src/index.js
var Errors5, shard;
var init_src6 = __esm({
  "node_modules/datastore-core/esm/src/index.js"() {
    init_node_globals();
    init_errors2();
    init_shard();
    init_base3();
    init_memory();
    init_keytransform();
    init_sharding();
    init_mount();
    init_tiered();
    init_namespace();
    Errors5 = { ...errors_exports };
    shard = { ...shard_exports };
  }
});

// node_modules/datastore-pubsub/esm/src/utils.js
function encodeBase32(buf2) {
  return toString3(buf2, "base32");
}
function keyToTopic(key) {
  if (typeof key === "string" || key instanceof String) {
    key = fromString3(key.toString());
  }
  const b64url = toString3(key, "base64url");
  return `${namespace2}${b64url}`;
}
function topicToKey(topic) {
  if (topic.substring(0, namespace2.length) !== namespace2) {
    throw (0, import_err_code6.default)(new Error("topic received is not from a record"), "ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");
  }
  const key = topic.substring(namespace2.length);
  return fromString3(key, "base64url");
}
var import_err_code6, namespace2;
var init_utils3 = __esm({
  "node_modules/datastore-pubsub/esm/src/utils.js"() {
    init_node_globals();
    import_err_code6 = __toModule(require_err_code());
    init_to_string();
    init_from_string();
    namespace2 = "/record/";
  }
});

// node_modules/datastore-pubsub/esm/src/index.js
var src_exports4 = {};
__export(src_exports4, {
  PubsubDatastore: () => PubsubDatastore
});
var import_err_code7, import_debug3, log3, PubsubDatastore;
var init_src7 = __esm({
  "node_modules/datastore-pubsub/esm/src/index.js"() {
    init_node_globals();
    init_src5();
    init_src6();
    init_utils3();
    init_equals();
    import_err_code7 = __toModule(require_err_code());
    import_debug3 = __toModule(require_browser2());
    log3 = Object.assign((0, import_debug3.default)("datastore-pubsub:publisher"), { error: (0, import_debug3.default)("datastore-pubsub:publisher:error") });
    PubsubDatastore = class extends BaseDatastore {
      constructor(pubsub, datastore, peerId, validator3, subscriptionKeyFn) {
        super();
        if (!validator3) {
          throw (0, import_err_code7.default)(new TypeError("missing validator"), "ERR_INVALID_PARAMETERS");
        }
        if (typeof validator3.validate !== "function") {
          throw (0, import_err_code7.default)(new TypeError("missing validate function"), "ERR_INVALID_PARAMETERS");
        }
        if (typeof validator3.select !== "function") {
          throw (0, import_err_code7.default)(new TypeError("missing select function"), "ERR_INVALID_PARAMETERS");
        }
        if (subscriptionKeyFn && typeof subscriptionKeyFn !== "function") {
          throw (0, import_err_code7.default)(new TypeError("invalid subscriptionKeyFn received"), "ERR_INVALID_PARAMETERS");
        }
        this._pubsub = pubsub;
        this._datastore = datastore;
        this._peerId = peerId;
        this._validator = validator3;
        this._handleSubscriptionKeyFn = subscriptionKeyFn;
        this._onMessage = this._onMessage.bind(this);
      }
      async put(key, val) {
        if (!(key instanceof Uint8Array)) {
          const errMsg = "datastore key does not have a valid format";
          log3.error(errMsg);
          throw (0, import_err_code7.default)(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
        }
        if (!(val instanceof Uint8Array)) {
          const errMsg = "received value is not a Uint8Array";
          log3.error(errMsg);
          throw (0, import_err_code7.default)(new Error(errMsg), "ERR_INVALID_VALUE_RECEIVED");
        }
        const stringifiedTopic = keyToTopic(key);
        log3(`publish value for topic ${stringifiedTopic}`);
        await this._pubsub.publish(stringifiedTopic, val);
      }
      async get(key) {
        if (!(key instanceof Uint8Array)) {
          const errMsg = "datastore key does not have a valid format";
          log3.error(errMsg);
          throw (0, import_err_code7.default)(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
        }
        const stringifiedTopic = keyToTopic(key);
        const subscriptions = await this._pubsub.getTopics();
        if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {
          return this._getLocal(key);
        }
        try {
          this._pubsub.on(stringifiedTopic, this._onMessage);
          await this._pubsub.subscribe(stringifiedTopic);
        } catch (err) {
          const errMsg = `cannot subscribe topic ${stringifiedTopic}`;
          log3.error(errMsg);
          throw (0, import_err_code7.default)(new Error(errMsg), "ERR_SUBSCRIBING_TOPIC");
        }
        log3(`subscribed values for key ${stringifiedTopic}`);
        return this._getLocal(key);
      }
      unsubscribe(key) {
        const stringifiedTopic = keyToTopic(key);
        this._pubsub.removeListener(stringifiedTopic, this._onMessage);
        return this._pubsub.unsubscribe(stringifiedTopic);
      }
      async _getLocal(key) {
        const routingKey = new Key("/" + encodeBase32(key), false);
        let dsVal;
        try {
          dsVal = await this._datastore.get(routingKey);
        } catch (err) {
          if (err.code !== "ERR_NOT_FOUND") {
            const errMsg2 = `unexpected error getting the ipns record for ${routingKey.toString()}`;
            log3.error(errMsg2);
            throw (0, import_err_code7.default)(new Error(errMsg2), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
          }
          const errMsg = `local record requested was not found for ${routingKey.toString()}`;
          log3.error(errMsg);
          throw (0, import_err_code7.default)(new Error(errMsg), "ERR_NOT_FOUND");
        }
        if (!(dsVal instanceof Uint8Array)) {
          const errMsg = "found record that we couldn't convert to a value";
          log3.error(errMsg);
          throw (0, import_err_code7.default)(new Error(errMsg), "ERR_INVALID_RECORD_RECEIVED");
        }
        return dsVal;
      }
      async _onMessage(msg) {
        const { data, from: from3, topicIDs } = msg;
        let key;
        try {
          key = topicToKey(topicIDs[0]);
        } catch (err) {
          log3.error(err);
          return;
        }
        log3(`message received for topic ${topicIDs[0]}`);
        if (from3 === this._peerId.toB58String()) {
          log3("message discarded as it is from the same peer");
          return;
        }
        if (this._handleSubscriptionKeyFn) {
          let res;
          try {
            res = await this._handleSubscriptionKeyFn(key);
          } catch (err) {
            log3.error("message discarded by the subscriptionKeyFn");
            return;
          }
          key = res;
        }
        try {
          await this._storeIfSubscriptionIsBetter(key, data);
        } catch (err) {
          log3.error(err);
        }
      }
      async _storeIfSubscriptionIsBetter(key, data) {
        let isBetter = false;
        try {
          isBetter = await this._isBetter(key, data);
        } catch (err) {
          if (err.code !== "ERR_NOT_VALID_RECORD") {
            throw err;
          }
        }
        if (isBetter) {
          await this._storeRecord(key, data);
        }
      }
      async _validateRecord(value, peerId) {
        return this._validator.validate(value, peerId);
      }
      async _selectRecord(key, records) {
        const res = await this._validator.select(key, records);
        return res === 0;
      }
      async _isBetter(key, val) {
        try {
          await this._validateRecord(val, key);
        } catch (err) {
          const errMsg = "record received through pubsub is not valid";
          log3.error(errMsg);
          throw (0, import_err_code7.default)(new Error(errMsg), "ERR_NOT_VALID_RECORD");
        }
        const dsKey = new Key(key);
        let currentRecord;
        try {
          currentRecord = await this._getLocal(dsKey.uint8Array());
        } catch (err) {
          return true;
        }
        if (equals3(currentRecord, val)) {
          return false;
        }
        return this._selectRecord(key, [
          currentRecord,
          val
        ]);
      }
      async _storeRecord(key, data) {
        const routingKey = new Key("/" + encodeBase32(key), false);
        await this._datastore.put(routingKey, data);
        log3(`record for ${keyToTopic(key)} was stored in the datastore`);
      }
    };
  }
});

// node_modules/ipfs-core/cjs/src/ipns/routing/pubsub-datastore.js
var require_pubsub_datastore = __commonJS({
  "node_modules/ipfs-core/cjs/src/ipns/routing/pubsub-datastore.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipns2 = (init_src4(), src_exports3);
    var base58 = (init_base58(), base58_exports);
    var datastorePubsub = (init_src7(), src_exports4);
    var fromString4 = (init_from_string(), from_string_exports);
    var toString4 = (init_to_string(), to_string_exports);
    var errCode32 = require_err_code();
    var debug17 = require_browser2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var ipns__namespace = /* @__PURE__ */ _interopNamespace(ipns2);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = Object.assign(debug__default["default"]("ipfs:ipns:pubsub"), { error: debug__default["default"]("ipfs:ipns:pubsub:error") });
    var IpnsPubsubDatastore = class {
      constructor(pubsub, localDatastore, peerId) {
        this._subscriptions = {};
        this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);
        this._pubsubDs = new datastorePubsub.PubsubDatastore(pubsub, localDatastore, peerId, ipns__namespace.validator, this._handleSubscriptionKey);
      }
      put(key, value) {
        return this._pubsubDs.put(key, value);
      }
      async get(key) {
        let res;
        let err;
        try {
          res = await this._pubsubDs.get(key);
        } catch (e) {
          err = e;
        }
        const ns = key.slice(0, ipns__namespace.namespaceLength);
        if (toString4.toString(ns) === ipns__namespace.namespace) {
          const stringifiedTopic = base58.base58btc.encode(key).substring(1);
          const id = base58.base58btc.encode(key.slice(ipns__namespace.namespaceLength)).substring(1);
          this._subscriptions[stringifiedTopic] = id;
          log15(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);
        }
        if (err) {
          throw err;
        }
        return res;
      }
      _handleSubscriptionKey(key) {
        if (key instanceof Uint8Array) {
          key = toString4.toString(key, "base58btc");
        }
        const subscriber = this._subscriptions[key];
        if (!subscriber) {
          throw errCode__default["default"](new Error(`key ${key} does not correspond to a subscription`), "ERR_INVALID_KEY");
        }
        let keys;
        try {
          keys = ipns__namespace.getIdKeys(fromString4.fromString(subscriber, "base58btc"));
        } catch (err) {
          log15.error(err);
          throw err;
        }
        return keys.routingKey.uint8Array();
      }
      getSubscriptions() {
        const subscriptions = Object.values(this._subscriptions).filter(Boolean);
        return subscriptions.map((sub) => `${ipns__namespace.namespace}${sub}`);
      }
      async cancel(name5) {
        if (typeof name5 !== "string") {
          throw errCode__default["default"](new Error("invalid subscription name"), "ERR_INVALID_SUBSCRIPTION_NAME");
        }
        if (name5.startsWith(ipns__namespace.namespace)) {
          name5 = name5.substring(ipns__namespace.namespaceLength);
        }
        const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name5);
        if (!stringifiedTopic) {
          return { canceled: false };
        }
        const bufTopic = fromString4.fromString(stringifiedTopic);
        this._pubsubDs.unsubscribe(bufTopic);
        delete this._subscriptions[stringifiedTopic];
        log15(`unsubscribed pubsub ${stringifiedTopic}: ${name5}`);
        return { canceled: true };
      }
    };
    exports2.IpnsPubsubDatastore = IpnsPubsubDatastore;
  }
});

// node_modules/libp2p-record/src/record/record.js
var require_record = __commonJS({
  "node_modules/libp2p-record/src/record/record.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var $protobuf5 = require_minimal2();
    var $Reader5 = $protobuf5.Reader;
    var $Writer5 = $protobuf5.Writer;
    var $util5 = $protobuf5.util;
    var $root5 = $protobuf5.roots["libp2p-record"] || ($protobuf5.roots["libp2p-record"] = {});
    $root5.Record = function() {
      function Record(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Record.prototype.key = $util5.newBuffer([]);
      Record.prototype.value = $util5.newBuffer([]);
      Record.prototype.timeReceived = "";
      Record.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        if (m.key != null && Object.hasOwnProperty.call(m, "key"))
          w.uint32(10).bytes(m.key);
        if (m.value != null && Object.hasOwnProperty.call(m, "value"))
          w.uint32(18).bytes(m.value);
        if (m.timeReceived != null && Object.hasOwnProperty.call(m, "timeReceived"))
          w.uint32(42).string(m.timeReceived);
        return w;
      };
      Record.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Record();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.key = r.bytes();
              break;
            case 2:
              m.value = r.bytes();
              break;
            case 5:
              m.timeReceived = r.string();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Record.fromObject = function fromObject(d) {
        if (d instanceof $root5.Record)
          return d;
        var m = new $root5.Record();
        if (d.key != null) {
          if (typeof d.key === "string")
            $util5.base64.decode(d.key, m.key = $util5.newBuffer($util5.base64.length(d.key)), 0);
          else if (d.key.length)
            m.key = d.key;
        }
        if (d.value != null) {
          if (typeof d.value === "string")
            $util5.base64.decode(d.value, m.value = $util5.newBuffer($util5.base64.length(d.value)), 0);
          else if (d.value.length)
            m.value = d.value;
        }
        if (d.timeReceived != null) {
          m.timeReceived = String(d.timeReceived);
        }
        return m;
      };
      Record.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.key = "";
          else {
            d.key = [];
            if (o.bytes !== Array)
              d.key = $util5.newBuffer(d.key);
          }
          if (o.bytes === String)
            d.value = "";
          else {
            d.value = [];
            if (o.bytes !== Array)
              d.value = $util5.newBuffer(d.value);
          }
          d.timeReceived = "";
        }
        if (m.key != null && m.hasOwnProperty("key")) {
          d.key = o.bytes === String ? $util5.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
        }
        if (m.value != null && m.hasOwnProperty("value")) {
          d.value = o.bytes === String ? $util5.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
        }
        if (m.timeReceived != null && m.hasOwnProperty("timeReceived")) {
          d.timeReceived = m.timeReceived;
        }
        return d;
      };
      Record.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      return Record;
    }();
    module2.exports = $root5;
  }
});

// node_modules/libp2p-record/src/utils.js
var require_utils5 = __commonJS({
  "node_modules/libp2p-record/src/utils.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports.toRFC3339 = (time) => {
      const year = time.getUTCFullYear();
      const month = String(time.getUTCMonth() + 1).padStart(2, "0");
      const day = String(time.getUTCDate()).padStart(2, "0");
      const hour = String(time.getUTCHours()).padStart(2, "0");
      const minute = String(time.getUTCMinutes()).padStart(2, "0");
      const seconds = String(time.getUTCSeconds()).padStart(2, "0");
      const milliseconds = time.getUTCMilliseconds();
      const nanoseconds = milliseconds * 1e3 * 1e3;
      return `${year}-${month}-${day}T${hour}:${minute}:${seconds}.${nanoseconds}Z`;
    };
    module2.exports.parseRFC3339 = (time) => {
      const rfc3339Matcher = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z");
      const m = String(time).trim().match(rfc3339Matcher);
      if (!m) {
        throw new Error("Invalid format");
      }
      const year = parseInt(m[1], 10);
      const month = parseInt(m[2], 10) - 1;
      const date = parseInt(m[3], 10);
      const hour = parseInt(m[4], 10);
      const minute = parseInt(m[5], 10);
      const second = parseInt(m[6], 10);
      const millisecond = parseInt(m[7].slice(0, -6), 10);
      return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond));
    };
  }
});

// node_modules/libp2p-record/src/record/index.js
var require_record2 = __commonJS({
  "node_modules/libp2p-record/src/record/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var {
      Record: PBRecord
    } = require_record();
    var utils = require_utils5();
    var Record = class {
      constructor(key, value, timeReceived) {
        if (!(key instanceof Uint8Array)) {
          throw new Error("key must be a Uint8Array");
        }
        if (!(value instanceof Uint8Array)) {
          throw new Error("value must be a Uint8Array");
        }
        this.key = key;
        this.value = value;
        this.timeReceived = timeReceived;
      }
      serialize() {
        return PBRecord.encode(this.prepareSerialize()).finish();
      }
      prepareSerialize() {
        return {
          key: this.key,
          value: this.value,
          timeReceived: this.timeReceived && utils.toRFC3339(this.timeReceived)
        };
      }
      static deserialize(raw7) {
        const message = PBRecord.decode(raw7);
        return Record.fromDeserialized(PBRecord.toObject(message, {
          defaults: false,
          arrays: true,
          longs: Number,
          objects: false
        }));
      }
      static fromDeserialized(obj) {
        let recvtime;
        if (obj.timeReceived) {
          recvtime = utils.parseRFC3339(obj.timeReceived);
        }
        const rec = new Record(obj.key, obj.value, recvtime);
        return rec;
      }
    };
    module2.exports = Record;
  }
});

// node_modules/libp2p-record/src/validators/public-key.js
var require_public_key = __commonJS({
  "node_modules/libp2p-record/src/validators/public-key.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
    var errcode7 = require_err_code();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var validatePublicKeyRecord = async (key, publicKey) => {
      if (!(key instanceof Uint8Array)) {
        throw errcode7(new Error('"key" must be a Uint8Array'), "ERR_INVALID_RECORD_KEY_NOT_BUFFER");
      }
      if (key.byteLength < 5) {
        throw errcode7(new Error("invalid public key record"), "ERR_INVALID_RECORD_KEY_TOO_SHORT");
      }
      const prefix = uint8ArrayToString(key.subarray(0, 4));
      if (prefix !== "/pk/") {
        throw errcode7(new Error("key was not prefixed with /pk/"), "ERR_INVALID_RECORD_KEY_BAD_PREFIX");
      }
      const keyhash = key.slice(4);
      const publicKeyHash = await sha2562.digest(publicKey);
      if (!uint8ArrayEquals(keyhash, publicKeyHash.bytes)) {
        throw errcode7(new Error("public key does not match passed in key"), "ERR_INVALID_RECORD_HASH_MISMATCH");
      }
    };
    module2.exports = {
      func: validatePublicKeyRecord,
      sign: false
    };
  }
});

// node_modules/libp2p-record/src/validators/index.js
var require_validators = __commonJS({
  "node_modules/libp2p-record/src/validators/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {
      pk: require_public_key()
    };
  }
});

// node_modules/libp2p-record/src/validator.js
var require_validator = __commonJS({
  "node_modules/libp2p-record/src/validator.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var verifyRecord = (validators, record) => {
      const key = record.key;
      const keyString = uint8ArrayToString(key);
      const parts = keyString.split("/");
      if (parts.length < 3) {
        return;
      }
      const validator3 = validators[parts[1].toString()];
      if (!validator3) {
        const errMsg = "Invalid record keytype";
        throw errcode7(new Error(errMsg), "ERR_INVALID_RECORD_KEY_TYPE");
      }
      return validator3.func(key, record.value);
    };
    module2.exports = {
      verifyRecord,
      validators: require_validators()
    };
  }
});

// node_modules/libp2p-record/src/selectors/public-key.js
var require_public_key2 = __commonJS({
  "node_modules/libp2p-record/src/selectors/public-key.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var publicKeySelector = (k, records) => {
      return 0;
    };
    module2.exports = publicKeySelector;
  }
});

// node_modules/libp2p-record/src/selectors/index.js
var require_selectors = __commonJS({
  "node_modules/libp2p-record/src/selectors/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {
      pk: require_public_key2()
    };
  }
});

// node_modules/libp2p-record/src/selection.js
var require_selection = __commonJS({
  "node_modules/libp2p-record/src/selection.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var bestRecord = (selectors, k, records) => {
      if (records.length === 0) {
        const errMsg = "No records given";
        throw errcode7(new Error(errMsg), "ERR_NO_RECORDS_RECEIVED");
      }
      const kStr = uint8ArrayToString(k);
      const parts = kStr.split("/");
      if (parts.length < 3) {
        const errMsg = "Record key does not have a selector function";
        throw errcode7(new Error(errMsg), "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY");
      }
      const selector2 = selectors[parts[1].toString()];
      if (!selector2) {
        const errMsg = `Unrecognized key prefix: ${parts[1]}`;
        throw errcode7(new Error(errMsg), "ERR_UNRECOGNIZED_KEY_PREFIX");
      }
      if (records.length === 1) {
        return 0;
      }
      return selector2(k, records);
    };
    module2.exports = {
      bestRecord,
      selectors: require_selectors()
    };
  }
});

// node_modules/libp2p-record/src/index.js
var require_src8 = __commonJS({
  "node_modules/libp2p-record/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {
      Record: require_record2(),
      validator: require_validator(),
      selection: require_selection()
    };
  }
});

// node_modules/ipfs-core/cjs/src/ipns/routing/offline-datastore.js
var require_offline_datastore = __commonJS({
  "node_modules/ipfs-core/cjs/src/ipns/routing/offline-datastore.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var key = (init_key(), key_exports);
    var libp2pRecord = require_src8();
    var errCode32 = require_err_code();
    var debug17 = require_browser2();
    var toString4 = (init_to_string(), to_string_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = Object.assign(debug__default["default"]("ipfs:ipns:offline-datastore"), { error: debug__default["default"]("ipfs:ipns:offline-datastore:error") });
    var OfflineDatastore = class {
      constructor(repo) {
        this._repo = repo;
        this.stores = [];
      }
      async put(key2, value) {
        if (!(key2 instanceof Uint8Array)) {
          throw errCode__default["default"](new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
        }
        if (!(value instanceof Uint8Array)) {
          throw errCode__default["default"](new Error("Offline datastore value must be a Uint8Array"), "ERR_INVALID_VALUE");
        }
        let routingKey;
        try {
          routingKey = this._routingKey(key2);
        } catch (err) {
          log15.error(err);
          throw errCode__default["default"](new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
        }
        const record = new libp2pRecord.Record(key2, value);
        return this._repo.datastore.put(routingKey, record.serialize());
      }
      async get(key2) {
        if (!(key2 instanceof Uint8Array)) {
          throw errCode__default["default"](new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
        }
        let routingKey;
        try {
          routingKey = this._routingKey(key2);
        } catch (err) {
          log15.error(err);
          throw errCode__default["default"](new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
        }
        const res = await this._repo.datastore.get(routingKey);
        let record;
        try {
          record = libp2pRecord.Record.deserialize(res);
        } catch (err) {
          log15.error(err);
          throw err;
        }
        return record.value;
      }
      _routingKey(key$1) {
        return new key.Key("/" + toString4.toString(key$1, "base32upper"), false);
      }
    };
    exports2.OfflineDatastore = OfflineDatastore;
  }
});

// node_modules/ipfs-core/cjs/src/ipns/routing/config.js
var require_config = __commonJS({
  "node_modules/ipfs-core/cjs/src/ipns/routing/config.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var tiered = (init_tiered(), tiered_exports);
    var get2 = require_dlv_umd();
    var pubsubDatastore = require_pubsub_datastore();
    var offlineDatastore = require_offline_datastore();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var get__default = /* @__PURE__ */ _interopDefaultLegacy(get2);
    function createRouting({ libp2p, repo, peerId, options }) {
      const ipnsStores = [];
      let pubsubDs;
      if (get__default["default"](options, "EXPERIMENTAL.ipnsPubsub", false)) {
        const pubsub = libp2p.pubsub;
        const localDatastore = repo.datastore;
        pubsubDs = new pubsubDatastore.IpnsPubsubDatastore(pubsub, localDatastore, peerId);
        ipnsStores.push(pubsubDs);
      }
      if (get__default["default"](options, "offline") || !get__default["default"](options, "libp2p.config.dht.enabled", false)) {
        const offlineDatastore$1 = new offlineDatastore.OfflineDatastore(repo);
        ipnsStores.push(offlineDatastore$1);
      } else {
        ipnsStores.push(libp2p._dht);
      }
      return new tiered.TieredDatastore(ipnsStores);
    }
    exports2.createRouting = createRouting;
  }
});

// node_modules/ipfs-core/cjs/src/components/ipns.js
var require_ipns2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/ipns.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var index = require_ipns();
    var config2 = require_config();
    var offlineDatastore = require_offline_datastore();
    var errors2 = require_errors();
    var debug17 = require_browser2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = debug__default["default"]("ipfs:components:ipns");
    var IPNSAPI = class {
      constructor(options = { pass: "" }) {
        this.options = options;
        this.offline = null;
        this.online = null;
      }
      getIPNS() {
        const ipns2 = this.online || this.offline;
        if (ipns2) {
          return ipns2;
        } else {
          throw new errors2.NotInitializedError();
        }
      }
      get routing() {
        return this.getIPNS().routing;
      }
      startOffline({ repo, peerId, keychain }) {
        if (this.offline != null) {
          throw new errors2.AlreadyInitializedError();
        }
        log15("initializing IPNS keyspace");
        const routing = new offlineDatastore.OfflineDatastore(repo);
        const ipns2 = new index.IPNS(routing, repo.datastore, peerId, keychain, this.options);
        this.offline = ipns2;
      }
      async startOnline({ libp2p, repo, peerId, keychain }) {
        if (this.online != null) {
          throw new errors2.AlreadyInitializedError();
        }
        const routing = config2.createRouting({
          libp2p,
          repo,
          peerId,
          options: this.options
        });
        const ipns2 = new index.IPNS(routing, repo.datastore, peerId, keychain, this.options);
        await ipns2.republisher.start();
        this.online = ipns2;
      }
      async stop() {
        const ipns2 = this.online;
        if (ipns2) {
          await ipns2.republisher.stop();
          this.online = null;
        }
      }
      publish(privKey, value, lifetime) {
        return this.getIPNS().publish(privKey, value, lifetime);
      }
      resolve(name5, options) {
        return this.getIPNS().resolve(name5, options);
      }
      initializeKeyspace(privKey, value) {
        return this.getIPNS().initializeKeyspace(privKey, value);
      }
    };
    exports2.IPNSAPI = IPNSAPI;
  }
});

// node_modules/parse-duration/index.js
var require_parse_duration = __commonJS({
  "node_modules/parse-duration/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var durationRE2 = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([\p{L}]*)/uig;
    module2.exports = parse2;
    module2.exports.default = parse2;
    parse2.nanosecond = parse2.ns = 1 / 1e6;
    parse2["\xB5s"] = parse2["\u03BCs"] = parse2.us = parse2.microsecond = 1 / 1e3;
    parse2.millisecond = parse2.ms = parse2[""] = 1;
    parse2.second = parse2.sec = parse2.s = parse2.ms * 1e3;
    parse2.minute = parse2.min = parse2.m = parse2.s * 60;
    parse2.hour = parse2.hr = parse2.h = parse2.m * 60;
    parse2.day = parse2.d = parse2.h * 24;
    parse2.week = parse2.wk = parse2.w = parse2.d * 7;
    parse2.month = parse2.b = parse2.d * (365.25 / 12);
    parse2.year = parse2.yr = parse2.y = parse2.d * 365.25;
    function parse2(str = "", format = "ms") {
      var result = null;
      str = (str + "").replace(/(\d)[,_](\d)/g, "$1$2");
      str.replace(durationRE2, function(_, n, units) {
        units = unitRatio2(units);
        if (units)
          result = (result || 0) + parseFloat(n, 10) * units;
      });
      return result && result / (unitRatio2(format) || 1);
    }
    function unitRatio2(str) {
      return parse2[str] || parse2[str.toLowerCase().replace(/s$/, "")];
    }
  }
});

// node_modules/ipfs-core/cjs/src/components/name/utils.js
var require_utils6 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/name/utils.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var isIpfs = require_src3();
    var toCidAndPath2 = (init_to_cid_and_path(), to_cid_and_path_exports);
    var drain6 = require_it_drain();
    var utils = require_utils();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var isIpfs__default = /* @__PURE__ */ _interopDefaultLegacy(isIpfs);
    var drain__default = /* @__PURE__ */ _interopDefaultLegacy(drain6);
    async function resolvePath({ ipns: ipns2, repo, codecs: codecs2 }, name5, options) {
      if (isIpfs__default["default"].ipnsPath(name5)) {
        return ipns2.resolve(name5);
      }
      const { cid, path } = toCidAndPath2.toCidAndPath(name5);
      await drain__default["default"](utils.resolve(cid, path || "", codecs2, repo, options));
    }
    exports2.resolvePath = resolvePath;
  }
});

// node_modules/ipfs-core/cjs/src/components/name/publish.js
var require_publish = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/name/publish.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug17 = require_browser2();
    var parseDuration = require_parse_duration();
    var crypto3 = require_src7();
    var errCode32 = require_err_code();
    var fromString4 = (init_from_string(), from_string_exports);
    var toString4 = (init_to_string(), to_string_exports);
    var utils = require_utils();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var utils$1 = require_utils6();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var parseDuration__default = /* @__PURE__ */ _interopDefaultLegacy(parseDuration);
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto3);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var log15 = Object.assign(debug__default["default"]("ipfs:name:publish"), { error: debug__default["default"]("ipfs:name:publish:error") });
    function createPublish3({ ipns: ipns2, repo, codecs: codecs2, peerId, isOnline, keychain }) {
      const lookupKey = async (keyName) => {
        if (keyName === "self") {
          return peerId.privKey;
        }
        try {
          const pem = await keychain.exportKey(keyName, "temp");
          const privateKey = await crypto__default["default"].keys.import(pem, "temp");
          return privateKey;
        } catch (err) {
          log15.error(err);
          throw errCode__default["default"](err, "ERR_CANNOT_GET_KEY");
        }
      };
      async function publish(value, options = {}) {
        const resolve6 = !(options.resolve === false);
        const lifetime = options.lifetime || "24h";
        const key = options.key || "self";
        if (!isOnline()) {
          throw errCode__default["default"](new Error(utils.OFFLINE_ERROR), "OFFLINE_ERROR");
        }
        try {
          value = utils.normalizePath(value);
        } catch (err) {
          log15.error(err);
          throw err;
        }
        let pubLifetime = 0;
        try {
          pubLifetime = parseDuration__default["default"](lifetime) || 0;
          pubLifetime = parseFloat(pubLifetime.toFixed(6));
        } catch (err) {
          log15.error(err);
          throw err;
        }
        const results = await Promise.all([
          lookupKey(key),
          resolve6 ? utils$1.resolvePath({
            ipns: ipns2,
            repo,
            codecs: codecs2
          }, value) : Promise.resolve()
        ]);
        const bytes3 = fromString4.fromString(value);
        const result = await ipns2.publish(results[0], bytes3, pubLifetime);
        return {
          name: result.name,
          value: toString4.toString(result.value)
        };
      }
      return withTimeoutOption2.withTimeoutOption(publish);
    }
    exports2.createPublish = createPublish3;
  }
});

// node_modules/is-domain-name/index.js
var require_is_domain_name = __commonJS({
  "node_modules/is-domain-name/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var domainNameRegex = /^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;
    module2.exports = function isDomainName(domainName, rootDot) {
      if (rootDot == null)
        rootDot = false;
      if (domainName.length < 2)
        return false;
      if (domainName.length > 255)
        return false;
      var lastChar = domainName[domainName.length - 1];
      if (rootDot) {
        if (lastChar !== ".")
          return false;
      } else {
        if (lastChar === ".")
          return false;
      }
      return domainNameRegex.test(domainName);
    };
  }
});

// node_modules/ipfs-core/cjs/src/components/name/resolve.js
var require_resolve2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/name/resolve.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug17 = require_browser2();
    var errCode32 = require_err_code();
    var mergeOpts = require_merge_options();
    var cid = (init_cid(), cid_exports);
    var PeerId2 = require_src6();
    var isDomain = require_is_domain_name();
    var toString4 = (init_to_string(), to_string_exports);
    var utils = require_utils();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var PeerId__default = /* @__PURE__ */ _interopDefaultLegacy(PeerId2);
    var isDomain__default = /* @__PURE__ */ _interopDefaultLegacy(isDomain);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var log15 = Object.assign(debug__default["default"]("ipfs:name:resolve"), { error: debug__default["default"]("ipfs:name:resolve:error") });
    var appendRemainder = (result, remainder) => remainder.length > 0 ? result + "/" + remainder.join("/") : result;
    function createResolve4({
      dns,
      ipns: ipns2,
      peerId,
      isOnline,
      options: { offline }
    }) {
      async function* resolve6(name5, options = {}) {
        options = mergeOptions2({
          nocache: false,
          recursive: true
        }, options);
        if (offline && options && options.nocache) {
          throw errCode__default["default"](new Error("cannot specify both offline and nocache"), "ERR_NOCACHE_AND_OFFLINE");
        }
        if (!name5) {
          name5 = peerId.toB58String();
        }
        if (!name5.startsWith("/ipns/")) {
          name5 = `/ipns/${name5}`;
        }
        const [namespace3, hash2, ...remainder] = name5.slice(1).split("/");
        try {
          if (hash2.substring(0, 1) === "1") {
            PeerId__default["default"].parse(hash2);
          } else {
            cid.CID.parse(hash2);
          }
        } catch (err) {
          if (isDomain__default["default"](hash2)) {
            yield appendRemainder(await dns(hash2, options), remainder);
            return;
          }
          log15.error(err);
          throw errCode__default["default"](new Error("Invalid IPNS name"), "ERR_IPNS_INVALID_NAME");
        }
        if (!isOnline() && !offline) {
          throw errCode__default["default"](new Error(utils.OFFLINE_ERROR), "OFFLINE_ERROR");
        }
        const value = await ipns2.resolve(`/${namespace3}/${hash2}`, options);
        yield appendRemainder(value instanceof Uint8Array ? toString4.toString(value) : value, remainder);
      }
      return withTimeoutOption2.withTimeoutOption(resolve6);
    }
    exports2.createResolve = createResolve4;
  }
});

// node_modules/ipfs-core/cjs/src/components/name/pubsub/utils.js
var require_utils7 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/name/pubsub/utils.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var pubsubDatastore = require_pubsub_datastore();
    var errCode32 = require_err_code();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    function getPubsubRouting(ipns2, options) {
      if (!ipns2 || !(options && options.ipnsPubsub)) {
        throw errCode__default["default"](new Error("IPNS pubsub subsystem is not enabled"), "ERR_IPNS_PUBSUB_NOT_ENABLED");
      }
      if (ipns2.routing instanceof pubsubDatastore.IpnsPubsubDatastore) {
        return ipns2.routing;
      }
      const pubsub = (ipns2.routing.stores || []).find((s) => s instanceof pubsubDatastore.IpnsPubsubDatastore);
      if (!pubsub) {
        throw errCode__default["default"](new Error("IPNS pubsub datastore not found"), "ERR_PUBSUB_DATASTORE_NOT_FOUND");
      }
      return pubsub;
    }
    exports2.getPubsubRouting = getPubsubRouting;
  }
});

// node_modules/ipfs-core/cjs/src/components/name/pubsub/cancel.js
var require_cancel = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/name/pubsub/cancel.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils7();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createCancel2({ ipns: ipns2, options }) {
      const experimental = options.EXPERIMENTAL;
      async function cancel(name5, options2 = {}) {
        const pubsub = utils.getPubsubRouting(ipns2, experimental);
        return pubsub.cancel(name5, options2);
      }
      return withTimeoutOption2.withTimeoutOption(cancel);
    }
    exports2.createCancel = createCancel2;
  }
});

// node_modules/ipfs-core/cjs/src/components/name/pubsub/state.js
var require_state = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/name/pubsub/state.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils7();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createState2({ ipns: ipns2, options }) {
      const experimental = options.EXPERIMENTAL;
      async function state(_options = {}) {
        try {
          return { enabled: Boolean(utils.getPubsubRouting(ipns2, experimental)) };
        } catch (err) {
          return { enabled: false };
        }
      }
      return withTimeoutOption2.withTimeoutOption(state);
    }
    exports2.createState = createState2;
  }
});

// node_modules/ipfs-core/cjs/src/components/name/pubsub/subs.js
var require_subs = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/name/pubsub/subs.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils7();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createSubs2({ ipns: ipns2, options }) {
      const experimental = options.EXPERIMENTAL;
      async function subs(options2 = {}) {
        const pubsub = utils.getPubsubRouting(ipns2, experimental);
        return pubsub.getSubscriptions(options2);
      }
      return withTimeoutOption2.withTimeoutOption(subs);
    }
    exports2.createSubs = createSubs2;
  }
});

// node_modules/ipfs-core/cjs/src/components/name/pubsub/index.js
var require_pubsub = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/name/pubsub/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cancel = require_cancel();
    var state = require_state();
    var subs = require_subs();
    var PubSubAPI = class {
      constructor({ ipns: ipns2, options }) {
        this.cancel = cancel.createCancel({
          ipns: ipns2,
          options
        });
        this.state = state.createState({
          ipns: ipns2,
          options
        });
        this.subs = subs.createSubs({
          ipns: ipns2,
          options
        });
      }
    };
    exports2.PubSubAPI = PubSubAPI;
  }
});

// node_modules/ipfs-core/cjs/src/components/name/index.js
var require_name = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/name/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var publish = require_publish();
    var resolve6 = require_resolve2();
    var index = require_pubsub();
    var NameAPI = class {
      constructor({ dns, ipns: ipns2, repo, codecs: codecs2, peerId, isOnline, keychain, options }) {
        this.publish = publish.createPublish({
          ipns: ipns2,
          repo,
          codecs: codecs2,
          peerId,
          isOnline,
          keychain
        });
        this.resolve = resolve6.createResolve({
          dns,
          ipns: ipns2,
          peerId,
          isOnline,
          options
        });
        this.pubsub = new index.PubSubAPI({
          ipns: ipns2,
          options
        });
      }
    };
    exports2.NameAPI = NameAPI;
  }
});

// node_modules/ipfs-core/cjs/src/components/refs/index.js
var require_refs = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/refs/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dagPB = (init_src2(), src_exports2);
    var Errors8 = (init_errors2(), errors_exports);
    var toCidAndPath2 = (init_to_cid_and_path(), to_cid_and_path_exports);
    var cid = (init_cid(), cid_exports);
    var TimeoutController2 = require_timeout_abort_controller();
    var anySignal4 = require_any_signal();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var TimeoutController__default = /* @__PURE__ */ _interopDefaultLegacy(TimeoutController2);
    var ERR_NOT_FOUND2 = Errors8.notFoundError().code;
    var Format = {
      default: "<dst>",
      edges: "<src> -> <dst>"
    };
    function createRefs2({ repo, codecs: codecs2, resolve: resolve6, preload: preload2 }) {
      async function* refs(ipfsPath2, options = {}) {
        if (options.maxDepth === 0) {
          return;
        }
        if (options.edges && options.format && options.format !== Format.default) {
          throw new Error("Cannot set edges to true and also specify format");
        }
        options.format = options.edges ? Format.edges : options.format;
        if (typeof options.maxDepth !== "number") {
          options.maxDepth = options.recursive ? Infinity : 1;
        }
        if (options.timeout) {
          const controller = new TimeoutController__default["default"](options.timeout);
          options.signal = anySignal4.anySignal([
            options.signal,
            controller.signal
          ]);
        }
        const rawPaths = Array.isArray(ipfsPath2) ? ipfsPath2 : [ipfsPath2];
        const paths = rawPaths.map((p) => getFullPath(preload2, p, options));
        for (const path of paths) {
          try {
            yield* refsStream(resolve6, repo, codecs2, path, options);
          } catch (err) {
            yield {
              ref: "",
              err: err.message
            };
          }
        }
      }
      return refs;
    }
    function getFullPath(preload2, ipfsPath2, options) {
      const { cid: cid2, path } = toCidAndPath2.toCidAndPath(ipfsPath2);
      if (options.preload !== false) {
        preload2(cid2);
      }
      return `/ipfs/${cid2}${path || ""}`;
    }
    async function* refsStream(resolve6, repo, codecs2, path, options) {
      const resPath = await resolve6(path, options);
      const { cid: cid2 } = toCidAndPath2.toCidAndPath(resPath);
      const maxDepth = options.maxDepth != null ? options.maxDepth : Infinity;
      const unique = options.unique || false;
      for await (const obj of objectStream(repo, codecs2, cid2, maxDepth, unique, options)) {
        if (!obj.parent) {
          continue;
        }
        if (obj.isDuplicate) {
          continue;
        }
        yield { ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format) };
      }
    }
    function formatLink(srcCid, dstCid, linkName = "", format = Format.default) {
      let out = format.replace(/<src>/g, srcCid.toString());
      out = out.replace(/<dst>/g, dstCid.toString());
      out = out.replace(/<linkname>/g, linkName);
      return out;
    }
    async function* objectStream(repo, codecs2, rootCid, maxDepth, uniqueOnly, options) {
      const seen = new Set();
      async function* traverseLevel(parent2, depth) {
        const nextLevelDepth = depth + 1;
        if (nextLevelDepth > maxDepth) {
          return;
        }
        try {
          for await (const link of getLinks(repo, codecs2, parent2.cid, options)) {
            yield {
              parent: parent2,
              node: link,
              isDuplicate: uniqueOnly && seen.has(link.cid.toString())
            };
            if (uniqueOnly) {
              seen.add(link.cid.toString());
            }
            yield* traverseLevel(link, nextLevelDepth);
          }
        } catch (err) {
          if (err.code === ERR_NOT_FOUND2) {
            err.message = `Could not find object with CID: ${parent2.cid}`;
          }
          throw err;
        }
      }
      yield* traverseLevel({ cid: rootCid }, 0);
    }
    async function* getLinks(repo, codecs2, cid2, options) {
      const block = await repo.blocks.get(cid2, options);
      const codec = await codecs2.getCodec(cid2.code);
      const value = codec.decode(block);
      const isDagPb = cid2.code === dagPB__namespace.code;
      const base3 = [];
      for (const [name5, cid3] of links2(value, base3)) {
        if (isDagPb) {
          const match = name5.match(/^Links\/(\d+)\/Hash$/);
          if (match) {
            const index = Number(match[1]);
            if (index < value.Links.length) {
              yield {
                name: value.Links[index].Name,
                cid: cid3
              };
              continue;
            }
          }
        }
        yield {
          name: name5,
          cid: cid3
        };
      }
    }
    var links2 = function* (source, base3) {
      if (source == null) {
        return;
      }
      if (source instanceof Uint8Array) {
        return;
      }
      for (const [key, value] of Object.entries(source)) {
        const path = [
          ...base3,
          key
        ];
        if (value != null && typeof value === "object") {
          if (Array.isArray(value)) {
            for (const [index, element] of value.entries()) {
              const elementPath = [
                ...path,
                index
              ];
              const cid$1 = cid.CID.asCID(element);
              if (cid$1) {
                yield [
                  elementPath.join("/"),
                  cid$1
                ];
              } else if (typeof element === "object") {
                yield* links2(element, elementPath);
              }
            }
          } else {
            const cid$1 = cid.CID.asCID(value);
            if (cid$1) {
              yield [
                path.join("/"),
                cid$1
              ];
            } else {
              yield* links2(value, path);
            }
          }
        }
      }
      return [];
    };
    exports2.Format = Format;
    exports2.createRefs = createRefs2;
  }
});

// node_modules/ipfs-core/cjs/src/components/refs/local.js
var require_local = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/refs/local.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createLocal2({ repo }) {
      async function* refsLocal(options = {}) {
        for await (const cid of repo.blocks.queryKeys({}, { signal: options.signal })) {
          yield { ref: cid.toString() };
        }
      }
      return withTimeoutOption2.withTimeoutOption(refsLocal);
    }
    exports2.createLocal = createLocal2;
  }
});

// node_modules/ipfs-core/cjs/src/components/bitswap/wantlist.js
var require_wantlist = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bitswap/wantlist.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createWantlist2({ network }) {
      async function wantlist(options = {}) {
        const { bitswap } = await network.use(options);
        const list = bitswap.getWantlist();
        return Array.from(list).map((e) => e[1].cid);
      }
      return withTimeoutOption2.withTimeoutOption(wantlist);
    }
    exports2.createWantlist = createWantlist2;
  }
});

// node_modules/ipfs-core/cjs/src/components/bitswap/wantlist-for-peer.js
var require_wantlist_for_peer = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bitswap/wantlist-for-peer.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PeerId2 = require_src6();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var PeerId__default = /* @__PURE__ */ _interopDefaultLegacy(PeerId2);
    function createWantlistForPeer2({ network }) {
      async function wantlistForPeer(peerId, options = {}) {
        const { bitswap } = await network.use(options);
        const list = bitswap.wantlistForPeer(PeerId__default["default"].createFromB58String(peerId));
        return Array.from(list).map((e) => e[1].cid);
      }
      return withTimeoutOption2.withTimeoutOption(wantlistForPeer);
    }
    exports2.createWantlistForPeer = createWantlistForPeer2;
  }
});

// node_modules/ipfs-core/cjs/src/components/bitswap/unwant.js
var require_unwant = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bitswap/unwant.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createUnwant2({ network }) {
      async function unwant(cids, options = {}) {
        const { bitswap } = await network.use(options);
        if (!Array.isArray(cids)) {
          cids = [cids];
        }
        return bitswap.unwant(cids);
      }
      return withTimeoutOption2.withTimeoutOption(unwant);
    }
    exports2.createUnwant = createUnwant2;
  }
});

// node_modules/ipfs-core/cjs/src/components/bitswap/stat.js
var require_stat = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bitswap/stat.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createStat6({ network }) {
      async function stat(options = {}) {
        const bitswap = (await network.use(options)).bitswap;
        const snapshot = bitswap.stat().snapshot;
        return {
          provideBufLen: parseInt(snapshot.providesBufferLength.toString()),
          blocksReceived: BigInt(snapshot.blocksReceived.toString()),
          wantlist: Array.from(bitswap.getWantlist()).map((e) => e[1].cid),
          peers: bitswap.peers().map((id) => id.toB58String()),
          dupBlksReceived: BigInt(snapshot.dupBlksReceived.toString()),
          dupDataReceived: BigInt(snapshot.dupDataReceived.toString()),
          dataReceived: BigInt(snapshot.dataReceived.toString()),
          blocksSent: BigInt(snapshot.blocksSent.toString()),
          dataSent: BigInt(snapshot.dataSent.toString())
        };
      }
      return withTimeoutOption2.withTimeoutOption(stat);
    }
    exports2.createStat = createStat6;
  }
});

// node_modules/ipfs-core/cjs/src/components/bitswap/index.js
var require_bitswap = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bitswap/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var wantlist = require_wantlist();
    var wantlistForPeer = require_wantlist_for_peer();
    var unwant = require_unwant();
    var stat = require_stat();
    var BitswapAPI = class {
      constructor({ network }) {
        this.wantlist = wantlist.createWantlist({ network });
        this.wantlistForPeer = wantlistForPeer.createWantlistForPeer({ network });
        this.unwant = unwant.createUnwant({ network });
        this.stat = stat.createStat({ network });
      }
    };
    exports2.BitswapAPI = BitswapAPI;
  }
});

// node_modules/ipfs-core/cjs/src/components/bootstrap/utils.js
var require_utils8 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bootstrap/utils.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var mafmt = require_src2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var mafmt__default = /* @__PURE__ */ _interopDefaultLegacy(mafmt);
    function isValidMultiaddr(ma) {
      try {
        return mafmt__default["default"].IPFS.matches(ma);
      } catch (err) {
        return false;
      }
    }
    exports2.isValidMultiaddr = isValidMultiaddr;
  }
});

// node_modules/ipfs-core/cjs/src/components/bootstrap/add.js
var require_add2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bootstrap/add.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils8();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createAdd6({ repo }) {
      async function add(multiaddr, options = {}) {
        if (!utils.isValidMultiaddr(multiaddr)) {
          throw new Error(`${multiaddr} is not a valid Multiaddr`);
        }
        const config2 = await repo.config.getAll(options);
        const boostrappers = config2.Bootstrap || [];
        boostrappers.push(multiaddr.toString());
        config2.Bootstrap = Array.from(new Set(boostrappers)).sort((a, b) => a.localeCompare(b));
        await repo.config.replace(config2);
        return { Peers: [multiaddr] };
      }
      return withTimeoutOption2.withTimeoutOption(add);
    }
    exports2.createAdd = createAdd6;
  }
});

// node_modules/ipfs-core/cjs/src/components/bootstrap/clear.js
var require_clear = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bootstrap/clear.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var multiaddr = require_src();
    function createClear2({ repo }) {
      async function clear(options = {}) {
        const config2 = await repo.config.getAll(options);
        const removed = config2.Bootstrap || [];
        config2.Bootstrap = [];
        await repo.config.replace(config2);
        return { Peers: removed.map((ma) => new multiaddr.Multiaddr(ma)) };
      }
      return withTimeoutOption2.withTimeoutOption(clear);
    }
    exports2.createClear = createClear2;
  }
});

// node_modules/ipfs-core/cjs/src/components/bootstrap/list.js
var require_list = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bootstrap/list.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var multiaddr = require_src();
    function createList4({ repo }) {
      async function list(options = {}) {
        const peers = await repo.config.get("Bootstrap", options);
        return { Peers: (peers || []).map((ma) => new multiaddr.Multiaddr(ma)) };
      }
      return withTimeoutOption2.withTimeoutOption(list);
    }
    exports2.createList = createList4;
  }
});

// node_modules/ipfs-core-config/esm/src/config.browser.js
var config_browser_exports = {};
__export(config_browser_exports, {
  default: () => config_browser_default
});
var config_browser_default;
var init_config_browser = __esm({
  "node_modules/ipfs-core-config/esm/src/config.browser.js"() {
    init_node_globals();
    config_browser_default = () => ({
      Addresses: {
        Swarm: [],
        Announce: [],
        NoAnnounce: [],
        API: "",
        Gateway: "",
        RPC: "",
        Delegates: [
          "/dns4/node0.delegate.ipfs.io/tcp/443/https",
          "/dns4/node1.delegate.ipfs.io/tcp/443/https",
          "/dns4/node2.delegate.ipfs.io/tcp/443/https",
          "/dns4/node3.delegate.ipfs.io/tcp/443/https"
        ]
      },
      Discovery: {
        MDNS: {
          Enabled: false,
          Interval: 10
        },
        webRTCStar: { Enabled: true }
      },
      Bootstrap: [
        "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
        "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
        "/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp",
        "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa",
        "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
        "/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic",
        "/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6",
        "/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS",
        "/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"
      ],
      Pubsub: { Enabled: true },
      Swarm: {
        ConnMgr: {
          LowWater: 200,
          HighWater: 500
        },
        DisableNatPortMap: true
      },
      Routing: { Type: "none" }
    });
  }
});

// node_modules/ipfs-core/cjs/src/components/bootstrap/reset.js
var require_reset = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bootstrap/reset.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var getDefaultConfig = (init_config_browser(), config_browser_exports);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var multiaddr = require_src();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var getDefaultConfig__default = /* @__PURE__ */ _interopDefaultLegacy(getDefaultConfig);
    function createReset2({ repo }) {
      async function reset(options = {}) {
        const config2 = await repo.config.getAll(options);
        config2.Bootstrap = getDefaultConfig__default["default"]().Bootstrap;
        await repo.config.replace(config2);
        return { Peers: getDefaultConfig__default["default"]().Bootstrap.map((ma) => new multiaddr.Multiaddr(ma)) };
      }
      return withTimeoutOption2.withTimeoutOption(reset);
    }
    exports2.createReset = createReset2;
  }
});

// node_modules/ipfs-core/cjs/src/components/bootstrap/rm.js
var require_rm2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bootstrap/rm.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils8();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createRm8({ repo }) {
      async function rm(multiaddr, options = {}) {
        if (!utils.isValidMultiaddr(multiaddr)) {
          throw new Error(`${multiaddr} is not a valid Multiaddr`);
        }
        const config2 = await repo.config.getAll(options);
        config2.Bootstrap = (config2.Bootstrap || []).filter((ma) => ma.toString() !== multiaddr.toString());
        await repo.config.replace(config2);
        return { Peers: [multiaddr] };
      }
      return withTimeoutOption2.withTimeoutOption(rm);
    }
    exports2.createRm = createRm8;
  }
});

// node_modules/ipfs-core/cjs/src/components/bootstrap/index.js
var require_bootstrap = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/bootstrap/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var add = require_add2();
    var clear = require_clear();
    var list = require_list();
    var reset = require_reset();
    var rm = require_rm2();
    var BootstrapAPI = class {
      constructor({ repo }) {
        this.add = add.createAdd({ repo });
        this.list = list.createList({ repo });
        this.rm = rm.createRm({ repo });
        this.clear = clear.createClear({ repo });
        this.reset = reset.createReset({ repo });
      }
    };
    exports2.BootstrapAPI = BootstrapAPI;
  }
});

// node_modules/ipfs-core/cjs/src/components/block/get.js
var require_get = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/block/get.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createGet7({ preload: preload2, repo }) {
      async function get2(cid, options = {}) {
        if (options.preload !== false) {
          preload2(cid);
        }
        return repo.blocks.get(cid, options);
      }
      return withTimeoutOption2.withTimeoutOption(get2);
    }
    exports2.createGet = createGet7;
  }
});

// node_modules/ipfs-core/cjs/src/components/block/put.js
var require_put = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/block/put.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cid = (init_cid(), cid_exports);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createPut5({ codecs: codecs2, hashers, repo, preload: preload2 }) {
      async function put(block, options = {}) {
        const release = options.pin ? await repo.gcLock.readLock() : null;
        try {
          const cidVersion = options.version != null ? options.version : 0;
          const codecName = options.format || (cidVersion === 0 ? "dag-pb" : "raw");
          const hasher = await hashers.getHasher(options.mhtype || "sha2-256");
          const hash2 = await hasher.digest(block);
          const codec = await codecs2.getCodec(codecName);
          const cid$1 = cid.CID.create(cidVersion, codec.code, hash2);
          await repo.blocks.put(cid$1, block, { signal: options.signal });
          if (options.preload !== false) {
            preload2(cid$1);
          }
          if (options.pin === true) {
            await repo.pins.pinRecursively(cid$1, { signal: options.signal });
          }
          return cid$1;
        } finally {
          if (release) {
            release();
          }
        }
      }
      return withTimeoutOption2.withTimeoutOption(put);
    }
    exports2.createPut = createPut5;
  }
});

// node_modules/p-defer/index.js
var require_p_defer = __commonJS({
  "node_modules/p-defer/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var pDefer = () => {
      const deferred = {};
      deferred.promise = new Promise((resolve6, reject) => {
        deferred.resolve = resolve6;
        deferred.reject = reject;
      });
      return deferred;
    };
    module2.exports = pDefer;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter4() {
      EventEmitter4.init.call(this);
    }
    module2.exports = EventEmitter4;
    module2.exports.once = once;
    EventEmitter4.EventEmitter = EventEmitter4;
    EventEmitter4.prototype._events = void 0;
    EventEmitter4.prototype._eventsCount = 0;
    EventEmitter4.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter4, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter4.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter4.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter4.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter4.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter4.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit("newListener", type, listener.listener ? listener.listener : listener);
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter4.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter4.prototype.on = EventEmitter4.prototype.addListener;
    EventEmitter4.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter4.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter4.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter4.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter4.prototype.off = EventEmitter4.prototype.removeListener;
    EventEmitter4.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap3) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap3 ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap3 ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter4.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter4.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter4.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter4.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter4.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name5) {
      return new Promise(function(resolve6, reject) {
        function errorListener(err) {
          emitter.removeListener(name5, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve6([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name5, resolver, { once: true });
        if (name5 !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name5, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name5, listener);
        } else {
          emitter.on(name5, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name5, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name5, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/it-parallel/index.js
var require_it_parallel = __commonJS({
  "node_modules/it-parallel/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var defer = require_p_defer();
    var EventEmitter4 = require_events().EventEmitter;
    async function* parallel(source, concurrency = 1) {
      if (concurrency < 1) {
        concurrency = 1;
      }
      const emitter = new EventEmitter4();
      const ops = [];
      let slotAvailable = defer();
      let sourceFinished = false;
      let resultAvailable = defer();
      emitter.on("task-complete", () => {
        resultAvailable.resolve();
        resultAvailable = defer();
      });
      Promise.resolve().then(async () => {
        try {
          for await (const task of source) {
            if (ops.length === concurrency) {
              await slotAvailable.promise;
            }
            const op = {
              done: false
            };
            ops.push(op);
            task().then((result) => {
              op.done = true;
              op.ok = true;
              op.value = result;
              emitter.emit("task-complete");
            }, (err) => {
              op.done = true;
              op.err = err;
              emitter.emit("task-complete");
            });
          }
          sourceFinished = true;
        } catch (err) {
          emitter.emit("task-complete");
        }
      });
      while (true) {
        await resultAvailable.promise;
        while (ops.length && ops[0].done) {
          const op = ops[0];
          ops.shift();
          if (op.ok) {
            yield op.value;
          } else {
            throw op.err;
          }
          slotAvailable.resolve();
          slotAvailable = defer();
        }
        if (sourceFinished && ops.length === 0) {
          break;
        }
      }
    }
    module2.exports = parallel;
  }
});

// node_modules/ipfs-core/cjs/src/components/block/utils.js
var require_utils9 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/block/utils.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cid = (init_cid(), cid_exports);
    function cleanCid(cid$1) {
      if (cid$1 instanceof Uint8Array) {
        return cid.CID.decode(cid$1);
      }
      return cid.CID.parse(cid$1.toString());
    }
    exports2.cleanCid = cleanCid;
  }
});

// node_modules/ipfs-core/cjs/src/components/block/rm.js
var require_rm3 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/block/rm.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errCode32 = require_err_code();
    var parallel = require_it_parallel();
    var map8 = require_it_map();
    var filter8 = require_it_filter();
    var itPipe = require_it_pipe();
    var utils = require_utils9();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var parallel__default = /* @__PURE__ */ _interopDefaultLegacy(parallel);
    var map__default = /* @__PURE__ */ _interopDefaultLegacy(map8);
    var filter__default = /* @__PURE__ */ _interopDefaultLegacy(filter8);
    var BLOCK_RM_CONCURRENCY2 = 8;
    function createRm8({ repo }) {
      async function* rm(cids, options = {}) {
        if (!Array.isArray(cids)) {
          cids = [cids];
        }
        const release = await repo.gcLock.writeLock();
        try {
          yield* itPipe.pipe(cids, (source) => map__default["default"](source, (cid) => {
            return async () => {
              cid = utils.cleanCid(cid);
              const result = { cid };
              try {
                const has = await repo.blocks.has(cid);
                if (!has) {
                  throw errCode__default["default"](new Error("block not found"), "ERR_BLOCK_NOT_FOUND");
                }
                await repo.blocks.delete(cid);
              } catch (err) {
                if (!options.force) {
                  err.message = `cannot remove ${cid}: ${err.message}`;
                  result.error = err;
                }
              }
              return result;
            };
          }), (source) => parallel__default["default"](source, BLOCK_RM_CONCURRENCY2), (source) => filter__default["default"](source, () => !options.quiet));
        } finally {
          release();
        }
      }
      return withTimeoutOption2.withTimeoutOption(rm);
    }
    exports2.createRm = createRm8;
  }
});

// node_modules/ipfs-core/cjs/src/components/block/stat.js
var require_stat2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/block/stat.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var utils = require_utils9();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createStat6({ repo, preload: preload2 }) {
      async function stat(cid, options = {}) {
        cid = utils.cleanCid(cid);
        if (options.preload !== false) {
          preload2(cid);
        }
        const block = await repo.blocks.get(cid);
        return {
          cid,
          size: block.length
        };
      }
      return withTimeoutOption2.withTimeoutOption(stat);
    }
    exports2.createStat = createStat6;
  }
});

// node_modules/ipfs-core/cjs/src/components/block/index.js
var require_block = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/block/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var get2 = require_get();
    var put = require_put();
    var rm = require_rm3();
    var stat = require_stat2();
    var BlockAPI = class {
      constructor({ codecs: codecs2, hashers, preload: preload2, repo }) {
        this.get = get2.createGet({
          preload: preload2,
          repo
        });
        this.put = put.createPut({
          codecs: codecs2,
          hashers,
          preload: preload2,
          repo
        });
        this.rm = rm.createRm({ repo });
        this.stat = stat.createStat({
          preload: preload2,
          repo
        });
      }
    };
    exports2.BlockAPI = BlockAPI;
  }
});

// node_modules/ipfs-core/cjs/src/components/add.js
var require_add3 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/add.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var last6 = require_it_last();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var last__default = /* @__PURE__ */ _interopDefaultLegacy(last6);
    function createAdd6({ addAll }) {
      async function add(entry, options = {}) {
        const result = await last__default["default"](addAll(entry, options));
        if (result == null) {
          throw Error("Failed to add a file, if you see this please report a bug");
        }
        return result;
      }
      return add;
    }
    exports2.createAdd = createAdd6;
  }
});

// node_modules/it-batch/index.js
var require_it_batch = __commonJS({
  "node_modules/it-batch/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    async function* batch3(source, size = 1) {
      let things = [];
      if (size < 1) {
        size = 1;
      }
      for await (const thing of source) {
        things.push(thing);
        while (things.length >= size) {
          yield things.slice(0, size);
          things = things.slice(size);
        }
      }
      while (things.length) {
        yield things.slice(0, size);
        things = things.slice(size);
      }
    }
    module2.exports = batch3;
  }
});

// node_modules/it-parallel-batch/index.js
var require_it_parallel_batch = __commonJS({
  "node_modules/it-parallel-batch/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var batch3 = require_it_batch();
    async function* parallelBatch4(source, size = 1) {
      for await (const tasks of batch3(source, size)) {
        const things = tasks.map((p) => {
          return p().then((value) => ({ ok: true, value }), (err) => ({ ok: false, err }));
        });
        for (let i = 0; i < things.length; i++) {
          const result = await things[i];
          if (result.ok) {
            yield result.value;
          } else {
            throw result.err;
          }
        }
      }
    }
    module2.exports = parallelBatch4;
  }
});

// node_modules/merge-options/index.mjs
var import_index2, merge_options_default;
var init_merge_options = __esm({
  "node_modules/merge-options/index.mjs"() {
    init_node_globals();
    import_index2 = __toModule(require_merge_options());
    merge_options_default = import_index2.default;
  }
});

// node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS({
  "node_modules/murmurhash3js-revisited/lib/murmurHash3js.js"(exports2, module2) {
    init_node_globals();
    (function(root, undefined2) {
      "use strict";
      var library = {
        "version": "3.0.0",
        "x86": {},
        "x64": {},
        "inputValidation": true
      };
      function _validBytes(bytes3) {
        if (!Array.isArray(bytes3) && !ArrayBuffer.isView(bytes3)) {
          return false;
        }
        for (var i = 0; i < bytes3.length; i++) {
          if (!Number.isInteger(bytes3[i]) || bytes3[i] < 0 || bytes3[i] > 255) {
            return false;
          }
        }
        return true;
      }
      function _x86Multiply(m, n) {
        return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
      }
      function _x86Rotl(m, n) {
        return m << n | m >>> 32 - n;
      }
      function _x86Fmix(h) {
        h ^= h >>> 16;
        h = _x86Multiply(h, 2246822507);
        h ^= h >>> 13;
        h = _x86Multiply(h, 3266489909);
        h ^= h >>> 16;
        return h;
      }
      function _x64Add(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] + n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] + n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] + n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] + n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Multiply(m, n) {
        m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
        n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
        var o = [0, 0, 0, 0];
        o[3] += m[3] * n[3];
        o[2] += o[3] >>> 16;
        o[3] &= 65535;
        o[2] += m[2] * n[3];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[2] += m[3] * n[2];
        o[1] += o[2] >>> 16;
        o[2] &= 65535;
        o[1] += m[1] * n[3];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[2] * n[2];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[1] += m[3] * n[1];
        o[0] += o[1] >>> 16;
        o[1] &= 65535;
        o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
        o[0] &= 65535;
        return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
      }
      function _x64Rotl(m, n) {
        n %= 64;
        if (n === 32) {
          return [m[1], m[0]];
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
        } else {
          n -= 32;
          return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
        }
      }
      function _x64LeftShift(m, n) {
        n %= 64;
        if (n === 0) {
          return m;
        } else if (n < 32) {
          return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
        } else {
          return [m[1] << n - 32, 0];
        }
      }
      function _x64Xor(m, n) {
        return [m[0] ^ n[0], m[1] ^ n[1]];
      }
      function _x64Fmix(h) {
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [4283543511, 3981806797]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        h = _x64Multiply(h, [3301882366, 444984403]);
        h = _x64Xor(h, [0, h[0] >>> 1]);
        return h;
      }
      library.x86.hash32 = function(bytes3, seed) {
        if (library.inputValidation && !_validBytes(bytes3)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes3.length % 4;
        var blocks = bytes3.length - remainder;
        var h1 = seed;
        var k1 = 0;
        var c1 = 3432918353;
        var c2 = 461845907;
        for (var i = 0; i < blocks; i = i + 4) {
          k1 = bytes3[i] | bytes3[i + 1] << 8 | bytes3[i + 2] << 16 | bytes3[i + 3] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 13);
          h1 = _x86Multiply(h1, 5) + 3864292196;
        }
        k1 = 0;
        switch (remainder) {
          case 3:
            k1 ^= bytes3[i + 2] << 16;
          case 2:
            k1 ^= bytes3[i + 1] << 8;
          case 1:
            k1 ^= bytes3[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes3.length;
        h1 = _x86Fmix(h1);
        return h1 >>> 0;
      };
      library.x86.hash128 = function(bytes3, seed) {
        if (library.inputValidation && !_validBytes(bytes3)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes3.length % 16;
        var blocks = bytes3.length - remainder;
        var h1 = seed;
        var h2 = seed;
        var h3 = seed;
        var h4 = seed;
        var k1 = 0;
        var k2 = 0;
        var k3 = 0;
        var k4 = 0;
        var c1 = 597399067;
        var c2 = 2869860233;
        var c3 = 951274213;
        var c4 = 2716044179;
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = bytes3[i] | bytes3[i + 1] << 8 | bytes3[i + 2] << 16 | bytes3[i + 3] << 24;
          k2 = bytes3[i + 4] | bytes3[i + 5] << 8 | bytes3[i + 6] << 16 | bytes3[i + 7] << 24;
          k3 = bytes3[i + 8] | bytes3[i + 9] << 8 | bytes3[i + 10] << 16 | bytes3[i + 11] << 24;
          k4 = bytes3[i + 12] | bytes3[i + 13] << 8 | bytes3[i + 14] << 16 | bytes3[i + 15] << 24;
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
          h1 = _x86Rotl(h1, 19);
          h1 += h2;
          h1 = _x86Multiply(h1, 5) + 1444728091;
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
          h2 = _x86Rotl(h2, 17);
          h2 += h3;
          h2 = _x86Multiply(h2, 5) + 197830471;
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
          h3 = _x86Rotl(h3, 15);
          h3 += h4;
          h3 = _x86Multiply(h3, 5) + 2530024501;
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
          h4 = _x86Rotl(h4, 13);
          h4 += h1;
          h4 = _x86Multiply(h4, 5) + 850148119;
        }
        k1 = 0;
        k2 = 0;
        k3 = 0;
        k4 = 0;
        switch (remainder) {
          case 15:
            k4 ^= bytes3[i + 14] << 16;
          case 14:
            k4 ^= bytes3[i + 13] << 8;
          case 13:
            k4 ^= bytes3[i + 12];
            k4 = _x86Multiply(k4, c4);
            k4 = _x86Rotl(k4, 18);
            k4 = _x86Multiply(k4, c1);
            h4 ^= k4;
          case 12:
            k3 ^= bytes3[i + 11] << 24;
          case 11:
            k3 ^= bytes3[i + 10] << 16;
          case 10:
            k3 ^= bytes3[i + 9] << 8;
          case 9:
            k3 ^= bytes3[i + 8];
            k3 = _x86Multiply(k3, c3);
            k3 = _x86Rotl(k3, 17);
            k3 = _x86Multiply(k3, c4);
            h3 ^= k3;
          case 8:
            k2 ^= bytes3[i + 7] << 24;
          case 7:
            k2 ^= bytes3[i + 6] << 16;
          case 6:
            k2 ^= bytes3[i + 5] << 8;
          case 5:
            k2 ^= bytes3[i + 4];
            k2 = _x86Multiply(k2, c2);
            k2 = _x86Rotl(k2, 16);
            k2 = _x86Multiply(k2, c3);
            h2 ^= k2;
          case 4:
            k1 ^= bytes3[i + 3] << 24;
          case 3:
            k1 ^= bytes3[i + 2] << 16;
          case 2:
            k1 ^= bytes3[i + 1] << 8;
          case 1:
            k1 ^= bytes3[i];
            k1 = _x86Multiply(k1, c1);
            k1 = _x86Rotl(k1, 15);
            k1 = _x86Multiply(k1, c2);
            h1 ^= k1;
        }
        h1 ^= bytes3.length;
        h2 ^= bytes3.length;
        h3 ^= bytes3.length;
        h4 ^= bytes3.length;
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        h1 = _x86Fmix(h1);
        h2 = _x86Fmix(h2);
        h3 = _x86Fmix(h3);
        h4 = _x86Fmix(h4);
        h1 += h2;
        h1 += h3;
        h1 += h4;
        h2 += h1;
        h3 += h1;
        h4 += h1;
        return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
      };
      library.x64.hash128 = function(bytes3, seed) {
        if (library.inputValidation && !_validBytes(bytes3)) {
          return undefined2;
        }
        seed = seed || 0;
        var remainder = bytes3.length % 16;
        var blocks = bytes3.length - remainder;
        var h1 = [0, seed];
        var h2 = [0, seed];
        var k1 = [0, 0];
        var k2 = [0, 0];
        var c1 = [2277735313, 289559509];
        var c2 = [1291169091, 658871167];
        for (var i = 0; i < blocks; i = i + 16) {
          k1 = [bytes3[i + 4] | bytes3[i + 5] << 8 | bytes3[i + 6] << 16 | bytes3[i + 7] << 24, bytes3[i] | bytes3[i + 1] << 8 | bytes3[i + 2] << 16 | bytes3[i + 3] << 24];
          k2 = [bytes3[i + 12] | bytes3[i + 13] << 8 | bytes3[i + 14] << 16 | bytes3[i + 15] << 24, bytes3[i + 8] | bytes3[i + 9] << 8 | bytes3[i + 10] << 16 | bytes3[i + 11] << 24];
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
          h1 = _x64Rotl(h1, 27);
          h1 = _x64Add(h1, h2);
          h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
          h2 = _x64Rotl(h2, 31);
          h2 = _x64Add(h2, h1);
          h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
        }
        k1 = [0, 0];
        k2 = [0, 0];
        switch (remainder) {
          case 15:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 14]], 48));
          case 14:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 13]], 40));
          case 13:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 12]], 32));
          case 12:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 11]], 24));
          case 11:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 10]], 16));
          case 10:
            k2 = _x64Xor(k2, _x64LeftShift([0, bytes3[i + 9]], 8));
          case 9:
            k2 = _x64Xor(k2, [0, bytes3[i + 8]]);
            k2 = _x64Multiply(k2, c2);
            k2 = _x64Rotl(k2, 33);
            k2 = _x64Multiply(k2, c1);
            h2 = _x64Xor(h2, k2);
          case 8:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 7]], 56));
          case 7:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 6]], 48));
          case 6:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 5]], 40));
          case 5:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 4]], 32));
          case 4:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 3]], 24));
          case 3:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 2]], 16));
          case 2:
            k1 = _x64Xor(k1, _x64LeftShift([0, bytes3[i + 1]], 8));
          case 1:
            k1 = _x64Xor(k1, [0, bytes3[i]]);
            k1 = _x64Multiply(k1, c1);
            k1 = _x64Rotl(k1, 31);
            k1 = _x64Multiply(k1, c2);
            h1 = _x64Xor(h1, k1);
        }
        h1 = _x64Xor(h1, [0, bytes3.length]);
        h2 = _x64Xor(h2, [0, bytes3.length]);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        h1 = _x64Fmix(h1);
        h2 = _x64Fmix(h2);
        h1 = _x64Add(h1, h2);
        h2 = _x64Add(h2, h1);
        return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
      };
      if (typeof exports2 !== "undefined") {
        if (typeof module2 !== "undefined" && module2.exports) {
          exports2 = module2.exports = library;
        }
        exports2.murmurHash3 = library;
      } else if (typeof define === "function" && define.amd) {
        define([], function() {
          return library;
        });
      } else {
        library._murmurHash3 = root.murmurHash3;
        library.noConflict = function() {
          root.murmurHash3 = library._murmurHash3;
          library._murmurHash3 = undefined2;
          library.noConflict = undefined2;
          return library;
        };
        root.murmurHash3 = library;
      }
    })(exports2);
  }
});

// node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited = __commonJS({
  "node_modules/murmurhash3js-revisited/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = require_murmurHash3js();
  }
});

// node_modules/@multiformats/murmur3/esm/index.js
var esm_exports2 = {};
__export(esm_exports2, {
  murmur3128: () => murmur3128,
  murmur332: () => murmur332
});
function fromNumberTo32BitBuf(number) {
  const bytes3 = new Array(4);
  for (let i = 0; i < 4; i++) {
    bytes3[i] = number & 255;
    number = number >> 8;
  }
  return new Uint8Array(bytes3);
}
var import_murmurhash3js_revisited, murmur332, murmur3128;
var init_esm2 = __esm({
  "node_modules/@multiformats/murmur3/esm/index.js"() {
    init_node_globals();
    init_hasher();
    init_src3();
    import_murmurhash3js_revisited = __toModule(require_murmurhash3js_revisited());
    murmur332 = from2({
      name: "murmur3-32",
      code: 35,
      encode: (input) => fromNumberTo32BitBuf(import_murmurhash3js_revisited.default.x86.hash32(input))
    });
    murmur3128 = from2({
      name: "murmur3-128",
      code: 34,
      encode: (input) => bytes_exports.fromHex(import_murmurhash3js_revisited.default.x64.hash128(input))
    });
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/options.js
async function hamtHashFn(buf2) {
  return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
}
var defaultOptions, options_default;
var init_options = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/options.js"() {
    init_node_globals();
    init_merge_options();
    init_sha2_browser();
    init_esm2();
    defaultOptions = {
      chunker: "fixed",
      strategy: "balanced",
      rawLeaves: false,
      onlyHash: false,
      reduceSingleLeafToSelf: true,
      hasher: sha256,
      leafType: "file",
      cidVersion: 0,
      progress: () => () => {
      },
      shardSplitThreshold: 1e3,
      fileImportConcurrency: 50,
      blockWriteConcurrency: 10,
      minChunkSize: 262144,
      maxChunkSize: 262144,
      avgChunkSize: 262144,
      window: 16,
      polynomial: 17437180132763652,
      maxChildrenPerNode: 174,
      layerRepeat: 4,
      wrapWithDirectory: false,
      recursive: false,
      hidden: false,
      timeout: void 0,
      hamtHashFn,
      hamtHashCode: 34,
      hamtBucketBits: 8
    };
    options_default = (options = {}) => {
      const defaults = merge_options_default.bind({ ignoreUndefined: true });
      return defaults(defaultOptions, options);
    };
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/utils/persist.js
var persist, persist_default;
var init_persist = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/utils/persist.js"() {
    init_node_globals();
    init_cid();
    init_src2();
    init_sha2_browser();
    persist = async (buffer2, blockstore, options) => {
      if (!options.codec) {
        options.codec = src_exports2;
      }
      if (!options.hasher) {
        options.hasher = sha256;
      }
      if (options.cidVersion === void 0) {
        options.cidVersion = 1;
      }
      if (options.codec === src_exports2 && options.hasher !== sha256) {
        options.cidVersion = 1;
      }
      const multihash = await options.hasher.digest(buffer2);
      const cid = CID.create(options.cidVersion, options.codec.code, multihash);
      if (!options.onlyHash) {
        await blockstore.put(cid, buffer2, { signal: options.signal });
      }
      return cid;
    };
    persist_default = persist;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/dir.js
var dirBuilder, dir_default;
var init_dir = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/dag-builder/dir.js"() {
    init_node_globals();
    init_src();
    init_persist();
    init_src2();
    dirBuilder = async (item, blockstore, options) => {
      const unixfs = new UnixFS({
        type: "directory",
        mtime: item.mtime,
        mode: item.mode
      });
      const buffer2 = encode3(prepare({ Data: unixfs.marshal() }));
      const cid = await persist_default(buffer2, blockstore, options);
      const path = item.path;
      return {
        cid,
        path,
        unixfs,
        size: buffer2.length
      };
    };
    dir_default = dirBuilder;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/flat.js
async function flat(source, reduce2) {
  return reduce2(await (0, import_it_all2.default)(source));
}
var import_it_all2, flat_default;
var init_flat = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/flat.js"() {
    init_node_globals();
    import_it_all2 = __toModule(require_it_all());
    flat_default = flat;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/balanced.js
function balanced(source, reduce2, options) {
  return reduceToParents(source, reduce2, options);
}
async function reduceToParents(source, reduce2, options) {
  const roots = [];
  for await (const chunked of (0, import_it_batch.default)(source, options.maxChildrenPerNode)) {
    roots.push(await reduce2(chunked));
  }
  if (roots.length > 1) {
    return reduceToParents(roots, reduce2, options);
  }
  return roots[0];
}
var import_it_batch, balanced_default;
var init_balanced = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/balanced.js"() {
    init_node_globals();
    import_it_batch = __toModule(require_it_batch());
    balanced_default = balanced;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/trickle.js
async function trickleStream(source, reduce2, options) {
  const root = new Root(options.layerRepeat);
  let iteration = 0;
  let maxDepth = 1;
  let subTree = root;
  for await (const layer of (0, import_it_batch2.default)(source, options.maxChildrenPerNode)) {
    if (subTree.isFull()) {
      if (subTree !== root) {
        root.addChild(await subTree.reduce(reduce2));
      }
      if (iteration && iteration % options.layerRepeat === 0) {
        maxDepth++;
      }
      subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
      iteration++;
    }
    subTree.append(layer);
  }
  if (subTree && subTree !== root) {
    root.addChild(await subTree.reduce(reduce2));
  }
  return root.reduce(reduce2);
}
var import_it_batch2, trickle_default, SubTree, Root;
var init_trickle = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/trickle.js"() {
    init_node_globals();
    import_it_batch2 = __toModule(require_it_batch());
    trickle_default = trickleStream;
    SubTree = class {
      constructor(maxDepth, layerRepeat, iteration = 0) {
        this.maxDepth = maxDepth;
        this.layerRepeat = layerRepeat;
        this.currentDepth = 1;
        this.iteration = iteration;
        this.root = this.node = this.parent = {
          children: [],
          depth: this.currentDepth,
          maxDepth,
          maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
        };
      }
      isFull() {
        if (!this.root.data) {
          return false;
        }
        if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
          this._addNextNodeToParent(this.node);
          return false;
        }
        const distantRelative = this._findParent(this.node, this.currentDepth);
        if (distantRelative) {
          this._addNextNodeToParent(distantRelative);
          return false;
        }
        return true;
      }
      _addNextNodeToParent(parent2) {
        this.parent = parent2;
        const nextNode = {
          children: [],
          depth: parent2.depth + 1,
          parent: parent2,
          maxDepth: this.maxDepth,
          maxChildren: Math.floor(parent2.children.length / this.layerRepeat) * this.layerRepeat
        };
        parent2.children.push(nextNode);
        this.currentDepth = nextNode.depth;
        this.node = nextNode;
      }
      append(layer) {
        this.node.data = layer;
      }
      reduce(reduce2) {
        return this._reduce(this.root, reduce2);
      }
      async _reduce(node, reduce2) {
        let children = [];
        if (node.children.length) {
          children = await Promise.all(node.children.filter((child) => child.data).map((child) => this._reduce(child, reduce2)));
        }
        return reduce2((node.data || []).concat(children));
      }
      _findParent(node, depth) {
        const parent2 = node.parent;
        if (!parent2 || parent2.depth === 0) {
          return;
        }
        if (parent2.children.length === parent2.maxChildren || !parent2.maxChildren) {
          return this._findParent(parent2, depth);
        }
        return parent2;
      }
    };
    Root = class extends SubTree {
      constructor(layerRepeat) {
        super(0, layerRepeat);
        this.root.depth = 0;
        this.currentDepth = 1;
      }
      addChild(child) {
        this.root.children.push(child);
      }
      reduce(reduce2) {
        return reduce2((this.root.data || []).concat(this.root.children));
      }
    };
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/buffer-importer.js
async function* bufferImporter(file, block, options) {
  for await (let buffer2 of file.content) {
    yield async () => {
      options.progress(buffer2.length, file.path);
      let unixfs;
      const opts = {
        codec: src_exports2,
        cidVersion: options.cidVersion,
        hasher: options.hasher,
        onlyHash: options.onlyHash
      };
      if (options.rawLeaves) {
        opts.codec = raw_exports;
        opts.cidVersion = 1;
      } else {
        unixfs = new UnixFS({
          type: options.leafType,
          data: buffer2,
          mtime: file.mtime,
          mode: file.mode
        });
        buffer2 = encode3({
          Data: unixfs.marshal(),
          Links: []
        });
      }
      return {
        cid: await persist_default(buffer2, block, opts),
        unixfs,
        size: buffer2.length
      };
    };
  }
}
var buffer_importer_default;
var init_buffer_importer = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/buffer-importer.js"() {
    init_node_globals();
    init_src();
    init_persist();
    init_src2();
    init_raw();
    buffer_importer_default = bufferImporter;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js
async function* buildFileBatch(file, blockstore, options) {
  let count = -1;
  let previous;
  let bufferImporter2;
  if (typeof options.bufferImporter === "function") {
    bufferImporter2 = options.bufferImporter;
  } else {
    bufferImporter2 = buffer_importer_default;
  }
  for await (const entry of (0, import_it_parallel_batch.default)(bufferImporter2(file, blockstore, options), options.blockWriteConcurrency)) {
    count++;
    if (count === 0) {
      previous = entry;
      continue;
    } else if (count === 1 && previous) {
      yield previous;
      previous = null;
    }
    yield entry;
  }
  if (previous) {
    previous.single = true;
    yield previous;
  }
}
function fileBuilder(file, block, options) {
  const dagBuilder2 = dagBuilders[options.strategy];
  if (!dagBuilder2) {
    throw (0, import_err_code8.default)(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
  }
  return dagBuilder2(buildFileBatch(file, block, options), reduce(file, block, options), options);
}
var import_err_code8, import_it_parallel_batch, dagBuilders, reduce, file_default;
var init_file = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/dag-builder/file/index.js"() {
    init_node_globals();
    import_err_code8 = __toModule(require_err_code());
    init_src();
    init_persist();
    init_src2();
    import_it_parallel_batch = __toModule(require_it_parallel_batch());
    init_raw();
    init_src2();
    init_flat();
    init_balanced();
    init_trickle();
    init_buffer_importer();
    dagBuilders = {
      flat: flat_default,
      balanced: balanced_default,
      trickle: trickle_default
    };
    reduce = (file, blockstore, options) => {
      async function reducer(leaves) {
        if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
          const leaf = leaves[0];
          if (leaf.cid.code === code3 && (file.mtime !== void 0 || file.mode !== void 0)) {
            let buffer3 = await blockstore.get(leaf.cid);
            leaf.unixfs = new UnixFS({
              type: "file",
              mtime: file.mtime,
              mode: file.mode,
              data: buffer3
            });
            buffer3 = encode3(prepare({ Data: leaf.unixfs.marshal() }));
            leaf.cid = await persist_default(buffer3, blockstore, {
              ...options,
              codec: src_exports2,
              hasher: options.hasher,
              cidVersion: options.cidVersion
            });
            leaf.size = buffer3.length;
          }
          return {
            cid: leaf.cid,
            path: file.path,
            unixfs: leaf.unixfs,
            size: leaf.size
          };
        }
        const f = new UnixFS({
          type: "file",
          mtime: file.mtime,
          mode: file.mode
        });
        const links2 = leaves.filter((leaf) => {
          if (leaf.cid.code === code3 && leaf.size) {
            return true;
          }
          if (leaf.unixfs && !leaf.unixfs.data && leaf.unixfs.fileSize()) {
            return true;
          }
          return Boolean(leaf.unixfs && leaf.unixfs.data && leaf.unixfs.data.length);
        }).map((leaf) => {
          if (leaf.cid.code === code3) {
            f.addBlockSize(leaf.size);
            return {
              Name: "",
              Tsize: leaf.size,
              Hash: leaf.cid
            };
          }
          if (!leaf.unixfs || !leaf.unixfs.data) {
            f.addBlockSize(leaf.unixfs && leaf.unixfs.fileSize() || 0);
          } else {
            f.addBlockSize(leaf.unixfs.data.length);
          }
          return {
            Name: "",
            Tsize: leaf.size,
            Hash: leaf.cid
          };
        });
        const node = {
          Data: f.marshal(),
          Links: links2
        };
        const buffer2 = encode3(prepare(node));
        const cid = await persist_default(buffer2, blockstore, options);
        return {
          cid,
          path: file.path,
          unixfs: f,
          size: buffer2.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
        };
      }
      return reducer;
    };
    file_default = fileBuilder;
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var symbol = Symbol.for("BufferList");
    function BufferList3(buf2) {
      if (!(this instanceof BufferList3)) {
        return new BufferList3(buf2);
      }
      BufferList3._init.call(this, buf2);
    }
    BufferList3._init = function _init(buf2) {
      Object.defineProperty(this, symbol, { value: true });
      this._bufs = [];
      this.length = 0;
      if (buf2) {
        this.append(buf2);
      }
    };
    BufferList3.prototype._new = function _new(buf2) {
      return new BufferList3(buf2);
    };
    BufferList3.prototype._offset = function _offset(offset) {
      if (offset === 0) {
        return [0, 0];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [i, offset - tot];
        }
        tot = _t;
      }
    };
    BufferList3.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList3.prototype.get = function get2(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    };
    BufferList3.prototype.slice = function slice2(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    };
    BufferList3.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes3 = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes3 <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes3) : this._bufs[off[0]].slice(start, start + bytes3);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes3 > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes3);
          bufoff += l;
          break;
        }
        bytes3 -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff)
        return dst.slice(0, bufoff);
      return dst;
    };
    BufferList3.prototype.shallowSlice = function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    };
    BufferList3.prototype.toString = function toString4(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    };
    BufferList3.prototype.consume = function consume(bytes3) {
      bytes3 = Math.trunc(bytes3);
      if (Number.isNaN(bytes3) || bytes3 <= 0)
        return this;
      while (this._bufs.length) {
        if (bytes3 >= this._bufs[0].length) {
          bytes3 -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes3);
          this.length -= bytes3;
          break;
        }
      }
      return this;
    };
    BufferList3.prototype.duplicate = function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    };
    BufferList3.prototype.append = function append(buf2) {
      if (buf2 == null) {
        return this;
      }
      if (buf2.buffer) {
        this._appendBuffer(Buffer2.from(buf2.buffer, buf2.byteOffset, buf2.byteLength));
      } else if (Array.isArray(buf2)) {
        for (let i = 0; i < buf2.length; i++) {
          this.append(buf2[i]);
        }
      } else if (this._isBufferList(buf2)) {
        for (let i = 0; i < buf2._bufs.length; i++) {
          this.append(buf2._bufs[i]);
        }
      } else {
        if (typeof buf2 === "number") {
          buf2 = buf2.toString();
        }
        this._appendBuffer(Buffer2.from(buf2));
      }
      return this;
    };
    BufferList3.prototype._appendBuffer = function appendBuffer(buf2) {
      this._bufs.push(buf2);
      this.length += buf2.length;
    };
    BufferList3.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([search]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([blIndex, nativeSearchResult]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([blIndex, buffOffset]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList3.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList3.prototype[m2] = function(offset, byteLength) {
              return this.slice(offset, offset + byteLength)[m2](0, byteLength);
            };
          } else {
            BufferList3.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList3.prototype._isBufferList = function _isBufferList(b) {
      return b instanceof BufferList3 || BufferList3.isBufferList(b);
    };
    BufferList3.isBufferList = function isBufferList(b) {
      return b != null && b[symbol];
    };
    module2.exports = BufferList3;
  }
});

// node_modules/rabin-wasm/src/rabin.js
var require_rabin = __commonJS({
  "node_modules/rabin-wasm/src/rabin.js"(exports2, module2) {
    init_node_globals();
    var Rabin = class {
      constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {
        this.bits = bits;
        this.min = min;
        this.max = max;
        this.asModule = asModule;
        this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial);
        this.polynomial = polynomial;
      }
      fingerprint(buf2) {
        const {
          __retain,
          __release,
          __allocArray,
          __getInt32Array,
          Int32Array_ID,
          Uint8Array_ID
        } = this.asModule;
        const lengths = new Int32Array(Math.ceil(buf2.length / this.min));
        const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
        const pointer = __retain(__allocArray(Uint8Array_ID, buf2));
        const out = this.rabin.fingerprint(pointer, lengthsPtr);
        const processed = __getInt32Array(out);
        __release(pointer);
        __release(lengthsPtr);
        const end = processed.indexOf(0);
        return end >= 0 ? processed.subarray(0, end) : processed;
      }
    };
    module2.exports = Rabin;
  }
});

// node_modules/@assemblyscript/loader/index.js
var require_loader = __commonJS({
  "node_modules/@assemblyscript/loader/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var ID_OFFSET = -8;
    var SIZE_OFFSET = -4;
    var ARRAYBUFFER_ID = 0;
    var STRING_ID = 1;
    var ARRAYBUFFERVIEW = 1 << 0;
    var ARRAY = 1 << 1;
    var SET = 1 << 2;
    var MAP = 1 << 3;
    var VAL_ALIGN_OFFSET = 5;
    var VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
    var VAL_SIGNED = 1 << 10;
    var VAL_FLOAT = 1 << 11;
    var VAL_NULLABLE = 1 << 12;
    var VAL_MANAGED = 1 << 13;
    var KEY_ALIGN_OFFSET = 14;
    var KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
    var KEY_SIGNED = 1 << 19;
    var KEY_FLOAT = 1 << 20;
    var KEY_NULLABLE = 1 << 21;
    var KEY_MANAGED = 1 << 22;
    var ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
    var ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
    var ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
    var ARRAYBUFFERVIEW_SIZE = 12;
    var ARRAY_LENGTH_OFFSET = 12;
    var ARRAY_SIZE = 16;
    var BIGINT = typeof BigUint64Array !== "undefined";
    var THIS = Symbol();
    var CHUNKSIZE = 1024;
    function getStringImpl(buffer2, ptr) {
      const U32 = new Uint32Array(buffer2);
      const U16 = new Uint16Array(buffer2);
      var length4 = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
      var offset = ptr >>> 1;
      if (length4 <= CHUNKSIZE)
        return String.fromCharCode.apply(String, U16.subarray(offset, offset + length4));
      const parts = [];
      do {
        const last6 = U16[offset + CHUNKSIZE - 1];
        const size = last6 >= 55296 && last6 < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
        parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));
        length4 -= size;
      } while (length4 > CHUNKSIZE);
      return parts.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length4));
    }
    function preInstantiate(imports) {
      const baseModule = {};
      function getString(memory, ptr) {
        if (!memory)
          return "<yet unknown>";
        return getStringImpl(memory.buffer, ptr);
      }
      const env = imports.env = imports.env || {};
      env.abort = env.abort || function abort(mesg, file, line, colm) {
        const memory = baseModule.memory || env.memory;
        throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
      };
      env.trace = env.trace || function trace(mesg, n) {
        const memory = baseModule.memory || env.memory;
        console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
      };
      imports.Math = imports.Math || Math;
      imports.Date = imports.Date || Date;
      return baseModule;
    }
    function postInstantiate(baseModule, instance) {
      const rawExports = instance.exports;
      const memory = rawExports.memory;
      const table = rawExports.table;
      const alloc2 = rawExports["__alloc"];
      const retain = rawExports["__retain"];
      const rttiBase = rawExports["__rtti_base"] || ~0;
      function getInfo(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2];
      }
      function getBase(id) {
        const U32 = new Uint32Array(memory.buffer);
        const count = U32[rttiBase >>> 2];
        if ((id >>>= 0) >= count)
          throw Error("invalid id: " + id);
        return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];
      }
      function getValueAlign(info) {
        return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
      }
      function getKeyAlign(info) {
        return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31);
      }
      function __allocString(str) {
        const length4 = str.length;
        const ptr = alloc2(length4 << 1, STRING_ID);
        const U16 = new Uint16Array(memory.buffer);
        for (var i = 0, p = ptr >>> 1; i < length4; ++i)
          U16[p + i] = str.charCodeAt(i);
        return ptr;
      }
      baseModule.__allocString = __allocString;
      function __getString(ptr) {
        const buffer2 = memory.buffer;
        const id = new Uint32Array(buffer2)[ptr + ID_OFFSET >>> 2];
        if (id !== STRING_ID)
          throw Error("not a string: " + ptr);
        return getStringImpl(buffer2, ptr);
      }
      baseModule.__getString = __getString;
      function getView(alignLog2, signed, float2) {
        const buffer2 = memory.buffer;
        if (float2) {
          switch (alignLog2) {
            case 2:
              return new Float32Array(buffer2);
            case 3:
              return new Float64Array(buffer2);
          }
        } else {
          switch (alignLog2) {
            case 0:
              return new (signed ? Int8Array : Uint8Array)(buffer2);
            case 1:
              return new (signed ? Int16Array : Uint16Array)(buffer2);
            case 2:
              return new (signed ? Int32Array : Uint32Array)(buffer2);
            case 3:
              return new (signed ? BigInt64Array : BigUint64Array)(buffer2);
          }
        }
        throw Error("unsupported align: " + alignLog2);
      }
      function __allocArray(id, values) {
        const info = getInfo(id);
        if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
          throw Error("not an array: " + id + " @ " + info);
        const align = getValueAlign(info);
        const length4 = values.length;
        const buf2 = alloc2(length4 << align, ARRAYBUFFER_ID);
        const arr = alloc2(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
        const U32 = new Uint32Array(memory.buffer);
        U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf2);
        U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf2;
        U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length4 << align;
        if (info & ARRAY)
          U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length4;
        const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
        if (info & VAL_MANAGED) {
          for (let i = 0; i < length4; ++i)
            view[(buf2 >>> align) + i] = retain(values[i]);
        } else {
          view.set(values, buf2 >>> align);
        }
        return arr;
      }
      baseModule.__allocArray = __allocArray;
      function __getArrayView(arr) {
        const U32 = new Uint32Array(memory.buffer);
        const id = U32[arr + ID_OFFSET >>> 2];
        const info = getInfo(id);
        if (!(info & ARRAYBUFFERVIEW))
          throw Error("not an array: " + id);
        const align = getValueAlign(info);
        var buf2 = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        const length4 = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf2 + SIZE_OFFSET >>> 2] >>> align;
        return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf2 >>>= align, buf2 + length4);
      }
      baseModule.__getArrayView = __getArrayView;
      function __getArray(arr) {
        const input = __getArrayView(arr);
        const len = input.length;
        const out = new Array(len);
        for (let i = 0; i < len; i++)
          out[i] = input[i];
        return out;
      }
      baseModule.__getArray = __getArray;
      function __getArrayBuffer(ptr) {
        const buffer2 = memory.buffer;
        const length4 = new Uint32Array(buffer2)[ptr + SIZE_OFFSET >>> 2];
        return buffer2.slice(ptr, ptr + length4);
      }
      baseModule.__getArrayBuffer = __getArrayBuffer;
      function getTypedArray(Type2, alignLog2, ptr) {
        return new Type2(getTypedArrayView(Type2, alignLog2, ptr));
      }
      function getTypedArrayView(Type2, alignLog2, ptr) {
        const buffer2 = memory.buffer;
        const U32 = new Uint32Array(buffer2);
        const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
        return new Type2(buffer2, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
      }
      baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
      baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
      baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
      baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
      baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
      baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
      baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
      baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
      baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
      baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
      baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
      baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
      baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
      baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
      if (BIGINT) {
        baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
        baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
        baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
        baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
      }
      baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
      baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
      baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
      baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
      function __instanceof(ptr, baseId) {
        const U32 = new Uint32Array(memory.buffer);
        var id = U32[ptr + ID_OFFSET >>> 2];
        if (id <= U32[rttiBase >>> 2]) {
          do
            if (id == baseId)
              return true;
          while (id = getBase(id));
        }
        return false;
      }
      baseModule.__instanceof = __instanceof;
      baseModule.memory = baseModule.memory || memory;
      baseModule.table = baseModule.table || table;
      return demangle(rawExports, baseModule);
    }
    function isResponse(o) {
      return typeof Response !== "undefined" && o instanceof Response;
    }
    async function instantiate(source, imports) {
      if (isResponse(source = await source))
        return instantiateStreaming(source, imports);
      return postInstantiate(preInstantiate(imports || (imports = {})), await WebAssembly.instantiate(source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source), imports));
    }
    exports2.instantiate = instantiate;
    function instantiateSync(source, imports) {
      return postInstantiate(preInstantiate(imports || (imports = {})), new WebAssembly.Instance(source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source), imports));
    }
    exports2.instantiateSync = instantiateSync;
    async function instantiateStreaming(source, imports) {
      if (!WebAssembly.instantiateStreaming) {
        return instantiate(isResponse(source = await source) ? source.arrayBuffer() : source, imports);
      }
      return postInstantiate(preInstantiate(imports || (imports = {})), (await WebAssembly.instantiateStreaming(source, imports)).instance);
    }
    exports2.instantiateStreaming = instantiateStreaming;
    function demangle(exports3, baseModule) {
      var module3 = baseModule ? Object.create(baseModule) : {};
      var setArgumentsLength = exports3["__argumentsLength"] ? function(length4) {
        exports3["__argumentsLength"].value = length4;
      } : exports3["__setArgumentsLength"] || exports3["__setargc"] || function() {
      };
      for (let internalName in exports3) {
        if (!Object.prototype.hasOwnProperty.call(exports3, internalName))
          continue;
        const elem = exports3[internalName];
        let parts = internalName.split(".");
        let curr = module3;
        while (parts.length > 1) {
          let part = parts.shift();
          if (!Object.prototype.hasOwnProperty.call(curr, part))
            curr[part] = {};
          curr = curr[part];
        }
        let name5 = parts[0];
        let hash2 = name5.indexOf("#");
        if (hash2 >= 0) {
          let className = name5.substring(0, hash2);
          let classElem = curr[className];
          if (typeof classElem === "undefined" || !classElem.prototype) {
            let ctor = function(...args) {
              return ctor.wrap(ctor.prototype.constructor(0, ...args));
            };
            ctor.prototype = {
              valueOf: function valueOf() {
                return this[THIS];
              }
            };
            ctor.wrap = function(thisValue) {
              return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });
            };
            if (classElem)
              Object.getOwnPropertyNames(classElem).forEach((name6) => Object.defineProperty(ctor, name6, Object.getOwnPropertyDescriptor(classElem, name6)));
            curr[className] = ctor;
          }
          name5 = name5.substring(hash2 + 1);
          curr = curr[className].prototype;
          if (/^(get|set):/.test(name5)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name5 = name5.substring(4))) {
              let getter = exports3[internalName.replace("set:", "get:")];
              let setter = exports3[internalName.replace("get:", "set:")];
              Object.defineProperty(curr, name5, {
                get: function() {
                  return getter(this[THIS]);
                },
                set: function(value) {
                  setter(this[THIS], value);
                },
                enumerable: true
              });
            }
          } else {
            if (name5 === "constructor") {
              (curr[name5] = (...args) => {
                setArgumentsLength(args.length);
                return elem(...args);
              }).original = elem;
            } else {
              (curr[name5] = function(...args) {
                setArgumentsLength(args.length);
                return elem(this[THIS], ...args);
              }).original = elem;
            }
          }
        } else {
          if (/^(get|set):/.test(name5)) {
            if (!Object.prototype.hasOwnProperty.call(curr, name5 = name5.substring(4))) {
              Object.defineProperty(curr, name5, {
                get: exports3[internalName.replace("set:", "get:")],
                set: exports3[internalName.replace("get:", "set:")],
                enumerable: true
              });
            }
          } else if (typeof elem === "function" && elem !== setArgumentsLength) {
            (curr[name5] = (...args) => {
              setArgumentsLength(args.length);
              return elem(...args);
            }).original = elem;
          } else {
            curr[name5] = elem;
          }
        }
      }
      return module3;
    }
    exports2.demangle = demangle;
  }
});

// node_modules/rabin-wasm/dist/rabin-wasm.js
var require_rabin_wasm = __commonJS({
  "node_modules/rabin-wasm/dist/rabin-wasm.js"(exports2, module2) {
    init_node_globals();
    var { instantiate } = require_loader();
    loadWebAssembly.supported = typeof WebAssembly !== "undefined";
    function loadWebAssembly(imp = {}) {
      if (!loadWebAssembly.supported)
        return null;
      var wasm = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 3, 127, 127, 127, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 8, 9, 3, 5, 2, 8, 6, 5, 3, 4, 2, 6, 9, 12, 13, 2, 5, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 6, 7, 7, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 165, 31, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 9, 0, 65, 63, 32, 0, 121, 167, 107, 11, 49, 1, 2, 127, 65, 63, 32, 1, 121, 167, 107, 33, 2, 3, 64, 65, 63, 32, 0, 121, 167, 107, 32, 2, 107, 34, 3, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 3, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 65, 0, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 254, 5, 2, 1, 127, 4, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 65, 0, 33, 4, 3, 64, 32, 4, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 32, 6, 66, 8, 134, 33, 6, 32, 0, 41, 3, 72, 34, 7, 33, 8, 65, 63, 32, 7, 121, 167, 107, 33, 1, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 6, 32, 8, 32, 3, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 63, 32, 0, 41, 3, 72, 121, 167, 107, 172, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 1, 32, 2, 172, 32, 7, 134, 34, 8, 33, 6, 65, 63, 32, 0, 41, 3, 72, 34, 9, 121, 167, 107, 33, 3, 3, 64, 65, 63, 32, 6, 121, 167, 107, 32, 3, 107, 34, 4, 65, 0, 78, 4, 64, 32, 6, 32, 9, 32, 4, 172, 134, 133, 33, 6, 12, 1, 11, 11, 32, 1, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 6, 32, 8, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 32, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 8, 32, 0, 40, 2, 0, 40, 2, 4, 106, 65, 1, 58, 0, 0, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
      return instantiate(new Response(new Blob([wasm], { type: "application/wasm" })), imp);
    }
    module2.exports = loadWebAssembly;
  }
});

// node_modules/rabin-wasm/src/index.js
var require_src9 = __commonJS({
  "node_modules/rabin-wasm/src/index.js"(exports2, module2) {
    init_node_globals();
    var Rabin = require_rabin();
    var getRabin = require_rabin_wasm();
    var create7 = async (avg, min, max, windowSize, polynomial) => {
      const compiled = await getRabin();
      return new Rabin(compiled, avg, min, max, windowSize, polynomial);
    };
    module2.exports = {
      Rabin,
      create: create7
    };
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/chunker/rabin.js
async function* rabinChunker(source, options) {
  let min, max, avg;
  if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
    avg = options.avgChunkSize;
    min = options.minChunkSize;
    max = options.maxChunkSize;
  } else if (!options.avgChunkSize) {
    throw (0, import_err_code9.default)(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
  } else {
    avg = options.avgChunkSize;
    min = avg / 3;
    max = avg + avg / 2;
  }
  if (min < 16) {
    throw (0, import_err_code9.default)(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
  }
  if (max < min) {
    max = min;
  }
  if (avg < min) {
    avg = min;
  }
  const sizepow = Math.floor(Math.log2(avg));
  for await (const chunk of rabin(source, {
    min,
    max,
    bits: sizepow,
    window: options.window,
    polynomial: options.polynomial
  })) {
    yield chunk;
  }
}
async function* rabin(source, options) {
  const r = await (0, import_rabin_wasm.create)(options.bits, options.min, options.max, options.window);
  const buffers = new import_BufferList.default();
  for await (const chunk of source) {
    buffers.append(chunk);
    const sizes = r.fingerprint(chunk);
    for (let i = 0; i < sizes.length; i++) {
      const size = sizes[i];
      const buf2 = buffers.slice(0, size);
      buffers.consume(size);
      yield buf2;
    }
  }
  if (buffers.length) {
    yield buffers.slice(0);
  }
}
var import_BufferList, import_rabin_wasm, import_err_code9, rabin_default;
var init_rabin = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/chunker/rabin.js"() {
    init_node_globals();
    import_BufferList = __toModule(require_BufferList());
    import_rabin_wasm = __toModule(require_src9());
    import_err_code9 = __toModule(require_err_code());
    rabin_default = rabinChunker;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/chunker/fixed-size.js
async function* fixedSizeChunker(source, options) {
  let bl = new import_BufferList2.default();
  let currentLength = 0;
  let emitted = false;
  const maxChunkSize = options.maxChunkSize;
  for await (const buffer2 of source) {
    bl.append(buffer2);
    currentLength += buffer2.length;
    while (currentLength >= maxChunkSize) {
      yield bl.slice(0, maxChunkSize);
      emitted = true;
      if (maxChunkSize === bl.length) {
        bl = new import_BufferList2.default();
        currentLength = 0;
      } else {
        const newBl = new import_BufferList2.default();
        newBl.append(bl.shallowSlice(maxChunkSize));
        bl = newBl;
        currentLength -= maxChunkSize;
      }
    }
  }
  if (!emitted || currentLength) {
    yield bl.slice(0, currentLength);
  }
}
var import_BufferList2, fixed_size_default;
var init_fixed_size = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/chunker/fixed-size.js"() {
    init_node_globals();
    import_BufferList2 = __toModule(require_BufferList());
    fixed_size_default = fixedSizeChunker;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/validate-chunks.js
async function* validateChunks(source) {
  for await (const content of source) {
    if (content.length === void 0) {
      throw (0, import_err_code10.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
    if (typeof content === "string" || content instanceof String) {
      yield fromString3(content.toString());
    } else if (Array.isArray(content)) {
      yield Uint8Array.from(content);
    } else if (content instanceof Uint8Array) {
      yield content;
    } else {
      throw (0, import_err_code10.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
    }
  }
}
var import_err_code10, validate_chunks_default;
var init_validate_chunks = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/dag-builder/validate-chunks.js"() {
    init_node_globals();
    import_err_code10 = __toModule(require_err_code());
    init_from_string();
    validate_chunks_default = validateChunks;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js
function isIterable(thing) {
  return Symbol.iterator in thing;
}
function isAsyncIterable(thing) {
  return Symbol.asyncIterator in thing;
}
function contentAsAsyncIterable(content) {
  try {
    if (content instanceof Uint8Array) {
      return async function* () {
        yield content;
      }();
    } else if (isIterable(content)) {
      return async function* () {
        yield* content;
      }();
    } else if (isAsyncIterable(content)) {
      return content;
    }
  } catch {
    throw (0, import_err_code11.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
  }
  throw (0, import_err_code11.default)(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
}
async function* dagBuilder(source, blockstore, options) {
  for await (const entry of source) {
    if (entry.path) {
      if (entry.path.substring(0, 2) === "./") {
        options.wrapWithDirectory = true;
      }
      entry.path = entry.path.split("/").filter((path) => path && path !== ".").join("/");
    }
    if (entry.content) {
      let chunker;
      if (typeof options.chunker === "function") {
        chunker = options.chunker;
      } else if (options.chunker === "rabin") {
        chunker = rabin_default;
      } else {
        chunker = fixed_size_default;
      }
      let chunkValidator;
      if (typeof options.chunkValidator === "function") {
        chunkValidator = options.chunkValidator;
      } else {
        chunkValidator = validate_chunks_default;
      }
      const file = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode,
        content: chunker(chunkValidator(contentAsAsyncIterable(entry.content), options), options)
      };
      yield () => file_default(file, blockstore, options);
    } else if (entry.path) {
      const dir = {
        path: entry.path,
        mtime: entry.mtime,
        mode: entry.mode
      };
      yield () => dir_default(dir, blockstore, options);
    } else {
      throw new Error("Import candidate must have content or path or both");
    }
  }
}
var import_err_code11, dag_builder_default;
var init_dag_builder = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/dag-builder/index.js"() {
    init_node_globals();
    init_dir();
    init_file();
    import_err_code11 = __toModule(require_err_code());
    init_rabin();
    init_fixed_size();
    init_validate_chunks();
    dag_builder_default = dagBuilder;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/dir.js
var Dir, dir_default2;
var init_dir2 = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/dir.js"() {
    init_node_globals();
    Dir = class {
      constructor(props, options) {
        this.options = options || {};
        this.root = props.root;
        this.dir = props.dir;
        this.path = props.path;
        this.dirty = props.dirty;
        this.flat = props.flat;
        this.parent = props.parent;
        this.parentKey = props.parentKey;
        this.unixfs = props.unixfs;
        this.mode = props.mode;
        this.mtime = props.mtime;
        this.cid = void 0;
        this.size = void 0;
      }
      async put(name5, value) {
      }
      get(name5) {
        return Promise.resolve(this);
      }
      async *eachChildSeries() {
      }
      async *flush(blockstore) {
      }
    };
    dir_default2 = Dir;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/dir-flat.js
var DirFlat, dir_flat_default;
var init_dir_flat = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/dir-flat.js"() {
    init_node_globals();
    init_src2();
    init_src();
    init_dir2();
    init_persist();
    DirFlat = class extends dir_default2 {
      constructor(props, options) {
        super(props, options);
        this._children = {};
      }
      async put(name5, value) {
        this.cid = void 0;
        this.size = void 0;
        this._children[name5] = value;
      }
      get(name5) {
        return Promise.resolve(this._children[name5]);
      }
      childCount() {
        return Object.keys(this._children).length;
      }
      directChildrenCount() {
        return this.childCount();
      }
      onlyChild() {
        return this._children[Object.keys(this._children)[0]];
      }
      async *eachChildSeries() {
        const keys = Object.keys(this._children);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          yield {
            key,
            child: this._children[key]
          };
        }
      }
      async *flush(block) {
        const children = Object.keys(this._children);
        const links2 = [];
        for (let i = 0; i < children.length; i++) {
          let child = this._children[children[i]];
          if (child instanceof dir_default2) {
            for await (const entry of child.flush(block)) {
              child = entry;
              yield child;
            }
          }
          if (child.size != null && child.cid) {
            links2.push({
              Name: children[i],
              Tsize: child.size,
              Hash: child.cid
            });
          }
        }
        const unixfs = new UnixFS({
          type: "directory",
          mtime: this.mtime,
          mode: this.mode
        });
        const node = {
          Data: unixfs.marshal(),
          Links: links2
        };
        const buffer2 = encode3(prepare(node));
        const cid = await persist_default(buffer2, block, this.options);
        const size = buffer2.length + node.Links.reduce((acc, curr) => acc + (curr.Tsize == null ? 0 : curr.Tsize), 0);
        this.cid = cid;
        this.size = size;
        yield {
          cid,
          unixfs,
          path: this.path,
          size
        };
      }
    };
    dir_flat_default = DirFlat;
  }
});

// node_modules/sparse-array/index.js
var require_sparse_array = __commonJS({
  "node_modules/sparse-array/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var BITS_PER_BYTE = 7;
    module2.exports = class SparseArray {
      constructor() {
        this._bitArrays = [];
        this._data = [];
        this._length = 0;
        this._changedLength = false;
        this._changedData = false;
      }
      set(index, value) {
        let pos = this._internalPositionFor(index, false);
        if (value === void 0) {
          if (pos !== -1) {
            this._unsetInternalPos(pos);
            this._unsetBit(index);
            this._changedLength = true;
            this._changedData = true;
          }
        } else {
          let needsSort = false;
          if (pos === -1) {
            pos = this._data.length;
            this._setBit(index);
            this._changedData = true;
          } else {
            needsSort = true;
          }
          this._setInternalPos(pos, index, value, needsSort);
          this._changedLength = true;
        }
      }
      unset(index) {
        this.set(index, void 0);
      }
      get(index) {
        this._sortData();
        const pos = this._internalPositionFor(index, true);
        if (pos === -1) {
          return void 0;
        }
        return this._data[pos][1];
      }
      push(value) {
        this.set(this.length, value);
        return this.length;
      }
      get length() {
        this._sortData();
        if (this._changedLength) {
          const last6 = this._data[this._data.length - 1];
          this._length = last6 ? last6[0] + 1 : 0;
          this._changedLength = false;
        }
        return this._length;
      }
      forEach(iterator) {
        let i = 0;
        while (i < this.length) {
          iterator(this.get(i), i, this);
          i++;
        }
      }
      map(iterator) {
        let i = 0;
        let mapped = new Array(this.length);
        while (i < this.length) {
          mapped[i] = iterator(this.get(i), i, this);
          i++;
        }
        return mapped;
      }
      reduce(reducer, initialValue) {
        let i = 0;
        let acc = initialValue;
        while (i < this.length) {
          const value = this.get(i);
          acc = reducer(acc, value, i);
          i++;
        }
        return acc;
      }
      find(finder) {
        let i = 0, found, last6;
        while (i < this.length && !found) {
          last6 = this.get(i);
          found = finder(last6);
          i++;
        }
        return found ? last6 : void 0;
      }
      _internalPositionFor(index, noCreate) {
        const bytePos = this._bytePosFor(index, noCreate);
        if (bytePos >= this._bitArrays.length) {
          return -1;
        }
        const byte = this._bitArrays[bytePos];
        const bitPos = index - bytePos * BITS_PER_BYTE;
        const exists = (byte & 1 << bitPos) > 0;
        if (!exists) {
          return -1;
        }
        const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
        const mask = ~(4294967295 << bitPos + 1);
        const bytePopCount = popCount(byte & mask);
        const arrayPos = previousPopCount + bytePopCount - 1;
        return arrayPos;
      }
      _bytePosFor(index, noCreate) {
        const bytePos = Math.floor(index / BITS_PER_BYTE);
        const targetLength = bytePos + 1;
        while (!noCreate && this._bitArrays.length < targetLength) {
          this._bitArrays.push(0);
        }
        return bytePos;
      }
      _setBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
      }
      _unsetBit(index) {
        const bytePos = this._bytePosFor(index, false);
        this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
      }
      _setInternalPos(pos, index, value, needsSort) {
        const data = this._data;
        const elem = [index, value];
        if (needsSort) {
          this._sortData();
          data[pos] = elem;
        } else {
          if (data.length) {
            if (data[data.length - 1][0] >= index) {
              data.push(elem);
            } else if (data[0][0] <= index) {
              data.unshift(elem);
            } else {
              const randomIndex = Math.round(data.length / 2);
              this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
            }
          } else {
            this._data.push(elem);
          }
          this._changedData = true;
          this._changedLength = true;
        }
      }
      _unsetInternalPos(pos) {
        this._data.splice(pos, 1);
      }
      _sortData() {
        if (this._changedData) {
          this._data.sort(sortInternal);
        }
        this._changedData = false;
      }
      bitField() {
        const bytes3 = [];
        let pendingBitsForResultingByte = 8;
        let pendingBitsForNewByte = 0;
        let resultingByte = 0;
        let newByte;
        const pending = this._bitArrays.slice();
        while (pending.length || pendingBitsForNewByte) {
          if (pendingBitsForNewByte === 0) {
            newByte = pending.shift();
            pendingBitsForNewByte = 7;
          }
          const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
          const mask = ~(255 << usingBits);
          const masked = newByte & mask;
          resultingByte |= masked << 8 - pendingBitsForResultingByte;
          newByte = newByte >>> usingBits;
          pendingBitsForNewByte -= usingBits;
          pendingBitsForResultingByte -= usingBits;
          if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
            bytes3.push(resultingByte);
            resultingByte = 0;
            pendingBitsForResultingByte = 8;
          }
        }
        for (var i = bytes3.length - 1; i > 0; i--) {
          const value = bytes3[i];
          if (value === 0) {
            bytes3.pop();
          } else {
            break;
          }
        }
        return bytes3;
      }
      compactArray() {
        this._sortData();
        return this._data.map(valueOnly);
      }
    };
    function popCountReduce(count, byte) {
      return count + popCount(byte);
    }
    function popCount(_v) {
      let v = _v;
      v = v - (v >> 1 & 1431655765);
      v = (v & 858993459) + (v >> 2 & 858993459);
      return (v + (v >> 4) & 252645135) * 16843009 >> 24;
    }
    function sortInternal(a, b) {
      return a[0] - b[0];
    }
    function valueOnly(elem) {
      return elem[1];
    }
  }
});

// node_modules/hamt-sharding/src/bucket.js
var require_bucket = __commonJS({
  "node_modules/hamt-sharding/src/bucket.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var SparseArray = require_sparse_array();
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var Bucket3 = class {
      constructor(options, parent2, posAtParent = 0) {
        this._options = options;
        this._popCount = 0;
        this._parent = parent2;
        this._posAtParent = posAtParent;
        this._children = new SparseArray();
        this.key = null;
      }
      async put(key, value) {
        const place = await this._findNewBucketAndPos(key);
        await place.bucket._putAt(place, key, value);
      }
      async get(key) {
        const child = await this._findChild(key);
        if (child) {
          return child.value;
        }
      }
      async del(key) {
        const place = await this._findPlace(key);
        const child = place.bucket._at(place.pos);
        if (child && child.key === key) {
          place.bucket._delAt(place.pos);
        }
      }
      leafCount() {
        const children = this._children.compactArray();
        return children.reduce((acc, child) => {
          if (child instanceof Bucket3) {
            return acc + child.leafCount();
          }
          return acc + 1;
        }, 0);
      }
      childrenCount() {
        return this._children.length;
      }
      onlyChild() {
        return this._children.get(0);
      }
      *eachLeafSeries() {
        const children = this._children.compactArray();
        for (const child of children) {
          if (child instanceof Bucket3) {
            yield* child.eachLeafSeries();
          } else {
            yield child;
          }
        }
        return [];
      }
      serialize(map8, reduce2) {
        const acc = [];
        return reduce2(this._children.reduce((acc2, child, index) => {
          if (child) {
            if (child instanceof Bucket3) {
              acc2.push(child.serialize(map8, reduce2));
            } else {
              acc2.push(map8(child, index));
            }
          }
          return acc2;
        }, acc));
      }
      asyncTransform(asyncMap, asyncReduce) {
        return asyncTransformBucket(this, asyncMap, asyncReduce);
      }
      toJSON() {
        return this.serialize(mapNode, reduceNodes);
      }
      prettyPrint() {
        return JSON.stringify(this.toJSON(), null, "  ");
      }
      tableSize() {
        return Math.pow(2, this._options.bits);
      }
      async _findChild(key) {
        const result = await this._findPlace(key);
        const child = result.bucket._at(result.pos);
        if (child instanceof Bucket3) {
          return void 0;
        }
        if (child && child.key === key) {
          return child;
        }
      }
      async _findPlace(key) {
        const hashValue = this._options.hash(typeof key === "string" ? uint8ArrayFromString(key) : key);
        const index = await hashValue.take(this._options.bits);
        const child = this._children.get(index);
        if (child instanceof Bucket3) {
          return child._findPlace(hashValue);
        }
        return {
          bucket: this,
          pos: index,
          hash: hashValue,
          existingChild: child
        };
      }
      async _findNewBucketAndPos(key) {
        const place = await this._findPlace(key);
        if (place.existingChild && place.existingChild.key !== key) {
          const bucket = new Bucket3(this._options, place.bucket, place.pos);
          place.bucket._putObjectAt(place.pos, bucket);
          const newPlace = await bucket._findPlace(place.existingChild.hash);
          newPlace.bucket._putAt(newPlace, place.existingChild.key, place.existingChild.value);
          return bucket._findNewBucketAndPos(place.hash);
        }
        return place;
      }
      _putAt(place, key, value) {
        this._putObjectAt(place.pos, {
          key,
          value,
          hash: place.hash
        });
      }
      _putObjectAt(pos, object) {
        if (!this._children.get(pos)) {
          this._popCount++;
        }
        this._children.set(pos, object);
      }
      _delAt(pos) {
        if (pos === -1) {
          throw new Error("Invalid position");
        }
        if (this._children.get(pos)) {
          this._popCount--;
        }
        this._children.unset(pos);
        this._level();
      }
      _level() {
        if (this._parent && this._popCount <= 1) {
          if (this._popCount === 1) {
            const onlyChild = this._children.find(exists);
            if (onlyChild && !(onlyChild instanceof Bucket3)) {
              const hash2 = onlyChild.hash;
              hash2.untake(this._options.bits);
              const place = {
                pos: this._posAtParent,
                hash: hash2,
                bucket: this._parent
              };
              this._parent._putAt(place, onlyChild.key, onlyChild.value);
            }
          } else {
            this._parent._delAt(this._posAtParent);
          }
        }
      }
      _at(index) {
        return this._children.get(index);
      }
    };
    function exists(o) {
      return Boolean(o);
    }
    function mapNode(node, index) {
      return node.key;
    }
    function reduceNodes(nodes) {
      return nodes;
    }
    async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
      const output = [];
      for (const child of bucket._children.compactArray()) {
        if (child instanceof Bucket3) {
          await asyncTransformBucket(child, asyncMap, asyncReduce);
        } else {
          const mappedChildren = await asyncMap(child);
          output.push({
            bitField: bucket._children.bitField(),
            children: mappedChildren
          });
        }
      }
      return asyncReduce(output);
    }
    module2.exports = Bucket3;
  }
});

// node_modules/hamt-sharding/src/consumable-buffer.js
var require_consumable_buffer = __commonJS({
  "node_modules/hamt-sharding/src/consumable-buffer.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var START_MASKS = [
      255,
      254,
      252,
      248,
      240,
      224,
      192,
      128
    ];
    var STOP_MASKS = [
      1,
      3,
      7,
      15,
      31,
      63,
      127,
      255
    ];
    module2.exports = class ConsumableBuffer {
      constructor(value) {
        this._value = value;
        this._currentBytePos = value.length - 1;
        this._currentBitPos = 7;
      }
      availableBits() {
        return this._currentBitPos + 1 + this._currentBytePos * 8;
      }
      totalBits() {
        return this._value.length * 8;
      }
      take(bits) {
        let pendingBits = bits;
        let result = 0;
        while (pendingBits && this._haveBits()) {
          const byte = this._value[this._currentBytePos];
          const availableBits = this._currentBitPos + 1;
          const taking = Math.min(availableBits, pendingBits);
          const value = byteBitsToInt(byte, availableBits - taking, taking);
          result = (result << taking) + value;
          pendingBits -= taking;
          this._currentBitPos -= taking;
          if (this._currentBitPos < 0) {
            this._currentBitPos = 7;
            this._currentBytePos--;
          }
        }
        return result;
      }
      untake(bits) {
        this._currentBitPos += bits;
        while (this._currentBitPos > 7) {
          this._currentBitPos -= 8;
          this._currentBytePos += 1;
        }
      }
      _haveBits() {
        return this._currentBytePos >= 0;
      }
    };
    function byteBitsToInt(byte, start, length4) {
      const mask = maskFor(start, length4);
      return (byte & mask) >>> start;
    }
    function maskFor(start, length4) {
      return START_MASKS[start] & STOP_MASKS[Math.min(length4 + start - 1, 7)];
    }
  }
});

// node_modules/hamt-sharding/src/consumable-hash.js
var require_consumable_hash = __commonJS({
  "node_modules/hamt-sharding/src/consumable-hash.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var ConsumableBuffer = require_consumable_buffer();
    var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
    function wrapHash(hashFn2) {
      function hashing(value) {
        if (value instanceof InfiniteHash) {
          return value;
        } else {
          return new InfiniteHash(value, hashFn2);
        }
      }
      return hashing;
    }
    var InfiniteHash = class {
      constructor(value, hashFn2) {
        if (!(value instanceof Uint8Array)) {
          throw new Error("can only hash Uint8Arrays");
        }
        this._value = value;
        this._hashFn = hashFn2;
        this._depth = -1;
        this._availableBits = 0;
        this._currentBufferIndex = 0;
        this._buffers = [];
      }
      async take(bits) {
        let pendingBits = bits;
        while (this._availableBits < pendingBits) {
          await this._produceMoreBits();
        }
        let result = 0;
        while (pendingBits > 0) {
          const hash2 = this._buffers[this._currentBufferIndex];
          const available = Math.min(hash2.availableBits(), pendingBits);
          const took = hash2.take(available);
          result = (result << available) + took;
          pendingBits -= available;
          this._availableBits -= available;
          if (hash2.availableBits() === 0) {
            this._currentBufferIndex++;
          }
        }
        return result;
      }
      untake(bits) {
        let pendingBits = bits;
        while (pendingBits > 0) {
          const hash2 = this._buffers[this._currentBufferIndex];
          const availableForUntake = Math.min(hash2.totalBits() - hash2.availableBits(), pendingBits);
          hash2.untake(availableForUntake);
          pendingBits -= availableForUntake;
          this._availableBits += availableForUntake;
          if (this._currentBufferIndex > 0 && hash2.totalBits() === hash2.availableBits()) {
            this._depth--;
            this._currentBufferIndex--;
          }
        }
      }
      async _produceMoreBits() {
        this._depth++;
        const value = this._depth ? uint8ArrayConcat([this._value, Uint8Array.from([this._depth])]) : this._value;
        const hashValue = await this._hashFn(value);
        const buffer2 = new ConsumableBuffer(hashValue);
        this._buffers.push(buffer2);
        this._availableBits += buffer2.availableBits();
      }
    };
    module2.exports = wrapHash;
    module2.exports.InfiniteHash = InfiniteHash;
  }
});

// node_modules/hamt-sharding/src/index.js
var require_src10 = __commonJS({
  "node_modules/hamt-sharding/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var Bucket3 = require_bucket();
    var wrapHash = require_consumable_hash();
    function createHAMT3(options) {
      if (!options || !options.hashFn) {
        throw new Error("please define an options.hashFn");
      }
      const bucketOptions = {
        bits: options.bits || 8,
        hash: wrapHash(options.hashFn)
      };
      return new Bucket3(bucketOptions);
    }
    module2.exports = {
      createHAMT: createHAMT3,
      Bucket: Bucket3
    };
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/dir-sharded.js
async function* flush(bucket, blockstore, shardRoot, options) {
  const children = bucket._children;
  const links2 = [];
  let childrenSize = 0;
  for (let i = 0; i < children.length; i++) {
    const child = children.get(i);
    if (!child) {
      continue;
    }
    const labelPrefix = i.toString(16).toUpperCase().padStart(2, "0");
    if (child instanceof import_hamt_sharding.Bucket) {
      let shard2;
      for await (const subShard of await flush(child, blockstore, null, options)) {
        shard2 = subShard;
      }
      if (!shard2) {
        throw new Error("Could not flush sharded directory, no subshard found");
      }
      links2.push({
        Name: labelPrefix,
        Tsize: shard2.size,
        Hash: shard2.cid
      });
      childrenSize += shard2.size;
    } else if (typeof child.value.flush === "function") {
      const dir2 = child.value;
      let flushedDir;
      for await (const entry of dir2.flush(blockstore)) {
        flushedDir = entry;
        yield flushedDir;
      }
      const label = labelPrefix + child.key;
      links2.push({
        Name: label,
        Tsize: flushedDir.size,
        Hash: flushedDir.cid
      });
      childrenSize += flushedDir.size;
    } else {
      const value = child.value;
      if (!value.cid) {
        continue;
      }
      const label = labelPrefix + child.key;
      const size2 = value.size;
      links2.push({
        Name: label,
        Tsize: size2,
        Hash: value.cid
      });
      childrenSize += size2;
    }
  }
  const data = Uint8Array.from(children.bitField().reverse());
  const dir = new UnixFS({
    type: "hamt-sharded-directory",
    data,
    fanout: bucket.tableSize(),
    hashType: options.hamtHashCode,
    mtime: shardRoot && shardRoot.mtime,
    mode: shardRoot && shardRoot.mode
  });
  const node = {
    Data: dir.marshal(),
    Links: links2
  };
  const buffer2 = encode3(prepare(node));
  const cid = await persist_default(buffer2, blockstore, options);
  const size = buffer2.length + childrenSize;
  yield {
    cid,
    unixfs: dir,
    size
  };
}
var import_hamt_sharding, DirSharded, dir_sharded_default;
var init_dir_sharded = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/dir-sharded.js"() {
    init_node_globals();
    init_src2();
    init_src();
    init_dir2();
    init_persist();
    import_hamt_sharding = __toModule(require_src10());
    DirSharded = class extends dir_default2 {
      constructor(props, options) {
        super(props, options);
        this._bucket = (0, import_hamt_sharding.createHAMT)({
          hashFn: options.hamtHashFn,
          bits: options.hamtBucketBits
        });
      }
      async put(name5, value) {
        await this._bucket.put(name5, value);
      }
      get(name5) {
        return this._bucket.get(name5);
      }
      childCount() {
        return this._bucket.leafCount();
      }
      directChildrenCount() {
        return this._bucket.childrenCount();
      }
      onlyChild() {
        return this._bucket.onlyChild();
      }
      async *eachChildSeries() {
        for await (const { key, value } of this._bucket.eachLeafSeries()) {
          yield {
            key,
            child: value
          };
        }
      }
      async *flush(blockstore) {
        for await (const entry of flush(this._bucket, blockstore, this, this.options)) {
          yield {
            ...entry,
            path: this.path
          };
        }
      }
    };
    dir_sharded_default = DirSharded;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/flat-to-shard.js
async function flatToShard(child, dir, threshold, options) {
  let newDir = dir;
  if (dir instanceof dir_flat_default && dir.directChildrenCount() >= threshold) {
    newDir = await convertToShard(dir, options);
  }
  const parent2 = newDir.parent;
  if (parent2) {
    if (newDir !== dir) {
      if (child) {
        child.parent = newDir;
      }
      if (!newDir.parentKey) {
        throw new Error("No parent key found");
      }
      await parent2.put(newDir.parentKey, newDir);
    }
    return flatToShard(newDir, parent2, threshold, options);
  }
  return newDir;
}
async function convertToShard(oldDir, options) {
  const newDir = new dir_sharded_default({
    root: oldDir.root,
    dir: true,
    parent: oldDir.parent,
    parentKey: oldDir.parentKey,
    path: oldDir.path,
    dirty: oldDir.dirty,
    flat: false,
    mtime: oldDir.mtime,
    mode: oldDir.mode
  }, options);
  for await (const { key, child } of oldDir.eachChildSeries()) {
    await newDir.put(key, child);
  }
  return newDir;
}
var flat_to_shard_default;
var init_flat_to_shard = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/flat-to-shard.js"() {
    init_node_globals();
    init_dir_sharded();
    init_dir_flat();
    flat_to_shard_default = flatToShard;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/utils/to-path-components.js
var toPathComponents, to_path_components_default;
var init_to_path_components = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/utils/to-path-components.js"() {
    init_node_globals();
    toPathComponents = (path = "") => {
      return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
    };
    to_path_components_default = toPathComponents;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/tree-builder.js
async function addToTree(elem, tree2, options) {
  const pathElems = to_path_components_default(elem.path || "");
  const lastIndex = pathElems.length - 1;
  let parent2 = tree2;
  let currentPath = "";
  for (let i = 0; i < pathElems.length; i++) {
    const pathElem = pathElems[i];
    currentPath += `${currentPath ? "/" : ""}${pathElem}`;
    const last6 = i === lastIndex;
    parent2.dirty = true;
    parent2.cid = void 0;
    parent2.size = void 0;
    if (last6) {
      await parent2.put(pathElem, elem);
      tree2 = await flat_to_shard_default(null, parent2, options.shardSplitThreshold, options);
    } else {
      let dir = await parent2.get(pathElem);
      if (!dir || !(dir instanceof dir_default2)) {
        dir = new dir_flat_default({
          root: false,
          dir: true,
          parent: parent2,
          parentKey: pathElem,
          path: currentPath,
          dirty: true,
          flat: true,
          mtime: dir && dir.unixfs && dir.unixfs.mtime,
          mode: dir && dir.unixfs && dir.unixfs.mode
        }, options);
      }
      await parent2.put(pathElem, dir);
      parent2 = dir;
    }
  }
  return tree2;
}
async function* flushAndYield(tree2, blockstore) {
  if (!(tree2 instanceof dir_default2)) {
    if (tree2 && tree2.unixfs && tree2.unixfs.isDirectory()) {
      yield tree2;
    }
    return;
  }
  yield* tree2.flush(blockstore);
}
async function* treeBuilder(source, block, options) {
  let tree2 = new dir_flat_default({
    root: true,
    dir: true,
    path: "",
    dirty: true,
    flat: true
  }, options);
  for await (const entry of source) {
    if (!entry) {
      continue;
    }
    tree2 = await addToTree(entry, tree2, options);
    if (!entry.unixfs || !entry.unixfs.isDirectory()) {
      yield entry;
    }
  }
  if (options.wrapWithDirectory) {
    yield* flushAndYield(tree2, block);
  } else {
    for await (const unwrapped of tree2.eachChildSeries()) {
      if (!unwrapped) {
        continue;
      }
      yield* flushAndYield(unwrapped.child, block);
    }
  }
}
var tree_builder_default;
var init_tree_builder = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/tree-builder.js"() {
    init_node_globals();
    init_dir_flat();
    init_flat_to_shard();
    init_dir2();
    init_to_path_components();
    tree_builder_default = treeBuilder;
  }
});

// node_modules/ipfs-unixfs-importer/esm/src/index.js
var src_exports5 = {};
__export(src_exports5, {
  importer: () => importer
});
async function* importer(source, blockstore, options = {}) {
  const opts = options_default(options);
  let dagBuilder2;
  if (typeof options.dagBuilder === "function") {
    dagBuilder2 = options.dagBuilder;
  } else {
    dagBuilder2 = dag_builder_default;
  }
  let treeBuilder2;
  if (typeof options.treeBuilder === "function") {
    treeBuilder2 = options.treeBuilder;
  } else {
    treeBuilder2 = tree_builder_default;
  }
  let candidates;
  if (Symbol.asyncIterator in source || Symbol.iterator in source) {
    candidates = source;
  } else {
    candidates = [source];
  }
  for await (const entry of treeBuilder2((0, import_it_parallel_batch2.default)(dagBuilder2(candidates, blockstore, opts), opts.fileImportConcurrency), blockstore, opts)) {
    yield {
      cid: entry.cid,
      path: entry.path,
      unixfs: entry.unixfs,
      size: entry.size
    };
  }
}
var import_it_parallel_batch2;
var init_src8 = __esm({
  "node_modules/ipfs-unixfs-importer/esm/src/index.js"() {
    init_node_globals();
    import_it_parallel_batch2 = __toModule(require_it_parallel_batch());
    init_options();
    init_dag_builder();
    init_tree_builder();
  }
});

// node_modules/browser-readablestream-to-it/index.js
var require_browser_readablestream_to_it = __commonJS({
  "node_modules/browser-readablestream-to-it/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    async function* browserReadableStreamToIt(stream, options = {}) {
      const reader = stream.getReader();
      try {
        while (true) {
          const result = await reader.read();
          if (result.done) {
            return;
          }
          yield result.value;
        }
      } finally {
        if (options.preventCancel !== true) {
          reader.cancel();
        }
        reader.releaseLock();
      }
    }
    module2.exports = browserReadableStreamToIt;
  }
});

// node_modules/blob-to-it/index.js
var require_blob_to_it = __commonJS({
  "node_modules/blob-to-it/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var browserReadableStreamToIt = require_browser_readablestream_to_it();
    function blobToIt2(blob) {
      if (typeof blob.stream === "function") {
        return browserReadableStreamToIt(blob.stream());
      }
      return browserReadableStreamToIt(new Response(blob).body);
    }
    module2.exports = blobToIt2;
  }
});

// node_modules/it-peekable/index.js
var require_it_peekable = __commonJS({
  "node_modules/it-peekable/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function peekableIterator(iterable) {
      const [iterator, symbol] = iterable[Symbol.asyncIterator] ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
      const queue = [];
      return {
        peek: () => {
          return iterator.next();
        },
        push: (value) => {
          queue.push(value);
        },
        next: () => {
          if (queue.length) {
            return {
              done: false,
              value: queue.shift()
            };
          }
          return iterator.next();
        },
        [symbol]() {
          return this;
        }
      };
    }
    module2.exports = peekableIterator;
  }
});

// node_modules/ipfs-core-utils/esm/src/files/utils.js
function isBytes(obj) {
  return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
}
function isBlob(obj) {
  return obj.constructor && (obj.constructor.name === "Blob" || obj.constructor.name === "File") && typeof obj.stream === "function";
}
function isFileObject(obj) {
  return typeof obj === "object" && (obj.path || obj.content);
}
var isReadableStream;
var init_utils4 = __esm({
  "node_modules/ipfs-core-utils/esm/src/files/utils.js"() {
    init_node_globals();
    isReadableStream = (value) => value && typeof value.getReader === "function";
  }
});

// node_modules/ipfs-core-utils/esm/src/files/normalise-content.js
async function normaliseContent(input) {
  return toAsyncGenerator(input);
}
async function* toAsyncGenerator(input) {
  if (isBytes(input)) {
    yield toBytes(input);
    return;
  }
  if (typeof input === "string" || input instanceof String) {
    yield toBytes(input.toString());
    return;
  }
  if (isBlob(input)) {
    yield* (0, import_blob_to_it.default)(input);
    return;
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable.default)(input);
    const { value, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      yield Uint8Array.from(await (0, import_it_all3.default)(peekable));
      return;
    }
    if (isBytes(value) || typeof value === "string" || value instanceof String) {
      yield* (0, import_it_map2.default)(peekable, toBytes);
      return;
    }
  }
  throw (0, import_err_code12.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
function toBytes(chunk) {
  if (chunk instanceof Uint8Array) {
    return chunk;
  }
  if (ArrayBuffer.isView(chunk)) {
    return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
  }
  if (chunk instanceof ArrayBuffer) {
    return new Uint8Array(chunk);
  }
  if (Array.isArray(chunk)) {
    return Uint8Array.from(chunk);
  }
  return fromString3(chunk.toString());
}
var import_err_code12, import_browser_readablestream_to_it, import_blob_to_it, import_it_peekable, import_it_all3, import_it_map2;
var init_normalise_content = __esm({
  "node_modules/ipfs-core-utils/esm/src/files/normalise-content.js"() {
    init_node_globals();
    import_err_code12 = __toModule(require_err_code());
    init_from_string();
    import_browser_readablestream_to_it = __toModule(require_browser_readablestream_to_it());
    import_blob_to_it = __toModule(require_blob_to_it());
    import_it_peekable = __toModule(require_it_peekable());
    import_it_all3 = __toModule(require_it_all());
    import_it_map2 = __toModule(require_it_map());
    init_utils4();
  }
});

// node_modules/ipfs-core-utils/esm/src/files/normalise.js
async function* normalise(input, normaliseContent3) {
  if (input === null || input === void 0) {
    throw (0, import_err_code13.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  if (typeof input === "string" || input instanceof String) {
    yield toFileObject(input.toString(), normaliseContent3);
    return;
  }
  if (isBytes(input) || isBlob(input)) {
    yield toFileObject(input, normaliseContent3);
    return;
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it2.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable2.default)(input);
    const { value, done } = await peekable.peek();
    if (done) {
      yield* [];
      return;
    }
    peekable.push(value);
    if (Number.isInteger(value) || isBytes(value)) {
      yield toFileObject(peekable, normaliseContent3);
      return;
    }
    if (value._readableState) {
      yield* (0, import_it_map3.default)(peekable, (value2) => toFileObject({ content: value2 }, normaliseContent3));
      return;
    }
    if (isFileObject(value) || isBlob(value) || typeof value === "string" || value instanceof String) {
      yield* (0, import_it_map3.default)(peekable, (value2) => toFileObject(value2, normaliseContent3));
      return;
    }
    if (value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value)) {
      yield* (0, import_it_map3.default)(peekable, (value2) => toFileObject(value2, normaliseContent3));
      return;
    }
  }
  if (isFileObject(input)) {
    yield toFileObject(input, normaliseContent3);
    return;
  }
  throw (0, import_err_code13.default)(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
}
async function toFileObject(input, normaliseContent3) {
  const { path, mode, mtime, content } = input;
  const file = {
    path: path || "",
    mode: parseMode(mode),
    mtime: parseMtime(mtime)
  };
  if (content) {
    file.content = await normaliseContent3(content);
  } else if (!path) {
    file.content = await normaliseContent3(input);
  }
  return file;
}
var import_err_code13, import_browser_readablestream_to_it2, import_it_peekable2, import_it_map3;
var init_normalise = __esm({
  "node_modules/ipfs-core-utils/esm/src/files/normalise.js"() {
    init_node_globals();
    import_err_code13 = __toModule(require_err_code());
    import_browser_readablestream_to_it2 = __toModule(require_browser_readablestream_to_it());
    import_it_peekable2 = __toModule(require_it_peekable());
    import_it_map3 = __toModule(require_it_map());
    init_utils4();
    init_src();
  }
});

// node_modules/ipfs-core-utils/esm/src/files/normalise-input.js
var normalise_input_exports2 = {};
__export(normalise_input_exports2, {
  normaliseInput: () => normaliseInput2
});
function normaliseInput2(input) {
  return normalise(input, normaliseContent);
}
var init_normalise_input2 = __esm({
  "node_modules/ipfs-core-utils/esm/src/files/normalise-input.js"() {
    init_node_globals();
    init_normalise_content();
    init_normalise();
  }
});

// node_modules/ipfs-core/cjs/src/components/add-all/utils.js
var require_utils10 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/add-all/utils.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var parseChunkerString = (chunker) => {
      if (!chunker) {
        return { chunker: "fixed" };
      } else if (chunker.startsWith("size-")) {
        const sizeStr = chunker.split("-")[1];
        const size = parseInt(sizeStr);
        if (isNaN(size)) {
          throw new Error("Chunker parameter size must be an integer");
        }
        return {
          chunker: "fixed",
          maxChunkSize: size
        };
      } else if (chunker.startsWith("rabin")) {
        return {
          chunker: "rabin",
          ...parseRabinString(chunker)
        };
      } else {
        throw new Error(`Unrecognized chunker option: ${chunker}`);
      }
    };
    var parseRabinString = (chunker) => {
      const options = {};
      const parts = chunker.split("-");
      switch (parts.length) {
        case 1:
          options.avgChunkSize = 262144;
          break;
        case 2:
          options.avgChunkSize = parseChunkSize(parts[1], "avg");
          break;
        case 4:
          options.minChunkSize = parseChunkSize(parts[1], "min");
          options.avgChunkSize = parseChunkSize(parts[2], "avg");
          options.maxChunkSize = parseChunkSize(parts[3], "max");
          break;
        default:
          throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"');
      }
      return options;
    };
    var parseChunkSize = (str, name5) => {
      const size = parseInt(str);
      if (isNaN(size)) {
        throw new Error(`Chunker parameter ${name5} must be an integer`);
      }
      return size;
    };
    exports2.parseChunkSize = parseChunkSize;
    exports2.parseChunkerString = parseChunkerString;
    exports2.parseRabinString = parseRabinString;
  }
});

// node_modules/ipfs-core/cjs/src/components/add-all/index.js
var require_add_all2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/add-all/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipfsUnixfsImporter = (init_src8(), src_exports5);
    var normaliseInput4 = (init_normalise_input2(), normalise_input_exports2);
    var utils = require_utils10();
    var itPipe = require_it_pipe();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var mergeOpts = require_merge_options();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    function createAddAll3({ repo, preload: preload2, options }) {
      const isShardingEnabled = options && options.sharding;
      async function* addAll(source, options2 = {}) {
        const opts = mergeOptions2({
          shardSplitThreshold: isShardingEnabled ? 1e3 : Infinity,
          strategy: "balanced"
        }, options2, { ...utils.parseChunkerString(options2.chunker) });
        if (opts.hashAlg && opts.hashAlg !== "sha2-256" && opts.cidVersion !== 1) {
          opts.cidVersion = 1;
        }
        if (opts.trickle) {
          opts.strategy = "trickle";
        }
        if (opts.strategy === "trickle") {
          opts.leafType = "raw";
          opts.reduceSingleLeafToSelf = false;
        }
        if (opts.cidVersion > 0 && opts.rawLeaves === void 0) {
          opts.rawLeaves = true;
        }
        if (opts.hashAlg !== void 0 && opts.rawLeaves === void 0) {
          opts.rawLeaves = true;
        }
        delete opts.trickle;
        const totals = {};
        if (opts.progress) {
          const prog = opts.progress;
          opts.progress = (bytes3, path) => {
            if (!totals[path]) {
              totals[path] = 0;
            }
            totals[path] += bytes3;
            prog(totals[path], path);
          };
        }
        const iterator = itPipe.pipe(normaliseInput4.normaliseInput(source), (source2) => ipfsUnixfsImporter.importer(source2, repo.blocks, {
          ...opts,
          pin: false
        }), transformFile(opts), preloadFile(preload2, opts), pinFile(repo, opts));
        const releaseLock = await repo.gcLock.readLock();
        try {
          for await (const added of iterator) {
            delete totals[added.path];
            yield added;
          }
        } finally {
          releaseLock();
        }
      }
      return withTimeoutOption2.withTimeoutOption(addAll);
    }
    function transformFile(opts) {
      async function* transformFile2(source) {
        for await (const file of source) {
          let cid = file.cid;
          if (opts.cidVersion === 1) {
            cid = cid.toV1();
          }
          let path = file.path ? file.path : cid.toString();
          if (opts.wrapWithDirectory && !file.path) {
            path = "";
          }
          yield {
            path,
            cid,
            size: file.size,
            mode: file.unixfs && file.unixfs.mode,
            mtime: file.unixfs && file.unixfs.mtime
          };
        }
      }
      return transformFile2;
    }
    function preloadFile(preload2, opts) {
      async function* maybePreloadFile(source) {
        for await (const file of source) {
          const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === "" : !file.path.includes("/");
          const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;
          if (shouldPreload) {
            preload2(file.cid);
          }
          yield file;
        }
      }
      return maybePreloadFile;
    }
    function pinFile(repo, opts) {
      async function* maybePinFile(source) {
        for await (const file of source) {
          const isRootDir = !(file.path && file.path.includes("/"));
          const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;
          if (shouldPin) {
            await repo.pins.pinRecursively(file.cid);
          }
          yield file;
        }
      }
      return maybePinFile;
    }
    exports2.createAddAll = createAddAll3;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js
var import_hamt_sharding2, hashFn, addLinksToHamtBucket, toPrefix, toBucketPath, findShardCid, find_cid_in_shard_default;
var init_find_cid_in_shard = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/utils/find-cid-in-shard.js"() {
    init_node_globals();
    import_hamt_sharding2 = __toModule(require_src10());
    init_src2();
    init_esm2();
    hashFn = async function(buf2) {
      return (await murmur3128.encode(buf2)).slice(0, 8).reverse();
    };
    addLinksToHamtBucket = (links2, bucket, rootBucket) => {
      return Promise.all(links2.map((link) => {
        if (link.Name == null) {
          throw new Error("Unexpected Link without a Name");
        }
        if (link.Name.length === 2) {
          const pos = parseInt(link.Name, 16);
          return bucket._putObjectAt(pos, new import_hamt_sharding2.Bucket({
            hash: rootBucket._options.hash,
            bits: rootBucket._options.bits
          }, bucket, pos));
        }
        return rootBucket.put(link.Name.substring(2), true);
      }));
    };
    toPrefix = (position) => {
      return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
    };
    toBucketPath = (position) => {
      let bucket = position.bucket;
      const path = [];
      while (bucket._parent) {
        path.push(bucket);
        bucket = bucket._parent;
      }
      path.push(bucket);
      return path.reverse();
    };
    findShardCid = async (node, name5, blockstore, context, options) => {
      if (!context) {
        const rootBucket = (0, import_hamt_sharding2.createHAMT)({ hashFn });
        context = {
          rootBucket,
          hamtDepth: 1,
          lastBucket: rootBucket
        };
      }
      await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);
      const position = await context.rootBucket._findNewBucketAndPos(name5);
      let prefix = toPrefix(position.pos);
      const bucketPath = toBucketPath(position);
      if (bucketPath.length > context.hamtDepth) {
        context.lastBucket = bucketPath[context.hamtDepth];
        prefix = toPrefix(context.lastBucket._posAtParent);
      }
      const link = node.Links.find((link2) => {
        if (link2.Name == null) {
          return false;
        }
        const entryPrefix = link2.Name.substring(0, 2);
        const entryName = link2.Name.substring(2);
        if (entryPrefix !== prefix) {
          return false;
        }
        if (entryName && entryName !== name5) {
          return false;
        }
        return true;
      });
      if (!link) {
        return null;
      }
      if (link.Name != null && link.Name.substring(2) === name5) {
        return link.Hash;
      }
      context.hamtDepth++;
      const block = await blockstore.get(link.Hash, options);
      node = decode5(block);
      return findShardCid(node, name5, blockstore, context, options);
    };
    find_cid_in_shard_default = findShardCid;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/utils/extract-data-from-block.js
function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
  const blockLength = block.length;
  const blockEnd = blockStart + blockLength;
  if (requestedStart >= blockEnd || requestedEnd < blockStart) {
    return new Uint8Array(0);
  }
  if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
    block = block.slice(0, requestedEnd - blockStart);
  }
  if (requestedStart >= blockStart && requestedStart < blockEnd) {
    block = block.slice(requestedStart - blockStart);
  }
  return block;
}
var extract_data_from_block_default;
var init_extract_data_from_block = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/utils/extract-data-from-block.js"() {
    init_node_globals();
    extract_data_from_block_default = extractDataFromBlock;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/utils/validate-offset-and-length.js
var import_err_code14, validateOffsetAndLength, validate_offset_and_length_default;
var init_validate_offset_and_length = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/utils/validate-offset-and-length.js"() {
    init_node_globals();
    import_err_code14 = __toModule(require_err_code());
    validateOffsetAndLength = (size, offset, length4) => {
      if (!offset) {
        offset = 0;
      }
      if (offset < 0) {
        throw (0, import_err_code14.default)(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
      }
      if (offset > size) {
        throw (0, import_err_code14.default)(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
      }
      if (!length4 && length4 !== 0) {
        length4 = size - offset;
      }
      if (length4 < 0) {
        throw (0, import_err_code14.default)(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
      }
      if (offset + length4 > size) {
        length4 = size - offset;
      }
      return {
        offset,
        length: length4
      };
    };
    validate_offset_and_length_default = validateOffsetAndLength;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js
async function* emitBytes(blockstore, node, start, end, streamPosition = 0, options) {
  if (node instanceof Uint8Array) {
    const buf2 = extract_data_from_block_default(node, streamPosition, start, end);
    if (buf2.length) {
      yield buf2;
    }
    streamPosition += buf2.length;
    return streamPosition;
  }
  if (node.Data == null) {
    throw (0, import_err_code15.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
  }
  let file;
  try {
    file = UnixFS.unmarshal(node.Data);
  } catch (err) {
    throw (0, import_err_code15.default)(err, "ERR_NOT_UNIXFS");
  }
  if (file.data && file.data.length) {
    const buf2 = extract_data_from_block_default(file.data, streamPosition, start, end);
    if (buf2.length) {
      yield buf2;
    }
    streamPosition += file.data.length;
  }
  let childStart = streamPosition;
  for (let i = 0; i < node.Links.length; i++) {
    const childLink = node.Links[i];
    const childEnd = streamPosition + file.blockSizes[i];
    if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {
      const block = await blockstore.get(childLink.Hash, { signal: options.signal });
      let child;
      switch (childLink.Hash.code) {
        case code:
          child = await decode5(block);
          break;
        case code3:
          child = block;
          break;
        case code2:
          child = await decode7(block);
          break;
        default:
          throw Error(`Unsupported codec: ${childLink.Hash.code}`);
      }
      for await (const buf2 of emitBytes(blockstore, child, start, end, streamPosition, options)) {
        streamPosition += buf2.length;
        yield buf2;
      }
    }
    streamPosition = childEnd;
    childStart = childEnd + 1;
  }
}
var import_err_code15, fileContent, file_default2;
var init_file2 = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/file.js"() {
    init_node_globals();
    init_extract_data_from_block();
    init_validate_offset_and_length();
    init_src();
    import_err_code15 = __toModule(require_err_code());
    init_src2();
    init_esm();
    init_raw();
    fileContent = (cid, node, unixfs, path, resolve6, depth, blockstore) => {
      function yieldFileContent(options = {}) {
        const fileSize = unixfs.fileSize();
        if (fileSize === void 0) {
          throw new Error("File was a directory");
        }
        const { offset, length: length4 } = validate_offset_and_length_default(fileSize, options.offset, options.length);
        const start = offset;
        const end = offset + length4;
        return emitBytes(blockstore, node, start, end, 0, options);
      }
      return yieldFileContent;
    };
    file_default2 = fileContent;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/directory.js
var directoryContent, directory_default;
var init_directory = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/directory.js"() {
    init_node_globals();
    directoryContent = (cid, node, unixfs, path, resolve6, depth, blockstore) => {
      async function* yieldDirectoryContent(options = {}) {
        const offset = options.offset || 0;
        const length4 = options.length || node.Links.length;
        const links2 = node.Links.slice(offset, length4);
        for (const link of links2) {
          const result = await resolve6(link.Hash, link.Name || "", `${path}/${link.Name || ""}`, [], depth + 1, blockstore, options);
          if (result.entry) {
            yield result.entry;
          }
        }
      }
      return yieldDirectoryContent;
    };
    directory_default = directoryContent;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js
async function* listDirectory(node, path, resolve6, depth, blockstore, options) {
  const links2 = node.Links;
  for (const link of links2) {
    const name5 = link.Name != null ? link.Name.substring(2) : null;
    if (name5) {
      const result = await resolve6(link.Hash, name5, `${path}/${name5}`, [], depth + 1, blockstore, options);
      yield result.entry;
    } else {
      const block = await blockstore.get(link.Hash);
      node = decode5(block);
      for await (const file of listDirectory(node, path, resolve6, depth, blockstore, options)) {
        yield file;
      }
    }
  }
}
var hamtShardedDirectoryContent, hamt_sharded_directory_default;
var init_hamt_sharded_directory = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js"() {
    init_node_globals();
    init_src2();
    hamtShardedDirectoryContent = (cid, node, unixfs, path, resolve6, depth, blockstore) => {
      function yieldHamtDirectoryContent(options = {}) {
        return listDirectory(node, path, resolve6, depth, blockstore, options);
      }
      return yieldHamtDirectoryContent;
    };
    hamt_sharded_directory_default = hamtShardedDirectoryContent;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js
var import_err_code16, findLinkCid, contentExporters, unixFsResolver, unixfs_v1_default;
var init_unixfs_v1 = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/resolvers/unixfs-v1/index.js"() {
    init_node_globals();
    import_err_code16 = __toModule(require_err_code());
    init_src();
    init_find_cid_in_shard();
    init_src2();
    init_file2();
    init_directory();
    init_hamt_sharded_directory();
    findLinkCid = (node, name5) => {
      const link = node.Links.find((link2) => link2.Name === name5);
      return link && link.Hash;
    };
    contentExporters = {
      raw: file_default2,
      file: file_default2,
      directory: directory_default,
      "hamt-sharded-directory": hamt_sharded_directory_default,
      metadata: (cid, node, unixfs, path, resolve6, depth, blockstore) => {
        return () => [];
      },
      symlink: (cid, node, unixfs, path, resolve6, depth, blockstore) => {
        return () => [];
      }
    };
    unixFsResolver = async (cid, name5, path, toResolve, resolve6, depth, blockstore, options) => {
      const block = await blockstore.get(cid, options);
      const node = decode5(block);
      let unixfs;
      let next;
      if (!name5) {
        name5 = cid.toString();
      }
      if (node.Data == null) {
        throw (0, import_err_code16.default)(new Error("no data in PBNode"), "ERR_NOT_UNIXFS");
      }
      try {
        unixfs = UnixFS.unmarshal(node.Data);
      } catch (err) {
        throw (0, import_err_code16.default)(err, "ERR_NOT_UNIXFS");
      }
      if (!path) {
        path = name5;
      }
      if (toResolve.length) {
        let linkCid;
        if (unixfs && unixfs.type === "hamt-sharded-directory") {
          linkCid = await find_cid_in_shard_default(node, toResolve[0], blockstore);
        } else {
          linkCid = findLinkCid(node, toResolve[0]);
        }
        if (!linkCid) {
          throw (0, import_err_code16.default)(new Error("file does not exist"), "ERR_NOT_FOUND");
        }
        const nextName = toResolve.shift();
        const nextPath = `${path}/${nextName}`;
        next = {
          cid: linkCid,
          toResolve,
          name: nextName || "",
          path: nextPath
        };
      }
      return {
        entry: {
          type: unixfs.isDirectory() ? "directory" : "file",
          name: name5,
          path,
          cid,
          content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve6, depth, blockstore),
          unixfs,
          depth,
          node,
          size: unixfs.fileSize()
        },
        next
      };
    };
    unixfs_v1_default = unixFsResolver;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/raw.js
var import_err_code17, rawContent, resolve, raw_default;
var init_raw2 = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/resolvers/raw.js"() {
    init_node_globals();
    import_err_code17 = __toModule(require_err_code());
    init_extract_data_from_block();
    init_validate_offset_and_length();
    rawContent = (node) => {
      async function* contentGenerator(options = {}) {
        const { offset, length: length4 } = validate_offset_and_length_default(node.length, options.offset, options.length);
        yield extract_data_from_block_default(node, 0, offset, offset + length4);
      }
      return contentGenerator;
    };
    resolve = async (cid, name5, path, toResolve, resolve6, depth, blockstore, options) => {
      if (toResolve.length) {
        throw (0, import_err_code17.default)(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
      }
      const block = await blockstore.get(cid, options);
      return {
        entry: {
          type: "raw",
          name: name5,
          path,
          cid,
          content: rawContent(block),
          depth,
          size: block.length,
          node: block
        }
      };
    };
    raw_default = resolve;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/dag-cbor.js
var import_err_code18, resolve2, dag_cbor_default;
var init_dag_cbor = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/resolvers/dag-cbor.js"() {
    init_node_globals();
    init_cid();
    import_err_code18 = __toModule(require_err_code());
    init_esm();
    resolve2 = async (cid, name5, path, toResolve, resolve6, depth, blockstore, options) => {
      const block = await blockstore.get(cid);
      const object = decode7(block);
      let subObject = object;
      let subPath = path;
      while (toResolve.length) {
        const prop = toResolve[0];
        if (prop in subObject) {
          toResolve.shift();
          subPath = `${subPath}/${prop}`;
          const subObjectCid = CID.asCID(subObject[prop]);
          if (subObjectCid) {
            return {
              entry: {
                type: "object",
                name: name5,
                path,
                cid,
                node: block,
                depth,
                size: block.length,
                content: async function* () {
                  yield object;
                }
              },
              next: {
                cid: subObjectCid,
                name: prop,
                path: subPath,
                toResolve
              }
            };
          }
          subObject = subObject[prop];
        } else {
          throw (0, import_err_code18.default)(new Error(`No property named ${prop} found in cbor node ${cid}`), "ERR_NO_PROP");
        }
      }
      return {
        entry: {
          type: "object",
          name: name5,
          path,
          cid,
          node: block,
          depth,
          size: block.length,
          content: async function* () {
            yield object;
          }
        }
      };
    };
    dag_cbor_default = resolve2;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/identity.js
var import_err_code19, rawContent2, resolve3, identity_default;
var init_identity3 = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/resolvers/identity.js"() {
    init_node_globals();
    import_err_code19 = __toModule(require_err_code());
    init_extract_data_from_block();
    init_validate_offset_and_length();
    init_digest();
    rawContent2 = (node) => {
      async function* contentGenerator(options = {}) {
        const { offset, length: length4 } = validate_offset_and_length_default(node.length, options.offset, options.length);
        yield extract_data_from_block_default(node, 0, offset, offset + length4);
      }
      return contentGenerator;
    };
    resolve3 = async (cid, name5, path, toResolve, resolve6, depth, blockstore, options) => {
      if (toResolve.length) {
        throw (0, import_err_code19.default)(new Error(`No link named ${path} found in raw node ${cid}`), "ERR_NOT_FOUND");
      }
      const buf2 = await decode3(cid.multihash.bytes);
      return {
        entry: {
          type: "identity",
          name: name5,
          path,
          cid,
          content: rawContent2(buf2.digest),
          depth,
          size: buf2.digest.length,
          node: buf2.digest
        }
      };
    };
    identity_default = resolve3;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/resolvers/index.js
function resolve4(cid, name5, path, toResolve, depth, blockstore, options) {
  const resolver = resolvers[cid.code];
  if (!resolver) {
    throw (0, import_err_code20.default)(new Error(`No resolver for code ${cid.code}`), "ERR_NO_RESOLVER");
  }
  return resolver(cid, name5, path, toResolve, resolve4, depth, blockstore, options);
}
var import_err_code20, resolvers, resolvers_default;
var init_resolvers = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/resolvers/index.js"() {
    init_node_globals();
    import_err_code20 = __toModule(require_err_code());
    init_src2();
    init_esm();
    init_raw();
    init_identity();
    init_unixfs_v1();
    init_raw2();
    init_dag_cbor();
    init_identity3();
    resolvers = {
      [code]: unixfs_v1_default,
      [code3]: raw_default,
      [code2]: dag_cbor_default,
      [identity.code]: identity_default
    };
    resolvers_default = resolve4;
  }
});

// node_modules/ipfs-unixfs-exporter/esm/src/index.js
var src_exports6 = {};
__export(src_exports6, {
  exporter: () => exporter,
  recursive: () => recursive,
  walkPath: () => walkPath
});
async function* walkPath(path, blockstore, options = {}) {
  let { cid, toResolve } = cidAndRest(path);
  let name5 = cid.toString();
  let entryPath = name5;
  const startingDepth = toResolve.length;
  while (true) {
    const result = await resolvers_default(cid, name5, entryPath, toResolve, startingDepth, blockstore, options);
    if (!result.entry && !result.next) {
      throw (0, import_err_code21.default)(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
    }
    if (result.entry) {
      yield result.entry;
    }
    if (!result.next) {
      return;
    }
    toResolve = result.next.toResolve;
    cid = result.next.cid;
    name5 = result.next.name;
    entryPath = result.next.path;
  }
}
async function exporter(path, blockstore, options = {}) {
  const result = await (0, import_it_last.default)(walkPath(path, blockstore, options));
  if (!result) {
    throw (0, import_err_code21.default)(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
  }
  return result;
}
async function* recursive(path, blockstore, options = {}) {
  const node = await exporter(path, blockstore, options);
  if (!node) {
    return;
  }
  yield node;
  if (node.type === "directory") {
    for await (const child of recurse(node, options)) {
      yield child;
    }
  }
  async function* recurse(node2, options2) {
    for await (const file of node2.content(options2)) {
      yield file;
      if (file instanceof Uint8Array) {
        continue;
      }
      if (file.type === "directory") {
        yield* recurse(file, options2);
      }
    }
  }
}
var import_err_code21, import_it_last, toPathComponents2, cidAndRest;
var init_src9 = __esm({
  "node_modules/ipfs-unixfs-exporter/esm/src/index.js"() {
    init_node_globals();
    import_err_code21 = __toModule(require_err_code());
    init_cid();
    init_resolvers();
    import_it_last = __toModule(require_it_last());
    toPathComponents2 = (path = "") => {
      return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
    };
    cidAndRest = (path) => {
      if (path instanceof Uint8Array) {
        return {
          cid: CID.decode(path),
          toResolve: []
        };
      }
      const cid = CID.asCID(path);
      if (cid) {
        return {
          cid,
          toResolve: []
        };
      }
      if (typeof path === "string") {
        if (path.indexOf("/ipfs/") === 0) {
          path = path.substring(6);
        }
        const output = toPathComponents2(path);
        return {
          cid: CID.parse(output[0]),
          toResolve: output.slice(1)
        };
      }
      throw (0, import_err_code21.default)(new Error(`Unknown path type ${path}`), "ERR_BAD_PATH");
    };
  }
});

// node_modules/ipfs-core/cjs/src/components/cat.js
var require_cat = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/cat.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipfsUnixfsExporter = (init_src9(), src_exports6);
    var utils = require_utils();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var cid = (init_cid(), cid_exports);
    function createCat2({ repo, preload: preload2 }) {
      async function* cat(ipfsPath2, options = {}) {
        ipfsPath2 = utils.normalizeCidPath(ipfsPath2);
        if (options.preload !== false) {
          const pathComponents = ipfsPath2.split("/");
          preload2(cid.CID.parse(pathComponents[0]));
        }
        const file = await ipfsUnixfsExporter.exporter(ipfsPath2, repo.blocks, options);
        if (file.type === "directory") {
          throw new Error("this dag node is a directory");
        }
        if (!file.content) {
          throw new Error("this dag node has no content");
        }
        yield* file.content(options);
      }
      return withTimeoutOption2.withTimeoutOption(cat);
    }
    exports2.createCat = createCat2;
  }
});

// node_modules/it-tar/extract-headers.js
var require_extract_headers = __commonJS({
  "node_modules/it-tar/extract-headers.js"(exports2) {
    init_node_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var BufferList3 = require_BufferList();
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR_MAGIC = Buffer2.from("ustar\0", "binary");
    var GNU_MAGIC = Buffer2.from("ustar ", "binary");
    var GNU_VER = Buffer2.from(" \0", "binary");
    var MAGIC_OFFSET = 257;
    var VERSION_OFFSET = 263;
    var clamp = function(index, len, defaultValue) {
      if (typeof index !== "number")
        return defaultValue;
      index = ~~index;
      if (index >= len)
        return len;
      if (index >= 0)
        return index;
      index += len;
      if (index >= 0)
        return index;
      return 0;
    };
    var toType = function(flag) {
      switch (flag) {
        case 0:
          return "file";
        case 1:
          return "link";
        case 2:
          return "symlink";
        case 3:
          return "character-device";
        case 4:
          return "block-device";
        case 5:
          return "directory";
        case 6:
          return "fifo";
        case 7:
          return "contiguous-file";
        case 72:
          return "pax-header";
        case 55:
          return "pax-global-header";
        case 27:
          return "gnu-long-link-path";
        case 28:
        case 30:
          return "gnu-long-path";
      }
      return null;
    };
    var indexOf = function(block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block.get(offset) === num)
          return offset;
      }
      return end;
    };
    var cksum = function(block) {
      let sum = 8 * 32;
      for (let i = 0; i < 148; i++)
        sum += block.get(i);
      for (let j = 156; j < 512; j++)
        sum += block.get(j);
      return sum;
    };
    function parse256(buf2) {
      let positive;
      if (buf2.get(0) === 128)
        positive = true;
      else if (buf2.get(0) === 255)
        positive = false;
      else
        return null;
      let zero = false;
      const tuple = [];
      for (let i = buf2.length - 1; i > 0; i--) {
        const byte = buf2.get(i);
        if (positive)
          tuple.push(byte);
        else if (zero && byte === 0)
          tuple.push(0);
        else if (zero) {
          zero = false;
          tuple.push(256 - byte);
        } else
          tuple.push(255 - byte);
      }
      let sum = 0;
      const l = tuple.length;
      for (let i = 0; i < l; i++) {
        sum += tuple[i] * Math.pow(256, i);
      }
      return positive ? sum : -1 * sum;
    }
    var decodeOct = function(val, offset, length4) {
      val = val.shallowSlice(offset, offset + length4);
      offset = 0;
      if (val.get(offset) & 128) {
        return parse256(val);
      } else {
        while (offset < val.length && val.get(offset) === 32)
          offset++;
        const end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while (offset < end && val.get(offset) === 0)
          offset++;
        if (end === offset)
          return 0;
        return parseInt(val.shallowSlice(offset, end).toString(), 8);
      }
    };
    var decodeStr = function(val, offset, length4, encoding) {
      return val.shallowSlice(offset, indexOf(val, 0, offset, offset + length4)).toString(encoding);
    };
    exports2.decodeLongPath = function(buf2, encoding) {
      buf2 = BufferList3.isBufferList(buf2) ? buf2 : new BufferList3(buf2);
      return decodeStr(buf2, 0, buf2.length, encoding);
    };
    exports2.decodePax = function(buf2) {
      buf2 = BufferList3.isBufferList(buf2) ? buf2 : new BufferList3(buf2);
      const result = {};
      while (buf2.length) {
        let i = 0;
        while (i < buf2.length && buf2.get(i) !== 32)
          i++;
        const len = parseInt(buf2.shallowSlice(0, i).toString(), 10);
        if (!len)
          return result;
        const b = buf2.shallowSlice(i + 1, len - 1).toString();
        const keyIndex = b.indexOf("=");
        if (keyIndex === -1)
          return result;
        result[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf2 = buf2.shallowSlice(len);
      }
      return result;
    };
    exports2.decode = function(buf2, filenameEncoding) {
      buf2 = BufferList3.isBufferList(buf2) ? buf2 : new BufferList3(buf2);
      let typeflag = buf2.get(156) === 0 ? 0 : buf2.get(156) - ZERO_OFFSET;
      let name5 = decodeStr(buf2, 0, 100, filenameEncoding);
      const mode = decodeOct(buf2, 100, 8);
      const uid = decodeOct(buf2, 108, 8);
      const gid = decodeOct(buf2, 116, 8);
      const size = decodeOct(buf2, 124, 12);
      const mtime = decodeOct(buf2, 136, 12);
      const type = toType(typeflag);
      const linkname = buf2.get(157) === 0 ? null : decodeStr(buf2, 157, 100, filenameEncoding);
      const uname = decodeStr(buf2, 265, 32);
      const gname = decodeStr(buf2, 297, 32);
      const devmajor = decodeOct(buf2, 329, 8);
      const devminor = decodeOct(buf2, 337, 8);
      const c = cksum(buf2);
      if (c === 8 * 32)
        return null;
      if (c !== decodeOct(buf2, 148, 8))
        throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
      if (USTAR_MAGIC.compare(buf2.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0) {
        if (buf2.get(345))
          name5 = decodeStr(buf2, 345, 155, filenameEncoding) + "/" + name5;
      } else if (GNU_MAGIC.compare(buf2.slice(MAGIC_OFFSET, MAGIC_OFFSET + 6)) === 0 && GNU_VER.compare(buf2.slice(VERSION_OFFSET, VERSION_OFFSET + 2)) === 0) {
      } else {
        throw new Error("Invalid tar header: unknown format.");
      }
      if (typeflag === 0 && name5 && name5[name5.length - 1] === "/")
        typeflag = 5;
      return {
        name: name5,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1e3 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor
      };
    };
  }
});

// node_modules/it-reader/index.js
var require_it_reader = __commonJS({
  "node_modules/it-reader/index.js"(exports2, module2) {
    init_node_globals();
    var BufferList3 = require_BufferList();
    module2.exports = (source) => {
      const reader = async function* () {
        let bytes3 = yield;
        let bl = new BufferList3();
        for await (const chunk of source) {
          if (!bytes3) {
            bytes3 = yield bl.append(chunk);
            bl = new BufferList3();
            continue;
          }
          bl.append(chunk);
          while (bl.length >= bytes3) {
            const data = bl.shallowSlice(0, bytes3);
            bl.consume(bytes3);
            bytes3 = yield data;
            if (!bytes3) {
              if (bl.length) {
                bytes3 = yield bl;
                bl = new BufferList3();
              }
              break;
            }
          }
        }
        if (bytes3) {
          throw Object.assign(new Error(`stream ended before ${bytes3} bytes became available`), { code: "ERR_UNDER_READ", buffer: bl });
        }
      }();
      reader.next();
      return reader;
    };
  }
});

// node_modules/it-tar/lte-reader.js
var require_lte_reader = __commonJS({
  "node_modules/it-tar/lte-reader.js"(exports2, module2) {
    init_node_globals();
    var BufferList3 = require_BufferList();
    var Reader = require_it_reader();
    module2.exports = function LteReader(source) {
      const reader = Reader(source);
      let overflow;
      const lteReader = {
        [Symbol.asyncIterator]: () => lteReader,
        async next(bytes3) {
          if (overflow) {
            let value;
            if (bytes3 == null || overflow.length === bytes3) {
              value = overflow;
              overflow = null;
            } else if (overflow.length > bytes3) {
              value = overflow.shallowSlice(0, bytes3);
              overflow = overflow.shallowSlice(bytes3);
            } else if (overflow.length < bytes3) {
              const { value: nextValue, done } = await reader.next(bytes3 - overflow.length);
              if (done) {
                throw Object.assign(new Error(`stream ended before ${bytes3 - overflow.length} bytes became available`), { code: "ERR_UNDER_READ" });
              }
              value = new BufferList3([overflow, nextValue]);
              overflow = null;
            }
            return { value };
          }
          return reader.next(bytes3);
        },
        async nextLte(bytes3) {
          let { done, value } = await lteReader.next();
          if (done)
            return { done };
          if (value.length <= bytes3)
            return { value };
          value = BufferList3.isBufferList(value) ? value : new BufferList3(value);
          if (overflow) {
            overflow.append(value.shallowSlice(bytes3));
          } else {
            overflow = value.shallowSlice(bytes3);
          }
          return { value: value.shallowSlice(0, bytes3) };
        },
        return() {
          return reader.return();
        }
      };
      return lteReader;
    };
  }
});

// node_modules/it-tar/extract.js
var require_extract = __commonJS({
  "node_modules/it-tar/extract.js"(exports2, module2) {
    init_node_globals();
    var defer = require_p_defer();
    var Headers = require_extract_headers();
    var LteReader = require_lte_reader();
    function getPadding(size) {
      size &= 511;
      return size && 512 - size;
    }
    async function discardPadding(reader, size) {
      const overflow = getPadding(size);
      if (overflow)
        await reader.next(overflow);
    }
    module2.exports = (options) => {
      options = options || {};
      options.highWaterMark = options.highWaterMark || 1024 * 16;
      return (source) => async function* () {
        const reader = LteReader(source);
        let gnuLongPath, gnuLongLinkPath, paxGlobal, pax;
        try {
          while (true) {
            let headerBytes;
            try {
              const { done, value } = await reader.next(512);
              if (done)
                return;
              headerBytes = value;
            } catch (err) {
              if (err.code === "ERR_UNDER_READ")
                return;
              throw err;
            }
            const header = Headers.decode(headerBytes, options.filenameEncoding);
            if (!header)
              continue;
            if (header.type === "gnu-long-path") {
              const { done, value: gnuLongPathBytes } = await reader.next(header.size);
              if (done)
                return;
              gnuLongPath = Headers.decodeLongPath(gnuLongPathBytes, options.filenameEncoding);
              await discardPadding(reader, header.size);
              continue;
            }
            if (header.type === "gnu-long-link-path") {
              const { done, value: gnuLongLinkPathBytes } = await reader.next(header.size);
              if (done)
                return;
              gnuLongLinkPath = Headers.decodeLongPath(gnuLongLinkPathBytes, options.filenameEncoding);
              await discardPadding(reader, header.size);
              continue;
            }
            if (header.type === "pax-global-header") {
              const { done, value: paxGlobalBytes } = await reader.next(header.size);
              if (done)
                return;
              paxGlobal = Headers.decodePax(paxGlobalBytes, options.filenameEncoding);
              await discardPadding(reader, header.size);
              continue;
            }
            if (header.type === "pax-header") {
              const { done, value: paxBytes } = await reader.next(header.size);
              if (done)
                return;
              pax = Headers.decodePax(paxBytes, options.filenameEncoding);
              if (paxGlobal)
                pax = { ...paxGlobal, ...pax };
              await discardPadding(reader, header.size);
              continue;
            }
            if (gnuLongPath) {
              header.name = gnuLongPath;
              gnuLongPath = null;
            }
            if (gnuLongLinkPath) {
              header.linkname = gnuLongLinkPath;
              gnuLongLinkPath = null;
            }
            if (pax) {
              if (pax.path)
                header.name = pax.path;
              if (pax.linkpath)
                header.linkname = pax.linkpath;
              if (pax.size)
                header.size = parseInt(pax.size, 10);
              header.pax = pax;
              pax = null;
            }
            if (!header.size || header.type === "directory") {
              yield { header, body: async function* () {
              }() };
              continue;
            }
            let bytesRemaining = header.size;
            const bodyConsumed = defer();
            const firstChunk = await reader.nextLte(Math.min(bytesRemaining, options.highWaterMark));
            bytesRemaining -= firstChunk.value.length;
            if (!bytesRemaining)
              bodyConsumed.resolve();
            const body = async function* () {
              try {
                yield firstChunk.value;
                while (bytesRemaining) {
                  const { done, value } = await reader.nextLte(bytesRemaining);
                  if (done) {
                    bytesRemaining = 0;
                    return;
                  }
                  bytesRemaining -= value.length;
                  yield value;
                }
              } finally {
                bodyConsumed.resolve();
              }
            }();
            yield { header, body };
            await bodyConsumed.promise;
            if (bytesRemaining) {
              for await (const _ of body) {
              }
            }
            await discardPadding(reader, header.size);
          }
        } finally {
          await reader.return();
        }
      }();
    };
  }
});

// node_modules/iso-constants/index.browser.js
var require_index_browser2 = __commonJS({
  "node_modules/iso-constants/index.browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {
      "E2BIG": 7,
      "EACCES": 13,
      "EADDRINUSE": 100,
      "EADDRNOTAVAIL": 101,
      "EAFNOSUPPORT": 102,
      "EAGAIN": 11,
      "EALREADY": 103,
      "EBADF": 9,
      "EBADMSG": 104,
      "EBUSY": 16,
      "ECANCELED": 105,
      "ECHILD": 10,
      "ECONNABORTED": 106,
      "ECONNREFUSED": 107,
      "ECONNRESET": 108,
      "EDEADLK": 36,
      "EDESTADDRREQ": 109,
      "EDOM": 33,
      "EEXIST": 17,
      "EFAULT": 14,
      "EFBIG": 27,
      "EHOSTUNREACH": 110,
      "EIDRM": 111,
      "EILSEQ": 42,
      "EINPROGRESS": 112,
      "EINTR": 4,
      "EINVAL": 22,
      "EIO": 5,
      "EISCONN": 113,
      "EISDIR": 21,
      "ELOOP": 114,
      "EMFILE": 24,
      "EMLINK": 31,
      "EMSGSIZE": 115,
      "ENAMETOOLONG": 38,
      "ENETDOWN": 116,
      "ENETRESET": 117,
      "ENETUNREACH": 118,
      "ENFILE": 23,
      "ENOBUFS": 119,
      "ENODATA": 120,
      "ENODEV": 19,
      "ENOENT": 2,
      "ENOEXEC": 8,
      "ENOLCK": 39,
      "ENOLINK": 121,
      "ENOMEM": 12,
      "ENOMSG": 122,
      "ENOPROTOOPT": 123,
      "ENOSPC": 28,
      "ENOSR": 124,
      "ENOSTR": 125,
      "ENOSYS": 40,
      "ENOTCONN": 126,
      "ENOTDIR": 20,
      "ENOTEMPTY": 41,
      "ENOTSOCK": 128,
      "ENOTSUP": 129,
      "ENOTTY": 25,
      "ENXIO": 6,
      "EOPNOTSUPP": 130,
      "EOVERFLOW": 132,
      "EPERM": 1,
      "EPIPE": 32,
      "EPROTO": 134,
      "EPROTONOSUPPORT": 135,
      "EPROTOTYPE": 136,
      "ERANGE": 34,
      "EROFS": 30,
      "ESPIPE": 29,
      "ESRCH": 3,
      "ETIME": 137,
      "ETIMEDOUT": 138,
      "ETXTBSY": 139,
      "EWOULDBLOCK": 140,
      "EXDEV": 18,
      "WSAEINTR": 10004,
      "WSAEBADF": 10009,
      "WSAEACCES": 10013,
      "WSAEFAULT": 10014,
      "WSAEINVAL": 10022,
      "WSAEMFILE": 10024,
      "WSAEWOULDBLOCK": 10035,
      "WSAEINPROGRESS": 10036,
      "WSAEALREADY": 10037,
      "WSAENOTSOCK": 10038,
      "WSAEDESTADDRREQ": 10039,
      "WSAEMSGSIZE": 10040,
      "WSAEPROTOTYPE": 10041,
      "WSAENOPROTOOPT": 10042,
      "WSAEPROTONOSUPPORT": 10043,
      "WSAESOCKTNOSUPPORT": 10044,
      "WSAEOPNOTSUPP": 10045,
      "WSAEPFNOSUPPORT": 10046,
      "WSAEAFNOSUPPORT": 10047,
      "WSAEADDRINUSE": 10048,
      "WSAEADDRNOTAVAIL": 10049,
      "WSAENETDOWN": 10050,
      "WSAENETUNREACH": 10051,
      "WSAENETRESET": 10052,
      "WSAECONNABORTED": 10053,
      "WSAECONNRESET": 10054,
      "WSAENOBUFS": 10055,
      "WSAEISCONN": 10056,
      "WSAENOTCONN": 10057,
      "WSAESHUTDOWN": 10058,
      "WSAETOOMANYREFS": 10059,
      "WSAETIMEDOUT": 10060,
      "WSAECONNREFUSED": 10061,
      "WSAELOOP": 10062,
      "WSAENAMETOOLONG": 10063,
      "WSAEHOSTDOWN": 10064,
      "WSAEHOSTUNREACH": 10065,
      "WSAENOTEMPTY": 10066,
      "WSAEPROCLIM": 10067,
      "WSAEUSERS": 10068,
      "WSAEDQUOT": 10069,
      "WSAESTALE": 10070,
      "WSAEREMOTE": 10071,
      "WSASYSNOTREADY": 10091,
      "WSAVERNOTSUPPORTED": 10092,
      "WSANOTINITIALISED": 10093,
      "WSAEDISCON": 10101,
      "WSAENOMORE": 10102,
      "WSAECANCELLED": 10103,
      "WSAEINVALIDPROCTABLE": 10104,
      "WSAEINVALIDPROVIDER": 10105,
      "WSAEPROVIDERFAILEDINIT": 10106,
      "WSASYSCALLFAILURE": 10107,
      "WSASERVICE_NOT_FOUND": 10108,
      "WSATYPE_NOT_FOUND": 10109,
      "WSA_E_NO_MORE": 10110,
      "WSA_E_CANCELLED": 10111,
      "WSAEREFUSED": 10112,
      "PRIORITY_LOW": 19,
      "PRIORITY_BELOW_NORMAL": 10,
      "PRIORITY_NORMAL": 0,
      "PRIORITY_ABOVE_NORMAL": -7,
      "PRIORITY_HIGH": -14,
      "PRIORITY_HIGHEST": -20,
      "SIGHUP": 1,
      "SIGINT": 2,
      "SIGILL": 4,
      "SIGABRT": 22,
      "SIGFPE": 8,
      "SIGKILL": 9,
      "SIGSEGV": 11,
      "SIGTERM": 15,
      "SIGBREAK": 21,
      "SIGWINCH": 28,
      "UV_FS_SYMLINK_DIR": 1,
      "UV_FS_SYMLINK_JUNCTION": 2,
      "O_RDONLY": 0,
      "O_WRONLY": 1,
      "O_RDWR": 2,
      "UV_DIRENT_UNKNOWN": 0,
      "UV_DIRENT_FILE": 1,
      "UV_DIRENT_DIR": 2,
      "UV_DIRENT_LINK": 3,
      "UV_DIRENT_FIFO": 4,
      "UV_DIRENT_SOCKET": 5,
      "UV_DIRENT_CHAR": 6,
      "UV_DIRENT_BLOCK": 7,
      "S_IFMT": 61440,
      "S_IFREG": 32768,
      "S_IFDIR": 16384,
      "S_IFCHR": 8192,
      "S_IFLNK": 40960,
      "O_CREAT": 256,
      "O_EXCL": 1024,
      "UV_FS_O_FILEMAP": 536870912,
      "O_TRUNC": 512,
      "O_APPEND": 8,
      "F_OK": 0,
      "R_OK": 4,
      "W_OK": 2,
      "X_OK": 1,
      "UV_FS_COPYFILE_EXCL": 1,
      "COPYFILE_EXCL": 1,
      "UV_FS_COPYFILE_FICLONE": 2,
      "COPYFILE_FICLONE": 2,
      "UV_FS_COPYFILE_FICLONE_FORCE": 4,
      "COPYFILE_FICLONE_FORCE": 4,
      "OPENSSL_VERSION_NUMBER": 269488319,
      "SSL_OP_ALL": 2147485780,
      "SSL_OP_ALLOW_NO_DHE_KEX": 1024,
      "SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION": 262144,
      "SSL_OP_CIPHER_SERVER_PREFERENCE": 4194304,
      "SSL_OP_CISCO_ANYCONNECT": 32768,
      "SSL_OP_COOKIE_EXCHANGE": 8192,
      "SSL_OP_CRYPTOPRO_TLSEXT_BUG": 2147483648,
      "SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS": 2048,
      "SSL_OP_EPHEMERAL_RSA": 0,
      "SSL_OP_LEGACY_SERVER_CONNECT": 4,
      "SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER": 0,
      "SSL_OP_MICROSOFT_SESS_ID_BUG": 0,
      "SSL_OP_MSIE_SSLV2_RSA_PADDING": 0,
      "SSL_OP_NETSCAPE_CA_DN_BUG": 0,
      "SSL_OP_NETSCAPE_CHALLENGE_BUG": 0,
      "SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG": 0,
      "SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG": 0,
      "SSL_OP_NO_COMPRESSION": 131072,
      "SSL_OP_NO_ENCRYPT_THEN_MAC": 524288,
      "SSL_OP_NO_QUERY_MTU": 4096,
      "SSL_OP_NO_RENEGOTIATION": 1073741824,
      "SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION": 65536,
      "SSL_OP_NO_SSLv2": 0,
      "SSL_OP_NO_SSLv3": 33554432,
      "SSL_OP_NO_TICKET": 16384,
      "SSL_OP_NO_TLSv1": 67108864,
      "SSL_OP_NO_TLSv1_1": 268435456,
      "SSL_OP_NO_TLSv1_2": 134217728,
      "SSL_OP_NO_TLSv1_3": 536870912,
      "SSL_OP_PKCS1_CHECK_1": 0,
      "SSL_OP_PKCS1_CHECK_2": 0,
      "SSL_OP_PRIORITIZE_CHACHA": 2097152,
      "SSL_OP_SINGLE_DH_USE": 0,
      "SSL_OP_SINGLE_ECDH_USE": 0,
      "SSL_OP_SSLEAY_080_CLIENT_DH_BUG": 0,
      "SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG": 0,
      "SSL_OP_TLS_BLOCK_PADDING_BUG": 0,
      "SSL_OP_TLS_D5_BUG": 0,
      "SSL_OP_TLS_ROLLBACK_BUG": 8388608,
      "ENGINE_METHOD_RSA": 1,
      "ENGINE_METHOD_DSA": 2,
      "ENGINE_METHOD_DH": 4,
      "ENGINE_METHOD_RAND": 8,
      "ENGINE_METHOD_EC": 2048,
      "ENGINE_METHOD_CIPHERS": 64,
      "ENGINE_METHOD_DIGESTS": 128,
      "ENGINE_METHOD_PKEY_METHS": 512,
      "ENGINE_METHOD_PKEY_ASN1_METHS": 1024,
      "ENGINE_METHOD_ALL": 65535,
      "ENGINE_METHOD_NONE": 0,
      "DH_CHECK_P_NOT_SAFE_PRIME": 2,
      "DH_CHECK_P_NOT_PRIME": 1,
      "DH_UNABLE_TO_CHECK_GENERATOR": 4,
      "DH_NOT_SUITABLE_GENERATOR": 8,
      "ALPN_ENABLED": 1,
      "RSA_PKCS1_PADDING": 1,
      "RSA_SSLV23_PADDING": 2,
      "RSA_NO_PADDING": 3,
      "RSA_PKCS1_OAEP_PADDING": 4,
      "RSA_X931_PADDING": 5,
      "RSA_PKCS1_PSS_PADDING": 6,
      "RSA_PSS_SALTLEN_DIGEST": -1,
      "RSA_PSS_SALTLEN_MAX_SIGN": -2,
      "RSA_PSS_SALTLEN_AUTO": -2,
      "defaultCoreCipherList": "TLS_AES_256_GCM_SHA384:TLS_CHACHA20_POLY1305_SHA256:TLS_AES_128_GCM_SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA256:ECDHE-RSA-AES256-SHA384:DHE-RSA-AES256-SHA384:ECDHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA256:HIGH:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!SRP:!CAMELLIA",
      "TLS1_VERSION": 769,
      "TLS1_1_VERSION": 770,
      "TLS1_2_VERSION": 771,
      "TLS1_3_VERSION": 772,
      "POINT_CONVERSION_COMPRESSED": 2,
      "POINT_CONVERSION_UNCOMPRESSED": 4,
      "POINT_CONVERSION_HYBRID": 6
    };
  }
});

// node_modules/it-concat/index.js
var require_it_concat = __commonJS({
  "node_modules/it-concat/index.js"(exports2, module2) {
    init_node_globals();
    var BufferList3 = require_BufferList();
    var TypeDefault = {
      string: () => "",
      buffer: () => BufferList3()
    };
    module2.exports = async (source, options) => {
      options = options || {};
      if (options.type && !TypeDefault[options.type]) {
        throw new Error(`invalid type "${options.type}"`);
      }
      let res, type;
      for await (const chunk of source) {
        if (!res) {
          type = options.type || (typeof chunk === "string" ? "string" : "buffer");
          res = TypeDefault[type]();
        }
        if (type === "string") {
          res += chunk;
        } else {
          res.append(chunk);
        }
      }
      return res || TypeDefault[options.type || "buffer"]();
    };
  }
});

// node_modules/it-tar/pack-headers.js
var require_pack_headers = __commonJS({
  "node_modules/it-tar/pack-headers.js"(exports2) {
    init_node_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var alloc2 = Buffer2.alloc;
    var ZEROS = "0000000000000000000";
    var SEVENS = "7777777777777777777";
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR_MAGIC = Buffer2.from("ustar\0", "binary");
    var USTAR_VER = Buffer2.from("00", "binary");
    var MASK = parseInt("7777", 8);
    var MAGIC_OFFSET = 257;
    var VERSION_OFFSET = 263;
    var toTypeflag = function(flag) {
      switch (flag) {
        case "file":
          return 0;
        case "link":
          return 1;
        case "symlink":
          return 2;
        case "character-device":
          return 3;
        case "block-device":
          return 4;
        case "directory":
          return 5;
        case "fifo":
          return 6;
        case "contiguous-file":
          return 7;
        case "pax-header":
          return 72;
      }
      return 0;
    };
    var cksum = function(block) {
      let sum = 8 * 32;
      for (let i = 0; i < 148; i++)
        sum += block[i];
      for (let j = 156; j < 512; j++)
        sum += block[j];
      return sum;
    };
    var encodeOct = function(val, n) {
      val = val.toString(8);
      if (val.length > n)
        return SEVENS.slice(0, n) + " ";
      else
        return ZEROS.slice(0, n - val.length) + val + " ";
    };
    var addLength = function(str) {
      const len = Buffer2.byteLength(str);
      let digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
      if (len + digits >= Math.pow(10, digits))
        digits++;
      return len + digits + str;
    };
    exports2.encodePax = function(opts) {
      let result = "";
      if (opts.name)
        result += addLength(" path=" + opts.name + "\n");
      if (opts.linkname)
        result += addLength(" linkpath=" + opts.linkname + "\n");
      const pax = opts.pax;
      if (pax) {
        for (const key in pax) {
          result += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
      return Buffer2.from(result);
    };
    exports2.encode = function(opts) {
      const buf2 = alloc2(512);
      let name5 = opts.name;
      let prefix = "";
      if (opts.typeflag === 5 && name5[name5.length - 1] !== "/")
        name5 += "/";
      if (Buffer2.byteLength(name5) !== name5.length)
        return null;
      while (Buffer2.byteLength(name5) > 100) {
        const i = name5.indexOf("/");
        if (i === -1)
          return null;
        prefix += prefix ? "/" + name5.slice(0, i) : name5.slice(0, i);
        name5 = name5.slice(i + 1);
      }
      if (Buffer2.byteLength(name5) > 100 || Buffer2.byteLength(prefix) > 155)
        return null;
      if (opts.linkname && Buffer2.byteLength(opts.linkname) > 100)
        return null;
      buf2.write(name5);
      buf2.write(encodeOct(opts.mode & MASK, 6), 100);
      buf2.write(encodeOct(opts.uid, 6), 108);
      buf2.write(encodeOct(opts.gid, 6), 116);
      buf2.write(encodeOct(opts.size, 11), 124);
      buf2.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
      buf2[156] = ZERO_OFFSET + toTypeflag(opts.type);
      if (opts.linkname)
        buf2.write(opts.linkname, 157);
      USTAR_MAGIC.copy(buf2, MAGIC_OFFSET);
      USTAR_VER.copy(buf2, VERSION_OFFSET);
      if (opts.uname)
        buf2.write(opts.uname, 265);
      if (opts.gname)
        buf2.write(opts.gname, 297);
      buf2.write(encodeOct(opts.devmajor || 0, 6), 329);
      buf2.write(encodeOct(opts.devminor || 0, 6), 337);
      if (prefix)
        buf2.write(prefix, 345);
      buf2.write(encodeOct(cksum(buf2), 6), 148);
      return buf2;
    };
  }
});

// node_modules/it-tar/pack.js
var require_pack = __commonJS({
  "node_modules/it-tar/pack.js"(exports2, module2) {
    init_node_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var BufferList3 = require_BufferList();
    var { S_IFMT, S_IFBLK, S_IFCHR, S_IFDIR, S_IFIFO, S_IFLNK } = require_index_browser2();
    var concat3 = require_it_concat();
    var Headers = require_pack_headers();
    var DMODE = parseInt("755", 8);
    var FMODE = parseInt("644", 8);
    var END_OF_TAR = Buffer2.alloc(1024);
    function modeToType(mode) {
      switch (mode & S_IFMT) {
        case S_IFBLK:
          return "block-device";
        case S_IFCHR:
          return "character-device";
        case S_IFDIR:
          return "directory";
        case S_IFIFO:
          return "fifo";
        case S_IFLNK:
          return "symlink";
      }
      return "file";
    }
    function getPadding(size) {
      size &= 511;
      if (size)
        return new BufferList3(END_OF_TAR.slice(0, 512 - size));
    }
    function encode10(header) {
      if (!header.pax) {
        const encoded = Headers.encode(header);
        if (encoded)
          return encoded;
      }
      return encodePax(header);
    }
    function encodePax(header) {
      const paxHeader = Headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      });
      const newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      return new BufferList3([
        Headers.encode(newHeader),
        paxHeader,
        getPadding(paxHeader.length),
        Headers.encode({ ...newHeader, size: header.size, type: header.type })
      ]);
    }
    module2.exports = () => async function* (source) {
      for await (let { header, body } of source) {
        if (!header.size || header.type === "symlink")
          header.size = 0;
        if (!header.type)
          header.type = modeToType(header.mode);
        if (!header.mode)
          header.mode = header.type === "directory" ? DMODE : FMODE;
        if (!header.uid)
          header.uid = 0;
        if (!header.gid)
          header.gid = 0;
        if (!header.mtime)
          header.mtime = new Date();
        if (typeof body === "string")
          body = Buffer2.from(body);
        if (Buffer2.isBuffer(body) || BufferList3.isBufferList(body)) {
          header.size = body.length;
          yield new BufferList3([encode10(header), body, getPadding(header.size)]);
          continue;
        }
        if (header.type === "symlink" && !header.linkname) {
          header.linkname = (await concat3(body)).toString();
          yield encode10(header);
          continue;
        }
        yield encode10(header);
        if (header.type !== "file" && header.type !== "contiguous-file") {
          continue;
        }
        let written = 0;
        for await (const chunk of body) {
          written += chunk.length;
          yield BufferList3.isBufferList(chunk) ? chunk : new BufferList3(chunk);
        }
        if (written !== header.size) {
          throw new Error("size mismatch");
        }
        const overflow = getPadding(header.size);
        if (overflow)
          yield overflow;
      }
      yield new BufferList3(END_OF_TAR);
    };
  }
});

// node_modules/it-tar/index.js
var require_it_tar = __commonJS({
  "node_modules/it-tar/index.js"(exports2) {
    init_node_globals();
    exports2.extract = require_extract();
    exports2.pack = require_pack();
  }
});

// node_modules/pako/lib/utils/common.js
var require_common4 = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports2) {
    init_node_globals();
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports2.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports2.shrinkBuf = function(buf2, size) {
      if (buf2.length === size) {
        return buf2;
      }
      if (buf2.subarray) {
        return buf2.subarray(0, size);
      }
      buf2.length = size;
      return buf2;
    };
    var fnTyped = {
      arraySet: function(dest, src2, src_offs, len, dest_offs) {
        if (src2.subarray && dest.subarray) {
          dest.set(src2.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      },
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk, result;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk = chunks[i];
          result.set(chunk, pos);
          pos += chunk.length;
        }
        return result;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src2, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src2[src_offs + i];
        }
      },
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports2.setTyped = function(on) {
      if (on) {
        exports2.Buf8 = Uint8Array;
        exports2.Buf16 = Uint16Array;
        exports2.Buf32 = Int32Array;
        exports2.assign(exports2, fnTyped);
      } else {
        exports2.Buf8 = Array;
        exports2.Buf16 = Array;
        exports2.Buf32 = Array;
        exports2.assign(exports2, fnUntyped);
      }
    };
    exports2.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports2) {
    init_node_globals();
    "use strict";
    var utils = require_common4();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf2) {
      var len = buf2.length;
      while (--len >= 0) {
        buf2[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0];
    var extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13];
    var extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7];
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length4) {
      if (s.bi_valid > Buf_size - length4) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length4 - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length4;
      }
    }
    function send_code(s, c, tree2) {
      send_bits(s, tree2[c * 2], tree2[c * 2 + 1]);
    }
    function bi_reverse(code5, len) {
      var res = 0;
      do {
        res |= code5 & 1;
        code5 >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree2 = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base3 = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree2[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree2[tree2[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree2[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base3) {
          xbits = extra[n - base3];
        }
        f = tree2[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree2[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree2[m * 2 + 1]) * tree2[m * 2];
            tree2[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree2, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code5 = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code5 = code5 + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree2[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree2[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length4;
      var code5;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length4 = 0;
      for (code5 = 0; code5 < LENGTH_CODES - 1; code5++) {
        base_length[code5] = length4;
        for (n = 0; n < 1 << extra_lbits[code5]; n++) {
          _length_code[length4++] = code5;
        }
      }
      _length_code[length4 - 1] = code5;
      dist = 0;
      for (code5 = 0; code5 < 16; code5++) {
        base_dist[code5] = dist;
        for (n = 0; n < 1 << extra_dbits[code5]; n++) {
          _dist_code[dist++] = code5;
        }
      }
      dist >>= 7;
      for (; code5 < D_CODES; code5++) {
        base_dist[code5] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code5] - 7; n++) {
          _dist_code[256 + dist++] = code5;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block3(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf2, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf2, len, s.pending);
      s.pending += len;
    }
    function smaller(tree2, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree2[_n2] < tree2[_m2] || tree2[_n2] === tree2[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree2, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree2, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree2, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code5;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code5 = _length_code[lc];
            send_code(s, code5 + LITERALS + 1, ltree);
            extra = extra_lbits[code5];
            if (extra !== 0) {
              lc -= base_length[code5];
              send_bits(s, lc, extra);
            }
            dist--;
            code5 = d_code(dist);
            send_code(s, code5, dtree);
            extra = extra_dbits[code5];
            if (extra !== 0) {
              dist -= base_dist[code5];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree2 = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree2[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree2[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree2[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree2, n);
      }
      node = elems;
      do {
        n = s.heap[1];
        s.heap[1] = s.heap[s.heap_len--];
        pqdownheap(s, tree2, 1);
        m = s.heap[1];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree2[node * 2] = tree2[n * 2] + tree2[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree2[n * 2 + 1] = tree2[m * 2 + 1] = node;
        s.heap[1] = node++;
        pqdownheap(s, tree2, 1);
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[1];
      gen_bitlen(s, desc);
      gen_codes(tree2, max_code, s.bl_count);
    }
    function scan_tree(s, tree2, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree2[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree2[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree2[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree2, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree2[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree2[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block3(s);
    }
    function _tr_stored_block(s, buf2, stored_len, last6) {
      send_bits(s, (STORED_BLOCK << 1) + (last6 ? 1 : 0), 3);
      copy_block(s, buf2, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf2, stored_len, last6) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf2 !== -1) {
        _tr_stored_block(s, buf2, stored_len, last6);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last6 ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last6 ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block3(s);
      if (last6) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports2._tr_init = _tr_init;
    exports2._tr_stored_block = _tr_stored_block;
    exports2._tr_flush_block = _tr_flush_block;
    exports2._tr_tally = _tr_tally;
    exports2._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function adler32(adler, buf2, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf2[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf2, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf2[i]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {
      2: "need dictionary",
      1: "stream end",
      0: "",
      "-1": "file error",
      "-2": "stream error",
      "-3": "data error",
      "-4": "insufficient memory",
      "-5": "buffer error",
      "-6": "incompatible version"
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports2) {
    init_node_globals();
    "use strict";
    var utils = require_common4();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf2) {
      var len = buf2.length;
      while (--len >= 0) {
        buf2[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last6) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last6);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf2, start, size) {
      var len = strm.avail_in;
      if (len > size) {
        len = size;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf2, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf2, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf2, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush2) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush2 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush2 === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush2) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush2 === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush2) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush2 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush2 === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush2) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush2 === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush2 === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush2) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush2 === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush2 === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      new Config(0, 0, 0, 0, deflate_stored),
      new Config(4, 4, 8, 4, deflate_fast),
      new Config(4, 5, 16, 8, deflate_fast),
      new Config(4, 6, 32, 32, deflate_fast),
      new Config(4, 4, 16, 16, deflate_slow),
      new Config(8, 16, 32, 32, deflate_slow),
      new Config(8, 16, 128, 128, deflate_slow),
      new Config(8, 32, 128, 256, deflate_slow),
      new Config(32, 128, 258, 1024, deflate_slow),
      new Config(32, 258, 258, 4096, deflate_slow)
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush2) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush2 > Z_BLOCK || flush2 < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush2 !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush2;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush2) <= rank(old_flush) && flush2 !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush2 !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush2) : s.strategy === Z_RLE ? deflate_rle(s, flush2) : configuration_table[s.level].func(s, flush2);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush2 === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush2 !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush2 === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush2 !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap = s.wrap;
      if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap;
      return Z_OK;
    }
    exports2.deflateInit = deflateInit;
    exports2.deflateInit2 = deflateInit2;
    exports2.deflateReset = deflateReset;
    exports2.deflateResetKeep = deflateResetKeep;
    exports2.deflateSetHeader = deflateSetHeader;
    exports2.deflate = deflate;
    exports2.deflateEnd = deflateEnd;
    exports2.deflateSetDictionary = deflateSetDictionary;
    exports2.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports2) {
    init_node_globals();
    "use strict";
    var utils = require_common4();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports2.string2buf = function(str) {
      var buf2, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf2 = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf2[i++] = c;
        } else if (c < 2048) {
          buf2[i++] = 192 | c >>> 6;
          buf2[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf2[i++] = 224 | c >>> 12;
          buf2[i++] = 128 | c >>> 6 & 63;
          buf2[i++] = 128 | c & 63;
        } else {
          buf2[i++] = 240 | c >>> 18;
          buf2[i++] = 128 | c >>> 12 & 63;
          buf2[i++] = 128 | c >>> 6 & 63;
          buf2[i++] = 128 | c & 63;
        }
      }
      return buf2;
    };
    function buf2binstring(buf2, len) {
      if (len < 65534) {
        if (buf2.subarray && STR_APPLY_UIA_OK || !buf2.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf2, len));
        }
      }
      var result = "";
      for (var i = 0; i < len; i++) {
        result += String.fromCharCode(buf2[i]);
      }
      return result;
    }
    exports2.buf2binstring = function(buf2) {
      return buf2binstring(buf2, buf2.length);
    };
    exports2.binstring2buf = function(str) {
      var buf2 = new utils.Buf8(str.length);
      for (var i = 0, len = buf2.length; i < len; i++) {
        buf2[i] = str.charCodeAt(i);
      }
      return buf2;
    };
    exports2.buf2string = function(buf2, max) {
      var i, out, c, c_len;
      var len = max || buf2.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf2[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf2[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports2.utf8border = function(buf2, max) {
      var pos;
      max = max || buf2.length;
      if (max > buf2.length) {
        max = buf2.length;
      }
      pos = max - 1;
      while (pos >= 0 && (buf2[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max;
      }
      if (pos === 0) {
        return max;
      }
      return pos + _utf8len[buf2[pos]] > max ? pos : max;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports2) {
    init_node_globals();
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common4();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString4 = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate))
        return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString4.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString4.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports2.Deflate = Deflate;
    exports2.deflate = deflate;
    exports2.deflateRaw = deflateRaw;
    exports2.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last6;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from3;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last6 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from3 = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from3 += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from3++];
                            } while (--op);
                            from3 = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from3 += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from3++];
                            } while (--op);
                            from3 = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from3++];
                              } while (--op);
                              from3 = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from3 += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from3++];
                            } while (--op);
                            from3 = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from3++];
                          output[_out++] = from_source[from3++];
                          output[_out++] = from_source[from3++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from3++];
                          if (len > 1) {
                            output[_out++] = from_source[from3++];
                          }
                        }
                      } else {
                        from3 = _out - dist;
                        do {
                          output[_out++] = output[from3++];
                          output[_out++] = output[from3++];
                          output[_out++] = output[from3++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from3++];
                          if (len > 1) {
                            output[_out++] = output[from3++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last6 && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last6 ? 5 + (last6 - _in) : 5 - (_in - last6);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_common4();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min = 0, max = 0;
      var root = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base3 = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root = bits;
      for (max = MAXBITS; max >= 1; max--) {
        if (count[max] !== 0) {
          break;
        }
      }
      if (root > max) {
        root = max;
      }
      if (max === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min = 1; min < max; min++) {
        if (count[min] !== 0) {
          break;
        }
      }
      if (root < min) {
        root = min;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base3 = extra = work;
        end = 19;
      } else if (type === LENS) {
        base3 = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base3 = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min;
      next = table_index;
      curr = root;
      drop = 0;
      low = -1;
      used = 1 << root;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base3[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root;
          }
          next += min;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports2) {
    init_node_globals();
    "use strict";
    var utils = require_common4();
    var adler32 = require_adler32();
    var crc32 = require_crc32();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE2 = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap = 0;
        windowBits = -windowBits;
      } else {
        wrap = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src2, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src2, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src2, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src2, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush2) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from3;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(state.head.extra, input, next, copy, len);
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            case TYPE:
              if (flush2 === Z_BLOCK || flush2 === Z_TREES) {
                break inf_leave;
              }
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush2 === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush2 === Z_TREES) {
                break inf_leave;
              }
            case COPY_:
              state.mode = COPY;
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush2 === Z_TREES) {
                break inf_leave;
              }
            case LEN_:
              state.mode = LEN;
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from3 = state.wsize - copy;
                } else {
                  from3 = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from3 = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from3++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE2;
            case DONE2:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush2 !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush2 === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports2.inflateReset = inflateReset;
    exports2.inflateReset2 = inflateReset2;
    exports2.inflateResetKeep = inflateResetKeep;
    exports2.inflateInit = inflateInit;
    exports2.inflateInit2 = inflateInit2;
    exports2.inflate = inflate;
    exports2.inflateEnd = inflateEnd;
    exports2.inflateGetHeader = inflateGetHeader;
    exports2.inflateSetDictionary = inflateSetDictionary;
    exports2.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      Z_BUF_ERROR: -5,
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      Z_BINARY: 0,
      Z_TEXT: 1,
      Z_UNKNOWN: 2,
      Z_DEFLATED: 8
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports2) {
    init_node_globals();
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common4();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString4 = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate))
        return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString4.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString4.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk) {
      this.chunks.push(chunk);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports2.Inflate = Inflate;
    exports2.inflate = inflate;
    exports2.inflateRaw = inflateRaw;
    exports2.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var assign = require_common4().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module2.exports = pako;
  }
});

// node_modules/it-to-buffer/index.js
var require_it_to_buffer = __commonJS({
  "node_modules/it-to-buffer/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
    async function toBuffer(stream) {
      let buffer2 = new Uint8Array(0);
      for await (const buf2 of stream) {
        buffer2 = uint8ArrayConcat([buffer2, buf2], buffer2.length + buf2.length);
      }
      return buffer2;
    }
    module2.exports = toBuffer;
  }
});

// node_modules/ipfs-core/cjs/src/components/get.js
var require_get2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/get.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipfsUnixfsExporter = (init_src9(), src_exports6);
    var errCode32 = require_err_code();
    var utils = require_utils();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var cid = (init_cid(), cid_exports);
    var itTar = require_it_tar();
    var itPipe = require_it_pipe();
    var Pako = require_pako();
    var map8 = require_it_map();
    var toBuffer = require_it_to_buffer();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var Pako__default = /* @__PURE__ */ _interopDefaultLegacy(Pako);
    var map__default = /* @__PURE__ */ _interopDefaultLegacy(map8);
    var toBuffer__default = /* @__PURE__ */ _interopDefaultLegacy(toBuffer);
    var DEFAULT_COMPRESSION_LEVEL = 6;
    function createGet7({ repo, preload: preload2 }) {
      async function* get2(ipfsPath2, options = {}) {
        if (options.compressionLevel < 0 || options.compressionLevel > 9) {
          throw errCode__default["default"](new Error("Compression level must be between 1 and 9"), "ERR_INVALID_PARAMS");
        }
        if (options.preload !== false) {
          let pathComponents;
          try {
            pathComponents = utils.normalizeCidPath(ipfsPath2).split("/");
          } catch (err) {
            throw errCode__default["default"](err, "ERR_INVALID_PATH");
          }
          preload2(cid.CID.parse(pathComponents[0]));
        }
        const ipfsPathOrCid = cid.CID.asCID(ipfsPath2) || ipfsPath2;
        const file = await ipfsUnixfsExporter.exporter(ipfsPathOrCid, repo.blocks, options);
        if (file.type === "file" || file.type === "raw") {
          const args = [];
          if (!options.compress || options.archive === true) {
            args.push([{
              header: {
                name: file.path,
                mode: file.type === "file" && file.unixfs.mode,
                mtime: file.type === "file" && file.unixfs.mtime ? new Date(file.unixfs.mtime.secs * 1e3) : void 0,
                size: file.size,
                type: "file"
              },
              body: file.content()
            }], itTar.pack(), (source) => map__default["default"](source, (buf2) => buf2.slice()));
          } else {
            args.push(file.content);
          }
          if (options.compress) {
            args.push(async function* (source) {
              const buf2 = await toBuffer__default["default"](source);
              yield Pako__default["default"].gzip(buf2, { level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL });
            });
          }
          yield* itPipe.pipe(...args);
          return;
        }
        if (file.type === "directory") {
          const args = [
            ipfsUnixfsExporter.recursive(ipfsPathOrCid, repo.blocks, options),
            async function* (source) {
              for await (const entry of source) {
                const output = {
                  header: {
                    name: entry.path,
                    size: entry.size
                  }
                };
                if (entry.type === "file") {
                  output.header.type = "file";
                  output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
                  output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
                  output.body = entry.content();
                } else if (entry.type === "raw") {
                  output.header.type = "file";
                  output.body = entry.content();
                } else if (entry.type === "directory") {
                  output.header.type = "directory";
                  output.header.mode = entry.unixfs.mode != null ? entry.unixfs.mode : void 0;
                  output.header.mtime = entry.unixfs.mtime ? new Date(entry.unixfs.mtime.secs * 1e3) : void 0;
                } else {
                  throw errCode__default["default"](new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
                }
                yield output;
              }
            },
            itTar.pack(),
            (source) => map__default["default"](source, (buf2) => buf2.slice())
          ];
          if (options.compress) {
            if (!options.archive) {
              throw errCode__default["default"](new Error("file is not regular"), "ERR_INVALID_PATH");
            }
            if (options.compress) {
              args.push(async function* (source) {
                const buf2 = await toBuffer__default["default"](source);
                yield Pako__default["default"].gzip(buf2, { level: options.compressionLevel || DEFAULT_COMPRESSION_LEVEL });
              });
            }
          }
          yield* itPipe.pipe(...args);
          return;
        }
        throw errCode__default["default"](new Error("Not a UnixFS node"), "ERR_NOT_UNIXFS");
      }
      return withTimeoutOption2.withTimeoutOption(get2);
    }
    exports2.createGet = createGet7;
  }
});

// node_modules/ipfs-core/cjs/src/components/ls.js
var require_ls2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/ls.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipfsUnixfsExporter = (init_src9(), src_exports6);
    var errCode32 = require_err_code();
    var utils = require_utils();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var cid = (init_cid(), cid_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    function createLs8({ repo, preload: preload2 }) {
      async function* ls(ipfsPath2, options = {}) {
        const legacyPath = utils.normalizeCidPath(ipfsPath2);
        const pathComponents = legacyPath.split("/");
        if (options.preload !== false) {
          preload2(cid.CID.parse(pathComponents[0]));
        }
        const ipfsPathOrCid = cid.CID.asCID(legacyPath) || legacyPath;
        const file = await ipfsUnixfsExporter.exporter(ipfsPathOrCid, repo.blocks, options);
        if (file.type === "file") {
          yield utils.mapFile(file);
          return;
        }
        if (file.type === "directory") {
          for await (const child of file.content()) {
            yield utils.mapFile(child);
          }
          return;
        }
        throw errCode__default["default"](new Error(`Unknown UnixFS type ${file.type}`), "ERR_UNKNOWN_UNIXFS_TYPE");
      }
      return withTimeoutOption2.withTimeoutOption(ls);
    }
    exports2.createLs = createLs8;
  }
});

// node_modules/ipfs-core/cjs/src/components/root.js
var require_root = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/root.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var add = require_add3();
    var index = require_add_all2();
    var cat = require_cat();
    var get2 = require_get2();
    var ls = require_ls2();
    var RootAPI = class {
      constructor({ preload: preload2, repo, options }) {
        const addAll = index.createAddAll({
          preload: preload2,
          repo,
          options
        });
        this.addAll = addAll;
        this.add = add.createAdd({ addAll });
        this.cat = cat.createCat({
          repo,
          preload: preload2
        });
        this.get = get2.createGet({
          repo,
          preload: preload2
        });
        this.ls = ls.createLs({
          repo,
          preload: preload2
        });
      }
    };
    exports2.RootAPI = RootAPI;
  }
});

// node_modules/ipfs-core/cjs/src/version.js
var require_version = __commonJS({
  "node_modules/ipfs-core/cjs/src/version.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipfsCore = "0.11.1";
    var commit = "5ddd0c555cc6577ee15667f4ef4e7f3a3b17d04c";
    var interfaceIpfsCore = "^0.151.1";
    exports2.commit = commit;
    exports2.interfaceIpfsCore = interfaceIpfsCore;
    exports2.ipfsCore = ipfsCore;
  }
});

// node_modules/ipfs-core/cjs/src/components/version.js
var require_version2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/version.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var version3 = require_version();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createVersion3({ repo }) {
      async function version$1(_options = {}) {
        const repoVersion3 = await repo.version.get();
        return {
          version: version3.ipfsCore,
          commit: version3.commit,
          repo: `${repoVersion3}`,
          "ipfs-core": version3.ipfsCore,
          "interface-ipfs-core": version3.interfaceIpfsCore
        };
      }
      return withTimeoutOption2.withTimeoutOption(version$1);
    }
    exports2.createVersion = createVersion3;
  }
});

// node_modules/ipfs-core/cjs/src/components/id.js
var require_id = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/id.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var version3 = require_version();
    var multiaddr = require_src();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var toString4 = (init_to_string(), to_string_exports);
    var PeerId2 = require_src6();
    var errors2 = require_errors();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var PeerId__default = /* @__PURE__ */ _interopDefaultLegacy(PeerId2);
    function createId2({ peerId, network }) {
      async function id(options = {}) {
        if (options.peerId === peerId.toB58String()) {
          delete options.peerId;
        }
        const net = network.try();
        if (!net) {
          if (options.peerId) {
            throw new errors2.NotStartedError();
          }
          const idStr2 = peerId.toB58String();
          return {
            id: idStr2,
            publicKey: toString4.toString(peerId.pubKey.bytes, "base64pad"),
            addresses: [],
            agentVersion: `js-ipfs/${version3.ipfsCore}`,
            protocolVersion: "9000",
            protocols: []
          };
        }
        const id2 = options.peerId ? PeerId__default["default"].createFromB58String(options.peerId.toString()) : peerId;
        const { libp2p } = net;
        const publicKey = options.peerId ? libp2p.peerStore.keyBook.get(id2) : id2.pubKey;
        const addresses = options.peerId ? libp2p.peerStore.addressBook.getMultiaddrsForPeer(id2) : libp2p.multiaddrs;
        const protocols = options.peerId ? libp2p.peerStore.protoBook.get(id2) : Array.from(libp2p.upgrader.protocols.keys());
        const agentVersion = toString4.toString(libp2p.peerStore.metadataBook.getValue(id2, "AgentVersion") || new Uint8Array());
        const protocolVersion = toString4.toString(libp2p.peerStore.metadataBook.getValue(id2, "ProtocolVersion") || new Uint8Array());
        const idStr = id2.toB58String();
        return {
          id: idStr,
          publicKey: toString4.toString(publicKey.bytes, "base64pad"),
          addresses: (addresses || []).map((ma) => {
            const str = ma.toString();
            if (str.endsWith(`/p2p/${idStr}`)) {
              return str;
            }
            return `${str}/p2p/${idStr}`;
          }).sort().map((ma) => new multiaddr.Multiaddr(ma)),
          agentVersion,
          protocolVersion,
          protocols: (protocols || []).sort()
        };
      }
      return withTimeoutOption2.withTimeoutOption(id);
    }
    exports2.createId = createId2;
  }
});

// node_modules/just-safe-set/index.js
var require_just_safe_set = __commonJS({
  "node_modules/just-safe-set/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = set;
    function set(obj, propsArg, value) {
      var props, lastProp;
      if (Array.isArray(propsArg)) {
        props = propsArg.slice(0);
      }
      if (typeof propsArg == "string") {
        props = propsArg.split(".");
      }
      if (typeof propsArg == "symbol") {
        props = [propsArg];
      }
      if (!Array.isArray(props)) {
        throw new Error("props arg must be an array, a string or a symbol");
      }
      lastProp = props.pop();
      if (!lastProp) {
        return false;
      }
      prototypeCheck(lastProp);
      var thisProp;
      while (thisProp = props.shift()) {
        prototypeCheck(thisProp);
        if (typeof obj[thisProp] == "undefined") {
          obj[thisProp] = {};
        }
        obj = obj[thisProp];
        if (!obj || typeof obj != "object") {
          return false;
        }
      }
      obj[lastProp] = value;
      return true;
    }
    function prototypeCheck(prop) {
      if (prop === "__proto__" || prop === "constructor" || prop === "prototype") {
        throw new Error("setting of prototype values not supported");
      }
    }
  }
});

// node_modules/ipfs-core/cjs/src/components/config/profiles.js
var require_profiles = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/config/profiles.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var set = require_just_safe_set();
    var getDefaultConfig = (init_config_browser(), config_browser_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var set__default = /* @__PURE__ */ _interopDefaultLegacy(set);
    var getDefaultConfig__default = /* @__PURE__ */ _interopDefaultLegacy(getDefaultConfig);
    var profiles = {
      server: {
        description: "Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",
        transform: (config2) => {
          set__default["default"](config2, "Discovery.MDNS.Enabled", false);
          set__default["default"](config2, "Discovery.webRTCStar.Enabled", false);
          config2.Swarm = {
            ...config2.Swarm || {},
            DisableNatPortMap: true
          };
          return config2;
        }
      },
      "local-discovery": {
        description: "Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",
        transform: (config2) => {
          set__default["default"](config2, "Discovery.MDNS.Enabled", true);
          set__default["default"](config2, "Discovery.webRTCStar.Enabled", true);
          set__default["default"](config2, "Swarm", {
            ...config2.Swarm || {},
            DisableNatPortMap: false
          });
          return config2;
        }
      },
      test: {
        description: "Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",
        transform: (config2) => {
          const defaultConfig = getDefaultConfig__default["default"]();
          set__default["default"](config2, "Addresses.API", defaultConfig.Addresses.API ? "/ip4/127.0.0.1/tcp/0" : "");
          set__default["default"](config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway ? "/ip4/127.0.0.1/tcp/0" : "");
          set__default["default"](config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm.length ? ["/ip4/127.0.0.1/tcp/0"] : []);
          set__default["default"](config2, "Addresses.Delegates", []);
          set__default["default"](config2, "Bootstrap", []);
          set__default["default"](config2, "Discovery.MDNS.Enabled", false);
          set__default["default"](config2, "Discovery.webRTCStar.Enabled", false);
          set__default["default"](config2, "Swarm", {
            ...config2.Swarm || {},
            DisableNatPortMap: true
          });
          return config2;
        }
      },
      "default-networking": {
        description: "Restores default network settings. Inverse profile of the `test` profile.",
        transform: (config2) => {
          const defaultConfig = getDefaultConfig__default["default"]();
          set__default["default"](config2, "Addresses.API", defaultConfig.Addresses.API);
          set__default["default"](config2, "Addresses.Gateway", defaultConfig.Addresses.Gateway);
          set__default["default"](config2, "Addresses.Swarm", defaultConfig.Addresses.Swarm);
          set__default["default"](config2, "Addresses.Delegates", defaultConfig.Addresses.Delegates);
          set__default["default"](config2, "Bootstrap", defaultConfig.Bootstrap);
          set__default["default"](config2, "Discovery.MDNS.Enabled", defaultConfig.Discovery.MDNS.Enabled);
          set__default["default"](config2, "Discovery.webRTCStar.Enabled", defaultConfig.Discovery.webRTCStar.Enabled);
          set__default["default"](config2, "Swarm", {
            ...config2.Swarm || {},
            DisableNatPortMap: false
          });
          return config2;
        }
      },
      lowpower: {
        description: "Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",
        transform: (config2) => {
          const Swarm = config2.Swarm || {};
          const ConnMgr = Swarm.ConnMgr || {};
          ConnMgr.LowWater = 20;
          ConnMgr.HighWater = 40;
          Swarm.ConnMgr = ConnMgr;
          config2.Swarm = Swarm;
          return config2;
        }
      },
      "default-power": {
        description: 'Inverse of "lowpower" profile.',
        transform: (config2) => {
          const defaultConfig = getDefaultConfig__default["default"]();
          config2.Swarm = defaultConfig.Swarm;
          return config2;
        }
      }
    };
    exports2.profiles = profiles;
  }
});

// node_modules/ipfs-core/cjs/src/components/config/index.js
var require_config2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/config/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var debug17 = require_browser2();
    var profiles = require_profiles();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = debug__default["default"]("ipfs:core:config");
    function createConfig2({ repo }) {
      return {
        getAll: withTimeoutOption2.withTimeoutOption(getAll),
        get: withTimeoutOption2.withTimeoutOption(get2),
        set: withTimeoutOption2.withTimeoutOption(set),
        replace: withTimeoutOption2.withTimeoutOption(replace),
        profiles: {
          apply: withTimeoutOption2.withTimeoutOption(applyProfile),
          list: withTimeoutOption2.withTimeoutOption(listProfiles)
        }
      };
      async function getAll(options = {}) {
        return repo.config.getAll(options);
      }
      async function get2(key, options) {
        if (!key) {
          return Promise.reject(new Error("key argument is required"));
        }
        return repo.config.get(key, options);
      }
      async function set(key, value, options) {
        return repo.config.set(key, value, options);
      }
      async function replace(value, options) {
        return repo.config.replace(value, options);
      }
      async function applyProfile(profileName, options = { dryRun: false }) {
        const { dryRun } = options;
        const profile = profiles.profiles[profileName];
        if (!profile) {
          throw new Error(`No profile with name '${profileName}' exists`);
        }
        try {
          const oldCfg = await repo.config.getAll(options);
          let newCfg = JSON.parse(JSON.stringify(oldCfg));
          newCfg = profile.transform(newCfg);
          if (!dryRun) {
            await repo.config.replace(newCfg, options);
          }
          delete oldCfg.Identity.PrivKey;
          delete newCfg.Identity.PrivKey;
          return {
            original: oldCfg,
            updated: newCfg
          };
        } catch (err) {
          log15(err);
          throw new Error(`Could not apply profile '${profileName}' to config: ${err.message}`);
        }
      }
    }
    async function listProfiles(_options) {
      return Object.keys(profiles.profiles).map((name5) => ({
        name: name5,
        description: profiles.profiles[name5].description
      }));
    }
    exports2.createConfig = createConfig2;
  }
});

// node_modules/multiformats/esm/src/block.js
var block_exports = {};
__export(block_exports, {
  Block: () => Block,
  create: () => create4,
  createUnsafe: () => createUnsafe,
  decode: () => decode10,
  encode: () => encode8
});
var readonly2, links, tree, get, Block, encode8, decode10, createUnsafe, create4;
var init_block = __esm({
  "node_modules/multiformats/esm/src/block.js"() {
    init_node_globals();
    init_src3();
    readonly2 = ({ enumerable = true, configurable = false } = {}) => ({
      enumerable,
      configurable,
      writable: false
    });
    links = function* (source, base3) {
      if (source == null)
        return;
      if (source instanceof Uint8Array)
        return;
      for (const [key, value] of Object.entries(source)) {
        const path = [
          ...base3,
          key
        ];
        if (value != null && typeof value === "object") {
          if (Array.isArray(value)) {
            for (const [index, element] of value.entries()) {
              const elementPath = [
                ...path,
                index
              ];
              const cid = CID.asCID(element);
              if (cid) {
                yield [
                  elementPath.join("/"),
                  cid
                ];
              } else if (typeof element === "object") {
                yield* links(element, elementPath);
              }
            }
          } else {
            const cid = CID.asCID(value);
            if (cid) {
              yield [
                path.join("/"),
                cid
              ];
            } else {
              yield* links(value, path);
            }
          }
        }
      }
    };
    tree = function* (source, base3) {
      if (source == null)
        return;
      for (const [key, value] of Object.entries(source)) {
        const path = [
          ...base3,
          key
        ];
        yield path.join("/");
        if (value != null && !(value instanceof Uint8Array) && typeof value === "object" && !CID.asCID(value)) {
          if (Array.isArray(value)) {
            for (const [index, element] of value.entries()) {
              const elementPath = [
                ...path,
                index
              ];
              yield elementPath.join("/");
              if (typeof element === "object" && !CID.asCID(element)) {
                yield* tree(element, elementPath);
              }
            }
          } else {
            yield* tree(value, path);
          }
        }
      }
    };
    get = (source, path) => {
      let node = source;
      for (const [index, key] of path.entries()) {
        node = node[key];
        if (node == null) {
          throw new Error(`Object has no property at ${path.slice(0, index + 1).map((part) => `[${JSON.stringify(part)}]`).join("")}`);
        }
        const cid = CID.asCID(node);
        if (cid) {
          return {
            value: cid,
            remaining: path.slice(index + 1).join("/")
          };
        }
      }
      return { value: node };
    };
    Block = class {
      constructor({ cid, bytes: bytes3, value }) {
        if (!cid || !bytes3 || typeof value === "undefined")
          throw new Error("Missing required argument");
        this.cid = cid;
        this.bytes = bytes3;
        this.value = value;
        this.asBlock = this;
        Object.defineProperties(this, {
          cid: readonly2(),
          bytes: readonly2(),
          value: readonly2(),
          asBlock: readonly2()
        });
      }
      links() {
        return links(this.value, []);
      }
      tree() {
        return tree(this.value, []);
      }
      get(path = "/") {
        return get(this.value, path.split("/").filter(Boolean));
      }
    };
    encode8 = async ({ value, codec, hasher }) => {
      if (typeof value === "undefined")
        throw new Error('Missing required argument "value"');
      if (!codec || !hasher)
        throw new Error("Missing required argument: codec or hasher");
      const bytes3 = codec.encode(value);
      const hash2 = await hasher.digest(bytes3);
      const cid = CID.create(1, codec.code, hash2);
      return new Block({
        value,
        bytes: bytes3,
        cid
      });
    };
    decode10 = async ({ bytes: bytes3, codec, hasher }) => {
      if (!bytes3)
        throw new Error('Missing required argument "bytes"');
      if (!codec || !hasher)
        throw new Error("Missing required argument: codec or hasher");
      const value = codec.decode(bytes3);
      const hash2 = await hasher.digest(bytes3);
      const cid = CID.create(1, codec.code, hash2);
      return new Block({
        value,
        bytes: bytes3,
        cid
      });
    };
    createUnsafe = ({
      bytes: bytes3,
      cid,
      value: maybeValue,
      codec
    }) => {
      const value = maybeValue !== void 0 ? maybeValue : codec && codec.decode(bytes3);
      if (value === void 0)
        throw new Error('Missing required argument, must either provide "value" or "codec"');
      return new Block({
        cid,
        bytes: bytes3,
        value
      });
    };
    create4 = async ({ bytes: bytes3, cid, hasher, codec }) => {
      if (!bytes3)
        throw new Error('Missing required argument "bytes"');
      if (!hasher)
        throw new Error('Missing required argument "hasher"');
      const value = codec.decode(bytes3);
      const hash2 = await hasher.digest(bytes3);
      if (!bytes_exports.equals(cid.multihash.bytes, hash2.bytes)) {
        throw new Error("CID hash does not match bytes");
      }
      return createUnsafe({
        bytes: bytes3,
        cid,
        value,
        codec
      });
    };
  }
});

// node_modules/@ipld/car/esm/lib/encoder.js
function createHeader(roots) {
  const headerBytes = encode5({
    version: 1,
    roots
  });
  const varintBytes = import_varint2.default.encode(headerBytes.length);
  const header = new Uint8Array(varintBytes.length + headerBytes.length);
  header.set(varintBytes, 0);
  header.set(headerBytes, varintBytes.length);
  return header;
}
function createEncoder(writer) {
  return {
    async setRoots(roots) {
      const bytes3 = createHeader(roots);
      await writer.write(bytes3);
    },
    async writeBlock(block) {
      const { cid, bytes: bytes3 } = block;
      await writer.write(new Uint8Array(import_varint2.default.encode(cid.bytes.length + bytes3.length)));
      await writer.write(cid.bytes);
      if (bytes3.length) {
        await writer.write(bytes3);
      }
    },
    async close() {
      return writer.end();
    }
  };
}
var import_varint2;
var init_encoder = __esm({
  "node_modules/@ipld/car/esm/lib/encoder.js"() {
    init_node_globals();
    import_varint2 = __toModule(require_varint());
    init_esm();
  }
});

// node_modules/@ipld/car/esm/lib/iterator-channel.js
function noop() {
}
function create5() {
  const chunkQueue = [];
  let drainer = null;
  let drainerResolver = noop;
  let ended = false;
  let outWait = null;
  let outWaitResolver = noop;
  const makeDrainer = () => {
    if (!drainer) {
      drainer = new Promise((resolve6) => {
        drainerResolver = () => {
          drainer = null;
          drainerResolver = noop;
          resolve6();
        };
      });
    }
    return drainer;
  };
  const writer = {
    write(chunk) {
      chunkQueue.push(chunk);
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    },
    async end() {
      ended = true;
      const drainer2 = makeDrainer();
      outWaitResolver();
      return drainer2;
    }
  };
  const iterator = {
    async next() {
      const chunk = chunkQueue.shift();
      if (chunk) {
        if (chunkQueue.length === 0) {
          drainerResolver();
        }
        return {
          done: false,
          value: chunk
        };
      }
      if (ended) {
        drainerResolver();
        return {
          done: true,
          value: void 0
        };
      }
      if (!outWait) {
        outWait = new Promise((resolve6) => {
          outWaitResolver = () => {
            outWait = null;
            outWaitResolver = noop;
            return resolve6(iterator.next());
          };
        });
      }
      return outWait;
    }
  };
  return {
    writer,
    iterator
  };
}
var init_iterator_channel = __esm({
  "node_modules/@ipld/car/esm/lib/iterator-channel.js"() {
    init_node_globals();
  }
});

// node_modules/@ipld/car/esm/lib/decoder.js
async function readVarint(reader) {
  const bytes3 = await reader.upTo(8);
  const i = import_varint3.default.decode(bytes3);
  reader.seek(import_varint3.default.decode.bytes);
  return i;
}
async function readHeader(reader) {
  const length4 = await readVarint(reader);
  if (length4 === 0) {
    throw new Error("Invalid CAR header (zero length)");
  }
  const header = await reader.exactly(length4);
  reader.seek(length4);
  const block = decode7(header);
  if (block == null || Array.isArray(block) || typeof block !== "object") {
    throw new Error("Invalid CAR header format");
  }
  if (block.version !== 1) {
    if (typeof block.version === "string") {
      throw new Error(`Invalid CAR version: "${block.version}"`);
    }
    throw new Error(`Invalid CAR version: ${block.version}`);
  }
  if (!Array.isArray(block.roots)) {
    throw new Error("Invalid CAR header format");
  }
  if (Object.keys(block).filter((p) => p !== "roots" && p !== "version").length) {
    throw new Error("Invalid CAR header format");
  }
  return block;
}
async function readMultihash(reader) {
  const bytes3 = await reader.upTo(8);
  import_varint3.default.decode(bytes3);
  const codeLength = import_varint3.default.decode.bytes;
  const length4 = import_varint3.default.decode(bytes3.subarray(import_varint3.default.decode.bytes));
  const lengthLength = import_varint3.default.decode.bytes;
  const mhLength = codeLength + lengthLength + length4;
  const multihash = await reader.exactly(mhLength);
  reader.seek(mhLength);
  return multihash;
}
async function readCid(reader) {
  const first3 = await reader.exactly(2);
  if (first3[0] === CIDV0_BYTES.SHA2_256 && first3[1] === CIDV0_BYTES.LENGTH) {
    const bytes4 = await reader.exactly(34);
    reader.seek(34);
    const multihash2 = decode3(bytes4);
    return CID.create(0, CIDV0_BYTES.DAG_PB, multihash2);
  }
  const version3 = await readVarint(reader);
  if (version3 !== 1) {
    throw new Error(`Unexpected CID version (${version3})`);
  }
  const codec = await readVarint(reader);
  const bytes3 = await readMultihash(reader);
  const multihash = decode3(bytes3);
  return CID.create(version3, codec, multihash);
}
async function readBlockHead(reader) {
  const start = reader.pos;
  let length4 = await readVarint(reader);
  if (length4 === 0) {
    throw new Error("Invalid CAR section (zero length)");
  }
  length4 += reader.pos - start;
  const cid = await readCid(reader);
  const blockLength = length4 - (reader.pos - start);
  return {
    cid,
    length: length4,
    blockLength
  };
}
async function readBlock(reader) {
  const { cid, blockLength } = await readBlockHead(reader);
  const bytes3 = await reader.exactly(blockLength);
  reader.seek(blockLength);
  return {
    bytes: bytes3,
    cid
  };
}
async function readBlockIndex(reader) {
  const offset = reader.pos;
  const { cid, length: length4, blockLength } = await readBlockHead(reader);
  const index = {
    cid,
    length: length4,
    blockLength,
    offset,
    blockOffset: reader.pos
  };
  reader.seek(index.blockLength);
  return index;
}
function createDecoder(reader) {
  const headerPromise = readHeader(reader);
  return {
    header: () => headerPromise,
    async *blocks() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlock(reader);
      }
    },
    async *blocksIndex() {
      await headerPromise;
      while ((await reader.upTo(8)).length > 0) {
        yield await readBlockIndex(reader);
      }
    }
  };
}
function bytesReader(bytes3) {
  let pos = 0;
  return {
    async upTo(length4) {
      return bytes3.subarray(pos, pos + Math.min(length4, bytes3.length - pos));
    },
    async exactly(length4) {
      if (length4 > bytes3.length - pos) {
        throw new Error("Unexpected end of data");
      }
      return bytes3.subarray(pos, pos + length4);
    },
    seek(length4) {
      pos += length4;
    },
    get pos() {
      return pos;
    }
  };
}
function chunkReader(readChunk) {
  let pos = 0;
  let have = 0;
  let offset = 0;
  let currentChunk = new Uint8Array(0);
  const read2 = async (length4) => {
    have = currentChunk.length - offset;
    const bufa = [currentChunk.subarray(offset)];
    while (have < length4) {
      const chunk = await readChunk();
      if (chunk == null) {
        break;
      }
      if (have < 0) {
        if (chunk.length > have) {
          bufa.push(chunk.subarray(-have));
        }
      } else {
        bufa.push(chunk);
      }
      have += chunk.length;
    }
    currentChunk = new Uint8Array(bufa.reduce((p, c) => p + c.length, 0));
    let off = 0;
    for (const b of bufa) {
      currentChunk.set(b, off);
      off += b.length;
    }
    offset = 0;
  };
  return {
    async upTo(length4) {
      if (currentChunk.length - offset < length4) {
        await read2(length4);
      }
      return currentChunk.subarray(offset, offset + Math.min(currentChunk.length - offset, length4));
    },
    async exactly(length4) {
      if (currentChunk.length - offset < length4) {
        await read2(length4);
      }
      if (currentChunk.length - offset < length4) {
        throw new Error("Unexpected end of data");
      }
      return currentChunk.subarray(offset, offset + length4);
    },
    seek(length4) {
      pos += length4;
      offset += length4;
    },
    get pos() {
      return pos;
    }
  };
}
function asyncIterableReader(asyncIterable) {
  const iterator = asyncIterable[Symbol.asyncIterator]();
  async function readChunk() {
    const next = await iterator.next();
    if (next.done) {
      return null;
    }
    return next.value;
  }
  return chunkReader(readChunk);
}
var import_varint3, CIDV0_BYTES;
var init_decoder = __esm({
  "node_modules/@ipld/car/esm/lib/decoder.js"() {
    init_node_globals();
    import_varint3 = __toModule(require_varint());
    init_cid();
    init_digest();
    init_esm();
    CIDV0_BYTES = {
      SHA2_256: 18,
      LENGTH: 32,
      DAG_PB: 112
    };
  }
});

// node_modules/@ipld/car/esm/lib/writer-browser.js
var writer_browser_exports = {};
__export(writer_browser_exports, {
  CarWriter: () => CarWriter,
  CarWriterOut: () => CarWriterOut,
  __browser: () => __browser
});
function encodeWriter() {
  const iw = create5();
  const { writer, iterator } = iw;
  const encoder = createEncoder(writer);
  return {
    encoder,
    iterator
  };
}
function toRoots(roots) {
  if (roots === void 0) {
    return [];
  }
  if (!Array.isArray(roots)) {
    const cid = CID.asCID(roots);
    if (!cid) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    return [cid];
  }
  const _roots = [];
  for (const root of roots) {
    const _root = CID.asCID(root);
    if (!_root) {
      throw new TypeError("roots must be a single CID or an array of CIDs");
    }
    _roots.push(_root);
  }
  return _roots;
}
var CarWriter, CarWriterOut, __browser;
var init_writer_browser = __esm({
  "node_modules/@ipld/car/esm/lib/writer-browser.js"() {
    init_node_globals();
    init_cid();
    init_encoder();
    init_iterator_channel();
    init_decoder();
    CarWriter = class {
      constructor(roots, encoder) {
        this._encoder = encoder;
        this._mutex = encoder.setRoots(roots);
        this._ended = false;
      }
      async put(block) {
        if (!(block.bytes instanceof Uint8Array) || !block.cid) {
          throw new TypeError("Can only write {cid, bytes} objects");
        }
        if (this._ended) {
          throw new Error("Already closed");
        }
        const cid = CID.asCID(block.cid);
        if (!cid) {
          throw new TypeError("Can only write {cid, bytes} objects");
        }
        this._mutex = this._mutex.then(() => this._encoder.writeBlock({
          cid,
          bytes: block.bytes
        }));
        return this._mutex;
      }
      async close() {
        if (this._ended) {
          throw new Error("Already closed");
        }
        await this._mutex;
        this._ended = true;
        return this._encoder.close();
      }
      static create(roots) {
        roots = toRoots(roots);
        const { encoder, iterator } = encodeWriter();
        const writer = new CarWriter(roots, encoder);
        const out = new CarWriterOut(iterator);
        return {
          writer,
          out
        };
      }
      static createAppender() {
        const { encoder, iterator } = encodeWriter();
        encoder.setRoots = () => Promise.resolve();
        const writer = new CarWriter([], encoder);
        const out = new CarWriterOut(iterator);
        return {
          writer,
          out
        };
      }
      static async updateRootsInBytes(bytes3, roots) {
        const reader = bytesReader(bytes3);
        await readHeader(reader);
        const newHeader = createHeader(roots);
        if (reader.pos !== newHeader.length) {
          throw new Error(`updateRoots() can only overwrite a header of the same length (old header is ${reader.pos} bytes, new header is ${newHeader.length} bytes)`);
        }
        bytes3.set(newHeader, 0);
        return bytes3;
      }
    };
    CarWriterOut = class {
      constructor(iterator) {
        this._iterator = iterator;
      }
      [Symbol.asyncIterator]() {
        if (this._iterating) {
          throw new Error("Multiple iterator not supported");
        }
        this._iterating = true;
        return this._iterator;
      }
    };
    __browser = true;
  }
});

// node_modules/ipfs-core/cjs/src/components/dag/export.js
var require_export = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/dag/export.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cid = (init_cid(), cid_exports);
    var block = (init_block(), block_exports);
    var base58 = (init_base58(), base58_exports);
    var writer = (init_writer_browser(), writer_browser_exports);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var debug17 = require_browser2();
    var raw7 = (init_raw(), raw_exports);
    var json = (init_json(), json_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var raw__namespace = /* @__PURE__ */ _interopNamespace(raw7);
    var json__namespace = /* @__PURE__ */ _interopNamespace(json);
    var log15 = debug__default["default"]("ipfs:components:dag:import");
    var NO_LINKS_CODECS = [
      raw__namespace.code,
      json__namespace.code
    ];
    function createExport3({ repo, preload: preload2, codecs: codecs2 }) {
      async function* dagExport(root, options = {}) {
        if (options.preload !== false) {
          preload2(root);
        }
        const cid$1 = cid.CID.asCID(root);
        if (!cid$1) {
          throw new Error(`Unexpected error converting CID type: ${root}`);
        }
        log15(`Exporting ${cid$1} as car`);
        const { writer: writer$1, out } = await writer.CarWriter.create([cid$1]);
        let err = null;
        (async () => {
          try {
            await traverseWrite(repo, {
              signal: options.signal,
              timeout: options.timeout
            }, cid$1, writer$1, codecs2);
            writer$1.close();
          } catch (e) {
            err = e;
          }
        })();
        for await (const chunk of out) {
          if (err) {
            break;
          }
          yield chunk;
        }
        if (err) {
          throw err;
        }
      }
      return withTimeoutOption2.withTimeoutOption(dagExport);
    }
    async function traverseWrite(repo, options, cid2, writer2, codecs2, seen = new Set()) {
      const b58Cid = cid2.toString(base58.base58btc);
      if (seen.has(b58Cid)) {
        return;
      }
      const block2 = await getBlock(repo, options, cid2, codecs2);
      log15(`Adding block ${cid2} to car`);
      await writer2.put(block2);
      seen.add(b58Cid);
      for (const link of block2.links) {
        await traverseWrite(repo, options, link, writer2, codecs2, seen);
      }
    }
    async function getBlock(repo, options, cid2, codecs2) {
      const bytes3 = await repo.blocks.get(cid2, options);
      let links2 = [];
      const codec = await codecs2.getCodec(cid2.code);
      if (codec) {
        const block$1 = block.createUnsafe({
          bytes: bytes3,
          cid: cid2,
          codec
        });
        links2 = [...block$1.links()].map((l) => l[1]);
      } else if (!NO_LINKS_CODECS.includes(cid2.code)) {
        throw new Error(`Can't decode links in block with codec 0x${cid2.code.toString(16)} to form complete DAG`);
      }
      return {
        cid: cid2,
        bytes: bytes3,
        links: links2
      };
    }
    exports2.createExport = createExport3;
  }
});

// node_modules/it-first/index.js
var require_it_first = __commonJS({
  "node_modules/it-first/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var first3 = async (source) => {
      for await (const entry of source) {
        return entry;
      }
      return void 0;
    };
    module2.exports = first3;
  }
});

// node_modules/ipfs-core/cjs/src/components/dag/get.js
var require_get3 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/dag/get.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var first3 = require_it_first();
    var last6 = require_it_last();
    var utils = require_utils();
    var errCode32 = require_err_code();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var first__default = /* @__PURE__ */ _interopDefaultLegacy(first3);
    var last__default = /* @__PURE__ */ _interopDefaultLegacy(last6);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    function createGet7({ codecs: codecs2, repo, preload: preload2 }) {
      const get2 = async function get3(cid, options = {}) {
        if (options.preload !== false) {
          preload2(cid);
        }
        if (options.path) {
          const entry = options.localResolve ? await first__default["default"](utils.resolve(cid, options.path, codecs2, repo, options)) : await last__default["default"](utils.resolve(cid, options.path, codecs2, repo, options));
          const result = entry;
          if (!result) {
            throw errCode__default["default"](new Error("Not found"), "ERR_NOT_FOUND");
          }
          return result;
        }
        const codec = await codecs2.getCodec(cid.code);
        const block = await repo.blocks.get(cid, options);
        const node = codec.decode(block);
        return {
          value: node,
          remainderPath: ""
        };
      };
      return withTimeoutOption2.withTimeoutOption(get2);
    }
    exports2.createGet = createGet7;
  }
});

// node_modules/@ipld/car/esm/lib/iterator.js
var iterator_exports = {};
__export(iterator_exports, {
  CarBlockIterator: () => CarBlockIterator,
  CarCIDIterator: () => CarCIDIterator,
  CarIteratorBase: () => CarIteratorBase
});
async function fromBytes(bytes3) {
  if (!(bytes3 instanceof Uint8Array)) {
    throw new TypeError("fromBytes() requires a Uint8Array");
  }
  return decodeIterator(bytesReader(bytes3));
}
async function fromIterable(asyncIterable) {
  if (!asyncIterable || !(typeof asyncIterable[Symbol.asyncIterator] === "function")) {
    throw new TypeError("fromIterable() requires an async iterable");
  }
  return decodeIterator(asyncIterableReader(asyncIterable));
}
async function decodeIterator(reader) {
  const decoder = createDecoder(reader);
  const { version: version3, roots } = await decoder.header();
  return {
    version: version3,
    roots,
    iterator: decoder.blocks()
  };
}
var CarIteratorBase, CarBlockIterator, CarCIDIterator;
var init_iterator = __esm({
  "node_modules/@ipld/car/esm/lib/iterator.js"() {
    init_node_globals();
    init_decoder();
    CarIteratorBase = class {
      constructor(version3, roots, iterable) {
        this._version = version3;
        this._roots = roots;
        this._iterable = iterable;
        this._decoded = false;
      }
      get version() {
        return this._version;
      }
      async getRoots() {
        return this._roots;
      }
    };
    CarBlockIterator = class extends CarIteratorBase {
      [Symbol.asyncIterator]() {
        if (this._decoded) {
          throw new Error("Cannot decode more than once");
        }
        if (!this._iterable) {
          throw new Error("Block iterable not found");
        }
        this._decoded = true;
        return this._iterable[Symbol.asyncIterator]();
      }
      static async fromBytes(bytes3) {
        const { version: version3, roots, iterator } = await fromBytes(bytes3);
        return new CarBlockIterator(version3, roots, iterator);
      }
      static async fromIterable(asyncIterable) {
        const { version: version3, roots, iterator } = await fromIterable(asyncIterable);
        return new CarBlockIterator(version3, roots, iterator);
      }
    };
    CarCIDIterator = class extends CarIteratorBase {
      [Symbol.asyncIterator]() {
        if (this._decoded) {
          throw new Error("Cannot decode more than once");
        }
        if (!this._iterable) {
          throw new Error("Block iterable not found");
        }
        this._decoded = true;
        const iterable = this._iterable[Symbol.asyncIterator]();
        return {
          async next() {
            const next = await iterable.next();
            if (next.done) {
              return next;
            }
            return {
              done: false,
              value: next.value.cid
            };
          }
        };
      }
      static async fromBytes(bytes3) {
        const { version: version3, roots, iterator } = await fromBytes(bytes3);
        return new CarCIDIterator(version3, roots, iterator);
      }
      static async fromIterable(asyncIterable) {
        const { version: version3, roots, iterator } = await fromIterable(asyncIterable);
        return new CarCIDIterator(version3, roots, iterator);
      }
    };
  }
});

// node_modules/ipfs-core/cjs/src/components/dag/import.js
var require_import = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/dag/import.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var iterator = (init_iterator(), iterator_exports);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var itPeekable4 = require_it_peekable();
    var drain6 = require_it_drain();
    var map8 = require_it_map();
    var debug17 = require_browser2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var itPeekable__default = /* @__PURE__ */ _interopDefaultLegacy(itPeekable4);
    var drain__default = /* @__PURE__ */ _interopDefaultLegacy(drain6);
    var map__default = /* @__PURE__ */ _interopDefaultLegacy(map8);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = debug__default["default"]("ipfs:components:dag:import");
    function createImport3({ repo }) {
      async function* dagImport(sources, options = {}) {
        const release = await repo.gcLock.readLock();
        try {
          const abortOptions = {
            signal: options.signal,
            timeout: options.timeout
          };
          const peekable = itPeekable__default["default"](sources);
          const { value, done } = await peekable.peek();
          if (done) {
            return;
          }
          if (value) {
            peekable.push(value);
          }
          let cars;
          if (value instanceof Uint8Array) {
            cars = [peekable];
          } else {
            cars = peekable;
          }
          for await (const car of cars) {
            const roots = await importCar(repo, abortOptions, car);
            if (options.pinRoots !== false) {
              for (const cid of roots) {
                let pinErrorMsg = "";
                try {
                  if (await repo.blocks.has(cid)) {
                    log15(`Pinning root ${cid}`);
                    await repo.pins.pinRecursively(cid);
                  } else {
                    pinErrorMsg = "blockstore: block not found";
                  }
                } catch (err) {
                  pinErrorMsg = err.message;
                }
                yield {
                  root: {
                    cid,
                    pinErrorMsg
                  }
                };
              }
            }
          }
        } finally {
          release();
        }
      }
      return withTimeoutOption2.withTimeoutOption(dagImport);
    }
    async function importCar(repo, options, source) {
      const reader = await iterator.CarBlockIterator.fromIterable(source);
      const roots = await reader.getRoots();
      await drain__default["default"](repo.blocks.putMany(map__default["default"](reader, ({
        cid: key,
        bytes: value
      }) => {
        log15(`Import block ${key}`);
        return {
          key,
          value
        };
      }), { signal: options.signal }));
      return roots;
    }
    exports2.createImport = createImport3;
  }
});

// node_modules/ipfs-core/cjs/src/components/dag/put.js
var require_put2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/dag/put.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cid = (init_cid(), cid_exports);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createPut5({ repo, codecs: codecs2, hashers, preload: preload2 }) {
      async function put(dagNode, options = {}) {
        const release = options.pin ? await repo.gcLock.readLock() : null;
        try {
          const codecName = options.format || "dag-cbor";
          const cidVersion = options.version != null ? options.version : codecName === "dag-pb" ? 0 : 1;
          const codec = await codecs2.getCodec(codecName);
          if (!codec) {
            throw new Error(`Unknown codec ${options.format}, please configure additional BlockCodecs for this IPFS instance`);
          }
          const hasher = await hashers.getHasher(options.hashAlg || "sha2-256");
          if (!hasher) {
            throw new Error(`Unknown hash algorithm ${options.hashAlg}, please configure additional MultihashHashers for this IPFS instance`);
          }
          const buf2 = codec.encode(dagNode);
          const hash2 = await hasher.digest(buf2);
          const cid$1 = cid.CID.create(cidVersion, codec.code, hash2);
          await repo.blocks.put(cid$1, buf2, { signal: options.signal });
          if (options.pin) {
            await repo.pins.pinRecursively(cid$1);
          }
          if (options.preload !== false) {
            preload2(cid$1);
          }
          return cid$1;
        } finally {
          if (release) {
            release();
          }
        }
      }
      return withTimeoutOption2.withTimeoutOption(put);
    }
    exports2.createPut = createPut5;
  }
});

// node_modules/ipfs-core/cjs/src/components/dag/resolve.js
var require_resolve3 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/dag/resolve.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var toCidAndPath2 = (init_to_cid_and_path(), to_cid_and_path_exports);
    var utils = require_utils();
    function createResolve4({ repo, codecs: codecs2, preload: preload2 }) {
      async function dagResolve(ipfsPath2, options = {}) {
        const { cid } = toCidAndPath2.toCidAndPath(ipfsPath2);
        if (options.preload !== false) {
          preload2(cid);
        }
        return utils.resolvePath(repo, codecs2, ipfsPath2, options);
      }
      return withTimeoutOption2.withTimeoutOption(dagResolve);
    }
    exports2.createResolve = createResolve4;
  }
});

// node_modules/ipfs-core/cjs/src/components/dag/index.js
var require_dag = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/dag/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _export = require_export();
    var get2 = require_get3();
    var _import = require_import();
    var put = require_put2();
    var resolve6 = require_resolve3();
    var DagAPI = class {
      constructor({ repo, codecs: codecs2, hashers, preload: preload2 }) {
        this.export = _export.createExport({
          repo,
          preload: preload2,
          codecs: codecs2
        });
        this.get = get2.createGet({
          codecs: codecs2,
          repo,
          preload: preload2
        });
        this.import = _import.createImport({ repo });
        this.resolve = resolve6.createResolve({
          repo,
          codecs: codecs2,
          preload: preload2
        });
        this.put = put.createPut({
          repo,
          codecs: codecs2,
          hashers,
          preload: preload2
        });
      }
    };
    exports2.DagAPI = DagAPI;
  }
});

// node_modules/multiaddr-to-uri/index.js
var require_multiaddr_to_uri = __commonJS({
  "node_modules/multiaddr-to-uri/index.js"(exports2, module2) {
    init_node_globals();
    var { Multiaddr: Multiaddr18 } = require_src();
    var reduceValue = (_, v) => v;
    var tcpUri = (str, port, parts, opts) => {
      if (opts && opts.assumeHttp === false)
        return `tcp://${str}:${port}`;
      let protocol = "tcp";
      let explicitPort = `:${port}`;
      const last6 = parts[parts.length - 1];
      if (last6.protocol === "tcp") {
        protocol = port === "443" ? "https" : "http";
        explicitPort = port === "443" || port === "80" ? "" : explicitPort;
      }
      return `${protocol}://${str}${explicitPort}`;
    };
    var Reducers = {
      ip4: reduceValue,
      ip6: (str, content, i, parts) => parts.length === 1 && parts[0].protocol === "ip6" ? content : `[${content}]`,
      tcp: (str, content, i, parts, opts) => parts.some((p) => ["http", "https", "ws", "wss"].includes(p.protocol)) ? `${str}:${content}` : tcpUri(str, content, parts, opts),
      udp: (str, content) => `udp://${str}:${content}`,
      dnsaddr: reduceValue,
      dns4: reduceValue,
      dns6: reduceValue,
      ipfs: (str, content) => `${str}/ipfs/${content}`,
      p2p: (str, content) => `${str}/p2p/${content}`,
      http: (str) => `http://${str}`,
      https: (str) => `https://${str}`,
      ws: (str) => `ws://${str}`,
      wss: (str) => `wss://${str}`,
      "p2p-websocket-star": (str) => `${str}/p2p-websocket-star`,
      "p2p-webrtc-star": (str) => `${str}/p2p-webrtc-star`,
      "p2p-webrtc-direct": (str) => `${str}/p2p-webrtc-direct`
    };
    module2.exports = (multiaddr, opts) => {
      const ma = new Multiaddr18(multiaddr);
      const parts = multiaddr.toString().split("/").slice(1);
      return ma.tuples().map((tuple) => ({
        protocol: parts.shift(),
        content: tuple[1] ? parts.shift() : null
      })).reduce((str, part, i, parts2) => {
        const reduce2 = Reducers[part.protocol];
        if (!reduce2)
          throw new Error(`Unsupported protocol ${part.protocol}`);
        return reduce2(str, part.content, i, parts2, opts);
      }, "");
    };
  }
});

// node_modules/array-shuffle/index.js
var require_array_shuffle = __commonJS({
  "node_modules/array-shuffle/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = (array2) => {
      if (!Array.isArray(array2)) {
        throw new TypeError(`Expected an array, got ${typeof array2}`);
      }
      array2 = [...array2];
      for (let index = array2.length - 1; index > 0; index--) {
        const newIndex = Math.floor(Math.random() * (index + 1));
        [array2[index], array2[newIndex]] = [array2[newIndex], array2[index]];
      }
      return array2;
    };
  }
});

// node_modules/ipfs-core-config/esm/src/preload.browser.js
var preload_browser_exports = {};
__export(preload_browser_exports, {
  preload: () => preload
});
function preload(url, options = {}) {
  log4(url);
  return httpQueue2.add(async () => {
    const res = await import_http2.default.post(url, { signal: options.signal });
    const reader = res.body.getReader();
    try {
      while (true) {
        const { done } = await reader.read();
        if (done)
          return;
      }
    } finally {
      reader.releaseLock();
    }
  });
}
var import_http2, import_debug4, import_p_queue2, log4, Queue2, httpQueue2;
var init_preload_browser = __esm({
  "node_modules/ipfs-core-config/esm/src/preload.browser.js"() {
    init_node_globals();
    import_http2 = __toModule(require_http());
    import_debug4 = __toModule(require_browser2());
    import_p_queue2 = __toModule(require_dist());
    log4 = Object.assign((0, import_debug4.default)("ipfs:preload"), { error: (0, import_debug4.default)("ipfs:preload:error") });
    Queue2 = import_p_queue2.default.default ? import_p_queue2.default.default : import_p_queue2.default;
    httpQueue2 = new Queue2({ concurrency: 4 });
  }
});

// node_modules/ipfs-core/cjs/src/preload.js
var require_preload = __commonJS({
  "node_modules/ipfs-core/cjs/src/preload.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var toUri = require_multiaddr_to_uri();
    var debug17 = require_browser2();
    var shuffle = require_array_shuffle();
    var nativeAbortController = require_src4();
    var preload2 = (init_preload_browser(), preload_browser_exports);
    var hashlru2 = require_hashlru();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var toUri__default = /* @__PURE__ */ _interopDefaultLegacy(toUri);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var shuffle__default = /* @__PURE__ */ _interopDefaultLegacy(shuffle);
    var hashlru__default = /* @__PURE__ */ _interopDefaultLegacy(hashlru2);
    var log15 = Object.assign(debug__default["default"]("ipfs:preload"), { error: debug__default["default"]("ipfs:preload:error") });
    function createPreloader(options = {}) {
      options.enabled = Boolean(options.enabled);
      options.addresses = options.addresses || [];
      options.cache = options.cache || 1e3;
      if (!options.enabled || !options.addresses.length) {
        log15("preload disabled");
        const api2 = () => {
        };
        return Object.assign(api2, {
          start: () => {
          },
          stop: () => {
          }
        });
      }
      let stopped = true;
      let requests = [];
      const apiUris = options.addresses.map(toUri__default["default"]);
      const cache2 = hashlru__default["default"](options.cache);
      const api = async (cid) => {
        try {
          if (stopped) {
            throw new Error(`preload ${cid} but preloader is not started`);
          }
          const path = cid.toString();
          if (cache2.has(path)) {
            return;
          }
          cache2.set(path, true);
          const fallbackApiUris = shuffle__default["default"](apiUris);
          let success = false;
          const now = Date.now();
          for (const uri of fallbackApiUris) {
            if (stopped)
              throw new Error(`preload aborted for ${path}`);
            let controller;
            try {
              controller = new nativeAbortController.AbortController();
              requests = requests.concat(controller);
              await preload2.preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path)}`, { signal: controller.signal });
              success = true;
            } catch (err) {
              if (err.type !== "aborted")
                log15.error(err);
            } finally {
              requests = requests.filter((r) => r !== controller);
            }
            if (success)
              break;
          }
          log15(`${success ? "" : "un"}successfully preloaded ${path} in ${Date.now() - now}ms`);
        } catch (err) {
          log15.error(err);
        }
      };
      api.start = () => {
        stopped = false;
      };
      api.stop = () => {
        stopped = true;
        log15(`aborting ${requests.length} pending preload request(s)`);
        requests.forEach((r) => r.abort());
        requests = [];
      };
      return api;
    }
    exports2.createPreloader = createPreloader;
  }
});

// node_modules/ipfs-core/cjs/src/mfs-preload.js
var require_mfs_preload = __commonJS({
  "node_modules/ipfs-core/cjs/src/mfs-preload.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug17 = require_browser2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = Object.assign(debug__default["default"]("ipfs:mfs-preload"), { error: debug__default["default"]("ipfs:mfs-preload:error") });
    function createMfsPreloader({ preload: preload2, files, options = {} }) {
      options.interval = options.interval || 30 * 1e3;
      if (!options.enabled) {
        log15("MFS preload disabled");
        const noop2 = async () => {
        };
        return {
          start: noop2,
          stop: noop2
        };
      }
      let rootCid = "";
      let timeoutId;
      const preloadMfs = async () => {
        try {
          const stats = await files.stat("/");
          const nextRootCid = stats.cid.toString();
          if (rootCid !== nextRootCid) {
            log15(`preloading updated MFS root ${rootCid} -> ${stats.cid}`);
            await preload2(stats.cid);
            rootCid = nextRootCid;
          }
        } catch (err) {
          log15.error("failed to preload MFS root", err);
        } finally {
          timeoutId = setTimeout(preloadMfs, options.interval);
        }
      };
      return {
        async start() {
          const stats = await files.stat("/");
          rootCid = stats.cid.toString();
          log15(`monitoring MFS root ${stats.cid}`);
          timeoutId = setTimeout(preloadMfs, options.interval);
        },
        stop() {
          clearTimeout(timeoutId);
        }
      };
    }
    exports2.createMfsPreloader = createMfsPreloader;
  }
});

// node_modules/mortice/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/mortice/lib/constants.js"(exports2, module2) {
    init_node_globals();
    module2.exports = {
      WORKER_REQUEST_READ_LOCK: "lock:worker:request-read",
      WORKER_RELEASE_READ_LOCK: "lock:worker:release-read",
      MASTER_GRANT_READ_LOCK: "lock:master:grant-read",
      WORKER_REQUEST_WRITE_LOCK: "lock:worker:request-write",
      WORKER_RELEASE_WRITE_LOCK: "lock:worker:release-write",
      MASTER_GRANT_WRITE_LOCK: "lock:master:grant-write"
    };
  }
});

// (disabled):cluster
var require_cluster = __commonJS({
  "(disabled):cluster"() {
    init_node_globals();
  }
});

// node_modules/mortice/lib/node.js
var require_node = __commonJS({
  "node_modules/mortice/lib/node.js"(exports2, module2) {
    init_node_globals();
    var EventEmitter4 = require_events().EventEmitter;
    var { nanoid: nanoid2 } = (init_index_prod(), index_prod_exports);
    var {
      WORKER_REQUEST_READ_LOCK,
      WORKER_RELEASE_READ_LOCK,
      MASTER_GRANT_READ_LOCK,
      WORKER_REQUEST_WRITE_LOCK,
      WORKER_RELEASE_WRITE_LOCK,
      MASTER_GRANT_WRITE_LOCK
    } = require_constants2();
    var cluster;
    var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
      return (worker, requestEvent) => {
        if (requestEvent && requestEvent.type === requestType) {
          emitter.emit(masterEvent, requestEvent.name, () => {
            worker.send({
              type: grantType,
              name: requestEvent.name,
              identifier: requestEvent.identifier
            });
            return new Promise((resolve6) => {
              const releaseEventListener = (releaseEvent) => {
                if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                  worker.removeListener("message", releaseEventListener);
                  resolve6();
                }
              };
              worker.on("message", releaseEventListener);
            });
          });
        }
      };
    };
    var makeWorkerLockRequest = (name5, requestType, grantType, releaseType) => {
      return () => {
        const id = nanoid2();
        process.send({
          type: requestType,
          identifier: id,
          name: name5
        });
        return new Promise((resolve6) => {
          const listener = (event) => {
            if (event && event.type === grantType && event.identifier === id) {
              process.removeListener("message", listener);
              resolve6(() => {
                process.send({
                  type: releaseType,
                  identifier: id,
                  name: name5
                });
              });
            }
          };
          process.on("message", listener);
        });
      };
    };
    module2.exports = (options) => {
      try {
        cluster = require_cluster();
        if (!Object.keys(cluster).length) {
          return;
        }
      } catch (_) {
        return;
      }
      if (cluster.isMaster || options.singleProcess) {
        const emitter = new EventEmitter4();
        cluster.on("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
        cluster.on("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
        return emitter;
      }
      return {
        isWorker: true,
        readLock: (name5) => makeWorkerLockRequest(name5, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
        writeLock: (name5) => makeWorkerLockRequest(name5, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
      };
    };
  }
});

// node_modules/observable-webworkers/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/observable-webworkers/lib/index.js"(exports2, module2) {
    init_node_globals();
    var events = {};
    var observable = (worker) => {
      worker.addEventListener("message", (event) => {
        observable.dispatchEvent("message", worker, event);
      });
      if (worker.port) {
        worker.port.addEventListener("message", (event) => {
          observable.dispatchEvent("message", worker, event);
        });
      }
    };
    observable.addEventListener = (type, fn) => {
      if (!events[type]) {
        events[type] = [];
      }
      events[type].push(fn);
    };
    observable.removeEventListener = (type, fn) => {
      if (!events[type]) {
        return;
      }
      events[type] = events[type].filter((listener) => listener === fn);
    };
    observable.dispatchEvent = function() {
      const args = Array.prototype.slice.call(arguments);
      const type = args.shift();
      if (!events[type]) {
        return;
      }
      events[type].forEach((fn) => fn.apply(null, args));
    };
    module2.exports = observable;
  }
});

// node_modules/mortice/lib/browser.js
var require_browser5 = __commonJS({
  "node_modules/mortice/lib/browser.js"(exports2, module2) {
    init_node_globals();
    var EventEmitter4 = require_events().EventEmitter;
    var { nanoid: nanoid2 } = (init_index_prod(), index_prod_exports);
    var {
      WORKER_REQUEST_READ_LOCK,
      WORKER_RELEASE_READ_LOCK,
      MASTER_GRANT_READ_LOCK,
      WORKER_REQUEST_WRITE_LOCK,
      WORKER_RELEASE_WRITE_LOCK,
      MASTER_GRANT_WRITE_LOCK
    } = require_constants2();
    var observer = require_lib2();
    var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
      return (worker, event) => {
        if (!event || !event.data || event.data.type !== requestType) {
          return;
        }
        const requestEvent = {
          type: event.data.type,
          name: event.data.name,
          identifier: event.data.identifier
        };
        emitter.emit(masterEvent, requestEvent.name, () => {
          worker.postMessage({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          return new Promise((resolve6) => {
            const releaseEventListener = (event2) => {
              if (!event2 || !event2.data) {
                return;
              }
              const releaseEvent = {
                type: event2.data.type,
                name: event2.data.name,
                identifier: event2.data.identifier
              };
              if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeEventListener("message", releaseEventListener);
                resolve6();
              }
            };
            worker.addEventListener("message", releaseEventListener);
          });
        });
      };
    };
    var makeWorkerLockRequest = (name5, requestType, grantType, releaseType) => {
      return () => {
        const id = nanoid2();
        globalThis.postMessage({
          type: requestType,
          identifier: id,
          name: name5
        });
        return new Promise((resolve6) => {
          const listener = (event) => {
            if (!event || !event.data) {
              return;
            }
            const responseEvent = {
              type: event.data.type,
              identifier: event.data.identifier
            };
            if (responseEvent && responseEvent.type === grantType && responseEvent.identifier === id) {
              globalThis.removeEventListener("message", listener);
              resolve6(() => {
                globalThis.postMessage({
                  type: releaseType,
                  identifier: id,
                  name: name5
                });
              });
            }
          };
          globalThis.addEventListener("message", listener);
        });
      };
    };
    var defaultOptions4 = {
      singleProcess: false
    };
    module2.exports = (options) => {
      options = Object.assign({}, defaultOptions4, options);
      const isMaster = !!globalThis.document || options.singleProcess;
      if (isMaster) {
        const emitter = new EventEmitter4();
        observer.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
        observer.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
        return emitter;
      }
      return {
        isWorker: true,
        readLock: (name5) => makeWorkerLockRequest(name5, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
        writeLock: (name5) => makeWorkerLockRequest(name5, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
      };
    };
  }
});

// node_modules/promise-timeout/index.js
var require_promise_timeout = __commonJS({
  "node_modules/promise-timeout/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var TimeoutError2;
    var timeout = module2.exports.timeout = function(promise, timeoutMillis) {
      var error = new TimeoutError2(), timeout2;
      return Promise.race([
        promise,
        new Promise(function(resolve6, reject) {
          timeout2 = setTimeout(function() {
            reject(error);
          }, timeoutMillis);
        })
      ]).then(function(v) {
        clearTimeout(timeout2);
        return v;
      }, function(err) {
        clearTimeout(timeout2);
        throw err;
      });
    };
    TimeoutError2 = module2.exports.TimeoutError = function() {
      Error.call(this);
      this.stack = Error().stack;
      this.message = "Timeout";
    };
    TimeoutError2.prototype = Object.create(Error.prototype);
    TimeoutError2.prototype.name = "TimeoutError";
  }
});

// node_modules/mortice/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/mortice/lib/index.js"(exports2, module2) {
    init_node_globals();
    var node = require_node();
    var browser = require_browser5();
    var { default: Queue4 } = require_dist();
    var { timeout } = require_promise_timeout();
    var observe = require_lib2();
    var mutexes = {};
    var implementation;
    function createReleaseable(queue, options) {
      let res;
      const p = new Promise((resolve6) => {
        res = resolve6;
      });
      queue.add(() => timeout((() => {
        return new Promise((resolve6) => {
          res(() => {
            resolve6();
          });
        });
      })(), options.timeout));
      return p;
    }
    var createMutex = (name5, options) => {
      if (implementation.isWorker) {
        return {
          readLock: implementation.readLock(name5, options),
          writeLock: implementation.writeLock(name5, options)
        };
      }
      const masterQueue = new Queue4({ concurrency: 1 });
      let readQueue = null;
      return {
        readLock: () => {
          if (readQueue) {
            return createReleaseable(readQueue, options);
          }
          readQueue = new Queue4({
            concurrency: options.concurrency,
            autoStart: false
          });
          const localReadQueue = readQueue;
          const readPromise = createReleaseable(readQueue, options);
          masterQueue.add(() => {
            localReadQueue.start();
            return localReadQueue.onIdle().then(() => {
              if (readQueue === localReadQueue) {
                readQueue = null;
              }
            });
          });
          return readPromise;
        },
        writeLock: () => {
          readQueue = null;
          return createReleaseable(masterQueue, options);
        }
      };
    };
    var defaultOptions4 = {
      concurrency: Infinity,
      timeout: 846e5,
      global,
      singleProcess: false
    };
    module2.exports = (name5, options) => {
      if (!options) {
        options = {};
      }
      if (typeof name5 === "object") {
        options = name5;
        name5 = "lock";
      }
      if (!name5) {
        name5 = "lock";
      }
      options = Object.assign({}, defaultOptions4, options);
      if (!implementation) {
        implementation = node(options) || browser(options);
        if (!implementation.isWorker) {
          implementation.on("requestReadLock", (name6, fn) => {
            if (!mutexes[name6]) {
              return;
            }
            mutexes[name6].readLock().then((release) => fn().finally(() => release()));
          });
          implementation.on("requestWriteLock", async (name6, fn) => {
            if (!mutexes[name6]) {
              return;
            }
            mutexes[name6].writeLock().then((release) => fn().finally(() => release()));
          });
        }
      }
      if (!mutexes[name5]) {
        mutexes[name5] = createMutex(name5, options);
      }
      return mutexes[name5];
    };
    module2.exports.Worker = function(script, Impl) {
      Impl = Impl || global.Worker;
      let worker;
      try {
        worker = new Impl(script);
      } catch (error) {
        if (error.message.includes("not a constructor")) {
          worker = Impl(script);
        }
      }
      if (!worker) {
        throw new Error("Could not create Worker from", Impl);
      }
      observe(worker);
      return worker;
    };
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/create-lock.js
var require_create_lock = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/create-lock.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var mortice2 = require_lib3();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var mortice__default = /* @__PURE__ */ _interopDefaultLegacy(mortice2);
    var lock2;
    function createLock(repoOwner = false) {
      if (lock2) {
        return lock2;
      }
      const mutex = mortice__default["default"]({ singleProcess: repoOwner });
      lock2 = {
        readLock: (func) => {
          return async (...args) => {
            const releaseLock = await mutex.readLock();
            try {
              return await func.apply(null, args);
            } finally {
              releaseLock();
            }
          };
        },
        writeLock: (func) => {
          return async (...args) => {
            const releaseLock = await mutex.writeLock();
            try {
              return await func.apply(null, args);
            } finally {
              releaseLock();
            }
          };
        }
      };
      return lock2;
    }
    exports2.createLock = createLock;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/with-mfs-root.js
var require_with_mfs_root = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/with-mfs-root.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cid = (init_cid(), cid_exports);
    var ipfsUnixfs = (init_src(), src_exports);
    var dagPB = (init_src2(), src_exports2);
    var sha2 = (init_sha2_browser(), sha2_browser_exports);
    var debug17 = require_browser2();
    var errCode32 = require_err_code();
    var utils = require_utils();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var log15 = debug__default["default"]("ipfs:mfs:utils:with-mfs-root");
    async function loadMfsRoot(context, options) {
      if (options && options.signal && options.signal.aborted) {
        throw errCode__default["default"](new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
      }
      await context.repo.datastore.open();
      let cid$1;
      try {
        const buf2 = await context.repo.datastore.get(utils.MFS_ROOT_KEY);
        cid$1 = cid.CID.decode(buf2);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
        log15("Creating new MFS root");
        const buf2 = dagPB__namespace.encode({
          Data: new ipfsUnixfs.UnixFS({ type: "directory" }).marshal(),
          Links: []
        });
        const hash2 = await sha2.sha256.digest(buf2);
        cid$1 = cid.CID.createV0(hash2);
        await context.repo.blocks.put(cid$1, buf2);
        if (options && options.signal && options.signal.aborted) {
          throw errCode__default["default"](new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
        }
        await context.repo.datastore.put(utils.MFS_ROOT_KEY, cid$1.bytes);
      }
      log15(`Loaded MFS root /ipfs/${cid$1}`);
      return cid$1;
    }
    exports2.loadMfsRoot = loadMfsRoot;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/to-path-components.js
var require_to_path_components = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/to-path-components.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function toPathComponents3(path = "") {
      return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
    }
    exports2.toPathComponents = toPathComponents3;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/to-mfs-path.js
var require_to_mfs_path = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/to-mfs-path.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withMfsRoot = require_with_mfs_root();
    var toPathComponents3 = require_to_path_components();
    var ipfsUnixfsExporter = (init_src9(), src_exports6);
    var errCode32 = require_err_code();
    var cid = (init_cid(), cid_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var IPFS_PREFIX2 = "ipfs";
    var toMfsPath = async (context, path, options) => {
      const root = await withMfsRoot.loadMfsRoot(context, options);
      let output = { entryType: "file" };
      let ipfsPath2 = "";
      if (cid.CID.asCID(path)) {
        ipfsPath2 = `/ipfs/${path}`;
      } else {
        ipfsPath2 = path.toString();
      }
      ipfsPath2 = ipfsPath2.trim();
      ipfsPath2 = ipfsPath2.replace(/(\/\/+)/g, "/");
      if (ipfsPath2.endsWith("/") && ipfsPath2.length > 1) {
        ipfsPath2 = ipfsPath2.substring(0, ipfsPath2.length - 1);
      }
      if (!ipfsPath2) {
        throw errCode__default["default"](new Error("paths must not be empty"), "ERR_NO_PATH");
      }
      if (ipfsPath2.substring(0, 1) !== "/") {
        throw errCode__default["default"](new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
      }
      if (ipfsPath2.substring(ipfsPath2.length - 1) === "/") {
        ipfsPath2 = ipfsPath2.substring(0, ipfsPath2.length - 1);
      }
      const pathComponents = toPathComponents3.toPathComponents(ipfsPath2);
      if (pathComponents[0] === IPFS_PREFIX2) {
        let mfsDirectory;
        if (pathComponents.length === 2) {
          mfsDirectory = `/${pathComponents.join("/")}`;
        } else {
          mfsDirectory = `/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
        }
        output = {
          type: "ipfs",
          depth: pathComponents.length - 2,
          entryType: "file",
          mfsPath: `/${pathComponents.join("/")}`,
          mfsDirectory,
          parts: pathComponents,
          path: `/${pathComponents.join("/")}`,
          name: pathComponents[pathComponents.length - 1]
        };
      } else {
        const mfsPath = `/${IPFS_PREFIX2}/${root}${pathComponents.length ? "/" + pathComponents.join("/") : ""}`;
        const mfsDirectory = `/${IPFS_PREFIX2}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
        output = {
          type: "mfs",
          depth: pathComponents.length,
          entryType: "file",
          mfsDirectory,
          mfsPath,
          parts: pathComponents,
          path: `/${pathComponents.join("/")}`,
          name: pathComponents[pathComponents.length - 1]
        };
      }
      const cidPath = output.type === "mfs" ? output.mfsPath : output.path;
      try {
        const res = await ipfsUnixfsExporter.exporter(cidPath, context.repo.blocks, options);
        output.cid = res.cid;
        output.mfsPath = `/ipfs/${res.path}`;
        output.entryType = res.type;
        output.content = res.content;
        if ((output.entryType === "file" || output.entryType === "directory") && (res.type === "file" || res.type === "directory")) {
          output.unixfs = res.unixfs;
        }
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      output.exists = Boolean(output.cid);
      return output;
    };
    exports2.toMfsPath = toMfsPath;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/stat.js
var require_stat3 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/stat.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var mergeOpts = require_merge_options();
    var toMfsPath = require_to_mfs_path();
    var ipfsUnixfsExporter = (init_src9(), src_exports6);
    var debug17 = require_browser2();
    var errCode32 = require_err_code();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var dagPB = (init_src2(), src_exports2);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var log15 = debug__default["default"]("ipfs:mfs:stat");
    var defaultOptions4 = { withLocal: false };
    function createStat6(context) {
      async function mfsStat(path, options = {}) {
        options = mergeOptions2(defaultOptions4, options);
        log15(`Fetching stats for ${path}`);
        const { type, cid, mfsPath } = await toMfsPath.toMfsPath(context, path, options);
        const exportPath = type === "ipfs" && cid ? cid : mfsPath;
        let file;
        try {
          file = await ipfsUnixfsExporter.exporter(exportPath, context.repo.blocks);
        } catch (err) {
          if (err.code === "ERR_NOT_FOUND") {
            throw errCode__default["default"](new Error(`${path} does not exist`), "ERR_NOT_FOUND");
          }
          throw err;
        }
        if (!statters[file.type]) {
          throw new Error(`Cannot stat codec ${file.cid.code}`);
        }
        return statters[file.type](file);
      }
      return withTimeoutOption2.withTimeoutOption(mfsStat);
    }
    var statters = {
      raw: (file) => {
        return {
          cid: file.cid,
          size: file.node.length,
          cumulativeSize: file.node.length,
          blocks: 0,
          type: "file",
          local: void 0,
          sizeLocal: void 0,
          withLocality: false
        };
      },
      file: (file) => {
        const stat = {
          cid: file.cid,
          type: "file",
          size: file.unixfs.fileSize(),
          cumulativeSize: dagPB__namespace.encode(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
          blocks: file.unixfs.blockSizes.length,
          local: void 0,
          sizeLocal: void 0,
          withLocality: false,
          mode: file.unixfs.mode
        };
        if (file.unixfs.mtime) {
          stat.mtime = file.unixfs.mtime;
        }
        return stat;
      },
      directory: (file) => {
        const stat = {
          cid: file.cid,
          type: "directory",
          size: 0,
          cumulativeSize: dagPB__namespace.encode(file.node).length + (file.node.Links || []).reduce((acc, curr) => acc + (curr.Tsize || 0), 0),
          blocks: file.node.Links.length,
          local: void 0,
          sizeLocal: void 0,
          withLocality: false,
          mode: file.unixfs.mode
        };
        if (file.unixfs.mtime) {
          stat.mtime = file.unixfs.mtime;
        }
        return stat;
      },
      object: (file) => {
        return {
          cid: file.cid,
          size: file.node.length,
          cumulativeSize: file.node.length,
          type: "file",
          blocks: 0,
          local: void 0,
          sizeLocal: void 0,
          withLocality: false
        };
      },
      identity: (file) => {
        return {
          cid: file.cid,
          size: file.node.length,
          cumulativeSize: file.node.length,
          blocks: 0,
          type: "file",
          local: void 0,
          sizeLocal: void 0,
          withLocality: false
        };
      }
    };
    exports2.createStat = createStat6;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/to-trail.js
var require_to_trail = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/to-trail.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipfsUnixfsExporter = (init_src9(), src_exports6);
    var debug17 = require_browser2();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = debug__default["default"]("ipfs:mfs:utils:to-trail");
    async function toTrail(context, path) {
      log15(`Creating trail for path ${path}`);
      const output = [];
      for await (const fsEntry of ipfsUnixfsExporter.walkPath(path, context.repo.blocks)) {
        output.push({
          name: fsEntry.name,
          cid: fsEntry.cid,
          size: fsEntry.size,
          type: fsEntry.type
        });
      }
      return output;
    }
    exports2.toTrail = toTrail;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/persist.js
var require_persist = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/persist.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cid = (init_cid(), cid_exports);
    var dagPB = (init_src2(), src_exports2);
    var sha2 = (init_sha2_browser(), sha2_browser_exports);
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var persist2 = async (buffer2, blockstore, options) => {
      if (!options.codec) {
        options.codec = dagPB__namespace;
      }
      if (!options.hasher) {
        options.hasher = sha2.sha256;
      }
      if (options.cidVersion === void 0) {
        options.cidVersion = 1;
      }
      if (options.codec === dagPB__namespace && options.hasher !== sha2.sha256) {
        options.cidVersion = 1;
      }
      const multihash = await options.hasher.digest(buffer2);
      const cid$1 = cid.CID.create(options.cidVersion, options.codec.code, multihash);
      if (!options.onlyHash) {
        await blockstore.put(cid$1, buffer2, { signal: options.signal });
      }
      return cid$1;
    };
    exports2.persist = persist2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/hamt-constants.js
var require_hamt_constants = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/hamt-constants.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var murmur3 = (init_esm2(), esm_exports2);
    var hamtHashCode = murmur3.murmur3128.code;
    var hamtBucketBits = 8;
    async function hamtHashFn2(buf2) {
      return (await murmur3.murmur3128.encode(buf2)).slice(0, 8).reverse();
    }
    exports2.hamtBucketBits = hamtBucketBits;
    exports2.hamtHashCode = hamtHashCode;
    exports2.hamtHashFn = hamtHashFn2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/dir-sharded.js
var require_dir_sharded = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/dir-sharded.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dagPB = (init_src2(), src_exports2);
    var ipfsUnixfs = (init_src(), src_exports);
    var persist2 = require_persist();
    var hamtSharding = require_src10();
    var hamtConstants = require_hamt_constants();
    var Dir2 = class {
      constructor(props, options) {
        this.options = options || {};
        this.root = props.root;
        this.dir = props.dir;
        this.path = props.path;
        this.dirty = props.dirty;
        this.flat = props.flat;
        this.parent = props.parent;
        this.parentKey = props.parentKey;
        this.unixfs = props.unixfs;
        this.mode = props.mode;
        this.mtime = props.mtime;
        this.cid = void 0;
        this.size = void 0;
      }
      async put(name5, value) {
      }
      get(name5) {
        return Promise.resolve(this);
      }
      async *eachChildSeries() {
      }
      async *flush(blockstore) {
      }
    };
    var DirSharded2 = class extends Dir2 {
      constructor(props, options) {
        super(props, options);
        this._bucket = hamtSharding.createHAMT({
          hashFn: hamtConstants.hamtHashFn,
          bits: hamtConstants.hamtBucketBits
        });
      }
      async put(name5, value) {
        await this._bucket.put(name5, value);
      }
      get(name5) {
        return this._bucket.get(name5);
      }
      childCount() {
        return this._bucket.leafCount();
      }
      directChildrenCount() {
        return this._bucket.childrenCount();
      }
      onlyChild() {
        return this._bucket.onlyChild();
      }
      async *eachChildSeries() {
        for await (const { key, value } of this._bucket.eachLeafSeries()) {
          yield {
            key,
            child: value
          };
        }
      }
      async *flush(blockstore) {
        yield* flush2(this._bucket, blockstore, this, this.options);
      }
    };
    async function* flush2(bucket, blockstore, shardRoot, options) {
      const children = bucket._children;
      const links2 = [];
      let childrenSize = 0;
      for (let i = 0; i < children.length; i++) {
        const child = children.get(i);
        if (!child) {
          continue;
        }
        const labelPrefix = i.toString(16).toUpperCase().padStart(2, "0");
        if (child instanceof hamtSharding.Bucket) {
          let shard2;
          for await (const subShard of await flush2(child, blockstore, null, options)) {
            shard2 = subShard;
          }
          if (!shard2) {
            throw new Error("Could not flush sharded directory, no subshard found");
          }
          links2.push({
            Name: labelPrefix,
            Tsize: shard2.size,
            Hash: shard2.cid
          });
          childrenSize += shard2.size;
        } else if (typeof child.value.flush === "function") {
          const dir2 = child.value;
          let flushedDir;
          for await (const entry of dir2.flush(blockstore)) {
            flushedDir = entry;
            yield flushedDir;
          }
          const label = labelPrefix + child.key;
          links2.push({
            Name: label,
            Tsize: flushedDir.size,
            Hash: flushedDir.cid
          });
          childrenSize += flushedDir.size;
        } else {
          const value = child.value;
          if (!value.cid) {
            continue;
          }
          const label = labelPrefix + child.key;
          const size2 = value.size;
          links2.push({
            Name: label,
            Tsize: size2,
            Hash: value.cid
          });
          childrenSize += size2;
        }
      }
      const data = Uint8Array.from(children.bitField().reverse());
      const dir = new ipfsUnixfs.UnixFS({
        type: "hamt-sharded-directory",
        data,
        fanout: bucket.tableSize(),
        hashType: hamtConstants.hamtHashCode,
        mtime: shardRoot && shardRoot.mtime,
        mode: shardRoot && shardRoot.mode
      });
      const node = {
        Data: dir.marshal(),
        Links: links2
      };
      const buffer2 = dagPB.encode(dagPB.prepare(node));
      const cid = await persist2.persist(buffer2, blockstore, options);
      const size = buffer2.length + childrenSize;
      yield {
        cid,
        node,
        size
      };
    }
    exports2.Dir = Dir2;
    exports2.DirSharded = DirSharded2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/hamt-utils.js
var require_hamt_utils = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/hamt-utils.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dagPB = (init_src2(), src_exports2);
    var hamtSharding = require_src10();
    var dirSharded = require_dir_sharded();
    var debug17 = require_browser2();
    var ipfsUnixfs = (init_src(), src_exports);
    var last6 = require_it_last();
    var cid = (init_cid(), cid_exports);
    var hamtConstants = require_hamt_constants();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var last__default = /* @__PURE__ */ _interopDefaultLegacy(last6);
    var log15 = debug__default["default"]("ipfs:mfs:core:utils:hamt-utils");
    var updateHamtDirectory = async (context, links2, bucket, options) => {
      if (!options.parent.Data) {
        throw new Error("Could not update HAMT directory because parent had no data");
      }
      const data = Uint8Array.from(bucket._children.bitField().reverse());
      const node = ipfsUnixfs.UnixFS.unmarshal(options.parent.Data);
      const dir = new ipfsUnixfs.UnixFS({
        type: "hamt-sharded-directory",
        data,
        fanout: bucket.tableSize(),
        hashType: hamtConstants.hamtHashCode,
        mode: node.mode,
        mtime: node.mtime
      });
      const hasher = await context.hashers.getHasher(options.hashAlg);
      const parent2 = {
        Data: dir.marshal(),
        Links: links2.sort((a, b) => (a.Name || "").localeCompare(b.Name || ""))
      };
      const buf2 = dagPB__namespace.encode(parent2);
      const hash2 = await hasher.digest(buf2);
      const cid$1 = cid.CID.create(options.cidVersion, dagPB__namespace.code, hash2);
      if (options.flush) {
        await context.repo.blocks.put(cid$1, buf2);
      }
      return {
        node: parent2,
        cid: cid$1,
        size: links2.reduce((sum, link) => sum + (link.Tsize || 0), buf2.length)
      };
    };
    var recreateHamtLevel = async (links2, rootBucket, parentBucket, positionAtParent) => {
      const bucket = new hamtSharding.Bucket({
        hash: rootBucket._options.hash,
        bits: rootBucket._options.bits
      }, parentBucket, positionAtParent);
      parentBucket._putObjectAt(positionAtParent, bucket);
      await addLinksToHamtBucket2(links2, bucket, rootBucket);
      return bucket;
    };
    var recreateInitialHamtLevel = async (links2) => {
      const bucket = hamtSharding.createHAMT({
        hashFn: hamtConstants.hamtHashFn,
        bits: hamtConstants.hamtBucketBits
      });
      await addLinksToHamtBucket2(links2, bucket, bucket);
      return bucket;
    };
    var addLinksToHamtBucket2 = async (links2, bucket, rootBucket) => {
      await Promise.all(links2.map((link) => {
        const linkName = link.Name || "";
        if (linkName.length === 2) {
          const pos = parseInt(linkName, 16);
          bucket._putObjectAt(pos, new hamtSharding.Bucket({
            hash: rootBucket._options.hash,
            bits: rootBucket._options.bits
          }, bucket, pos));
          return Promise.resolve();
        }
        return rootBucket.put(linkName.substring(2), {
          size: link.Tsize,
          cid: link.Hash
        });
      }));
    };
    var toPrefix2 = (position) => {
      return position.toString(16).toUpperCase().padStart(2, "0").substring(0, 2);
    };
    var generatePath = async (context, fileName, rootNode) => {
      const rootBucket = await recreateInitialHamtLevel(rootNode.Links);
      const position = await rootBucket._findNewBucketAndPos(fileName);
      const path = [{
        bucket: position.bucket,
        prefix: toPrefix2(position.pos)
      }];
      let currentBucket = position.bucket;
      while (currentBucket !== rootBucket) {
        path.push({
          bucket: currentBucket,
          prefix: toPrefix2(currentBucket._posAtParent)
        });
        currentBucket = currentBucket._parent;
      }
      path.reverse();
      path[0].node = rootNode;
      for (let i = 0; i < path.length; i++) {
        const segment = path[i];
        if (!segment.node) {
          throw new Error("Could not generate HAMT path");
        }
        const link = segment.node.Links.filter((link2) => (link2.Name || "").substring(0, 2) === segment.prefix).pop();
        if (!link) {
          log15(`Link ${segment.prefix}${fileName} will be added`);
          continue;
        }
        if (link.Name === `${segment.prefix}${fileName}`) {
          log15(`Link ${segment.prefix}${fileName} will be replaced`);
          continue;
        }
        log15(`Found subshard ${segment.prefix}`);
        const block = await context.repo.blocks.get(link.Hash);
        const node = dagPB__namespace.decode(block);
        if (!path[i + 1]) {
          log15(`Loaded new subshard ${segment.prefix}`);
          await recreateHamtLevel(node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
          const position2 = await rootBucket._findNewBucketAndPos(fileName);
          path.push({
            bucket: position2.bucket,
            prefix: toPrefix2(position2.pos),
            node
          });
          continue;
        }
        const nextSegment = path[i + 1];
        await addLinksToHamtBucket2(node.Links, nextSegment.bucket, rootBucket);
        nextSegment.node = node;
      }
      await rootBucket.put(fileName, true);
      path.reverse();
      return {
        rootBucket,
        path
      };
    };
    var createShard = async (context, contents, options = {}) => {
      const shard2 = new dirSharded.DirSharded({
        root: true,
        dir: true,
        parent: void 0,
        parentKey: void 0,
        path: "",
        dirty: true,
        flat: false,
        mtime: options.mtime,
        mode: options.mode
      }, options);
      for (let i = 0; i < contents.length; i++) {
        await shard2._bucket.put(contents[i].name, {
          size: contents[i].size,
          cid: contents[i].cid
        });
      }
      const res = await last__default["default"](shard2.flush(context.repo.blocks));
      if (!res) {
        throw new Error("Flushing shard yielded no result");
      }
      return res;
    };
    exports2.addLinksToHamtBucket = addLinksToHamtBucket2;
    exports2.createShard = createShard;
    exports2.generatePath = generatePath;
    exports2.recreateHamtLevel = recreateHamtLevel;
    exports2.recreateInitialHamtLevel = recreateInitialHamtLevel;
    exports2.toPrefix = toPrefix2;
    exports2.updateHamtDirectory = updateHamtDirectory;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/add-link.js
var require_add_link = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/add-link.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dagPB = (init_src2(), src_exports2);
    var cid = (init_cid(), cid_exports);
    var debug17 = require_browser2();
    var ipfsUnixfs = (init_src(), src_exports);
    var dirSharded = require_dir_sharded();
    var hamtUtils = require_hamt_utils();
    var errCode32 = require_err_code();
    var last6 = require_it_last();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var last__default = /* @__PURE__ */ _interopDefaultLegacy(last6);
    var log15 = debug__default["default"]("ipfs:mfs:core:utils:add-link");
    async function addLink(context, options) {
      let parent2 = options.parent;
      if (options.parentCid) {
        const parentCid = cid.CID.asCID(options.parentCid);
        if (parentCid === null) {
          throw errCode__default["default"](new Error("Invalid CID passed to addLink"), "EINVALIDPARENTCID");
        }
        if (parentCid.code !== dagPB__namespace.code) {
          throw errCode__default["default"](new Error("Unsupported codec. Only DAG-PB is supported"), "EINVALIDPARENTCID");
        }
        log15(`Loading parent node ${parentCid}`);
        const block = await context.repo.blocks.get(parentCid);
        parent2 = dagPB__namespace.decode(block);
      }
      if (!parent2) {
        throw errCode__default["default"](new Error("No parent node or CID passed to addLink"), "EINVALIDPARENT");
      }
      if (!options.cid) {
        throw errCode__default["default"](new Error("No child cid passed to addLink"), "EINVALIDCHILDCID");
      }
      if (!options.name) {
        throw errCode__default["default"](new Error("No child name passed to addLink"), "EINVALIDCHILDNAME");
      }
      if (!options.size && options.size !== 0) {
        throw errCode__default["default"](new Error("No child size passed to addLink"), "EINVALIDCHILDSIZE");
      }
      if (!parent2.Data) {
        throw errCode__default["default"](new Error("Parent node with no data passed to addLink"), "ERR_INVALID_PARENT");
      }
      const meta = ipfsUnixfs.UnixFS.unmarshal(parent2.Data);
      if (meta.type === "hamt-sharded-directory") {
        log15("Adding link to sharded directory");
        return addToShardedDirectory(context, {
          ...options,
          parent: parent2
        });
      }
      if (parent2.Links.length >= options.shardSplitThreshold) {
        log15("Converting directory to sharded directory");
        return convertToShardedDirectory(context, {
          ...options,
          parent: parent2,
          mtime: meta.mtime,
          mode: meta.mode
        });
      }
      log15(`Adding ${options.name} (${options.cid}) to regular directory`);
      return addToDirectory(context, {
        ...options,
        parent: parent2
      });
    }
    var convertToShardedDirectory = async (context, options) => {
      const result = await hamtUtils.createShard(context, options.parent.Links.map((link) => ({
        name: link.Name || "",
        size: link.Tsize || 0,
        cid: link.Hash
      })).concat({
        name: options.name,
        size: options.size,
        cid: options.cid
      }), options);
      log15(`Converted directory to sharded directory ${result.cid}`);
      return result;
    };
    var addToDirectory = async (context, options) => {
      const parentLinks = options.parent.Links.filter((link) => {
        return link.Name !== options.name;
      });
      parentLinks.push({
        Name: options.name,
        Tsize: options.size,
        Hash: options.cid
      });
      if (!options.parent.Data) {
        throw errCode__default["default"](new Error("Parent node with no data passed to addToDirectory"), "ERR_INVALID_PARENT");
      }
      const node = ipfsUnixfs.UnixFS.unmarshal(options.parent.Data);
      let data;
      if (node.mtime) {
        const ms = Date.now();
        const secs = Math.floor(ms / 1e3);
        node.mtime = {
          secs,
          nsecs: (ms - secs * 1e3) * 1e3
        };
        data = node.marshal();
      } else {
        data = options.parent.Data;
      }
      options.parent = dagPB__namespace.prepare({
        Data: data,
        Links: parentLinks
      });
      const hasher = await context.hashers.getHasher(options.hashAlg);
      const buf2 = dagPB__namespace.encode(options.parent);
      const hash2 = await hasher.digest(buf2);
      const cid$1 = cid.CID.create(options.cidVersion, dagPB__namespace.code, hash2);
      if (options.flush) {
        await context.repo.blocks.put(cid$1, buf2);
      }
      return {
        node: options.parent,
        cid: cid$1,
        size: buf2.length
      };
    };
    var addToShardedDirectory = async (context, options) => {
      const { shard: shard2, path } = await addFileToShardedDirectory(context, options);
      const result = await last__default["default"](shard2.flush(context.repo.blocks));
      if (!result) {
        throw new Error("No result from flushing shard");
      }
      const block = await context.repo.blocks.get(result.cid);
      const node = dagPB__namespace.decode(block);
      const parentLinks = options.parent.Links.filter((link) => {
        return (link.Name || "").substring(0, 2) !== path[0].prefix;
      });
      const newLink = node.Links.find((link) => (link.Name || "").substring(0, 2) === path[0].prefix);
      if (!newLink) {
        throw new Error(`No link found with prefix ${path[0].prefix}`);
      }
      parentLinks.push(newLink);
      return hamtUtils.updateHamtDirectory(context, parentLinks, path[0].bucket, options);
    };
    var addFileToShardedDirectory = async (context, options) => {
      const file = {
        name: options.name,
        cid: options.cid,
        size: options.size
      };
      if (!options.parent.Data) {
        throw errCode__default["default"](new Error("Parent node with no data passed to addFileToShardedDirectory"), "ERR_INVALID_PARENT");
      }
      const rootBucket = await hamtUtils.recreateInitialHamtLevel(options.parent.Links);
      const node = ipfsUnixfs.UnixFS.unmarshal(options.parent.Data);
      const shard2 = new dirSharded.DirSharded({
        root: true,
        dir: true,
        parent: void 0,
        parentKey: void 0,
        path: "",
        dirty: true,
        flat: false,
        mode: node.mode
      }, options);
      shard2._bucket = rootBucket;
      if (node.mtime) {
        shard2.mtime = { secs: Math.round(Date.now() / 1e3) };
      }
      const position = await rootBucket._findNewBucketAndPos(file.name);
      const path = toBucketPath2(position);
      path[0].node = options.parent;
      let index = 0;
      while (index < path.length) {
        const segment = path[index];
        index++;
        const node2 = segment.node;
        if (!node2) {
          throw new Error("Segment had no node");
        }
        const link = node2.Links.find((link2) => (link2.Name || "").substring(0, 2) === segment.prefix);
        if (!link) {
          log15(`Link ${segment.prefix}${file.name} will be added`);
          index = path.length;
          break;
        }
        if (link.Name === `${segment.prefix}${file.name}`) {
          log15(`Link ${segment.prefix}${file.name} will be replaced`);
          index = path.length;
          break;
        }
        if ((link.Name || "").length > 2) {
          log15(`Link ${link.Name} ${link.Hash} will be replaced with a subshard`);
          index = path.length;
          break;
        }
        log15(`Found subshard ${segment.prefix}`);
        const block = await context.repo.blocks.get(link.Hash);
        const subShard = dagPB__namespace.decode(block);
        if (!path[index]) {
          log15(`Loaded new subshard ${segment.prefix}`);
          await hamtUtils.recreateHamtLevel(subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
          const position2 = await rootBucket._findNewBucketAndPos(file.name);
          path.push({
            bucket: position2.bucket,
            prefix: hamtUtils.toPrefix(position2.pos),
            node: subShard
          });
          break;
        }
        const nextSegment = path[index];
        await hamtUtils.addLinksToHamtBucket(subShard.Links, nextSegment.bucket, rootBucket);
        nextSegment.node = subShard;
      }
      await shard2._bucket.put(file.name, {
        size: file.size,
        cid: file.cid
      });
      return {
        shard: shard2,
        path
      };
    };
    var toBucketPath2 = (position) => {
      const path = [{
        bucket: position.bucket,
        prefix: hamtUtils.toPrefix(position.pos)
      }];
      let bucket = position.bucket._parent;
      let positionInBucket = position.bucket._posAtParent;
      while (bucket) {
        path.push({
          bucket,
          prefix: hamtUtils.toPrefix(positionInBucket)
        });
        positionInBucket = bucket._posAtParent;
        bucket = bucket._parent;
      }
      path.reverse();
      return path;
    };
    exports2.addLink = addLink;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/update-tree.js
var require_update_tree = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/update-tree.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug17 = require_browser2();
    var addLink = require_add_link();
    var dagPB = (init_src2(), src_exports2);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = debug__default["default"]("ipfs:mfs:utils:update-tree");
    var defaultOptions4 = { shardSplitThreshold: 1e3 };
    async function updateTree(context, trail, options) {
      options = Object.assign({}, defaultOptions4, options);
      log15("Trail", trail);
      trail = trail.slice().reverse();
      let index = 0;
      let child;
      for await (const block of context.repo.blocks.getMany(trail.map((node) => node.cid))) {
        const node = dagPB.decode(block);
        const cid2 = trail[index].cid;
        const name5 = trail[index].name;
        index++;
        if (!child) {
          child = {
            cid: cid2,
            name: name5,
            size: block.length
          };
          continue;
        }
        const result = await addLink.addLink(context, {
          parent: node,
          name: child.name,
          cid: child.cid,
          size: child.size,
          flush: options.flush,
          shardSplitThreshold: options.shardSplitThreshold,
          hashAlg: options.hashAlg,
          cidVersion: options.cidVersion
        });
        child = {
          cid: result.cid,
          name: name5,
          size: result.size
        };
      }
      const { cid } = child;
      log15(`Final CID ${cid}`);
      return cid;
    }
    exports2.updateTree = updateTree;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/update-mfs-root.js
var require_update_mfs_root = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/update-mfs-root.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug17 = require_browser2();
    var utils = require_utils();
    var errCode32 = require_err_code();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var log15 = debug__default["default"]("ipfs:mfs:utils:update-mfs-root");
    async function updateMfsRoot(context, cid, options) {
      if (options && options.signal && options.signal.aborted) {
        throw errCode__default["default"](new Error("Request aborted"), "ERR_ABORTED", { name: "Aborted" });
      }
      log15(`New MFS root will be ${cid}`);
      await context.repo.datastore.put(utils.MFS_ROOT_KEY, cid.bytes);
      return cid;
    }
    exports2.updateMfsRoot = updateMfsRoot;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/create-node.js
var require_create_node = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/create-node.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipfsUnixfs = (init_src(), src_exports);
    var dagPB = (init_src2(), src_exports2);
    var cid = (init_cid(), cid_exports);
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    async function createNode2(context, type, options) {
      const metadata = new ipfsUnixfs.UnixFS({
        type,
        mode: options.mode,
        mtime: options.mtime
      });
      const hasher = await context.hashers.getHasher(options.hashAlg);
      const node = {
        Data: metadata.marshal(),
        Links: []
      };
      const buf2 = dagPB__namespace.encode(node);
      const hash2 = await hasher.digest(buf2);
      const cid$1 = cid.CID.create(options.cidVersion, dagPB__namespace.code, hash2);
      if (options.flush) {
        await context.repo.blocks.put(cid$1, buf2);
      }
      return {
        cid: cid$1,
        node
      };
    }
    exports2.createNode = createNode2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/mkdir.js
var require_mkdir = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/mkdir.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errCode32 = require_err_code();
    var debug17 = require_browser2();
    var ipfsUnixfsExporter = (init_src9(), src_exports6);
    var createNode2 = require_create_node();
    var toPathComponents3 = require_to_path_components();
    var updateMfsRoot = require_update_mfs_root();
    var updateTree = require_update_tree();
    var addLink = require_add_link();
    var withMfsRoot = require_with_mfs_root();
    var mergeOpts = require_merge_options();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var log15 = debug__default["default"]("ipfs:mfs:mkdir");
    var defaultOptions4 = {
      parents: false,
      hashAlg: "sha2-256",
      cidVersion: 0,
      shardSplitThreshold: 1e3,
      flush: true
    };
    function createMkdir2(context) {
      async function mfsMkdir(path, options = {}) {
        const opts = mergeOptions2(defaultOptions4, options);
        if (!path) {
          throw new Error("no path given to Mkdir");
        }
        path = path.trim();
        if (path === "/") {
          if (opts.parents) {
            return;
          }
          throw errCode__default["default"](new Error("cannot create directory '/': Already exists"), "ERR_INVALID_PATH");
        }
        if (path.substring(0, 1) !== "/") {
          throw errCode__default["default"](new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
        }
        log15(`Creating ${path}`);
        const pathComponents = toPathComponents3.toPathComponents(path);
        if (pathComponents[0] === "ipfs") {
          throw errCode__default["default"](new Error("path cannot have the prefix 'ipfs'"), "ERR_INVALID_PATH");
        }
        const root = await withMfsRoot.loadMfsRoot(context, opts);
        let parent2;
        const trail = [];
        const emptyDir = await createNode2.createNode(context, "directory", opts);
        for (let i = 0; i <= pathComponents.length; i++) {
          const subPathComponents = pathComponents.slice(0, i);
          const subPath = `/ipfs/${root}/${subPathComponents.join("/")}`;
          try {
            parent2 = await ipfsUnixfsExporter.exporter(subPath, context.repo.blocks);
            if (parent2.type !== "file" && parent2.type !== "directory") {
              throw errCode__default["default"](new Error(`${path} was not a UnixFS node`), "ERR_NOT_UNIXFS");
            }
            if (i === pathComponents.length) {
              if (opts.parents) {
                return;
              }
              throw errCode__default["default"](new Error("file already exists"), "ERR_ALREADY_EXISTS");
            }
            trail.push({
              name: parent2.name,
              cid: parent2.cid
            });
          } catch (err) {
            if (err.code === "ERR_NOT_FOUND") {
              if (i < pathComponents.length && !opts.parents) {
                throw errCode__default["default"](new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), "ERR_NOT_FOUND");
              }
              await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);
            } else {
              throw err;
            }
          }
        }
        const newRootCid = await updateTree.updateTree(context, trail, opts);
        await updateMfsRoot.updateMfsRoot(context, newRootCid, opts);
      }
      return withTimeoutOption2.withTimeoutOption(mfsMkdir);
    }
    var addEmptyDir = async (context, childName, emptyDir, parent2, trail, options) => {
      log15(`Adding empty dir called ${childName} to ${parent2.cid}`);
      const result = await addLink.addLink(context, {
        parent: parent2.node,
        parentCid: parent2.cid,
        size: 0,
        cid: emptyDir.cid,
        name: childName,
        hashAlg: options.hashAlg,
        cidVersion: options.cidVersion,
        flush: options.flush,
        shardSplitThreshold: options.shardSplitThreshold
      });
      trail[trail.length - 1].cid = result.cid;
      trail.push({
        name: childName,
        cid: emptyDir.cid
      });
    };
    exports2.createMkdir = createMkdir2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/cp.js
var require_cp = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/cp.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var mkdir = require_mkdir();
    var stat = require_stat3();
    var debug17 = require_browser2();
    var errCode32 = require_err_code();
    var updateTree = require_update_tree();
    var updateMfsRoot = require_update_mfs_root();
    var addLink = require_add_link();
    var toMfsPath = require_to_mfs_path();
    var mergeOpts = require_merge_options();
    var toTrail = require_to_trail();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var log15 = debug__default["default"]("ipfs:mfs:cp");
    var defaultOptions4 = {
      parents: false,
      flush: true,
      hashAlg: "sha2-256",
      cidVersion: 0,
      shardSplitThreshold: 1e3
    };
    function createCp2(context) {
      async function mfsCp(from3, to, opts = {}) {
        const options = mergeOptions2(defaultOptions4, opts);
        if (!Array.isArray(from3)) {
          from3 = [from3];
        }
        const sources = await Promise.all(from3.map((path) => toMfsPath.toMfsPath(context, path, options)));
        let destination = await toMfsPath.toMfsPath(context, to, options);
        if (!sources.length || !destination) {
          throw errCode__default["default"](new Error("Please supply at least one source"), "ERR_INVALID_PARAMS");
        }
        const missing = sources.find((source) => !source.exists);
        if (missing) {
          throw errCode__default["default"](new Error(`${missing.path} does not exist`), "ERR_INVALID_PARAMS");
        }
        const destinationIsDirectory = isDirectory(destination);
        if (destination.exists) {
          log15("Destination exists");
          if (sources.length === 1 && !destinationIsDirectory) {
            throw errCode__default["default"](new Error("directory already has entry by that name"), "ERR_ALREADY_EXISTS");
          }
        } else {
          log15("Destination does not exist");
          if (sources.length > 1) {
            if (!options.parents) {
              throw errCode__default["default"](new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
            }
            await mkdir.createMkdir(context)(destination.path, options);
            destination = await toMfsPath.toMfsPath(context, destination.path, options);
          } else if (destination.parts.length > 1) {
            const parentFolder = `/${destination.parts.slice(0, -1).join("/")}`;
            try {
              await stat.createStat(context)(parentFolder, options);
            } catch (err) {
              if (err.code !== "ERR_NOT_FOUND") {
                throw err;
              }
              if (!options.parents) {
                throw errCode__default["default"](new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
              }
              await mkdir.createMkdir(context)(parentFolder, options);
              destination = await toMfsPath.toMfsPath(context, destination.path, options);
            }
          }
        }
        const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;
        const trail = await toTrail.toTrail(context, destinationPath);
        if (sources.length === 1) {
          const source = sources.pop();
          if (!source) {
            throw errCode__default["default"](new Error("could not find source"), "ERR_INVALID_PARAMS");
          }
          const destinationName = destinationIsDirectory ? source.name : destination.name;
          log15(`Only one source, copying to destination ${destinationIsDirectory ? "directory" : "file"} ${destinationName}`);
          return copyToFile(context, source, destinationName, trail, options);
        }
        log15("Multiple sources, wrapping in a directory");
        return copyToDirectory(context, sources, destination, trail, options);
      }
      return withTimeoutOption2.withTimeoutOption(mfsCp);
    }
    var isDirectory = (destination) => {
      return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes("directory");
    };
    var copyToFile = async (context, source, destination, destinationTrail, options) => {
      let parent2 = destinationTrail.pop();
      if (!parent2) {
        throw errCode__default["default"](new Error("destination had no parent"), "ERR_INVALID_PARAMS");
      }
      parent2 = await addSourceToParent(context, source, destination, parent2, options);
      destinationTrail.push(parent2);
      const newRootCid = await updateTree.updateTree(context, destinationTrail, options);
      await updateMfsRoot.updateMfsRoot(context, newRootCid, options);
    };
    var copyToDirectory = async (context, sources, destination, destinationTrail, options) => {
      for (let i = 0; i < sources.length; i++) {
        const source = sources[i];
        destination = await addSourceToParent(context, source, source.name, destination, options);
      }
      destinationTrail[destinationTrail.length - 1] = destination;
      const newRootCid = await updateTree.updateTree(context, destinationTrail, options);
      await updateMfsRoot.updateMfsRoot(context, newRootCid, options);
    };
    var addSourceToParent = async (context, source, childName, parent2, options) => {
      const sourceBlock = await context.repo.blocks.get(source.cid);
      const { node, cid, size } = await addLink.addLink(context, {
        parentCid: parent2.cid,
        size: sourceBlock.length,
        cid: source.cid,
        name: childName,
        hashAlg: options.hashAlg,
        cidVersion: options.cidVersion,
        flush: options.flush,
        shardSplitThreshold: options.shardSplitThreshold
      });
      parent2.node = node;
      parent2.cid = cid;
      parent2.size = size;
      return parent2;
    };
    exports2.createCp = createCp2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/remove-link.js
var require_remove_link = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/remove-link.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dagPB = (init_src2(), src_exports2);
    var cid = (init_cid(), cid_exports);
    var debug17 = require_browser2();
    var ipfsUnixfs = (init_src(), src_exports);
    var hamtUtils = require_hamt_utils();
    var errCode32 = require_err_code();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var log15 = debug__default["default"]("ipfs:mfs:core:utils:remove-link");
    async function removeLink(context, options) {
      let parent2 = options.parent;
      if (options.parentCid) {
        const parentCid = cid.CID.asCID(options.parentCid);
        if (parentCid === null) {
          throw errCode__default["default"](new Error("Invalid CID passed to removeLink"), "EINVALIDPARENTCID");
        }
        log15(`Loading parent node ${parentCid}`);
        const block = await context.repo.blocks.get(parentCid);
        parent2 = dagPB__namespace.decode(block);
      }
      if (!parent2) {
        throw errCode__default["default"](new Error("No parent node or CID passed to removeLink"), "EINVALIDPARENT");
      }
      if (!options.name) {
        throw errCode__default["default"](new Error("No child name passed to removeLink"), "EINVALIDCHILDNAME");
      }
      if (!parent2.Data) {
        throw errCode__default["default"](new Error("Parent node had no data"), "ERR_INVALID_NODE");
      }
      const meta = ipfsUnixfs.UnixFS.unmarshal(parent2.Data);
      if (meta.type === "hamt-sharded-directory") {
        log15(`Removing ${options.name} from sharded directory`);
        return removeFromShardedDirectory(context, {
          ...options,
          parent: parent2
        });
      }
      log15(`Removing link ${options.name} regular directory`);
      return removeFromDirectory(context, {
        ...options,
        parent: parent2
      });
    }
    var removeFromDirectory = async (context, options) => {
      options.parent.Links = options.parent.Links.filter((link) => {
        return link.Name !== options.name;
      });
      const parentBlock = await dagPB__namespace.encode(options.parent);
      const hasher = await context.hashers.getHasher(options.hashAlg);
      const hash2 = await hasher.digest(parentBlock);
      const parentCid = cid.CID.create(options.cidVersion, dagPB__namespace.code, hash2);
      await context.repo.blocks.put(parentCid, parentBlock);
      log15(`Updated regular directory ${parentCid}`);
      return {
        node: options.parent,
        cid: parentCid
      };
    };
    var removeFromShardedDirectory = async (context, options) => {
      const { rootBucket, path } = await hamtUtils.generatePath(context, options.name, options.parent);
      await rootBucket.del(options.name);
      const { node } = await updateShard(context, path, options.name, options);
      return hamtUtils.updateHamtDirectory(context, node.Links, rootBucket, options);
    };
    var updateShard = async (context, positions, name5, options) => {
      const last6 = positions.pop();
      if (!last6) {
        throw errCode__default["default"](new Error("Could not find parent"), "EINVALIDPARENT");
      }
      const { bucket, prefix, node } = last6;
      if (!node) {
        throw errCode__default["default"](new Error("Could not find parent"), "EINVALIDPARENT");
      }
      const link = node.Links.find((link2) => (link2.Name || "").substring(0, 2) === prefix);
      if (!link) {
        throw errCode__default["default"](new Error(`No link found with prefix ${prefix} for file ${name5}`), "ERR_NOT_FOUND");
      }
      if (link.Name === `${prefix}${name5}`) {
        log15(`Removing existing link ${link.Name}`);
        const links2 = node.Links.filter((nodeLink) => {
          return nodeLink.Name !== link.Name;
        });
        await bucket.del(name5);
        return hamtUtils.updateHamtDirectory(context, links2, bucket, options);
      }
      log15(`Descending into sub-shard ${link.Name} for ${prefix}${name5}`);
      const result = await updateShard(context, positions, name5, options);
      let cid2 = result.cid;
      let size = result.size;
      let newName = prefix;
      if (result.node.Links.length === 1) {
        log15(`Removing subshard for ${prefix}`);
        const link2 = result.node.Links[0];
        newName = `${prefix}${(link2.Name || "").substring(2)}`;
        cid2 = link2.Hash;
        size = link2.Tsize || 0;
      }
      log15(`Updating shard ${prefix} with name ${newName}`);
      return updateShardParent(context, bucket, node, prefix, newName, size, cid2, options);
    };
    var updateShardParent = (context, bucket, parent2, oldName, newName, size, cid2, options) => {
      const parentLinks = parent2.Links.filter((link) => {
        return link.Name !== oldName;
      });
      parentLinks.push({
        Name: newName,
        Tsize: size,
        Hash: cid2
      });
      return hamtUtils.updateHamtDirectory(context, parentLinks, bucket, options);
    };
    exports2.removeLink = removeLink;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/rm.js
var require_rm4 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/rm.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errCode32 = require_err_code();
    var updateTree = require_update_tree();
    var updateMfsRoot = require_update_mfs_root();
    var removeLink = require_remove_link();
    var toMfsPath = require_to_mfs_path();
    var toTrail = require_to_trail();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var mergeOpts = require_merge_options();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var defaultOptions4 = {
      recursive: false,
      cidVersion: 0,
      hashAlg: "sha2-256",
      flush: true,
      shardSplitThreshold: 1e3
    };
    function createRm8(context) {
      async function mfsRm(paths, opts = {}) {
        const options = mergeOptions2(defaultOptions4, opts);
        if (!Array.isArray(paths)) {
          paths = [paths];
        }
        const sources = await Promise.all(paths.map((path) => toMfsPath.toMfsPath(context, path, options)));
        if (!sources.length) {
          throw errCode__default["default"](new Error("Please supply at least one path to remove"), "ERR_INVALID_PARAMS");
        }
        sources.forEach((source) => {
          if (source.path === "/") {
            throw errCode__default["default"](new Error("Cannot delete root"), "ERR_INVALID_PARAMS");
          }
        });
        for (const source of sources) {
          await removePath(context, source.path, options);
        }
      }
      return withTimeoutOption2.withTimeoutOption(mfsRm);
    }
    var removePath = async (context, path, options) => {
      const mfsPath = await toMfsPath.toMfsPath(context, path, options);
      const trail = await toTrail.toTrail(context, mfsPath.mfsPath);
      const child = trail[trail.length - 1];
      trail.pop();
      const parent2 = trail[trail.length - 1];
      if (!parent2) {
        throw errCode__default["default"](new Error(`${path} does not exist`), "ERR_NOT_FOUND");
      }
      if (child.type === "directory" && !options.recursive) {
        throw errCode__default["default"](new Error(`${path} is a directory, use -r to remove directories`), "ERR_WAS_DIR");
      }
      const { cid } = await removeLink.removeLink(context, {
        parentCid: parent2.cid,
        name: child.name,
        hashAlg: options.hashAlg,
        cidVersion: options.cidVersion,
        flush: options.flush,
        shardSplitThreshold: options.shardSplitThreshold
      });
      parent2.cid = cid;
      const newRootCid = await updateTree.updateTree(context, trail, options);
      await updateMfsRoot.updateMfsRoot(context, newRootCid, options);
    };
    exports2.createRm = createRm8;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/chmod.js
var require_chmod = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/chmod.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var mergeOpts = require_merge_options();
    var toMfsPath = require_to_mfs_path();
    var debug17 = require_browser2();
    var errCode32 = require_err_code();
    var ipfsUnixfs = (init_src(), src_exports);
    var toTrail = require_to_trail();
    var addLink = require_add_link();
    var updateTree = require_update_tree();
    var updateMfsRoot = require_update_mfs_root();
    var dagPB = (init_src2(), src_exports2);
    var cid = (init_cid(), cid_exports);
    var itPipe = require_it_pipe();
    var ipfsUnixfsImporter = (init_src8(), src_exports5);
    var ipfsUnixfsExporter = (init_src9(), src_exports6);
    var last6 = require_it_last();
    var cp = require_cp();
    var rm = require_rm4();
    var persist2 = require_persist();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var last__default = /* @__PURE__ */ _interopDefaultLegacy(last6);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var log15 = debug__default["default"]("ipfs:mfs:touch");
    var defaultOptions4 = {
      flush: true,
      shardSplitThreshold: 1e3,
      hashAlg: "sha2-256",
      cidVersion: 0,
      recursive: false
    };
    function calculateModification(mode, originalMode, isDirectory) {
      let modification = 0;
      if (mode.includes("x") || mode.includes("X") && (isDirectory || (originalMode & 1 || originalMode & 8 || originalMode & 64))) {
        modification += 1;
      }
      if (mode.includes("w")) {
        modification += 2;
      }
      if (mode.includes("r")) {
        modification += 4;
      }
      return modification;
    }
    function calculateUGO(references, modification) {
      let ugo = 0;
      if (references.includes("u")) {
        ugo += modification << 6;
      }
      if (references.includes("g")) {
        ugo += modification << 3;
      }
      if (references.includes("o")) {
        ugo += modification;
      }
      return ugo;
    }
    function calculateSpecial(references, mode, modification) {
      if (mode.includes("t")) {
        modification += parseInt("1000", 8);
      }
      if (mode.includes("s")) {
        if (references.includes("u")) {
          modification += parseInt("4000", 8);
        }
        if (references.includes("g")) {
          modification += parseInt("2000", 8);
        }
      }
      return modification;
    }
    function parseSymbolicMode(input, originalMode, isDirectory) {
      if (!originalMode) {
        originalMode = 0;
      }
      const match = input.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);
      if (!match) {
        throw new Error(`Invalid file mode: ${input}`);
      }
      let [, references, operator, mode] = match;
      if (references === "a" || !references) {
        references = "ugo";
      }
      let modification = calculateModification(mode, originalMode, isDirectory);
      modification = calculateUGO(references, modification);
      modification = calculateSpecial(references, mode, modification);
      if (operator === "=") {
        if (references.includes("u")) {
          originalMode = originalMode & parseInt("7077", 8);
          originalMode = originalMode | modification;
        }
        if (references.includes("g")) {
          originalMode = originalMode & parseInt("7707", 8);
          originalMode = originalMode | modification;
        }
        if (references.includes("o")) {
          originalMode = originalMode & parseInt("7770", 8);
          originalMode = originalMode | modification;
        }
        return originalMode;
      }
      if (operator === "+") {
        return modification | originalMode;
      }
      if (operator === "-") {
        return modification ^ originalMode;
      }
      return originalMode;
    }
    function calculateMode(mode, metadata) {
      if (mode instanceof String || typeof mode === "string") {
        const strMode = `${mode}`;
        if (strMode.match(/^\d+$/g)) {
          mode = parseInt(strMode, 8);
        } else {
          mode = 0 + strMode.split(",").reduce((curr, acc) => {
            return parseSymbolicMode(acc, curr, metadata.isDirectory());
          }, metadata.mode || 0);
        }
      }
      return mode;
    }
    function createChmod2(context) {
      async function mfsChmod(path, mode, options = {}) {
        const opts = mergeOptions2(defaultOptions4, options);
        log15(`Fetching stats for ${path}`);
        const { cid: cid$1, mfsDirectory, name: name5 } = await toMfsPath.toMfsPath(context, path, opts);
        if (cid$1.code !== dagPB__namespace.code) {
          throw errCode__default["default"](new Error(`${path} was not a UnixFS node`), "ERR_NOT_UNIXFS");
        }
        if (opts.recursive) {
          const root = await itPipe.pipe(async function* () {
            for await (const entry of ipfsUnixfsExporter.recursive(cid$1, context.repo.blocks)) {
              if (entry.type !== "file" && entry.type !== "directory") {
                throw errCode__default["default"](new Error(`${path} was not a UnixFS node`), "ERR_NOT_UNIXFS");
              }
              entry.unixfs.mode = calculateMode(mode, entry.unixfs);
              const node2 = dagPB__namespace.prepare({
                Data: entry.unixfs.marshal(),
                Links: entry.node.Links
              });
              yield {
                path: entry.path,
                content: node2
              };
            }
          }, (source) => ipfsUnixfsImporter.importer(source, context.repo.blocks, {
            ...opts,
            pin: false,
            dagBuilder: async function* (source2, block2, opts2) {
              for await (const entry of source2) {
                yield async function() {
                  const node2 = entry.content;
                  const buf2 = dagPB__namespace.encode(node2);
                  const cid2 = await persist2.persist(buf2, block2, opts2);
                  if (!node2.Data) {
                    throw errCode__default["default"](new Error(`${cid2} had no data`), "ERR_INVALID_NODE");
                  }
                  const unixfs = ipfsUnixfs.UnixFS.unmarshal(node2.Data);
                  return {
                    cid: cid2,
                    size: buf2.length,
                    path: entry.path,
                    unixfs
                  };
                };
              }
            }
          }), (nodes) => last__default["default"](nodes));
          if (!root) {
            throw errCode__default["default"](new Error(`Could not chmod ${path}`), "ERR_COULD_NOT_CHMOD");
          }
          await rm.createRm(context)(path, opts);
          await cp.createCp(context)(`/ipfs/${root.cid}`, path, opts);
          return;
        }
        const block = await context.repo.blocks.get(cid$1);
        const node = dagPB__namespace.decode(block);
        if (!node.Data) {
          throw errCode__default["default"](new Error(`${cid$1} had no data`), "ERR_INVALID_NODE");
        }
        const metadata = ipfsUnixfs.UnixFS.unmarshal(node.Data);
        metadata.mode = calculateMode(mode, metadata);
        const updatedBlock = dagPB__namespace.encode({
          Data: metadata.marshal(),
          Links: node.Links
        });
        const hashAlg = opts.hashAlg || defaultOptions4.hashAlg;
        const hasher = await context.hashers.getHasher(hashAlg);
        const hash2 = await hasher.digest(updatedBlock);
        const updatedCid = cid.CID.create(opts.cidVersion, dagPB__namespace.code, hash2);
        if (opts.flush) {
          await context.repo.blocks.put(updatedCid, updatedBlock);
        }
        const trail = await toTrail.toTrail(context, mfsDirectory);
        const parent2 = trail[trail.length - 1];
        const parentCid = cid.CID.decode(parent2.cid.bytes);
        const parentBlock = await context.repo.blocks.get(parentCid);
        const parentNode = dagPB__namespace.decode(parentBlock);
        const result = await addLink.addLink(context, {
          parent: parentNode,
          name: name5,
          cid: updatedCid,
          size: updatedBlock.length,
          flush: opts.flush,
          hashAlg,
          cidVersion: cid$1.version,
          shardSplitThreshold: Infinity
        });
        parent2.cid = result.cid;
        const newRootCid = await updateTree.updateTree(context, trail, opts);
        await updateMfsRoot.updateMfsRoot(context, newRootCid, opts);
      }
      return withTimeoutOption2.withTimeoutOption(mfsChmod);
    }
    exports2.createChmod = createChmod2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/flush.js
var require_flush = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/flush.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var stat = require_stat3();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var mergeOpts = require_merge_options();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var defaultOptions4 = {};
    function createFlush2(context) {
      async function mfsFlush(path, options = {}) {
        options = mergeOptions2(defaultOptions4, options);
        const { cid } = await stat.createStat(context)(path, options);
        return cid;
      }
      return withTimeoutOption2.withTimeoutOption(mfsFlush);
    }
    exports2.createFlush = createFlush2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/mv.js
var require_mv = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/mv.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var cp = require_cp();
    var rm = require_rm4();
    var mergeOpts = require_merge_options();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var defaultOptions4 = {
      parents: false,
      flush: true,
      cidVersion: 0,
      hashAlg: "sha2-256",
      shardSplitThreshold: 1e3
    };
    function createMv2(context) {
      async function mfsMv(from3, to, options = {}) {
        const opts = mergeOptions2(defaultOptions4, options);
        await cp.createCp(context)(from3, to, opts);
        await rm.createRm(context)(from3, {
          ...opts,
          recursive: true
        });
      }
      return withTimeoutOption2.withTimeoutOption(mfsMv);
    }
    exports2.createMv = createMv2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/touch.js
var require_touch = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/touch.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var mergeOpts = require_merge_options();
    var toMfsPath = require_to_mfs_path();
    var debug17 = require_browser2();
    var errCode32 = require_err_code();
    var ipfsUnixfs = (init_src(), src_exports);
    var toTrail = require_to_trail();
    var addLink = require_add_link();
    var updateTree = require_update_tree();
    var updateMfsRoot = require_update_mfs_root();
    var dagPB = (init_src2(), src_exports2);
    var cid = (init_cid(), cid_exports);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var log15 = debug__default["default"]("ipfs:mfs:touch");
    var defaultOptions4 = {
      flush: true,
      shardSplitThreshold: 1e3,
      cidVersion: 0,
      hashAlg: "sha2-256"
    };
    function createTouch2(context) {
      async function mfsTouch(path, options = {}) {
        const settings = mergeOptions2(defaultOptions4, options);
        settings.mtime = settings.mtime || new Date();
        log15(`Touching ${path} mtime: ${settings.mtime}`);
        const { cid: cid$1, mfsDirectory, name: name5, exists } = await toMfsPath.toMfsPath(context, path, settings);
        const hashAlg = options.hashAlg || defaultOptions4.hashAlg;
        const hasher = await context.hashers.getHasher(hashAlg);
        let updatedBlock;
        let updatedCid;
        let cidVersion = settings.cidVersion;
        if (!exists) {
          const metadata = new ipfsUnixfs.UnixFS({
            type: "file",
            mtime: settings.mtime
          });
          updatedBlock = dagPB__namespace.encode({
            Data: metadata.marshal(),
            Links: []
          });
          const hash2 = await hasher.digest(updatedBlock);
          updatedCid = cid.CID.create(settings.cidVersion, dagPB__namespace.code, hash2);
          if (settings.flush) {
            await context.repo.blocks.put(updatedCid, updatedBlock);
          }
        } else {
          if (cid$1.code !== dagPB__namespace.code) {
            throw errCode__default["default"](new Error(`${path} was not a UnixFS node`), "ERR_NOT_UNIXFS");
          }
          cidVersion = cid$1.version;
          const block = await context.repo.blocks.get(cid$1);
          const node = dagPB__namespace.decode(block);
          if (!node.Data) {
            throw errCode__default["default"](new Error(`${path} had no data`), "ERR_INVALID_NODE");
          }
          const metadata = ipfsUnixfs.UnixFS.unmarshal(node.Data);
          metadata.mtime = settings.mtime;
          updatedBlock = dagPB__namespace.encode({
            Data: metadata.marshal(),
            Links: node.Links
          });
          const hash2 = await hasher.digest(updatedBlock);
          updatedCid = cid.CID.create(settings.cidVersion, dagPB__namespace.code, hash2);
          if (settings.flush) {
            await context.repo.blocks.put(updatedCid, updatedBlock);
          }
        }
        const trail = await toTrail.toTrail(context, mfsDirectory);
        const parent2 = trail[trail.length - 1];
        const parentCid = parent2.cid;
        const parentBlock = await context.repo.blocks.get(parentCid);
        const parentNode = dagPB__namespace.decode(parentBlock);
        const result = await addLink.addLink(context, {
          parent: parentNode,
          name: name5,
          cid: updatedCid,
          size: updatedBlock.length,
          flush: settings.flush,
          shardSplitThreshold: settings.shardSplitThreshold,
          hashAlg: settings.hashAlg,
          cidVersion
        });
        parent2.cid = result.cid;
        const newRootCid = await updateTree.updateTree(context, trail, settings);
        await updateMfsRoot.updateMfsRoot(context, newRootCid, settings);
      }
      return withTimeoutOption2.withTimeoutOption(mfsTouch);
    }
    exports2.createTouch = createTouch2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/read.js
var require_read = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/read.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipfsUnixfsExporter = (init_src9(), src_exports6);
    var mergeOpts = require_merge_options();
    var toMfsPath = require_to_mfs_path();
    var errCode32 = require_err_code();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var defaultOptions4 = {
      offset: 0,
      length: Infinity
    };
    function createRead2(context) {
      function mfsRead(path, options = {}) {
        options = mergeOptions2(defaultOptions4, options);
        return {
          [Symbol.asyncIterator]: async function* read2() {
            const mfsPath = await toMfsPath.toMfsPath(context, path, options);
            const result = await ipfsUnixfsExporter.exporter(mfsPath.mfsPath, context.repo.blocks);
            if (result.type !== "file") {
              throw errCode__default["default"](new Error(`${path} was not a file`), "ERR_NOT_FILE");
            }
            if (!result.content) {
              throw errCode__default["default"](new Error(`Could not load content stream from ${path}`), "ERR_NO_CONTENT");
            }
            for await (const buf2 of result.content({
              offset: options.offset,
              length: options.length
            })) {
              yield buf2;
            }
          }
        };
      }
      return withTimeoutOption2.withTimeoutOption(mfsRead);
    }
    exports2.createRead = createRead2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/utils/to-async-iterator.js
var require_to_async_iterator = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/utils/to-async-iterator.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var errCode32 = require_err_code();
    var debug17 = require_browser2();
    var utils = require_utils();
    var fromString4 = (init_from_string(), from_string_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = debug__default["default"]("ipfs:mfs:utils:to-async-iterator");
    function toAsyncIterator(content) {
      if (!content) {
        throw errCode__default["default"](new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
      }
      if (typeof content === "string" || content instanceof String) {
        log15("Content was a string");
        content = fromString4.fromString(content.toString());
      }
      if (content.length) {
        log15("Content was array-like");
        return {
          [Symbol.asyncIterator]: function* bufferContent() {
            yield content;
          }
        };
      }
      if (content[Symbol.asyncIterator]) {
        log15("Content was an async iterator");
        return content;
      }
      if (content[Symbol.iterator]) {
        log15("Content was an iterator");
        return content;
      }
      if (global.Blob && content instanceof global.Blob) {
        log15("Content was an HTML5 Blob");
        let index = 0;
        const iterator = {
          next: () => {
            if (index > content.size) {
              return { done: true };
            }
            return new Promise((resolve6, reject) => {
              const chunk = content.slice(index, utils.MFS_MAX_CHUNK_SIZE);
              index += utils.MFS_MAX_CHUNK_SIZE;
              const reader = new global.FileReader();
              const handleLoad = (ev) => {
                reader.removeEventListener("loadend", handleLoad, false);
                if (ev.error) {
                  return reject(ev.error);
                }
                resolve6({
                  done: false,
                  value: new Uint8Array(reader.result)
                });
              };
              reader.addEventListener("loadend", handleLoad);
              reader.readAsArrayBuffer(chunk);
            });
          }
        };
        return {
          [Symbol.asyncIterator]: () => {
            return iterator;
          }
        };
      }
      throw errCode__default["default"](new Error(`Don't know how to convert ${content} into an async iterator`), "ERR_INVALID_PARAMS");
    }
    exports2.toAsyncIterator = toAsyncIterator;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/write.js
var require_write = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/write.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug17 = require_browser2();
    var ipfsUnixfsImporter = (init_src8(), src_exports5);
    var dagPB = (init_src2(), src_exports2);
    var sha2 = (init_sha2_browser(), sha2_browser_exports);
    var stat = require_stat3();
    var mkdir = require_mkdir();
    var addLink = require_add_link();
    var mergeOpts = require_merge_options();
    var createLock = require_create_lock();
    var toAsyncIterator = require_to_async_iterator();
    var toMfsPath = require_to_mfs_path();
    var toPathComponents3 = require_to_path_components();
    var toTrail = require_to_trail();
    var updateTree = require_update_tree();
    var updateMfsRoot = require_update_mfs_root();
    var errCode32 = require_err_code();
    var utils = require_utils();
    var last6 = require_it_last();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var ipfsUnixfs = (init_src(), src_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var last__default = /* @__PURE__ */ _interopDefaultLegacy(last6);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var log15 = debug__default["default"]("ipfs:mfs:write");
    var defaultOptions4 = {
      offset: 0,
      length: Infinity,
      create: false,
      truncate: false,
      rawLeaves: false,
      reduceSingleLeafToSelf: false,
      cidVersion: 0,
      hashAlg: "sha2-256",
      parents: false,
      progress: (bytes3, path) => {
      },
      strategy: "trickle",
      flush: true,
      leafType: "raw",
      shardSplitThreshold: 1e3
    };
    function createWrite2(context) {
      async function mfsWrite(path, content, opts = {}) {
        const options = mergeOptions2(defaultOptions4, opts);
        let source;
        let destination;
        let parent2;
        log15("Reading source, destination and parent");
        await createLock.createLock().readLock(async () => {
          source = await toAsyncIterator.toAsyncIterator(content);
          destination = await toMfsPath.toMfsPath(context, path, options);
          parent2 = await toMfsPath.toMfsPath(context, destination.mfsDirectory, options);
        })();
        log15("Read source, destination and parent");
        if (!options.parents && !parent2.exists) {
          throw errCode__default["default"](new Error("directory does not exist"), "ERR_NO_EXIST");
        }
        if (source == null) {
          throw errCode__default["default"](new Error("could not create source"), "ERR_NO_SOURCE");
        }
        if (destination == null) {
          throw errCode__default["default"](new Error("could not create destination"), "ERR_NO_DESTINATION");
        }
        if (!options.create && !destination.exists) {
          throw errCode__default["default"](new Error("file does not exist"), "ERR_NO_EXIST");
        }
        if (destination.entryType !== "file") {
          throw errCode__default["default"](new Error("not a file"), "ERR_NOT_A_FILE");
        }
        return updateOrImport(context, path, source, destination, options);
      }
      return withTimeoutOption2.withTimeoutOption(mfsWrite);
    }
    var updateOrImport = async (context, path, source, destination, options) => {
      const child = await write(context, source, destination, options);
      await createLock.createLock().writeLock(async () => {
        const pathComponents = toPathComponents3.toPathComponents(path);
        const fileName = pathComponents.pop();
        if (fileName == null) {
          throw errCode__default["default"](new Error("source does not exist"), "ERR_NO_EXIST");
        }
        let parentExists = false;
        try {
          await stat.createStat(context)(`/${pathComponents.join("/")}`, options);
          parentExists = true;
        } catch (err) {
          if (err.code !== "ERR_NOT_FOUND") {
            throw err;
          }
        }
        if (!parentExists) {
          await mkdir.createMkdir(context)(`/${pathComponents.join("/")}`, options);
        }
        const updatedPath = await toMfsPath.toMfsPath(context, path, options);
        const trail = await toTrail.toTrail(context, updatedPath.mfsDirectory);
        const parent2 = trail[trail.length - 1];
        if (!parent2) {
          throw errCode__default["default"](new Error("directory does not exist"), "ERR_NO_EXIST");
        }
        if (!parent2.type || !parent2.type.includes("directory")) {
          throw errCode__default["default"](new Error(`cannot write to ${parent2.name}: Not a directory`), "ERR_NOT_A_DIRECTORY");
        }
        const parentBlock = await context.repo.blocks.get(parent2.cid);
        const parentNode = dagPB.decode(parentBlock);
        const result = await addLink.addLink(context, {
          parent: parentNode,
          name: fileName,
          cid: child.cid,
          size: child.size,
          flush: options.flush,
          shardSplitThreshold: options.shardSplitThreshold,
          hashAlg: options.hashAlg,
          cidVersion: options.cidVersion
        });
        parent2.cid = result.cid;
        const newRootCid = await updateTree.updateTree(context, trail, options);
        await updateMfsRoot.updateMfsRoot(context, newRootCid, options);
      })();
    };
    var write = async (context, source, destination, options) => {
      if (destination.exists) {
        log15(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`);
      } else {
        log15(`Writing file offset ${options.offset} length ${options.length}`);
      }
      const sources = [];
      if (options.offset > 0) {
        if (destination.unixfs) {
          log15(`Writing first ${options.offset} bytes of original file`);
          sources.push(() => {
            return destination.content({
              offset: 0,
              length: options.offset
            });
          });
          if (destination.unixfs.fileSize() < options.offset) {
            const extra = options.offset - destination.unixfs.fileSize();
            log15(`Writing zeros for extra ${extra} bytes`);
            sources.push(asyncZeroes(extra));
          }
        } else {
          log15(`Writing zeros for first ${options.offset} bytes`);
          sources.push(asyncZeroes(options.offset));
        }
      }
      sources.push(limitAsyncStreamBytes(source, options.length));
      const content = countBytesStreamed(catAsyncIterators(sources), (bytesWritten) => {
        if (destination.unixfs && !options.truncate) {
          const fileSize = destination.unixfs.fileSize();
          if (fileSize > bytesWritten) {
            log15(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`);
            return destination.content({ offset: bytesWritten });
          } else {
            log15("Not writing last bytes from original file");
          }
        }
        return {
          [Symbol.asyncIterator]: async function* () {
          }
        };
      });
      let mode;
      if (options.mode !== void 0 && options.mode !== null) {
        mode = ipfsUnixfs.parseMode(options.mode);
      } else if (destination && destination.unixfs) {
        mode = destination.unixfs.mode;
      }
      let mtime;
      if (options.mtime != null) {
        mtime = ipfsUnixfs.parseMtime(options.mtime);
      } else if (destination && destination.unixfs) {
        mtime = destination.unixfs.mtime;
      }
      let hasher;
      switch (options.hashAlg) {
        case "sha2-256":
          hasher = sha2.sha256;
          break;
        case "sha2-512":
          hasher = sha2.sha512;
          break;
        default:
          throw new Error(`TODO vmx 2021-03-31: Proper error message for unsupported hash algorithms like ${options.hashAlg}`);
      }
      const result = await last__default["default"](ipfsUnixfsImporter.importer([{
        content,
        mode,
        mtime
      }], context.repo.blocks, {
        progress: options.progress,
        hasher,
        cidVersion: options.cidVersion,
        strategy: options.strategy,
        rawLeaves: options.rawLeaves,
        reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,
        leafType: options.leafType
      }));
      if (!result) {
        throw errCode__default["default"](new Error(`cannot write to ${parent.name}`), "ERR_COULD_NOT_WRITE");
      }
      log15(`Wrote ${result.cid}`);
      return {
        cid: result.cid,
        size: result.size
      };
    };
    var limitAsyncStreamBytes = (stream, limit) => {
      return async function* _limitAsyncStreamBytes() {
        let emitted = 0;
        for await (const buf2 of stream) {
          emitted += buf2.length;
          if (emitted > limit) {
            yield buf2.slice(0, limit - emitted);
            return;
          }
          yield buf2;
        }
      };
    };
    var asyncZeroes = (count, chunkSize = utils.MFS_MAX_CHUNK_SIZE) => {
      const buf2 = new Uint8Array(chunkSize);
      async function* _asyncZeroes() {
        while (true) {
          yield buf2.slice();
        }
      }
      return limitAsyncStreamBytes(_asyncZeroes(), count);
    };
    var catAsyncIterators = async function* (sources) {
      for (let i = 0; i < sources.length; i++) {
        yield* sources[i]();
      }
    };
    var countBytesStreamed = async function* (source, notify) {
      let wrote = 0;
      for await (const buf2 of source) {
        wrote += buf2.length;
        yield buf2;
      }
      for await (const buf2 of notify(wrote)) {
        wrote += buf2.length;
        yield buf2;
      }
    };
    exports2.createWrite = createWrite2;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/ls.js
var require_ls3 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/ls.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipfsUnixfsExporter = (init_src9(), src_exports6);
    var toMfsPath = require_to_mfs_path();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var map8 = require_it_map();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var map__default = /* @__PURE__ */ _interopDefaultLegacy(map8);
    var toOutput = (fsEntry) => {
      const output = {
        cid: fsEntry.cid,
        name: fsEntry.name,
        type: fsEntry.type === "directory" ? "directory" : "file",
        size: fsEntry.size
      };
      if (fsEntry.type === "file" || fsEntry.type === "directory") {
        output.mode = fsEntry.unixfs.mode;
        output.mtime = fsEntry.unixfs.mtime;
      }
      return output;
    };
    function createLs8(context) {
      async function* mfsLs(path, options = {}) {
        const mfsPath = await toMfsPath.toMfsPath(context, path, options);
        const fsEntry = await ipfsUnixfsExporter.exporter(mfsPath.mfsPath, context.repo.blocks);
        if (fsEntry.type === "directory") {
          yield* map__default["default"](fsEntry.content(options), toOutput);
          return;
        }
        yield toOutput(fsEntry);
      }
      return withTimeoutOption2.withTimeoutOption(mfsLs);
    }
    exports2.createLs = createLs8;
  }
});

// node_modules/ipfs-core/cjs/src/components/files/index.js
var require_files = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/files/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var createLock = require_create_lock();
    var isIpfs = require_src3();
    var stat = require_stat3();
    var chmod = require_chmod();
    var cp = require_cp();
    var flush2 = require_flush();
    var mkdir = require_mkdir();
    var mv = require_mv();
    var rm = require_rm4();
    var touch = require_touch();
    var read2 = require_read();
    var write = require_write();
    var ls = require_ls3();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var isIpfs__default = /* @__PURE__ */ _interopDefaultLegacy(isIpfs);
    var readOperations = { stat: stat.createStat };
    var writeOperations = {
      chmod: chmod.createChmod,
      cp: cp.createCp,
      flush: flush2.createFlush,
      mkdir: mkdir.createMkdir,
      mv: mv.createMv,
      rm: rm.createRm,
      touch: touch.createTouch
    };
    var unwrappedOperations = {
      write: write.createWrite,
      read: read2.createRead,
      ls: ls.createLs
    };
    var wrap = ({ options, mfs, operations, lock: lock2 }) => {
      Object.keys(operations).forEach((key) => {
        mfs[key] = lock2(operations[key](options));
      });
    };
    var defaultOptions4 = {
      repoOwner: true,
      repo: null
    };
    function createMfs(options) {
      const { repoOwner } = Object.assign({}, defaultOptions4 || {}, options);
      const lock2 = createLock.createLock(repoOwner);
      const readLock = (operation) => {
        return lock2.readLock(operation);
      };
      const writeLock = (operation) => {
        return lock2.writeLock(operation);
      };
      const mfs = {};
      wrap({
        options,
        mfs,
        operations: readOperations,
        lock: readLock
      });
      wrap({
        options,
        mfs,
        operations: writeOperations,
        lock: writeLock
      });
      Object.keys(unwrappedOperations).forEach((key) => {
        mfs[key] = unwrappedOperations[key](options);
      });
      return mfs;
    }
    function createFiles2({
      repo,
      preload: preload2,
      hashers,
      options: constructorOptions
    }) {
      const methods = createMfs({
        repo,
        repoOwner: Boolean(constructorOptions.repoOwner),
        hashers
      });
      const withPreload = (fn) => {
        const wrapped = (...args) => {
          const paths = args.filter((arg) => isIpfs__default["default"].ipfsPath(arg) || isIpfs__default["default"].cid(arg));
          if (paths.length) {
            const options = args[args.length - 1];
            if (options && options.preload !== false) {
              paths.forEach((path) => preload2(path));
            }
          }
          return fn(...args);
        };
        return wrapped;
      };
      return {
        ...methods,
        chmod: methods.chmod,
        cp: withPreload(methods.cp),
        mkdir: methods.mkdir,
        stat: withPreload(methods.stat),
        rm: methods.rm,
        read: withPreload(methods.read),
        touch: methods.touch,
        write: methods.write,
        mv: withPreload(methods.mv),
        flush: methods.flush,
        ls: withPreload(async function* (...args) {
          for await (const file of methods.ls(...args)) {
            yield {
              ...file,
              size: file.size || 0
            };
          }
        })
      };
    }
    exports2.createFiles = createFiles2;
  }
});

// node_modules/ipfs-core/cjs/src/components/key/export.js
var require_export2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/key/export.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createExport3({ keychain }) {
      const exportKey = (name5, password) => keychain.exportKey(name5, password);
      return withTimeoutOption2.withTimeoutOption(exportKey);
    }
    exports2.createExport = createExport3;
  }
});

// node_modules/ipfs-core/cjs/src/components/key/gen.js
var require_gen = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/key/gen.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var DEFAULT_KEY_TYPE = "ed25519";
    var DEFAULT_KEY_SIZE = 2048;
    function createGen2({ keychain }) {
      const gen = (name5, options = {
        type: DEFAULT_KEY_TYPE,
        size: DEFAULT_KEY_SIZE
      }) => {
        return keychain.createKey(name5, options.type || DEFAULT_KEY_TYPE, options.size || DEFAULT_KEY_SIZE);
      };
      return withTimeoutOption2.withTimeoutOption(gen);
    }
    exports2.createGen = createGen2;
  }
});

// node_modules/ipfs-core/cjs/src/components/key/import.js
var require_import2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/key/import.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createImport3({ keychain }) {
      const importKey = (name5, pem, password) => {
        return keychain.importKey(name5, pem, password);
      };
      return withTimeoutOption2.withTimeoutOption(importKey);
    }
    exports2.createImport = createImport3;
  }
});

// node_modules/ipfs-core/cjs/src/components/key/info.js
var require_info = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/key/info.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createInfo2({ keychain }) {
      const info = (name5) => keychain.findKeyByName(name5);
      return withTimeoutOption2.withTimeoutOption(info);
    }
    exports2.createInfo = createInfo2;
  }
});

// node_modules/ipfs-core/cjs/src/components/key/list.js
var require_list2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/key/list.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createList4({ keychain }) {
      const list = () => keychain.listKeys();
      return withTimeoutOption2.withTimeoutOption(list);
    }
    exports2.createList = createList4;
  }
});

// node_modules/ipfs-core/cjs/src/components/key/rename.js
var require_rename = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/key/rename.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createRename2({ keychain }) {
      const rename = async (oldName, newName) => {
        const key = await keychain.renameKey(oldName, newName);
        return {
          was: oldName,
          now: key.name,
          id: key.id,
          overwrite: false
        };
      };
      return withTimeoutOption2.withTimeoutOption(rename);
    }
    exports2.createRename = createRename2;
  }
});

// node_modules/ipfs-core/cjs/src/components/key/rm.js
var require_rm5 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/key/rm.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createRm8({ keychain }) {
      const rm = (name5) => keychain.removeKey(name5);
      return withTimeoutOption2.withTimeoutOption(rm);
    }
    exports2.createRm = createRm8;
  }
});

// node_modules/ipfs-core/cjs/src/components/key/index.js
var require_key3 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/key/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var _export = require_export2();
    var gen = require_gen();
    var _import = require_import2();
    var info = require_info();
    var list = require_list2();
    var rename = require_rename();
    var rm = require_rm5();
    var KeyAPI = class {
      constructor({ keychain }) {
        this.gen = gen.createGen({ keychain });
        this.list = list.createList({ keychain });
        this.rm = rm.createRm({ keychain });
        this.rename = rename.createRename({ keychain });
        this.export = _export.createExport({ keychain });
        this.import = _import.createImport({ keychain });
        this.info = info.createInfo({ keychain });
      }
    };
    exports2.KeyAPI = KeyAPI;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/get.js
var require_get4 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/get.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dagPB = (init_src2(), src_exports2);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    function createGet7({ repo, preload: preload2 }) {
      async function get2(cid, options = {}) {
        if (options.preload !== false) {
          preload2(cid);
        }
        const block = await repo.blocks.get(cid, options);
        return dagPB__namespace.decode(block);
      }
      return withTimeoutOption2.withTimeoutOption(get2);
    }
    exports2.createGet = createGet7;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/data.js
var require_data = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/data.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var get2 = require_get4();
    function createData2({ repo, preload: preload2 }) {
      const get$1 = get2.createGet({
        repo,
        preload: preload2
      });
      async function data(multihash, options = {}) {
        const node = await get$1(multihash, options);
        return node.Data || new Uint8Array(0);
      }
      return withTimeoutOption2.withTimeoutOption(data);
    }
    exports2.createData = createData2;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/links.js
var require_links = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/links.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dagPB = (init_src2(), src_exports2);
    var dagCBOR = (init_esm(), esm_exports);
    var raw7 = (init_raw(), raw_exports);
    var cid = (init_cid(), cid_exports);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var dagCBOR__namespace = /* @__PURE__ */ _interopNamespace(dagCBOR);
    var raw__namespace = /* @__PURE__ */ _interopNamespace(raw7);
    function findLinks(node, links2 = []) {
      for (const key in node) {
        const val = node[key];
        if (key === "/" && Object.keys(node).length === 1) {
          try {
            links2.push({
              Name: "",
              Tsize: 0,
              Hash: cid.CID.parse(val)
            });
            continue;
          } catch (_) {
          }
        }
        const cid$1 = cid.CID.asCID(val);
        if (cid$1) {
          links2.push({
            Name: "",
            Tsize: 0,
            Hash: cid$1
          });
          continue;
        }
        if (Array.isArray(val)) {
          findLinks(val, links2);
        }
        if (val && typeof val === "object") {
          findLinks(val, links2);
        }
      }
      return links2;
    }
    function createLinks2({ repo, codecs: codecs2 }) {
      async function links2(cid2, options = {}) {
        const codec = await codecs2.getCodec(cid2.code);
        const block = await repo.blocks.get(cid2, options);
        const node = codec.decode(block);
        if (cid2.code === raw__namespace.code) {
          return [];
        }
        if (cid2.code === dagPB__namespace.code) {
          return node.Links;
        }
        if (cid2.code === dagCBOR__namespace.code) {
          return findLinks(node);
        }
        throw new Error(`Cannot resolve links from codec ${cid2.code}`);
      }
      return withTimeoutOption2.withTimeoutOption(links2);
    }
    exports2.createLinks = createLinks2;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/new.js
var require_new = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/new.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dagPB = (init_src2(), src_exports2);
    var sha2 = (init_sha2_browser(), sha2_browser_exports);
    var ipfsUnixfs = (init_src(), src_exports);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var cid = (init_cid(), cid_exports);
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    function createNew2({ repo, preload: preload2 }) {
      async function _new(options = {}) {
        let data;
        if (options.template) {
          if (options.template === "unixfs-dir") {
            data = new ipfsUnixfs.UnixFS({ type: "directory" }).marshal();
          } else {
            throw new Error("unknown template");
          }
        }
        const buf2 = dagPB__namespace.encode({
          Data: data,
          Links: []
        });
        const hash2 = await sha2.sha256.digest(buf2);
        const cid$1 = cid.CID.createV0(hash2);
        await repo.blocks.put(cid$1, buf2, { signal: options.signal });
        if (options.preload !== false) {
          preload2(cid$1);
        }
        return cid$1;
      }
      return withTimeoutOption2.withTimeoutOption(_new);
    }
    exports2.createNew = createNew2;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/put.js
var require_put3 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/put.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dagPB = (init_src2(), src_exports2);
    var cid = (init_cid(), cid_exports);
    var sha2 = (init_sha2_browser(), sha2_browser_exports);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    function createPut5({ repo, preload: preload2 }) {
      async function put(obj, options = {}) {
        const release = await repo.gcLock.readLock();
        try {
          const buf2 = dagPB__namespace.encode(obj);
          const hash2 = await sha2.sha256.digest(buf2);
          const cid$1 = cid.CID.createV0(hash2);
          await repo.blocks.put(cid$1, buf2, { signal: options.signal });
          if (options.preload !== false) {
            preload2(cid$1);
          }
          if (options.pin) {
            await repo.pins.pinRecursively(cid$1, { signal: options.signal });
          }
          return cid$1;
        } finally {
          release();
        }
      }
      return withTimeoutOption2.withTimeoutOption(put);
    }
    exports2.createPut = createPut5;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/stat.js
var require_stat4 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/stat.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dagPB = (init_src2(), src_exports2);
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var get2 = require_get4();
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    function createStat6({ repo, preload: preload2 }) {
      const get$1 = get2.createGet({
        repo,
        preload: preload2
      });
      async function stat(cid, options = {}) {
        const node = await get$1(cid, options);
        const serialized = dagPB__namespace.encode(node);
        const blockSize = serialized.length;
        const linkLength = node.Links.reduce((a, l) => a + (l.Tsize || 0), 0);
        return {
          Hash: cid,
          NumLinks: node.Links.length,
          BlockSize: blockSize,
          LinksSize: blockSize - (node.Data || []).length,
          DataSize: (node.Data || []).length,
          CumulativeSize: blockSize + linkLength
        };
      }
      return withTimeoutOption2.withTimeoutOption(stat);
    }
    exports2.createStat = createStat6;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/patch/add-link.js
var require_add_link2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/patch/add-link.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var get2 = require_get4();
    var put = require_put3();
    function createAddLink2({ repo, preload: preload2 }) {
      const get$1 = get2.createGet({
        repo,
        preload: preload2
      });
      const put$1 = put.createPut({
        repo,
        preload: preload2
      });
      async function addLink(cid, link, options = {}) {
        const node = await get$1(cid, options);
        return put$1({
          ...node,
          Links: node.Links.concat([link])
        }, options);
      }
      return withTimeoutOption2.withTimeoutOption(addLink);
    }
    exports2.createAddLink = createAddLink2;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/patch/append-data.js
var require_append_data = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/patch/append-data.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var concat3 = (init_concat(), concat_exports);
    var get2 = require_get4();
    var put = require_put3();
    function createAppendData2({ repo, preload: preload2 }) {
      const get$1 = get2.createGet({
        repo,
        preload: preload2
      });
      const put$1 = put.createPut({
        repo,
        preload: preload2
      });
      async function appendData(cid, data, options = {}) {
        const node = await get$1(cid, options);
        const newData = concat3.concat([
          node.Data || [],
          data
        ]);
        return put$1({
          ...node,
          Data: newData
        }, options);
      }
      return withTimeoutOption2.withTimeoutOption(appendData);
    }
    exports2.createAppendData = createAppendData2;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/patch/rm-link.js
var require_rm_link = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/patch/rm-link.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var get2 = require_get4();
    var put = require_put3();
    function createRmLink2({ repo, preload: preload2 }) {
      const get$1 = get2.createGet({
        repo,
        preload: preload2
      });
      const put$1 = put.createPut({
        repo,
        preload: preload2
      });
      async function rmLink(multihash, linkRef, options = {}) {
        const node = await get$1(multihash, options);
        const name5 = (typeof linkRef === "string" ? linkRef : linkRef.Name) || "";
        node.Links = node.Links.filter((l) => l.Name !== name5);
        return put$1(node, options);
      }
      return withTimeoutOption2.withTimeoutOption(rmLink);
    }
    exports2.createRmLink = createRmLink2;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/patch/set-data.js
var require_set_data = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/patch/set-data.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var get2 = require_get4();
    var put = require_put3();
    function createSetData2({ repo, preload: preload2 }) {
      const get$1 = get2.createGet({
        repo,
        preload: preload2
      });
      const put$1 = put.createPut({
        repo,
        preload: preload2
      });
      async function setData(cid, data, options = {}) {
        const node = await get$1(cid, options);
        return put$1({
          ...node,
          Data: data
        }, options);
      }
      return withTimeoutOption2.withTimeoutOption(setData);
    }
    exports2.createSetData = createSetData2;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/patch/index.js
var require_patch = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/patch/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var addLink = require_add_link2();
    var appendData = require_append_data();
    var rmLink = require_rm_link();
    var setData = require_set_data();
    var ObjectPatchAPI = class {
      constructor({ repo, preload: preload2 }) {
        this.addLink = addLink.createAddLink({
          repo,
          preload: preload2
        });
        this.appendData = appendData.createAppendData({
          repo,
          preload: preload2
        });
        this.rmLink = rmLink.createRmLink({
          repo,
          preload: preload2
        });
        this.setData = setData.createSetData({
          repo,
          preload: preload2
        });
      }
    };
    exports2.ObjectPatchAPI = ObjectPatchAPI;
  }
});

// node_modules/ipfs-core/cjs/src/components/object/index.js
var require_object = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/object/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var data = require_data();
    var get2 = require_get4();
    var links2 = require_links();
    var _new = require_new();
    var put = require_put3();
    var stat = require_stat4();
    var index = require_patch();
    var ObjectAPI = class {
      constructor({ repo, codecs: codecs2, preload: preload2 }) {
        this.data = data.createData({
          repo,
          preload: preload2
        });
        this.get = get2.createGet({
          repo,
          preload: preload2
        });
        this.links = links2.createLinks({
          repo,
          codecs: codecs2
        });
        this.new = _new.createNew({
          repo,
          preload: preload2
        });
        this.put = put.createPut({
          repo,
          preload: preload2
        });
        this.stat = stat.createStat({
          repo,
          preload: preload2
        });
        this.patch = new index.ObjectPatchAPI({
          repo,
          preload: preload2
        });
      }
    };
    exports2.ObjectAPI = ObjectAPI;
  }
});

// node_modules/ipfs-core/cjs/src/components/repo/gc.js
var require_gc = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/repo/gc.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug17 = require_browser2();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var withMfsRoot = require_with_mfs_root();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var log15 = debug__default["default"]("ipfs:repo:gc");
    function createGc2({ repo, hashers }) {
      async function* gc2(options = {}) {
        const start = Date.now();
        let mfsRootCid;
        try {
          mfsRootCid = await withMfsRoot.loadMfsRoot({
            repo,
            hashers
          }, options);
          await repo.pins.pinRecursively(mfsRootCid);
          yield* repo.gc();
        } finally {
          if (mfsRootCid) {
            await repo.pins.unpin(mfsRootCid);
          }
        }
        log15(`Complete (${Date.now() - start}ms)`);
      }
      return withTimeoutOption2.withTimeoutOption(gc2);
    }
    exports2.createGc = createGc2;
  }
});

// node_modules/ipfs-core/cjs/src/components/repo/stat.js
var require_stat5 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/repo/stat.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createStat6({ repo }) {
      async function stat(options = {}) {
        const stats = await repo.stat();
        return {
          numObjects: BigInt(stats.numObjects.toString()),
          repoSize: BigInt(stats.repoSize.toString()),
          repoPath: stats.repoPath,
          version: `${stats.version}`,
          storageMax: BigInt(stats.storageMax.toString())
        };
      }
      return withTimeoutOption2.withTimeoutOption(stat);
    }
    exports2.createStat = createStat6;
  }
});

// node_modules/ipfs-repo/esm/src/constants.js
var constants_exports = {};
__export(constants_exports, {
  repoVersion: () => repoVersion
});
var repoVersion;
var init_constants = __esm({
  "node_modules/ipfs-repo/esm/src/constants.js"() {
    init_node_globals();
    repoVersion = 11;
  }
});

// node_modules/ipfs-core/cjs/src/components/repo/version.js
var require_version3 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/repo/version.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var constants = (init_constants(), constants_exports);
    function createVersion3({ repo }) {
      async function version3(options = {}) {
        try {
          await repo._checkInitialized(options);
        } catch (err) {
          const match = [
            /Key not found in database \[\/version\]/,
            /ENOENT/,
            /repo is not initialized yet/
          ].some((m) => {
            return m.test(err.message);
          });
          if (match) {
            return constants.repoVersion;
          }
          throw err;
        }
        return repo.version.get();
      }
      return withTimeoutOption2.withTimeoutOption(version3);
    }
    exports2.createVersion = createVersion3;
  }
});

// node_modules/ipfs-core/cjs/src/components/repo/index.js
var require_repo = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/repo/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var gc2 = require_gc();
    var stat = require_stat5();
    var version3 = require_version3();
    var RepoAPI = class {
      constructor({ repo, hashers }) {
        this.gc = gc2.createGc({
          repo,
          hashers
        });
        this.stat = stat.createStat({ repo });
        this.version = version3.createVersion({ repo });
        this.setApiAddr = (addr) => repo.apiAddr.set(addr);
      }
    };
    exports2.RepoAPI = RepoAPI;
  }
});

// node_modules/ipfs-core/cjs/src/components/stats/bw.js
var require_bw = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/stats/bw.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var parseDuration = require_parse_duration();
    var errCode32 = require_err_code();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var parseDuration__default = /* @__PURE__ */ _interopDefaultLegacy(parseDuration);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    function getBandwidthStats(libp2p, opts) {
      let stats;
      if (!libp2p.metrics) {
        stats = void 0;
      } else if (opts.peer) {
        stats = libp2p.metrics.forPeer(opts.peer);
      } else if (opts.proto) {
        stats = libp2p.metrics.forProtocol(opts.proto);
      } else {
        stats = libp2p.metrics.global;
      }
      if (!stats) {
        return {
          totalIn: BigInt(0),
          totalOut: BigInt(0),
          rateIn: 0,
          rateOut: 0
        };
      }
      const { movingAverages, snapshot } = stats;
      return {
        totalIn: BigInt(snapshot.dataReceived.integerValue().toString()),
        totalOut: BigInt(snapshot.dataSent.integerValue().toString()),
        rateIn: movingAverages.dataReceived[6e4].movingAverage() / 60,
        rateOut: movingAverages.dataSent[6e4].movingAverage() / 60
      };
    }
    function createBw2({ network }) {
      const bw = async function* (options = {}) {
        const { libp2p } = await network.use(options);
        if (!options.poll) {
          yield getBandwidthStats(libp2p, options);
          return;
        }
        const interval = options.interval || 1e3;
        let ms = -1;
        try {
          ms = typeof interval === "string" ? parseDuration__default["default"](interval) || -1 : interval;
          if (!ms || ms < 0)
            throw new Error("invalid duration");
        } catch (err) {
          throw errCode__default["default"](err, "ERR_INVALID_POLL_INTERVAL");
        }
        let timeoutId;
        try {
          while (true) {
            yield getBandwidthStats(libp2p, options);
            await new Promise((resolve6) => {
              timeoutId = setTimeout(resolve6, ms);
            });
          }
        } finally {
          clearTimeout(timeoutId);
        }
      };
      return withTimeoutOption2.withTimeoutOption(bw);
    }
    exports2.createBw = createBw2;
  }
});

// node_modules/ipfs-core/cjs/src/components/stats/index.js
var require_stats = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/stats/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var bw = require_bw();
    var stat = require_stat5();
    var stat$1 = require_stat();
    var StatsAPI = class {
      constructor({ repo, network }) {
        this.repo = stat.createStat({ repo });
        this.bw = bw.createBw({ network });
        this.bitswap = stat$1.createStat({ network });
      }
    };
    exports2.StatsAPI = StatsAPI;
  }
});

// node_modules/just-safe-get/index.js
var require_just_safe_get = __commonJS({
  "node_modules/just-safe-get/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = get2;
    function get2(obj, propsArg, defaultValue) {
      if (!obj) {
        return defaultValue;
      }
      var props, prop;
      if (Array.isArray(propsArg)) {
        props = propsArg.slice(0);
      }
      if (typeof propsArg == "string") {
        props = propsArg.split(".");
      }
      if (typeof propsArg == "symbol") {
        props = [propsArg];
      }
      if (!Array.isArray(props)) {
        throw new Error("props arg must be an array, a string or a symbol");
      }
      while (props.length) {
        prop = props.shift();
        if (!obj) {
          return defaultValue;
        }
        obj = obj[prop];
        if (obj === void 0) {
          return defaultValue;
        }
      }
      return obj;
    }
  }
});

// node_modules/it-length/index.js
var require_it_length = __commonJS({
  "node_modules/it-length/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var length4 = async (iterator) => {
      let count = 0;
      for await (const _ of iterator) {
        count++;
      }
      return count;
    };
    module2.exports = length4;
  }
});

// node_modules/ipfs-repo-migrations/esm/migrations/migration-8/index.js
function unwrap(blockstore) {
  if (blockstore.child) {
    return unwrap(blockstore.child);
  }
  return blockstore;
}
function keyToMultihash(key) {
  try {
    const buf2 = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const multihash = CID.decode(buf2).multihash.bytes;
    const multihashStr = base32.encode(multihash).slice(1).toUpperCase();
    return new Key(`/${multihashStr}`, false);
  } catch (err) {
    return key;
  }
}
function keyToCid(key) {
  try {
    const buf2 = base32.decode(`b${key.toString().toLowerCase().slice(1)}`);
    const digest = decode3(buf2);
    const multihash = base32.encode(CID.createV1(code3, digest).bytes).slice(1);
    return new Key(`/${multihash.toUpperCase()}`, false);
  } catch {
    return key;
  }
}
async function process2(backends, onProgress, keyFunction) {
  const blockstore = backends.blocks;
  await blockstore.open();
  const unwrapped = unwrap(blockstore);
  const blockCount = await (0, import_it_length.default)(unwrapped.queryKeys({
    filters: [(key) => {
      const newKey = keyFunction(key);
      return newKey.toString() !== key.toString();
    }]
  }));
  try {
    let counter = 0;
    for await (const block of unwrapped.query({})) {
      const newKey = keyFunction(block.key);
      if (newKey.toString() !== block.key.toString()) {
        counter += 1;
        log5(`Migrating Block from ${block.key} to ${newKey}`, await unwrapped.has(block.key));
        await unwrapped.delete(block.key);
        await unwrapped.put(newKey, block.value);
        onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);
      }
    }
  } finally {
    await blockstore.close();
  }
}
var import_debug5, import_it_length, log5, migration;
var init_migration_8 = __esm({
  "node_modules/ipfs-repo-migrations/esm/migrations/migration-8/index.js"() {
    init_node_globals();
    init_cid();
    init_key();
    import_debug5 = __toModule(require_browser2());
    import_it_length = __toModule(require_it_length());
    init_base32();
    init_raw();
    init_digest();
    log5 = (0, import_debug5.default)("ipfs:repo:migrator:migration-8");
    migration = {
      version: 8,
      description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",
      migrate: (backends, onProgress = () => {
      }) => {
        return process2(backends, onProgress, keyToMultihash);
      },
      revert: (backends, onProgress = () => {
      }) => {
        return process2(backends, onProgress, keyToCid);
      }
    };
  }
});

// node_modules/ipfs-repo-migrations/esm/migrations/migration-9/pin.js
var import_minimal3, $Reader3, $Writer3, $util3, $root3, ipfs;
var init_pin = __esm({
  "node_modules/ipfs-repo-migrations/esm/migrations/migration-9/pin.js"() {
    init_node_globals();
    import_minimal3 = __toModule(require_minimal2());
    $Reader3 = import_minimal3.default.Reader;
    $Writer3 = import_minimal3.default.Writer;
    $util3 = import_minimal3.default.util;
    $root3 = import_minimal3.default.roots["default"] || (import_minimal3.default.roots["default"] = {});
    ipfs = $root3.ipfs = (() => {
      const ipfs2 = {};
      ipfs2.pin = function() {
        const pin = {};
        pin.Set = function() {
          function Set2(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          Set2.prototype.version = 0;
          Set2.prototype.fanout = 0;
          Set2.prototype.seed = 0;
          Set2.encode = function encode10(m, w) {
            if (!w)
              w = $Writer3.create();
            if (m.version != null && Object.hasOwnProperty.call(m, "version"))
              w.uint32(8).uint32(m.version);
            if (m.fanout != null && Object.hasOwnProperty.call(m, "fanout"))
              w.uint32(16).uint32(m.fanout);
            if (m.seed != null && Object.hasOwnProperty.call(m, "seed"))
              w.uint32(29).fixed32(m.seed);
            return w;
          };
          Set2.decode = function decode12(r, l) {
            if (!(r instanceof $Reader3))
              r = $Reader3.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root3.ipfs.pin.Set();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.version = r.uint32();
                  break;
                case 2:
                  m.fanout = r.uint32();
                  break;
                case 3:
                  m.seed = r.fixed32();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          Set2.fromObject = function fromObject(d) {
            if (d instanceof $root3.ipfs.pin.Set)
              return d;
            var m = new $root3.ipfs.pin.Set();
            if (d.version != null) {
              m.version = d.version >>> 0;
            }
            if (d.fanout != null) {
              m.fanout = d.fanout >>> 0;
            }
            if (d.seed != null) {
              m.seed = d.seed >>> 0;
            }
            return m;
          };
          Set2.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.defaults) {
              d.version = 0;
              d.fanout = 0;
              d.seed = 0;
            }
            if (m.version != null && m.hasOwnProperty("version")) {
              d.version = m.version;
            }
            if (m.fanout != null && m.hasOwnProperty("fanout")) {
              d.fanout = m.fanout;
            }
            if (m.seed != null && m.hasOwnProperty("seed")) {
              d.seed = m.seed;
            }
            return d;
          };
          Set2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, import_minimal3.default.util.toJSONOptions);
          };
          return Set2;
        }();
        return pin;
      }();
      return ipfs2;
    })();
  }
});

// node_modules/fnv1a/index.js
var require_fnv1a = __commonJS({
  "node_modules/fnv1a/index.js"(exports2, module2) {
    init_node_globals();
    hash2.BASE = 2166136261;
    function hash2(s) {
      var h = hash2.BASE;
      for (var i = 0, l = s.length; i < l; i++) {
        h ^= s.charCodeAt(i);
        h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
      }
      return h >>> 0;
    }
    module2.exports = hash2;
  }
});

// node_modules/ipfs-repo-migrations/esm/migrations/migration-9/utils.js
function cidToKey(cid) {
  return new Key(`/${base32.encode(cid.multihash.bytes).toUpperCase().substring(1)}`);
}
var PIN_DS_KEY, DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY, PinTypes2;
var init_utils5 = __esm({
  "node_modules/ipfs-repo-migrations/esm/migrations/migration-9/utils.js"() {
    init_node_globals();
    init_key();
    init_base32();
    init_cid();
    PIN_DS_KEY = new Key("/local/pins");
    DEFAULT_FANOUT = 256;
    MAX_ITEMS = 8192;
    EMPTY_KEY = CID.parse("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n");
    PinTypes2 = {
      direct: "direct",
      recursive: "recursive"
    };
  }
});

// node_modules/uint8arrays/esm/src/compare.js
var compare_exports = {};
__export(compare_exports, {
  compare: () => compare2
});
function compare2(a, b) {
  for (let i = 0; i < a.byteLength; i++) {
    if (a[i] < b[i]) {
      return -1;
    }
    if (a[i] > b[i]) {
      return 1;
    }
  }
  if (a.byteLength > b.byteLength) {
    return 1;
  }
  if (a.byteLength < b.byteLength) {
    return -1;
  }
  return 0;
}
var init_compare = __esm({
  "node_modules/uint8arrays/esm/src/compare.js"() {
    init_node_globals();
  }
});

// node_modules/ipfs-repo-migrations/esm/migrations/migration-9/pin-set.js
function readHeader2(rootNode) {
  const rootData = rootNode.Data;
  if (!rootData) {
    throw new Error("No data present");
  }
  const hdrLength = import_varint4.default.decode(rootData);
  const vBytes = import_varint4.default.decode.bytes;
  if (vBytes <= 0) {
    throw new Error("Invalid Set header length");
  }
  if (vBytes + hdrLength > rootData.length) {
    throw new Error("Impossibly large set header length");
  }
  const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);
  const header = PinSet.toObject(PinSet.decode(hdrSlice), {
    defaults: false,
    arrays: true,
    longs: Number,
    objects: false
  });
  if (header.version !== 1) {
    throw new Error(`Unsupported Set version: ${header.version}`);
  }
  if (header.fanout > rootNode.Links.length) {
    throw new Error("Impossibly large fanout");
  }
  return {
    header,
    data: rootData.slice(hdrLength + vBytes)
  };
}
function hash(seed, key) {
  const buffer2 = new Uint8Array(4);
  const dataView2 = new DataView(buffer2.buffer);
  dataView2.setUint32(0, seed, true);
  const encodedKey = fromString3(key.toString());
  const data = concat2([
    buffer2,
    encodedKey
  ], buffer2.byteLength + encodedKey.byteLength);
  return (0, import_fnv1a.default)(toString3(data));
}
async function* walkItems(blockstore, node) {
  const pbh = readHeader2(node);
  let idx = 0;
  for (const link of node.Links) {
    if (idx < pbh.header.fanout) {
      const linkHash = link.Hash;
      if (!EMPTY_KEY.equals(linkHash)) {
        const buf2 = await blockstore.get(linkHash);
        const node2 = decode5(buf2);
        yield* walkItems(blockstore, node2);
      }
    } else {
      yield link.Hash;
    }
    idx++;
  }
}
async function* loadSet(blockstore, rootNode, name5) {
  const link = rootNode.Links.find((l) => l.Name === name5);
  if (!link) {
    throw new Error("No link found with name " + name5);
  }
  const buf2 = await blockstore.get(link.Hash);
  const node = decode5(buf2);
  yield* walkItems(blockstore, node);
}
function storeItems(blockstore, items) {
  return storePins(items, 0);
  async function storePins(pins, depth) {
    const pbHeader = PinSet.encode({
      version: 1,
      fanout: DEFAULT_FANOUT,
      seed: depth
    }).finish();
    const header = import_varint4.default.encode(pbHeader.length);
    const headerBuf = concat2([
      header,
      pbHeader
    ]);
    const fanoutLinks = [];
    for (let i = 0; i < DEFAULT_FANOUT; i++) {
      fanoutLinks.push({
        Name: "",
        Tsize: 1,
        Hash: EMPTY_KEY
      });
    }
    if (pins.length <= MAX_ITEMS) {
      const nodes = pins.map((item) => {
        return {
          link: {
            Name: "",
            Tsize: 1,
            Hash: item.key
          },
          data: item.data || new Uint8Array()
        };
      }).sort((a, b) => {
        return compare2(a.link.Hash.bytes, b.link.Hash.bytes);
      });
      const rootLinks = fanoutLinks.concat(nodes.map((item) => item.link));
      const rootData = concat2([
        headerBuf,
        ...nodes.map((item) => item.data)
      ]);
      return {
        Data: rootData,
        Links: rootLinks
      };
    } else {
      const bins = pins.reduce((bins2, pin) => {
        const n = hash(depth, pin.key) % DEFAULT_FANOUT;
        bins2[n] = n in bins2 ? bins2[n].concat([pin]) : [pin];
        return bins2;
      }, []);
      let idx = 0;
      for (const bin of bins) {
        const child = await storePins(bin, depth + 1);
        await storeChild(child, idx);
        idx++;
      }
      return {
        Data: headerBuf,
        Links: fanoutLinks
      };
    }
    async function storeChild(child, binIdx) {
      const buf2 = encode3(child);
      const digest = await sha256.digest(buf2);
      const cid = CID.createV0(digest);
      await blockstore.put(cid, buf2);
      const size = child.Links.reduce((acc, curr) => acc + (curr.Tsize || 0), 0) + buf2.length;
      fanoutLinks[binIdx] = {
        Name: "",
        Tsize: size,
        Hash: cid
      };
    }
  }
}
async function storeSet(blockstore, type, cids) {
  const rootNode = await storeItems(blockstore, cids.map((cid2) => {
    return { key: cid2 };
  }));
  const buf2 = encode3(rootNode);
  const digest = await sha256.digest(buf2);
  const cid = CID.createV0(digest);
  await blockstore.put(cid, buf2);
  const size = rootNode.Links.reduce((acc, curr) => acc + curr.Tsize, 0) + buf2.length;
  return {
    Name: type,
    Tsize: size,
    Hash: cid
  };
}
var import_fnv1a, import_varint4, PinSet;
var init_pin_set = __esm({
  "node_modules/ipfs-repo-migrations/esm/migrations/migration-9/pin-set.js"() {
    init_node_globals();
    init_cid();
    init_pin();
    import_fnv1a = __toModule(require_fnv1a());
    import_varint4 = __toModule(require_varint());
    init_src2();
    init_utils5();
    init_concat();
    init_compare();
    init_to_string();
    init_from_string();
    init_sha2_browser();
    PinSet = ipfs.pin.Set;
  }
});

// node_modules/ipfs-repo-migrations/esm/migrations/migration-9/index.js
async function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {
  if (!await datastore.has(PIN_DS_KEY)) {
    return;
  }
  const mh2 = await datastore.get(PIN_DS_KEY);
  const cid = CID.decode(mh2);
  const pinRootBuf = await blockstore.get(cid);
  const pinRoot = decode5(pinRootBuf);
  let counter = 0;
  const pinCount = await (0, import_it_length2.default)(loadSet(blockstore, pinRoot, PinTypes2.recursive)) + await (0, import_it_length2.default)(loadSet(blockstore, pinRoot, PinTypes2.direct));
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes2.recursive)) {
    counter++;
    const pin = { depth: Infinity };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode4(pin));
    onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid2}`);
  }
  for await (const cid2 of loadSet(blockstore, pinRoot, PinTypes2.direct)) {
    counter++;
    const pin = { depth: 0 };
    if (cid2.version !== 0) {
      pin.version = cid2.version;
    }
    if (cid2.code !== code) {
      pin.codec = cid2.code;
    }
    await pinstore.put(cidToKey(cid2), encode4(pin));
    onProgress(counter / pinCount * 100, `Migrated direct pin ${cid2}`);
  }
  await blockstore.delete(cid);
  await datastore.delete(PIN_DS_KEY);
}
async function pinsToDAG(blockstore, datastore, pinstore, onProgress) {
  const recursivePins = [];
  const directPins = [];
  let counter = 0;
  const pinCount = await (0, import_it_length2.default)(pinstore.queryKeys({}));
  for await (const { key, value } of pinstore.query({})) {
    counter++;
    const pin = decode6(value);
    const cid2 = CID.create(pin.version || 0, pin.codec || code, decode3(base32.decode("b" + key.toString().toLowerCase().split("/").pop())));
    if (pin.depth === 0) {
      onProgress(counter / pinCount * 100, `Reverted direct pin ${cid2}`);
      directPins.push(cid2);
    } else {
      onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid2}`);
      recursivePins.push(cid2);
    }
  }
  onProgress(100, "Updating pin root");
  const pinRoot = {
    Links: [
      await storeSet(blockstore, PinTypes2.direct, directPins),
      await storeSet(blockstore, PinTypes2.recursive, recursivePins)
    ]
  };
  const buf2 = encode3(pinRoot);
  const digest = await sha256.digest(buf2);
  const cid = CID.createV0(digest);
  await blockstore.put(cid, buf2);
  await datastore.put(PIN_DS_KEY, cid.bytes);
}
async function process3(backends, onProgress, fn) {
  const blockstore = backends.blocks;
  const datastore = backends.datastore;
  const pinstore = backends.pins;
  await blockstore.open();
  await datastore.open();
  await pinstore.open();
  try {
    await fn(blockstore, datastore, pinstore, onProgress);
  } finally {
    await pinstore.close();
    await datastore.close();
    await blockstore.close();
  }
}
var import_it_length2, migration2;
var init_migration_9 = __esm({
  "node_modules/ipfs-repo-migrations/esm/migrations/migration-9/index.js"() {
    init_node_globals();
    init_cid();
    init_src2();
    init_cborg();
    init_pin_set();
    init_utils5();
    import_it_length2 = __toModule(require_it_length());
    init_sha2_browser();
    init_digest();
    init_base32();
    migration2 = {
      version: 9,
      description: "Migrates pins to datastore",
      migrate: (backends, onProgress = () => {
      }) => {
        return process3(backends, onProgress, pinsToDatastore);
      },
      revert: (backends, onProgress = () => {
      }) => {
        return process3(backends, onProgress, pinsToDAG);
      }
    };
  }
});

// node_modules/ipfs-repo-migrations/esm/src/utils.js
function findLevelJs(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
async function hasWithFallback(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve6, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve6(Boolean(req.result));
    };
  });
}
async function getWithFallback(key, get2, has, store) {
  if (await has(key)) {
    return get2(key);
  }
  const levelJs = findLevelJs(store);
  if (!levelJs) {
    throw notFoundError();
  }
  return new Promise((resolve6, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve6(req.result);
      }
      reject(notFoundError());
    };
  });
}
function wrapStore(store) {
  const originalGet = store.get.bind(store);
  const originalHas = store.has.bind(store);
  store.get = (key) => getWithFallback(key, originalGet, originalHas, store);
  store.has = (key) => hasWithFallback(key, originalHas, store);
  return store;
}
function wrapBackends(backends) {
  return {
    ...backends,
    root: wrapStore(backends.root),
    datastore: wrapStore(backends.datastore),
    pins: wrapStore(backends.pins),
    keys: wrapStore(backends.keys)
  };
}
var CONFIG_KEY, VERSION_KEY;
var init_utils6 = __esm({
  "node_modules/ipfs-repo-migrations/esm/src/utils.js"() {
    init_node_globals();
    init_key();
    init_errors2();
    CONFIG_KEY = new Key("/config");
    VERSION_KEY = new Key("/version");
  }
});

// node_modules/ipfs-repo-migrations/esm/migrations/migration-10/index.js
async function keysToBinary(name5, store, onProgress = () => {
}) {
  const db = findLevelJs(store);
  if (!db) {
    onProgress(`${name5} did not need an upgrade`);
    return;
  }
  onProgress(`Upgrading ${name5}`);
  const upgrade = (key, value) => {
    return [
      {
        type: "del",
        key
      },
      {
        type: "put",
        key: fromString3(key),
        value
      }
    ];
  };
  await withEach(db, upgrade);
}
async function keysToStrings(name5, store, onProgress = () => {
}) {
  const db = findLevelJs(store);
  if (!db) {
    onProgress(`${name5} did not need a downgrade`);
    return;
  }
  onProgress(`Downgrading ${name5}`);
  const downgrade = (key, value) => {
    return [
      {
        type: "del",
        key
      },
      {
        type: "put",
        key: toString3(key),
        value
      }
    ];
  };
  await withEach(db, downgrade);
}
function unwrap2(store) {
  if (store.child) {
    return unwrap2(store.child);
  }
  return store;
}
async function process4(backends, onProgress, fn) {
  const datastores = Object.entries(backends).map(([key, backend]) => ({
    key,
    backend: unwrap2(backend)
  })).filter(({ key, backend }) => backend.constructor.name === "LevelDatastore").map(({ key, backend }) => ({
    name: key,
    store: backend
  }));
  onProgress(0, `Migrating ${datastores.length} dbs`);
  let migrated = 0;
  const progress = (message) => {
    onProgress(Math.round(migrated / datastores.length * 100), message);
  };
  for (const { name: name5, store } of datastores) {
    await store.open();
    try {
      await fn(name5, store, progress);
    } finally {
      migrated++;
      await store.close();
    }
  }
  onProgress(100, `Migrated ${datastores.length} dbs`);
}
function withEach(db, fn) {
  function batch3(operations, next) {
    const store = db.store("readwrite");
    const transaction = store.transaction;
    let index = 0;
    let error;
    transaction.onabort = () => next(error || transaction.error || new Error("aborted by user"));
    transaction.oncomplete = () => next();
    function loop() {
      const op = operations[index++];
      const key = op.key;
      let req;
      try {
        req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
      } catch (err) {
        error = err;
        transaction.abort();
        return;
      }
      if (index < operations.length) {
        req.onsuccess = loop;
      }
    }
    loop();
  }
  return new Promise((resolve6, reject) => {
    const it = db.iterator();
    const id = (data) => data;
    it._deserializeKey = it._deserializeValue = id;
    next();
    function next() {
      const handleNext = (err, key, value) => {
        if (err || key === void 0) {
          const handleEnd = (err2) => {
            if (err2) {
              reject(err2);
              return;
            }
            resolve6();
          };
          it.end(handleEnd);
          return;
        }
        batch3(fn(key, value), next);
      };
      it.next(handleNext);
    }
  });
}
var migration3;
var init_migration_10 = __esm({
  "node_modules/ipfs-repo-migrations/esm/migrations/migration-10/index.js"() {
    init_node_globals();
    init_utils6();
    init_from_string();
    init_to_string();
    migration3 = {
      version: 10,
      description: "Migrates datastore-level keys to binary",
      migrate: (backends, onProgress = () => {
      }) => {
        return process4(backends, onProgress, keysToBinary);
      },
      revert: (backends, onProgress = () => {
      }) => {
        return process4(backends, onProgress, keysToStrings);
      }
    };
  }
});

// node_modules/ipfs-repo-migrations/esm/migrations/migration-11/index.js
async function storeMfsRootInDatastore(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.root.has(MFS_ROOT_KEY)) {
    const root = await backends.root.get(MFS_ROOT_KEY);
    await backends.datastore.put(MFS_ROOT_KEY, root);
    await backends.root.delete(MFS_ROOT_KEY);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo datastore");
}
async function storeMfsRootInRoot(backends, onProgress = () => {
}) {
  onProgress(100, "Migrating MFS root to repo root datastore");
  await backends.root.open();
  await backends.datastore.open();
  if (await backends.datastore.has(MFS_ROOT_KEY)) {
    const root = await backends.datastore.get(MFS_ROOT_KEY);
    await backends.root.put(MFS_ROOT_KEY, root);
    await backends.datastore.delete(MFS_ROOT_KEY);
  }
  await backends.datastore.close();
  await backends.root.close();
  onProgress(100, "Stored MFS root in repo root datastore");
}
var MFS_ROOT_KEY, migration4;
var init_migration_11 = __esm({
  "node_modules/ipfs-repo-migrations/esm/migrations/migration-11/index.js"() {
    init_node_globals();
    init_key();
    MFS_ROOT_KEY = new Key("/local/filesroot");
    migration4 = {
      version: 11,
      description: "Store mfs root in the datastore",
      migrate: storeMfsRootInDatastore,
      revert: storeMfsRootInRoot
    };
  }
});

// node_modules/ipfs-repo-migrations/esm/migrations/index.js
var emptyMigration, migrations_default;
var init_migrations = __esm({
  "node_modules/ipfs-repo-migrations/esm/migrations/index.js"() {
    init_node_globals();
    init_migration_8();
    init_migration_9();
    init_migration_10();
    init_migration_11();
    emptyMigration = {
      description: "Empty migration.",
      migrate: () => {
      },
      revert: () => {
      },
      empty: true
    };
    migrations_default = [
      Object.assign({ version: 1 }, emptyMigration),
      Object.assign({ version: 2 }, emptyMigration),
      Object.assign({ version: 3 }, emptyMigration),
      Object.assign({ version: 4 }, emptyMigration),
      Object.assign({ version: 5 }, emptyMigration),
      Object.assign({ version: 6 }, emptyMigration),
      Object.assign({ version: 7 }, emptyMigration),
      migration,
      migration2,
      migration3,
      migration4
    ];
  }
});

// node_modules/ipfs-repo-migrations/esm/src/errors.js
var errors_exports2 = {};
__export(errors_exports2, {
  InvalidValueError: () => InvalidValueError,
  MissingRepoOptionsError: () => MissingRepoOptionsError,
  NonReversibleMigrationError: () => NonReversibleMigrationError,
  NotInitializedRepoError: () => NotInitializedRepoError,
  RequiredParameterError: () => RequiredParameterError
});
var NonReversibleMigrationError, NotInitializedRepoError, RequiredParameterError, InvalidValueError, MissingRepoOptionsError;
var init_errors4 = __esm({
  "node_modules/ipfs-repo-migrations/esm/src/errors.js"() {
    init_node_globals();
    NonReversibleMigrationError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "NonReversibleMigrationError";
        this.code = NonReversibleMigrationError.code;
        this.message = message;
      }
    };
    NonReversibleMigrationError.code = "ERR_NON_REVERSIBLE_MIGRATION";
    NotInitializedRepoError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "NotInitializedRepoError";
        this.code = NotInitializedRepoError.code;
        this.message = message;
      }
    };
    NotInitializedRepoError.code = "ERR_NOT_INITIALIZED_REPO";
    RequiredParameterError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "RequiredParameterError";
        this.code = RequiredParameterError.code;
        this.message = message;
      }
    };
    RequiredParameterError.code = "ERR_REQUIRED_PARAMETER";
    InvalidValueError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InvalidValueError";
        this.code = InvalidValueError.code;
        this.message = message;
      }
    };
    InvalidValueError.code = "ERR_INVALID_VALUE";
    MissingRepoOptionsError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "MissingRepoOptionsError";
        this.code = MissingRepoOptionsError.code;
        this.message = message;
      }
    };
    MissingRepoOptionsError.code = "ERR_MISSING_REPO_OPTIONS";
  }
});

// node_modules/ipfs-repo-migrations/esm/src/repo/init.js
async function isRepoInitialized(backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const root = backends.root;
  try {
    await root.open();
    const versionCheck = await root.has(VERSION_KEY);
    const configCheck = await root.has(CONFIG_KEY);
    if (!versionCheck || !configCheck) {
      log6(`Version entry present: ${versionCheck}`);
      log6(`Config entry present: ${configCheck}`);
      return false;
    }
    return true;
  } catch (e) {
    log6("While checking if repo is initialized error was thrown: " + e.message);
    return false;
  } finally {
    if (root !== void 0) {
      try {
        await root.close();
      } catch {
      }
    }
  }
}
var import_debug6, log6;
var init_init = __esm({
  "node_modules/ipfs-repo-migrations/esm/src/repo/init.js"() {
    init_node_globals();
    import_debug6 = __toModule(require_browser2());
    init_utils6();
    init_errors4();
    log6 = (0, import_debug6.default)("ipfs:repo:migrator:repo:init");
  }
});

// node_modules/ipfs-repo-migrations/esm/src/repo/version.js
async function getVersion(backends) {
  if (!await isRepoInitialized(backends)) {
    throw new NotInitializedRepoError("Repo is not initialized!");
  }
  const store = backends.root;
  await store.open();
  try {
    return parseInt(toString3(await store.get(VERSION_KEY)));
  } finally {
    await store.close();
  }
}
async function setVersion(version3, backends) {
  if (!backends) {
    throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
  }
  const store = backends.root;
  await store.open();
  await store.put(VERSION_KEY, fromString3(String(version3)));
  await store.close();
}
var init_version = __esm({
  "node_modules/ipfs-repo-migrations/esm/src/repo/version.js"() {
    init_node_globals();
    init_init();
    init_errors4();
    init_utils6();
    init_from_string();
    init_to_string();
  }
});

// node_modules/ipfs-repo-migrations/esm/src/index.js
function getLatestMigrationVersion(migrations) {
  migrations = migrations || migrations_default;
  if (!Array.isArray(migrations) || migrations.length === 0) {
    return 0;
  }
  return migrations[migrations.length - 1].version;
}
async function migrate(path, backends, repoOptions, toVersion, { ignoreLock = false, onProgress, isDryRun = false, migrations }) {
  migrations = migrations || migrations_default;
  if (!path) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("toVersion argument is required!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log7("Nothing to migrate.");
    return;
  }
  if (currentVersion > toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);
  }
  verifyAvailableMigrations(migrations, currentVersion, toVersion);
  let lock2;
  if (!isDryRun && !ignoreLock) {
    lock2 = await repoOptions.repoLock.lock(path);
  }
  try {
    for (const migration5 of migrations) {
      if (toVersion !== void 0 && migration5.version > toVersion) {
        break;
      }
      if (migration5.version <= currentVersion) {
        continue;
      }
      log7(`Migrating version ${migration5.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message) => onProgress(migration5.version, percent.toFixed(2), message);
          }
          await migration5.migrate(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyMigratedVersion = migration5.version - 1;
        log7(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);
        await setVersion(lastSuccessfullyMigratedVersion, backends);
        throw new Error(`During migration to version ${migration5.version} exception was raised: ${e.stack || e.message || e}`);
      }
      log7(`Migrating to version ${migration5.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion || getLatestMigrationVersion(migrations), backends);
    }
    log7("Repo successfully migrated", toVersion !== void 0 ? `to version ${toVersion}!` : "to latest version!");
  } finally {
    if (!isDryRun && !ignoreLock && lock2) {
      await lock2.close();
    }
  }
}
async function revert(path, backends, repoOptions, toVersion, { ignoreLock = false, onProgress, isDryRun = false, migrations }) {
  migrations = migrations || migrations_default;
  if (!path) {
    throw new errors.RequiredParameterError("Path argument is required!");
  }
  if (!repoOptions) {
    throw new errors.RequiredParameterError("repoOptions argument is required!");
  }
  if (!toVersion) {
    throw new errors.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
  }
  if (!Number.isInteger(toVersion) || toVersion <= 0) {
    throw new errors.InvalidValueError("Version has to be positive integer!");
  }
  backends = wrapBackends(backends);
  const currentVersion = await getVersion(backends);
  if (currentVersion === toVersion) {
    log7("Nothing to revert.");
    return;
  }
  if (currentVersion < toVersion) {
    throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);
  }
  verifyAvailableMigrations(migrations, toVersion, currentVersion, true);
  let lock2;
  if (!isDryRun && !ignoreLock) {
    lock2 = await repoOptions.repoLock.lock(path);
  }
  log7(`Reverting from version ${currentVersion} to ${toVersion}`);
  try {
    const reversedMigrationArray = migrations.slice().reverse();
    for (const migration5 of reversedMigrationArray) {
      if (migration5.version <= toVersion) {
        break;
      }
      if (migration5.version > currentVersion) {
        continue;
      }
      log7(`Reverting migration version ${migration5.version}`);
      try {
        if (!isDryRun) {
          let progressCallback = () => {
          };
          if (onProgress) {
            progressCallback = (percent, message) => onProgress(migration5.version, percent.toFixed(2), message);
          }
          await migration5.revert(backends, progressCallback);
        }
      } catch (e) {
        const lastSuccessfullyRevertedVersion = migration5.version;
        log7(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);
        await setVersion(lastSuccessfullyRevertedVersion, backends);
        e.message = `During reversion to version ${migration5.version} exception was raised: ${e.message}`;
        throw e;
      }
      log7(`Reverting to version ${migration5.version} finished`);
    }
    if (!isDryRun) {
      await setVersion(toVersion, backends);
    }
    log7(`All migrations successfully reverted to version ${toVersion}!`);
  } finally {
    if (!isDryRun && !ignoreLock && lock2) {
      await lock2.close();
    }
  }
}
function verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {
  let migrationCounter = 0;
  for (const migration5 of migrations) {
    if (migration5.version > toVersion) {
      break;
    }
    if (migration5.version > fromVersion) {
      if (checkReversibility && !migration5.revert) {
        throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration5.version} is not reversible. Cancelling reversion.`);
      }
      migrationCounter++;
    }
  }
  if (migrationCounter !== toVersion - fromVersion) {
    throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);
  }
}
var import_debug7, log7, errors;
var init_src10 = __esm({
  "node_modules/ipfs-repo-migrations/esm/src/index.js"() {
    init_node_globals();
    init_migrations();
    init_version();
    init_errors4();
    init_utils6();
    import_debug7 = __toModule(require_browser2());
    log7 = (0, import_debug7.default)("ipfs:repo:migrator");
    errors = errors_exports2;
  }
});

// node_modules/bytes/index.js
var require_bytes = __commonJS({
  "node_modules/bytes/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = bytes3;
    module2.exports.format = format;
    module2.exports.parse = parse2;
    var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
    var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
    var map8 = {
      b: 1,
      kb: 1 << 10,
      mb: 1 << 20,
      gb: 1 << 30,
      tb: Math.pow(1024, 4),
      pb: Math.pow(1024, 5)
    };
    var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
    function bytes3(value, options) {
      if (typeof value === "string") {
        return parse2(value);
      }
      if (typeof value === "number") {
        return format(value, options);
      }
      return null;
    }
    function format(value, options) {
      if (!Number.isFinite(value)) {
        return null;
      }
      var mag = Math.abs(value);
      var thousandsSeparator = options && options.thousandsSeparator || "";
      var unitSeparator = options && options.unitSeparator || "";
      var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
      var fixedDecimals = Boolean(options && options.fixedDecimals);
      var unit = options && options.unit || "";
      if (!unit || !map8[unit.toLowerCase()]) {
        if (mag >= map8.pb) {
          unit = "PB";
        } else if (mag >= map8.tb) {
          unit = "TB";
        } else if (mag >= map8.gb) {
          unit = "GB";
        } else if (mag >= map8.mb) {
          unit = "MB";
        } else if (mag >= map8.kb) {
          unit = "KB";
        } else {
          unit = "B";
        }
      }
      var val = value / map8[unit.toLowerCase()];
      var str = val.toFixed(decimalPlaces);
      if (!fixedDecimals) {
        str = str.replace(formatDecimalsRegExp, "$1");
      }
      if (thousandsSeparator) {
        str = str.replace(formatThousandsRegExp, thousandsSeparator);
      }
      return str + unitSeparator + unit;
    }
    function parse2(val) {
      if (typeof val === "number" && !isNaN(val)) {
        return val;
      }
      if (typeof val !== "string") {
        return null;
      }
      var results = parseRegExp.exec(val);
      var floatValue;
      var unit = "b";
      if (!results) {
        floatValue = parseInt(val, 10);
        unit = "b";
      } else {
        floatValue = parseFloat(results[1]);
        unit = results[4].toLowerCase();
      }
      return Math.floor(map8[unit] * floatValue);
    }
  }
});

// node_modules/ipfs-repo/esm/src/errors.js
var errors_exports3 = {};
__export(errors_exports3, {
  ERR_REPO_ALREADY_CLOSED: () => ERR_REPO_ALREADY_CLOSED,
  ERR_REPO_ALREADY_OPEN: () => ERR_REPO_ALREADY_OPEN,
  ERR_REPO_NOT_INITIALIZED: () => ERR_REPO_NOT_INITIALIZED,
  InvalidRepoVersionError: () => InvalidRepoVersionError,
  LockExistsError: () => LockExistsError,
  NotFoundError: () => NotFoundError
});
var LockExistsError, NotFoundError, InvalidRepoVersionError, ERR_REPO_NOT_INITIALIZED, ERR_REPO_ALREADY_OPEN, ERR_REPO_ALREADY_CLOSED;
var init_errors5 = __esm({
  "node_modules/ipfs-repo/esm/src/errors.js"() {
    init_node_globals();
    LockExistsError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "LockExistsError";
        this.code = LockExistsError.code;
      }
    };
    LockExistsError.code = "ERR_LOCK_EXISTS";
    NotFoundError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "NotFoundError";
        this.code = NotFoundError.code;
      }
    };
    NotFoundError.code = "ERR_NOT_FOUND";
    InvalidRepoVersionError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "InvalidRepoVersionError";
        this.code = InvalidRepoVersionError.code;
      }
    };
    InvalidRepoVersionError.code = "ERR_INVALID_REPO_VERSION";
    ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED";
    ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN";
    ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED";
  }
});

// node_modules/ipfs-repo/esm/src/utils/level.js
async function hasWithFallback2(key, has, store) {
  const result = await has(key);
  if (result) {
    return result;
  }
  const levelJs = findLevelJs2(store);
  if (!levelJs) {
    return false;
  }
  return new Promise((resolve6, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      resolve6(Boolean(req.result));
    };
  });
}
async function getWithFallback2(key, get2, has, store) {
  if (await has(key)) {
    return get2(key);
  }
  const levelJs = findLevelJs2(store);
  if (!levelJs) {
    throw new NotFoundError();
  }
  return new Promise((resolve6, reject) => {
    const req = levelJs.store("readonly").get(key.toString());
    req.transaction.onabort = () => {
      reject(req.transaction.error);
    };
    req.transaction.oncomplete = () => {
      if (req.result) {
        return resolve6(req.result);
      }
      reject(new NotFoundError());
    };
  });
}
function findLevelJs2(store) {
  let db = store;
  while (db.db || db.child) {
    db = db.db || db.child;
    if (db.type === "level-js" || db.constructor.name === "Level") {
      return db;
    }
  }
}
var init_level = __esm({
  "node_modules/ipfs-repo/esm/src/utils/level.js"() {
    init_node_globals();
    init_errors5();
  }
});

// node_modules/ipfs-repo/esm/src/version.js
function version2(store) {
  return {
    async exists() {
      return hasWithFallback2(versionKey, store.has.bind(store), store);
    },
    async get() {
      const buf2 = await getWithFallback2(versionKey, store.get.bind(store), store.has.bind(store), store);
      return parseInt(toString3(buf2), 10);
    },
    set(version3) {
      return store.put(versionKey, fromString3(String(version3)));
    },
    async check(expected) {
      const version3 = await this.get();
      log8("comparing version: %s and %s", version3, expected);
      const compatibleVersion = version3 === 6 && expected === 7 || expected === 6 && version3 === 7;
      return version3 === expected || compatibleVersion;
    }
  };
}
var import_debug8, log8, versionKey;
var init_version2 = __esm({
  "node_modules/ipfs-repo/esm/src/version.js"() {
    init_node_globals();
    init_key();
    import_debug8 = __toModule(require_browser2());
    init_to_string();
    init_from_string();
    init_level();
    log8 = (0, import_debug8.default)("ipfs:repo:version");
    versionKey = new Key("version");
  }
});

// node_modules/ipfs-repo/esm/src/config.js
function config(store) {
  const setQueue = new Queue3({ concurrency: 1 });
  const configStore = {
    async getAll(options = {}) {
      const encodedValue = await getWithFallback2(configKey, store.get.bind(store), store.has.bind(store), store);
      return JSON.parse(toString3(encodedValue));
    },
    async get(key, options = {}) {
      if (key == null) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      const config2 = await this.getAll(options);
      const value = (0, import_just_safe_get.default)(config2, key);
      if (value === void 0) {
        throw new NotFoundError(`Key ${key} does not exist in config`);
      }
      return value;
    },
    set(key, value, options = {}) {
      if (typeof key !== "string" && !(key instanceof String)) {
        throw (0, import_err_code22.default)(new Error("Invalid key type: " + typeof key), "ERR_INVALID_KEY");
      }
      if (value === void 0 || value instanceof Uint8Array) {
        throw (0, import_err_code22.default)(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key,
        value
      }, options.signal));
    },
    replace(value, options = {}) {
      if (!value || value instanceof Uint8Array) {
        throw (0, import_err_code22.default)(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
      }
      return setQueue.add(() => _maybeDoSet({
        key: void 0,
        value
      }, options.signal));
    },
    async exists() {
      return hasWithFallback2(configKey, store.has.bind(store), store);
    }
  };
  return configStore;
  async function _maybeDoSet(m, signal) {
    if (signal && signal.aborted) {
      return;
    }
    const key = m.key;
    const value = m.value;
    if (key) {
      const config2 = await configStore.getAll();
      if (typeof config2 === "object" && config2 !== null) {
        (0, import_just_safe_set.default)(config2, key, value);
      }
      return _saveAll(config2);
    }
    return _saveAll(value);
  }
  function _saveAll(config2) {
    const buf2 = fromString3(JSON.stringify(config2, null, 2));
    return store.put(configKey, buf2);
  }
}
var import_p_queue3, import_just_safe_get, import_just_safe_set, import_err_code22, Queue3, configKey;
var init_config = __esm({
  "node_modules/ipfs-repo/esm/src/config.js"() {
    init_node_globals();
    init_key();
    import_p_queue3 = __toModule(require_dist());
    import_just_safe_get = __toModule(require_just_safe_get());
    import_just_safe_set = __toModule(require_just_safe_set());
    import_err_code22 = __toModule(require_err_code());
    init_errors5();
    init_to_string();
    init_from_string();
    init_level();
    Queue3 = import_p_queue3.default.default ? import_p_queue3.default.default : import_p_queue3.default;
    configKey = new Key("config");
  }
});

// node_modules/sort-keys/index.js
var require_sort_keys = __commonJS({
  "node_modules/sort-keys/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var isPlainObject = require_is_plain_obj();
    module2.exports = (object, options = {}) => {
      if (!isPlainObject(object) && !Array.isArray(object)) {
        throw new TypeError("Expected a plain object or array");
      }
      const { deep } = options;
      const seenInput = [];
      const seenOutput = [];
      const deepSortArray = (array2) => {
        const seenIndex = seenInput.indexOf(array2);
        if (seenIndex !== -1) {
          return seenOutput[seenIndex];
        }
        const result = [];
        seenInput.push(array2);
        seenOutput.push(result);
        result.push(...array2.map((item) => {
          if (Array.isArray(item)) {
            return deepSortArray(item);
          }
          if (isPlainObject(item)) {
            return sortKeys2(item);
          }
          return item;
        }));
        return result;
      };
      const sortKeys2 = (object2) => {
        const seenIndex = seenInput.indexOf(object2);
        if (seenIndex !== -1) {
          return seenOutput[seenIndex];
        }
        const result = {};
        const keys = Object.keys(object2).sort(options.compare);
        seenInput.push(object2);
        seenOutput.push(result);
        for (const key of keys) {
          const value = object2[key];
          let newValue;
          if (deep && Array.isArray(value)) {
            newValue = deepSortArray(value);
          } else {
            newValue = deep && isPlainObject(value) ? sortKeys2(value) : value;
          }
          Object.defineProperty(result, key, {
            ...Object.getOwnPropertyDescriptor(object2, key),
            value: newValue
          });
        }
        return result;
      };
      if (Array.isArray(object)) {
        return deep ? deepSortArray(object) : object.slice();
      }
      return sortKeys2(object);
    };
  }
});

// node_modules/ipfs-repo/esm/src/spec.js
function spec(store) {
  return {
    exists() {
      return store.has(specKey);
    },
    async get() {
      const buf2 = await store.get(specKey);
      return JSON.parse(toString3(buf2));
    },
    async set(spec2) {
      return store.put(specKey, fromString3(JSON.stringify((0, import_sort_keys.default)(spec2, { deep: true }))));
    }
  };
}
var import_sort_keys, specKey;
var init_spec = __esm({
  "node_modules/ipfs-repo/esm/src/spec.js"() {
    init_node_globals();
    init_src5();
    import_sort_keys = __toModule(require_sort_keys());
    init_to_string();
    init_from_string();
    specKey = new Key("datastore_spec");
  }
});

// node_modules/ipfs-repo/esm/src/api-addr.js
function apiAddr(store) {
  return {
    async get() {
      const value = await store.get(apiFile);
      return value && value.toString();
    },
    set(value) {
      return store.put(apiFile, fromString3(value.toString()));
    },
    delete() {
      return store.delete(apiFile);
    }
  };
}
var apiFile;
var init_api_addr = __esm({
  "node_modules/ipfs-repo/esm/src/api-addr.js"() {
    init_node_globals();
    init_key();
    init_from_string();
    apiFile = new Key("api");
  }
});

// node_modules/ipfs-repo/esm/src/idstore.js
function createIdStore(store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      const extracted = extractContents(cid);
      if (extracted.isIdentity) {
        return Promise.resolve(extracted.digest);
      }
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      for await (const cid of cids) {
        yield this.get(cid, options);
      }
    },
    async put(cid, buf2, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return;
      }
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      const output = (0, import_it_pushable2.default)();
      const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
      runner(async () => {
        try {
          await (0, import_it_drain3.default)(store.putMany(async function* () {
            for await (const { key, value } of pairs) {
              if (!extractContents(key).isIdentity) {
                yield {
                  key,
                  value
                };
              }
              output.push({
                key,
                value
              });
            }
          }()));
          output.end();
        } catch (err) {
          output.end(err);
        }
      });
      yield* output;
    },
    has(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve(true);
      }
      return store.has(cid, options);
    },
    delete(cid, options) {
      const { isIdentity } = extractContents(cid);
      if (isIdentity) {
        return Promise.resolve();
      }
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany((0, import_it_filter3.default)(cids, (cid) => !extractContents(cid).isIdentity), options);
    },
    batch() {
      const batch3 = store.batch();
      return {
        put(cid, buf2) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch3.put(cid, buf2);
        },
        delete(cid) {
          const { isIdentity } = extractContents(cid);
          if (isIdentity) {
            return;
          }
          batch3.delete(cid);
        },
        commit: (options) => {
          return batch3.commit(options);
        }
      };
    }
  };
}
function extractContents(k) {
  const cid = CID.asCID(k);
  if (cid == null) {
    throw (0, import_err_code23.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  if (cid.multihash.code !== identity.code) {
    return { isIdentity: false };
  }
  return {
    isIdentity: true,
    digest: cid.multihash.digest
  };
}
var import_it_filter3, import_it_pushable2, import_it_drain3, import_err_code23;
var init_idstore = __esm({
  "node_modules/ipfs-repo/esm/src/idstore.js"() {
    init_node_globals();
    import_it_filter3 = __toModule(require_it_filter());
    import_it_pushable2 = __toModule(require_it_pushable());
    import_it_drain3 = __toModule(require_it_drain());
    init_cid();
    import_err_code23 = __toModule(require_err_code());
    init_identity();
  }
});

// node_modules/ipfs-repo/esm/src/locks/memory.js
async function lock(dir) {
  const file = dir + "/" + lockFile;
  log9("locking %s", file);
  if (LOCKS[file] === true) {
    throw new LockExistsError(`Lock already being held for file: ${file}`);
  }
  LOCKS[file] = true;
  const closer = {
    async close() {
      if (LOCKS[file]) {
        delete LOCKS[file];
      }
    }
  };
  return closer;
}
async function locked(dir) {
  const file = dir + "/" + lockFile;
  log9(`checking lock: ${file}`);
  return Boolean(LOCKS[file]);
}
var import_debug9, log9, lockFile, LOCKS, MemoryLock;
var init_memory2 = __esm({
  "node_modules/ipfs-repo/esm/src/locks/memory.js"() {
    init_node_globals();
    init_errors5();
    import_debug9 = __toModule(require_browser2());
    log9 = (0, import_debug9.default)("ipfs:repo:lock:memory");
    lockFile = "repo.lock";
    LOCKS = {};
    MemoryLock = {
      lock,
      locked
    };
  }
});

// node_modules/ipfs-repo/esm/src/default-options.js
var default_options_default;
var init_default_options = __esm({
  "node_modules/ipfs-repo/esm/src/default-options.js"() {
    init_node_globals();
    init_memory2();
    default_options_default = {
      autoMigrate: true,
      onMigrationProgress: () => {
      },
      repoOwner: true,
      repoLock: MemoryLock
    };
  }
});

// node_modules/ipfs-repo/esm/src/default-datastore.js
var default_datastore_default;
var init_default_datastore = __esm({
  "node_modules/ipfs-repo/esm/src/default-datastore.js"() {
    init_node_globals();
    default_datastore_default = {
      Spec: {
        type: "mount",
        mounts: [
          {
            mountpoint: "/blocks",
            type: "measure",
            prefix: "flatfs.datastore",
            child: {
              type: "flatfs",
              path: "blocks",
              sync: true,
              shardFunc: "/repo/flatfs/shard/v1/next-to-last/2"
            }
          },
          {
            mountpoint: "/",
            type: "measure",
            prefix: "leveldb.datastore",
            child: {
              type: "levelds",
              path: "datastore",
              compression: "none"
            }
          }
        ]
      }
    };
  }
});

// node_modules/ipfs-repo/esm/src/utils/blockstore.js
function cidToKey2(c) {
  const cid = CID.asCID(c);
  if (cid == null) {
    throw (0, import_err_code24.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  const encoded = base32.encode(cid.multihash.bytes);
  return new Key("/" + encoded.slice(1).toUpperCase(), false);
}
function keyToMultihash2(key) {
  return decode3(base32.decode(`b${key.toString().toLowerCase().substring(1)}`));
}
var import_err_code24;
var init_blockstore = __esm({
  "node_modules/ipfs-repo/esm/src/utils/blockstore.js"() {
    init_node_globals();
    init_key();
    init_src3();
    init_raw();
    import_err_code24 = __toModule(require_err_code());
    init_base32();
    init_digest();
  }
});

// node_modules/ipfs-repo/esm/src/utils/walk-dag.js
async function* walkDag(cid, blockstore, loadCodec, options) {
  try {
    const bytes3 = await blockstore.get(cid, options);
    const codec = await loadCodec(cid.code);
    const block = createUnsafe({
      bytes: bytes3,
      cid,
      codec
    });
    for (const [, childCid] of block.links()) {
      yield childCid;
      yield* walkDag(childCid, blockstore, loadCodec, options);
    }
  } catch (err) {
    log10("Could not walk DAG for CID", cid.toString(), err);
    throw err;
  }
}
var import_debug10, log10;
var init_walk_dag = __esm({
  "node_modules/ipfs-repo/esm/src/utils/walk-dag.js"() {
    init_node_globals();
    import_debug10 = __toModule(require_browser2());
    init_block();
    log10 = (0, import_debug10.default)("ipfs:repo:utils:walk-dag");
  }
});

// node_modules/ipfs-repo/esm/src/pin-manager.js
function invalidPinTypeErr(type) {
  const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;
  return (0, import_err_code25.default)(new Error(errMsg), "ERR_INVALID_PIN_TYPE");
}
var import_err_code25, import_debug11, import_it_first, PinManager;
var init_pin_manager = __esm({
  "node_modules/ipfs-repo/esm/src/pin-manager.js"() {
    init_node_globals();
    init_cid();
    import_err_code25 = __toModule(require_err_code());
    import_debug11 = __toModule(require_browser2());
    import_it_first = __toModule(require_it_first());
    init_block();
    init_cborg();
    init_src2();
    init_blockstore();
    init_walk_dag();
    init_pin_types();
    PinManager = class {
      constructor({ pinstore, blockstore, loadCodec }) {
        this.pinstore = pinstore;
        this.blockstore = blockstore;
        this.loadCodec = loadCodec;
        this.log = (0, import_debug11.default)("ipfs:repo:pin");
        this.directPins = new Set();
        this.recursivePins = new Set();
      }
      async pinDirectly(cid, options = {}) {
        await this.blockstore.get(cid, options);
        const pin = { depth: 0 };
        if (cid.version !== 0) {
          pin.version = cid.version;
        }
        if (cid.code !== code) {
          pin.codec = cid.code;
        }
        if (options.metadata) {
          pin.metadata = options.metadata;
        }
        return this.pinstore.put(cidToKey2(cid), encode4(pin));
      }
      unpin(cid, options) {
        return this.pinstore.delete(cidToKey2(cid), options);
      }
      async pinRecursively(cid, options = {}) {
        await this.fetchCompleteDag(cid, options);
        const pin = { depth: Infinity };
        if (cid.version !== 0) {
          pin.version = cid.version;
        }
        if (cid.code !== code) {
          pin.codec = cid.code;
        }
        if (options.metadata) {
          pin.metadata = options.metadata;
        }
        await this.pinstore.put(cidToKey2(cid), encode4(pin));
      }
      async *directKeys(options) {
        for await (const entry of this.pinstore.query({
          filters: [(entry2) => {
            const pin = decode6(entry2.value);
            return pin.depth === 0;
          }]
        })) {
          const pin = decode6(entry.value);
          const version3 = pin.version || 0;
          const codec = pin.codec != null ? pin.codec : code;
          const multihash = keyToMultihash2(entry.key);
          yield {
            cid: CID.create(version3, codec, multihash),
            metadata: pin.metadata
          };
        }
      }
      async *recursiveKeys(options) {
        for await (const entry of this.pinstore.query({
          filters: [(entry2) => {
            const pin = decode6(entry2.value);
            return pin.depth === Infinity;
          }]
        })) {
          const pin = decode6(entry.value);
          const version3 = pin.version || 0;
          const codec = pin.codec != null ? pin.codec : code;
          const multihash = keyToMultihash2(entry.key);
          yield {
            cid: CID.create(version3, codec, multihash),
            metadata: pin.metadata
          };
        }
      }
      async *indirectKeys(options) {
        for await (const { cid } of this.recursiveKeys()) {
          for await (const childCid of walkDag(cid, this.blockstore, this.loadCodec, options)) {
            const types2 = [PinTypes.recursive];
            const result = await this.isPinnedWithType(childCid, types2);
            if (result.pinned) {
              continue;
            }
            yield childCid;
          }
        }
      }
      async isPinnedWithType(cid, types2, options) {
        if (!Array.isArray(types2)) {
          types2 = [types2];
        }
        const all6 = types2.includes(PinTypes.all);
        const direct = types2.includes(PinTypes.direct);
        const recursive2 = types2.includes(PinTypes.recursive);
        const indirect = types2.includes(PinTypes.indirect);
        if (recursive2 || direct || all6) {
          const result = await (0, import_it_first.default)(this.pinstore.query({
            prefix: cidToKey2(cid).toString(),
            filters: [(entry) => {
              if (all6) {
                return true;
              }
              const pin = decode6(entry.value);
              return types2.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);
            }],
            limit: 1
          }));
          if (result) {
            const pin = decode6(result.value);
            return {
              cid,
              pinned: true,
              reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,
              metadata: pin.metadata
            };
          }
        }
        const self2 = this;
        async function* findChild(key, source) {
          for await (const { cid: parentCid } of source) {
            for await (const childCid of walkDag(parentCid, self2.blockstore, self2.loadCodec)) {
              if (childCid.equals(key)) {
                yield parentCid;
                return;
              }
            }
          }
        }
        if (all6 || indirect) {
          const parentCid = await (0, import_it_first.default)(findChild(cid, this.recursiveKeys()));
          if (parentCid) {
            return {
              cid,
              pinned: true,
              reason: PinTypes.indirect,
              parent: parentCid
            };
          }
        }
        return {
          cid,
          pinned: false
        };
      }
      async fetchCompleteDag(cid, options) {
        const seen = new Set();
        const walkDag2 = async (cid2, options2) => {
          if (seen.has(cid2.toString())) {
            return;
          }
          seen.add(cid2.toString());
          const bytes3 = await this.blockstore.get(cid2, options2);
          const codec = await this.loadCodec(cid2.code);
          const block = createUnsafe({
            bytes: bytes3,
            cid: cid2,
            codec
          });
          await Promise.all([...block.links()].map(([, childCid]) => walkDag2(childCid, options2)));
        };
        await walkDag2(cid, options);
      }
      static checkPinType(type) {
        if (typeof type !== "string" || !Object.keys(PinTypes).includes(type)) {
          throw invalidPinTypeErr(type);
        }
        return true;
      }
    };
  }
});

// node_modules/ipfs-repo/esm/src/pinned-blockstore.js
function createPinnedBlockstore(pins, store) {
  return {
    open() {
      return store.open();
    },
    close() {
      return store.close();
    },
    query(query, options) {
      return store.query(query, options);
    },
    queryKeys(query, options) {
      return store.queryKeys(query, options);
    },
    async get(cid, options) {
      return store.get(cid, options);
    },
    async *getMany(cids, options) {
      yield* store.getMany(cids, options);
    },
    async put(cid, buf2, options) {
      await store.put(cid, buf2, options);
    },
    async *putMany(pairs, options) {
      yield* store.putMany(pairs, options);
    },
    has(cid, options) {
      return store.has(cid, options);
    },
    async delete(cid, options) {
      await ensureNotPinned(cid, pins);
      return store.delete(cid, options);
    },
    deleteMany(cids, options) {
      return store.deleteMany((0, import_it_map4.default)(cids, async (cid) => {
        await ensureNotPinned(cid, pins);
        return cid;
      }), options);
    },
    batch() {
      return store.batch();
    }
  };
}
async function ensureNotPinned(cid, pins) {
  const { pinned, reason } = await pins.isPinnedWithType(cid, PinTypes.all);
  if (pinned) {
    throw (0, import_err_code26.default)(new Error(`pinned: ${reason}`), "ERR_BLOCK_PINNED");
  }
}
var import_it_map4, import_err_code26;
var init_pinned_blockstore = __esm({
  "node_modules/ipfs-repo/esm/src/pinned-blockstore.js"() {
    init_node_globals();
    import_it_map4 = __toModule(require_it_map());
    import_err_code26 = __toModule(require_err_code());
    init_pin_types();
  }
});

// node_modules/ipfs-repo/esm/src/gc.js
function gc({ gcLock, pins, blockstore, root, loadCodec }) {
  async function* gc2() {
    const start = Date.now();
    log11("Creating set of marked blocks");
    const release = await gcLock.writeLock();
    try {
      const markedSet = await createMarkedSet({
        pins,
        blockstore,
        root,
        loadCodec
      });
      const blockKeys = blockstore.queryKeys({});
      yield* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys);
      log11(`Complete (${Date.now() - start}ms)`);
    } finally {
      release();
    }
  }
  return gc2;
}
async function createMarkedSet({ pins, blockstore, loadCodec, root }) {
  const mfsSource = async function* () {
    let mh2;
    try {
      mh2 = await root.get(MFS_ROOT_KEY2);
    } catch (err) {
      if (err.code === ERR_NOT_FOUND) {
        log11("No blocks in MFS");
        return;
      }
      throw err;
    }
    const rootCid = CID.decode(mh2);
    yield rootCid;
    yield* walkDag(rootCid, blockstore, loadCodec);
  }();
  const pinsSource = (0, import_it_merge2.default)((0, import_it_map5.default)(pins.recursiveKeys(), ({ cid }) => cid), pins.indirectKeys(), (0, import_it_map5.default)(pins.directKeys(), ({ cid }) => cid), mfsSource);
  const output = new Set();
  for await (const cid of (0, import_it_merge2.default)(pinsSource, mfsSource)) {
    output.add(base32.encode(cid.multihash.bytes));
  }
  return output;
}
async function* deleteUnmarkedBlocks({ blockstore }, markedSet, blockKeys) {
  let blocksCount = 0;
  let removedBlocksCount = 0;
  const removeBlock = async (cid) => {
    return async function remove() {
      blocksCount++;
      try {
        const b32 = base32.encode(cid.multihash.bytes);
        if (markedSet.has(b32)) {
          return null;
        }
        try {
          await blockstore.delete(cid);
          removedBlocksCount++;
        } catch (err) {
          return { err: new Error(`Could not delete block with CID ${cid}: ${err.message}`) };
        }
        return { cid };
      } catch (err) {
        const msg = `Could delete block with CID ${cid}`;
        log11(msg, err);
        return { err: new Error(msg + `: ${err.message}`) };
      }
    };
  };
  yield* (0, import_it_pipe2.pipe)((0, import_it_parallel_batch3.default)((0, import_it_map5.default)(blockKeys, removeBlock), BLOCK_RM_CONCURRENCY), (source) => (0, import_it_filter4.default)(source, Boolean));
  log11(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. Deleted ${removedBlocksCount} blocks.`);
}
var import_debug12, import_it_parallel_batch3, import_it_pipe2, import_it_merge2, import_it_map5, import_it_filter4, log11, ERR_NOT_FOUND, BLOCK_RM_CONCURRENCY, MFS_ROOT_KEY2;
var init_gc = __esm({
  "node_modules/ipfs-repo/esm/src/gc.js"() {
    init_node_globals();
    init_cid();
    import_debug12 = __toModule(require_browser2());
    init_errors2();
    import_it_parallel_batch3 = __toModule(require_it_parallel_batch());
    import_it_pipe2 = __toModule(require_it_pipe());
    import_it_merge2 = __toModule(require_it_merge());
    import_it_map5 = __toModule(require_it_map());
    import_it_filter4 = __toModule(require_it_filter());
    init_key();
    init_base32();
    init_walk_dag();
    log11 = (0, import_debug12.default)("ipfs:repo:gc");
    ERR_NOT_FOUND = notFoundError().code;
    BLOCK_RM_CONCURRENCY = 256;
    MFS_ROOT_KEY2 = new Key("/local/filesroot");
  }
});

// node_modules/ipfs-repo/esm/src/index.js
async function getSize(datastore) {
  let sum = BigInt(0);
  for await (const block of datastore.query({})) {
    sum += BigInt(block.value.byteLength);
    sum += BigInt(block.key.uint8Array().byteLength);
  }
  return sum;
}
function createRepo(path, loadCodec, backends, options) {
  return new Repo(path, loadCodec, backends, options);
}
function buildConfig(_config) {
  _config.Datastore = Object.assign({}, default_datastore_default, (0, import_just_safe_get2.default)(_config, "datastore"));
  return _config;
}
function buildDatastoreSpec(_config) {
  const spec2 = {
    ...default_datastore_default.Spec,
    ...(0, import_just_safe_get2.default)(_config, "Datastore.Spec")
  };
  return {
    type: spec2.type,
    mounts: spec2.mounts.map((mounting) => ({
      mountpoint: mounting.mountpoint,
      type: mounting.child.type,
      path: mounting.child.path,
      shardFunc: mounting.child.shardFunc
    }))
  };
}
var import_just_safe_get2, import_debug13, import_err_code27, import_bytes9, import_mortice, log12, noLimit, AUTO_MIGRATE_CONFIG_KEY, Repo;
var init_src11 = __esm({
  "node_modules/ipfs-repo/esm/src/index.js"() {
    init_node_globals();
    import_just_safe_get2 = __toModule(require_just_safe_get());
    import_debug13 = __toModule(require_browser2());
    import_err_code27 = __toModule(require_err_code());
    init_src10();
    import_bytes9 = __toModule(require_bytes());
    init_merge_options();
    init_constants();
    init_version2();
    init_config();
    init_spec();
    init_api_addr();
    init_idstore();
    init_default_options();
    init_default_datastore();
    init_errors5();
    init_pin_manager();
    init_pinned_blockstore();
    import_mortice = __toModule(require_lib3());
    init_gc();
    log12 = (0, import_debug13.default)("ipfs:repo");
    noLimit = Number.MAX_SAFE_INTEGER;
    AUTO_MIGRATE_CONFIG_KEY = "repoAutoMigrate";
    Repo = class {
      constructor(path, loadCodec, backends, options) {
        if (typeof path !== "string") {
          throw new Error("missing repo path");
        }
        if (typeof loadCodec !== "function") {
          throw new Error("missing codec loader");
        }
        this.options = merge_options_default(default_options_default, options);
        this.closed = true;
        this.path = path;
        this.root = backends.root;
        this.datastore = backends.datastore;
        this.keys = backends.keys;
        const blockstore = backends.blocks;
        const pinstore = backends.pins;
        this.pins = new PinManager({
          pinstore,
          blockstore,
          loadCodec
        });
        const pinnedBlockstore = createPinnedBlockstore(this.pins, blockstore);
        this.blocks = createIdStore(pinnedBlockstore);
        this.version = version2(this.root);
        this.config = config(this.root);
        this.spec = spec(this.root);
        this.apiAddr = apiAddr(this.root);
        this.gcLock = (0, import_mortice.default)(path, { singleProcess: this.options.repoOwner !== false });
        this.gc = gc({
          gcLock: this.gcLock,
          pins: this.pins,
          blockstore: this.blocks,
          root: this.root,
          loadCodec
        });
      }
      async init(config2) {
        log12("initializing at: %s", this.path);
        await this._openRoot();
        await this.config.replace(buildConfig(config2));
        await this.spec.set(buildDatastoreSpec(config2));
        await this.version.set(repoVersion);
      }
      async isInitialized() {
        if (!this.closed) {
          return true;
        }
        try {
          await this._openRoot();
          await this._checkInitialized();
          await this.root.close();
          return true;
        } catch (err) {
          return false;
        }
      }
      async open() {
        if (!this.closed) {
          throw (0, import_err_code27.default)(new Error("repo is already open"), ERR_REPO_ALREADY_OPEN);
        }
        log12("opening at: %s", this.path);
        try {
          await this._openRoot();
          await this._checkInitialized();
          this._lockfile = await this._openLock();
          log12("acquired repo.lock");
          const isCompatible = await this.version.check(repoVersion);
          if (!isCompatible) {
            if (await this._isAutoMigrationEnabled()) {
              await this._migrate(repoVersion, {
                root: this.root,
                datastore: this.datastore,
                pins: this.pins.pinstore,
                blocks: this.pins.blockstore,
                keys: this.keys
              });
            } else {
              throw new InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
            }
          }
          log12("creating datastore");
          await this.datastore.open();
          log12("creating blocks");
          this.blocks.open();
          log12("creating keystore");
          await this.keys.open();
          log12("creating pins");
          await this.pins.pinstore.open();
          this.closed = false;
          log12("all opened");
        } catch (err) {
          if (this._lockfile) {
            try {
              await this._closeLock();
              this._lockfile = null;
            } catch (err2) {
              log12("error removing lock", err2);
            }
          }
          throw err;
        }
      }
      async _openRoot() {
        try {
          await this.root.open();
        } catch (err) {
          if (err.message !== "Already open") {
            throw err;
          }
        }
      }
      async _openLock() {
        const lockfile = await this.options.repoLock.lock(this.path);
        if (typeof lockfile.close !== "function") {
          throw (0, import_err_code27.default)(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
        }
        return lockfile;
      }
      _closeLock() {
        return this._lockfile && this._lockfile.close();
      }
      async _checkInitialized() {
        log12("init check");
        let config2;
        try {
          [config2] = await Promise.all([
            this.config.exists(),
            this.spec.exists(),
            this.version.exists()
          ]);
        } catch (err) {
          if (err.code === "ERR_NOT_FOUND") {
            throw (0, import_err_code27.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, { path: this.path });
          }
          throw err;
        }
        if (!config2) {
          throw (0, import_err_code27.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, { path: this.path });
        }
      }
      async close() {
        if (this.closed) {
          throw (0, import_err_code27.default)(new Error("repo is already closed"), ERR_REPO_ALREADY_CLOSED);
        }
        log12("closing at: %s", this.path);
        try {
          await this.apiAddr.delete();
        } catch (err) {
          if (err.code !== ERR_REPO_NOT_INITIALIZED && !err.message.startsWith("ENOENT")) {
            throw err;
          }
        }
        await Promise.all([
          this.root,
          this.blocks,
          this.keys,
          this.datastore,
          this.pins.pinstore
        ].map((store) => store && store.close()));
        log12("unlocking");
        this.closed = true;
        await this._closeLock();
      }
      exists() {
        return this.version.exists();
      }
      async stat() {
        if (this.datastore && this.keys) {
          const [storageMax, blocks, version3, datastore, keys] = await Promise.all([
            this._storageMaxStat(),
            this._blockStat(),
            this.version.get(),
            getSize(this.datastore),
            getSize(this.keys)
          ]);
          const size = blocks.size + datastore + keys;
          return {
            repoPath: this.path,
            storageMax,
            version: version3,
            numObjects: blocks.count,
            repoSize: size
          };
        }
        throw (0, import_err_code27.default)(new Error("repo is not initialized yet"), ERR_REPO_NOT_INITIALIZED, { path: this.path });
      }
      async _isAutoMigrationEnabled() {
        if (this.options.autoMigrate !== void 0) {
          return this.options.autoMigrate;
        }
        let autoMigrateConfig;
        try {
          autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);
        } catch (e) {
          if (e.code === NotFoundError.code) {
            autoMigrateConfig = true;
          } else {
            throw e;
          }
        }
        return autoMigrateConfig;
      }
      async _migrate(toVersion, backends) {
        const currentRepoVersion = await this.version.get();
        if (currentRepoVersion > toVersion) {
          log12(`reverting to version ${toVersion}`);
          return revert(this.path, backends, this.options, toVersion, {
            ignoreLock: true,
            onProgress: this.options.onMigrationProgress
          });
        } else {
          log12(`migrating to version ${toVersion}`);
          return migrate(this.path, backends, this.options, toVersion, {
            ignoreLock: true,
            onProgress: this.options.onMigrationProgress
          });
        }
      }
      async _storageMaxStat() {
        try {
          const max = await this.config.get("Datastore.StorageMax");
          return BigInt((0, import_bytes9.default)(max));
        } catch (err) {
          return BigInt(noLimit);
        }
      }
      async _blockStat() {
        let count = BigInt(0);
        let size = BigInt(0);
        if (this.blocks) {
          for await (const { key, value } of this.blocks.query({})) {
            count += BigInt(1);
            size += BigInt(value.byteLength);
            size += BigInt(key.bytes.byteLength);
          }
        }
        return {
          count,
          size
        };
      }
    };
  }
});

// node_modules/it-sort/index.js
var require_it_sort = __commonJS({
  "node_modules/it-sort/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var all6 = require_it_all();
    var sort2 = async function* (source, sorter) {
      const arr = await all6(source);
      yield* arr.sort(sorter);
    };
    module2.exports = sort2;
  }
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "node_modules/has-symbols/shams.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/has-tostringtag/shams.js
var require_shams2 = __commonJS({
  "node_modules/has-tostringtag/shams.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var hasSymbols = require_shams();
    module2.exports = function hasToStringTagShams() {
      return hasSymbols() && !!Symbol.toStringTag;
    };
  }
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "node_modules/has-symbols/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var slice2 = Array.prototype.slice;
    var toStr = Object.prototype.toString;
    var funcType = "[object Function]";
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.call(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slice2.call(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(this, args.concat(slice2.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          return target.apply(that, args.concat(slice2.call(arguments)));
        }
      };
      var boundLength = Math.max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs.push("$" + i);
      }
      bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/has/src/index.js
var require_src11 = __commonJS({
  "node_modules/has/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var bind = require_function_bind();
    module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
  }
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "node_modules/get-intrinsic/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var undefined2;
    var $SyntaxError = SyntaxError;
    var $Function = Function;
    var $TypeError = TypeError;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var getProto = Object.getPrototypeOf || function(x) {
      return x.__proto__;
    };
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": Error,
      "%eval%": eval,
      "%EvalError%": EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto(new Map()[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": RangeError,
      "%ReferenceError%": ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto(new Set()[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    var doEval = function doEval2(name5) {
      var value;
      if (name5 === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name5 === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name5 === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name5 === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name5 === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name5] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_src11();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string3) {
      var first3 = $strSlice(string3, 0, 1);
      var last6 = $strSlice(string3, -1);
      if (first3 === "%" && last6 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last6 === "%" && first3 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result = [];
      $replace(string3, rePropName, function(match, number, quote, subString) {
        result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name5, allowMissing) {
      var intrinsicName = name5;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name5 + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name5 + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name5, allowMissing) {
      if (typeof name5 !== "string" || name5.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      var parts = stringToPath(name5);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first3 = $strSlice(part, 0, 1);
        var last6 = $strSlice(part, -1);
        if ((first3 === '"' || first3 === "'" || first3 === "`" || (last6 === '"' || last6 === "'" || last6 === "`")) && first3 !== last6) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name5 + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "node_modules/call-bind/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
    var $max = GetIntrinsic("%Math.max%");
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = null;
      }
    }
    module2.exports = function callBind(originalFunction) {
      var func = $reflectApply(bind, $call, arguments);
      if ($gOPD && $defineProperty) {
        var desc = $gOPD(func, "length");
        if (desc.configurable) {
          $defineProperty(func, "length", { value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) });
        }
      }
      return func;
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "node_modules/call-bind/callBound.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name5, allowMissing) {
      var intrinsic = GetIntrinsic(name5, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name5, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS({
  "node_modules/is-arguments/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var hasToStringTag = require_shams2()();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var isStandardArguments = function isArguments(value) {
      if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
        return false;
      }
      return $toString(value) === "[object Arguments]";
    };
    var isLegacyArguments = function isArguments(value) {
      if (isStandardArguments(value)) {
        return true;
      }
      return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
    };
    var supportsStandardArguments = function() {
      return isStandardArguments(arguments);
    }();
    isStandardArguments.isLegacyArguments = isLegacyArguments;
    module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
  }
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS({
  "node_modules/is-generator-function/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var toStr = Object.prototype.toString;
    var fnToStr = Function.prototype.toString;
    var isFnRegex = /^\s*(?:function)?\*/;
    var hasToStringTag = require_shams2()();
    var getProto = Object.getPrototypeOf;
    var getGeneratorFunc = function() {
      if (!hasToStringTag) {
        return false;
      }
      try {
        return Function("return function*() {}")();
      } catch (e) {
      }
    };
    var GeneratorFunction;
    module2.exports = function isGeneratorFunction(fn) {
      if (typeof fn !== "function") {
        return false;
      }
      if (isFnRegex.test(fnToStr.call(fn))) {
        return true;
      }
      if (!hasToStringTag) {
        var str = toStr.call(fn);
        return str === "[object GeneratorFunction]";
      }
      if (!getProto) {
        return false;
      }
      if (typeof GeneratorFunction === "undefined") {
        var generatorFunc = getGeneratorFunc();
        GeneratorFunction = generatorFunc ? getProto(generatorFunc) : false;
      }
      return getProto(fn) === GeneratorFunction;
    };
  }
});

// node_modules/foreach/index.js
var require_foreach = __commonJS({
  "node_modules/foreach/index.js"(exports2, module2) {
    init_node_globals();
    var hasOwn = Object.prototype.hasOwnProperty;
    var toString4 = Object.prototype.toString;
    module2.exports = function forEach(obj, fn, ctx) {
      if (toString4.call(fn) !== "[object Function]") {
        throw new TypeError("iterator must be a function");
      }
      var l = obj.length;
      if (l === +l) {
        for (var i = 0; i < l; i++) {
          fn.call(ctx, obj[i], i, obj);
        }
      } else {
        for (var k in obj) {
          if (hasOwn.call(obj, k)) {
            fn.call(ctx, obj[k], k, obj);
          }
        }
      }
    };
  }
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS({
  "node_modules/available-typed-arrays/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var possibleNames = [
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ];
    var g = typeof globalThis === "undefined" ? global : globalThis;
    module2.exports = function availableTypedArrays() {
      var out = [];
      for (var i = 0; i < possibleNames.length; i++) {
        if (typeof g[possibleNames[i]] === "function") {
          out[out.length] = possibleNames[i];
        }
      }
      return out;
    };
  }
});

// node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
var require_getOwnPropertyDescriptor = __commonJS({
  "node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS({
  "node_modules/is-typed-array/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var forEach = require_foreach();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array2, value) {
      for (var i = 0; i < array2.length; i += 1) {
        if (array2[i] === value) {
          return i;
        }
      }
      return -1;
    };
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var gOPD = require_getOwnPropertyDescriptor();
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        var arr = new g[typedArray]();
        if (Symbol.toStringTag in arr) {
          var proto = getPrototypeOf(arr);
          var descriptor = gOPD(proto, Symbol.toStringTag);
          if (!descriptor) {
            var superProto = getPrototypeOf(proto);
            descriptor = gOPD(superProto, Symbol.toStringTag);
          }
          toStrTags[typedArray] = descriptor.get;
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var anyTrue = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!anyTrue) {
          try {
            anyTrue = getter.call(value) === typedArray;
          } catch (e) {
          }
        }
      });
      return anyTrue;
    };
    module2.exports = function isTypedArray(value) {
      if (!value || typeof value !== "object") {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        var tag2 = $slice($toString(value), 8, -1);
        return $indexOf(typedArrays, tag2) > -1;
      }
      if (!gOPD) {
        return false;
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS({
  "node_modules/which-typed-array/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var forEach = require_foreach();
    var availableTypedArrays = require_available_typed_arrays();
    var callBound = require_callBound();
    var $toString = callBound("Object.prototype.toString");
    var hasToStringTag = require_shams2()();
    var g = typeof globalThis === "undefined" ? global : globalThis;
    var typedArrays = availableTypedArrays();
    var $slice = callBound("String.prototype.slice");
    var toStrTags = {};
    var gOPD = require_getOwnPropertyDescriptor();
    var getPrototypeOf = Object.getPrototypeOf;
    if (hasToStringTag && gOPD && getPrototypeOf) {
      forEach(typedArrays, function(typedArray) {
        if (typeof g[typedArray] === "function") {
          var arr = new g[typedArray]();
          if (Symbol.toStringTag in arr) {
            var proto = getPrototypeOf(arr);
            var descriptor = gOPD(proto, Symbol.toStringTag);
            if (!descriptor) {
              var superProto = getPrototypeOf(proto);
              descriptor = gOPD(superProto, Symbol.toStringTag);
            }
            toStrTags[typedArray] = descriptor.get;
          }
        }
      });
    }
    var tryTypedArrays = function tryAllTypedArrays(value) {
      var foundName = false;
      forEach(toStrTags, function(getter, typedArray) {
        if (!foundName) {
          try {
            var name5 = getter.call(value);
            if (name5 === typedArray) {
              foundName = name5;
            }
          } catch (e) {
          }
        }
      });
      return foundName;
    };
    var isTypedArray = require_is_typed_array();
    module2.exports = function whichTypedArray(value) {
      if (!isTypedArray(value)) {
        return false;
      }
      if (!hasToStringTag || !(Symbol.toStringTag in value)) {
        return $slice($toString(value), 8, -1);
      }
      return tryTypedArrays(value);
    };
  }
});

// node_modules/util/support/types.js
var require_types = __commonJS({
  "node_modules/util/support/types.js"(exports2) {
    init_node_globals();
    "use strict";
    var isArgumentsObject = require_is_arguments();
    var isGeneratorFunction = require_is_generator_function();
    var whichTypedArray = require_which_typed_array();
    var isTypedArray = require_is_typed_array();
    function uncurryThis(f) {
      return f.call.bind(f);
    }
    var BigIntSupported = typeof BigInt !== "undefined";
    var SymbolSupported = typeof Symbol !== "undefined";
    var ObjectToString = uncurryThis(Object.prototype.toString);
    var numberValue = uncurryThis(Number.prototype.valueOf);
    var stringValue = uncurryThis(String.prototype.valueOf);
    var booleanValue = uncurryThis(Boolean.prototype.valueOf);
    if (BigIntSupported) {
      bigIntValue = uncurryThis(BigInt.prototype.valueOf);
    }
    var bigIntValue;
    if (SymbolSupported) {
      symbolValue = uncurryThis(Symbol.prototype.valueOf);
    }
    var symbolValue;
    function checkBoxedPrimitive(value, prototypeValueOf) {
      if (typeof value !== "object") {
        return false;
      }
      try {
        prototypeValueOf(value);
        return true;
      } catch (e) {
        return false;
      }
    }
    exports2.isArgumentsObject = isArgumentsObject;
    exports2.isGeneratorFunction = isGeneratorFunction;
    exports2.isTypedArray = isTypedArray;
    function isPromise(input) {
      return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
    }
    exports2.isPromise = isPromise;
    function isArrayBufferView(value) {
      if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
        return ArrayBuffer.isView(value);
      }
      return isTypedArray(value) || isDataView(value);
    }
    exports2.isArrayBufferView = isArrayBufferView;
    function isUint8Array(value) {
      return whichTypedArray(value) === "Uint8Array";
    }
    exports2.isUint8Array = isUint8Array;
    function isUint8ClampedArray(value) {
      return whichTypedArray(value) === "Uint8ClampedArray";
    }
    exports2.isUint8ClampedArray = isUint8ClampedArray;
    function isUint16Array(value) {
      return whichTypedArray(value) === "Uint16Array";
    }
    exports2.isUint16Array = isUint16Array;
    function isUint32Array(value) {
      return whichTypedArray(value) === "Uint32Array";
    }
    exports2.isUint32Array = isUint32Array;
    function isInt8Array(value) {
      return whichTypedArray(value) === "Int8Array";
    }
    exports2.isInt8Array = isInt8Array;
    function isInt16Array(value) {
      return whichTypedArray(value) === "Int16Array";
    }
    exports2.isInt16Array = isInt16Array;
    function isInt32Array(value) {
      return whichTypedArray(value) === "Int32Array";
    }
    exports2.isInt32Array = isInt32Array;
    function isFloat32Array(value) {
      return whichTypedArray(value) === "Float32Array";
    }
    exports2.isFloat32Array = isFloat32Array;
    function isFloat64Array(value) {
      return whichTypedArray(value) === "Float64Array";
    }
    exports2.isFloat64Array = isFloat64Array;
    function isBigInt64Array(value) {
      return whichTypedArray(value) === "BigInt64Array";
    }
    exports2.isBigInt64Array = isBigInt64Array;
    function isBigUint64Array(value) {
      return whichTypedArray(value) === "BigUint64Array";
    }
    exports2.isBigUint64Array = isBigUint64Array;
    function isMapToString(value) {
      return ObjectToString(value) === "[object Map]";
    }
    isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map());
    function isMap(value) {
      if (typeof Map === "undefined") {
        return false;
      }
      return isMapToString.working ? isMapToString(value) : value instanceof Map;
    }
    exports2.isMap = isMap;
    function isSetToString(value) {
      return ObjectToString(value) === "[object Set]";
    }
    isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set());
    function isSet(value) {
      if (typeof Set === "undefined") {
        return false;
      }
      return isSetToString.working ? isSetToString(value) : value instanceof Set;
    }
    exports2.isSet = isSet;
    function isWeakMapToString(value) {
      return ObjectToString(value) === "[object WeakMap]";
    }
    isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
    function isWeakMap(value) {
      if (typeof WeakMap === "undefined") {
        return false;
      }
      return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
    }
    exports2.isWeakMap = isWeakMap;
    function isWeakSetToString(value) {
      return ObjectToString(value) === "[object WeakSet]";
    }
    isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
    function isWeakSet(value) {
      return isWeakSetToString(value);
    }
    exports2.isWeakSet = isWeakSet;
    function isArrayBufferToString(value) {
      return ObjectToString(value) === "[object ArrayBuffer]";
    }
    isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
    function isArrayBuffer(value) {
      if (typeof ArrayBuffer === "undefined") {
        return false;
      }
      return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
    }
    exports2.isArrayBuffer = isArrayBuffer;
    function isDataViewToString(value) {
      return ObjectToString(value) === "[object DataView]";
    }
    isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
    function isDataView(value) {
      if (typeof DataView === "undefined") {
        return false;
      }
      return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
    }
    exports2.isDataView = isDataView;
    var SharedArrayBufferCopy = typeof SharedArrayBuffer !== "undefined" ? SharedArrayBuffer : void 0;
    function isSharedArrayBufferToString(value) {
      return ObjectToString(value) === "[object SharedArrayBuffer]";
    }
    function isSharedArrayBuffer(value) {
      if (typeof SharedArrayBufferCopy === "undefined") {
        return false;
      }
      if (typeof isSharedArrayBufferToString.working === "undefined") {
        isSharedArrayBufferToString.working = isSharedArrayBufferToString(new SharedArrayBufferCopy());
      }
      return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBufferCopy;
    }
    exports2.isSharedArrayBuffer = isSharedArrayBuffer;
    function isAsyncFunction(value) {
      return ObjectToString(value) === "[object AsyncFunction]";
    }
    exports2.isAsyncFunction = isAsyncFunction;
    function isMapIterator(value) {
      return ObjectToString(value) === "[object Map Iterator]";
    }
    exports2.isMapIterator = isMapIterator;
    function isSetIterator(value) {
      return ObjectToString(value) === "[object Set Iterator]";
    }
    exports2.isSetIterator = isSetIterator;
    function isGeneratorObject(value) {
      return ObjectToString(value) === "[object Generator]";
    }
    exports2.isGeneratorObject = isGeneratorObject;
    function isWebAssemblyCompiledModule(value) {
      return ObjectToString(value) === "[object WebAssembly.Module]";
    }
    exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
    function isNumberObject(value) {
      return checkBoxedPrimitive(value, numberValue);
    }
    exports2.isNumberObject = isNumberObject;
    function isStringObject(value) {
      return checkBoxedPrimitive(value, stringValue);
    }
    exports2.isStringObject = isStringObject;
    function isBooleanObject(value) {
      return checkBoxedPrimitive(value, booleanValue);
    }
    exports2.isBooleanObject = isBooleanObject;
    function isBigIntObject(value) {
      return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
    }
    exports2.isBigIntObject = isBigIntObject;
    function isSymbolObject(value) {
      return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
    }
    exports2.isSymbolObject = isSymbolObject;
    function isBoxedPrimitive(value) {
      return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
    }
    exports2.isBoxedPrimitive = isBoxedPrimitive;
    function isAnyArrayBuffer(value) {
      return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
    }
    exports2.isAnyArrayBuffer = isAnyArrayBuffer;
    ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
      Object.defineProperty(exports2, method, {
        enumerable: false,
        value: function() {
          throw new Error(method + " is not supported in userland");
        }
      });
    });
  }
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS({
  "node_modules/util/support/isBufferBrowser.js"(exports2, module2) {
    init_node_globals();
    module2.exports = function isBuffer3(arg) {
      return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
    };
  }
});

// node_modules/util/util.js
var require_util3 = __commonJS({
  "node_modules/util/util.js"(exports2) {
    init_node_globals();
    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
      var keys = Object.keys(obj);
      var descriptors = {};
      for (var i = 0; i < keys.length; i++) {
        descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
      }
      return descriptors;
    };
    var formatRegExp = /%[sdj%]/g;
    exports2.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(" ");
      }
      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x2) {
        if (x2 === "%%")
          return "%";
        if (i >= len)
          return x2;
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return "[Circular]";
            }
          default:
            return x2;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += " " + x;
        } else {
          str += " " + inspect(x);
        }
      }
      return str;
    };
    exports2.deprecate = function(fn, msg) {
      if (typeof process !== "undefined" && process.noDeprecation === true) {
        return fn;
      }
      if (typeof process === "undefined") {
        return function() {
          return exports2.deprecate(fn, msg).apply(this, arguments);
        };
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    };
    var debugs = {};
    var debugEnvRegex = /^$/;
    if (process.env.NODE_DEBUG) {
      debugEnv = process.env.NODE_DEBUG;
      debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
      debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
    }
    var debugEnv;
    exports2.debuglog = function(set) {
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (debugEnvRegex.test(set)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports2.format.apply(exports2, arguments);
            console.error("%s %d: %s", set, pid, msg);
          };
        } else {
          debugs[set] = function() {
          };
        }
      }
      return debugs[set];
    };
    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      if (arguments.length >= 3)
        ctx.depth = arguments[2];
      if (arguments.length >= 4)
        ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        ctx.showHidden = opts;
      } else if (opts) {
        exports2._extend(ctx, opts);
      }
      if (isUndefined(ctx.showHidden))
        ctx.showHidden = false;
      if (isUndefined(ctx.depth))
        ctx.depth = 2;
      if (isUndefined(ctx.colors))
        ctx.colors = false;
      if (isUndefined(ctx.customInspect))
        ctx.customInspect = true;
      if (ctx.colors)
        ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports2.inspect = inspect;
    inspect.colors = {
      "bold": [1, 22],
      "italic": [3, 23],
      "underline": [4, 24],
      "inverse": [7, 27],
      "white": [37, 39],
      "grey": [90, 39],
      "black": [30, 39],
      "blue": [34, 39],
      "cyan": [36, 39],
      "green": [32, 39],
      "magenta": [35, 39],
      "red": [31, 39],
      "yellow": [33, 39]
    };
    inspect.styles = {
      "special": "cyan",
      "number": "yellow",
      "boolean": "yellow",
      "undefined": "grey",
      "null": "bold",
      "string": "green",
      "date": "magenta",
      "regexp": "red"
    };
    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];
      if (style) {
        return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
      } else {
        return str;
      }
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array2) {
      var hash2 = {};
      array2.forEach(function(val, idx) {
        hash2[val] = true;
      });
      return hash2;
    }
    function formatValue(ctx, value, recurseTimes) {
      if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports2.inspect && !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);
      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }
      if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
        return formatError(value);
      }
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name5 = value.name ? ": " + value.name : "";
          return ctx.stylize("[Function" + name5 + "]", "special");
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), "date");
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base3 = "", array2 = false, braces = ["{", "}"];
      if (isArray(value)) {
        array2 = true;
        braces = ["[", "]"];
      }
      if (isFunction(value)) {
        var n = value.name ? ": " + value.name : "";
        base3 = " [Function" + n + "]";
      }
      if (isRegExp(value)) {
        base3 = " " + RegExp.prototype.toString.call(value);
      }
      if (isDate(value)) {
        base3 = " " + Date.prototype.toUTCString.call(value);
      }
      if (isError(value)) {
        base3 = " " + formatError(value);
      }
      if (keys.length === 0 && (!array2 || value.length == 0)) {
        return braces[0] + base3 + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
        } else {
          return ctx.stylize("[Object]", "special");
        }
      }
      ctx.seen.push(value);
      var output;
      if (array2) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base3, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize("undefined", "undefined");
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, "string");
      }
      if (isNumber(value))
        return ctx.stylize("" + value, "number");
      if (isBoolean(value))
        return ctx.stylize("" + value, "boolean");
      if (isNull(value))
        return ctx.stylize("null", "null");
    }
    function formatError(value) {
      return "[" + Error.prototype.toString.call(value) + "]";
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push("");
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array2) {
      var name5, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize("[Getter/Setter]", "special");
        } else {
          str = ctx.stylize("[Getter]", "special");
        }
      } else {
        if (desc.set) {
          str = ctx.stylize("[Setter]", "special");
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name5 = "[" + key + "]";
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf("\n") > -1) {
            if (array2) {
              str = str.split("\n").map(function(line) {
                return "  " + line;
              }).join("\n").substr(2);
            } else {
              str = "\n" + str.split("\n").map(function(line) {
                return "   " + line;
              }).join("\n");
            }
          }
        } else {
          str = ctx.stylize("[Circular]", "special");
        }
      }
      if (isUndefined(name5)) {
        if (array2 && key.match(/^\d+$/)) {
          return str;
        }
        name5 = JSON.stringify("" + key);
        if (name5.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name5 = name5.substr(1, name5.length - 2);
          name5 = ctx.stylize(name5, "name");
        } else {
          name5 = name5.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name5 = ctx.stylize(name5, "string");
        }
      }
      return name5 + ": " + str;
    }
    function reduceToSingleString(output, base3, braces) {
      var numLinesEst = 0;
      var length4 = output.reduce(function(prev, cur) {
        numLinesEst++;
        if (cur.indexOf("\n") >= 0)
          numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      if (length4 > 60) {
        return braces[0] + (base3 === "" ? "" : base3 + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
      }
      return braces[0] + base3 + " " + output.join(", ") + " " + braces[1];
    }
    exports2.types = require_types();
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports2.isArray = isArray;
    function isBoolean(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean;
    function isNull(arg) {
      return arg === null;
    }
    exports2.isNull = isNull;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined;
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    exports2.types.isRegExp = isRegExp;
    function isObject(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject;
    function isDate(d) {
      return isObject(d) && objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    exports2.types.isDate = isDate;
    function isError(e) {
      return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
    }
    exports2.isError = isError;
    exports2.types.isNativeError = isError;
    function isFunction(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require_isBufferBrowser();
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function pad(n) {
      return n < 10 ? "0" + n.toString(10) : n.toString(10);
    }
    var months = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function timestamp() {
      var d = new Date();
      var time = [
        pad(d.getHours()),
        pad(d.getMinutes()),
        pad(d.getSeconds())
      ].join(":");
      return [d.getDate(), months[d.getMonth()], time].join(" ");
    }
    exports2.log = function() {
      console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
    };
    exports2.inherits = require_inherits_browser();
    exports2._extend = function(origin, add) {
      if (!add || !isObject(add))
        return origin;
      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
    exports2.promisify = function promisify(original) {
      if (typeof original !== "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== "function") {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
        return fn;
      }
      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function(resolve6, reject) {
          promiseResolve = resolve6;
          promiseReject = reject;
        });
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function(err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });
        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }
        return promise;
      }
      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
      if (kCustomPromisifiedSymbol)
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn,
          enumerable: false,
          writable: false,
          configurable: true
        });
      return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
    };
    exports2.promisify.custom = kCustomPromisifiedSymbol;
    function callbackifyOnRejected(reason, cb) {
      if (!reason) {
        var newReason = new Error("Promise was rejected with a falsy value");
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }
    function callbackify(original) {
      if (typeof original !== "function") {
        throw new TypeError('The "original" argument must be of type Function');
      }
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        var maybeCb = args.pop();
        if (typeof maybeCb !== "function") {
          throw new TypeError("The last argument must be of type Function");
        }
        var self2 = this;
        var cb = function() {
          return maybeCb.apply(self2, arguments);
        };
        original.apply(this, args).then(function(ret) {
          process.nextTick(cb.bind(null, null, ret));
        }, function(rej) {
          process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
        });
      }
      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
      return callbackified;
    }
    exports2.callbackify = callbackify;
  }
});

// node_modules/level-supports/index.js
var require_level_supports = __commonJS({
  "node_modules/level-supports/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = function supports(...manifests) {
      const manifest = manifests.reduce((acc, m) => Object.assign(acc, m), {});
      return Object.assign(manifest, {
        bufferKeys: manifest.bufferKeys || false,
        snapshots: manifest.snapshots || false,
        permanence: manifest.permanence || false,
        seek: manifest.seek || false,
        clear: manifest.clear || false,
        getMany: manifest.getMany || false,
        keyIterator: manifest.keyIterator || false,
        valueIterator: manifest.valueIterator || false,
        iteratorNextv: manifest.iteratorNextv || false,
        iteratorAll: manifest.iteratorAll || false,
        status: manifest.status || false,
        idempotentOpen: manifest.idempotentOpen || false,
        passiveOpen: manifest.passiveOpen || false,
        serialize: manifest.serialize || false,
        createIfMissing: manifest.createIfMissing || false,
        errorIfExists: manifest.errorIfExists || false,
        deferredOpen: manifest.deferredOpen || false,
        openCallback: manifest.openCallback || false,
        promises: manifest.promises || false,
        streams: manifest.streams || false,
        encodings: manifest.encodings || false,
        events: maybeObject(manifest.events),
        additionalMethods: Object.assign({}, manifest.additionalMethods)
      });
    };
    function maybeObject(value) {
      return !value ? false : Object.assign({}, value);
    }
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = function isBuffer3(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// node_modules/queue-tick/queue-microtask.js
var require_queue_microtask = __commonJS({
  "node_modules/queue-tick/queue-microtask.js"(exports2, module2) {
    init_node_globals();
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask : (fn) => Promise.resolve().then(fn);
  }
});

// node_modules/catering/index.js
var require_catering = __commonJS({
  "node_modules/catering/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var queueTick = require_queue_microtask();
    exports2.fromCallback = function(callback, symbol) {
      if (callback === void 0) {
        var promise = new Promise(function(resolve6, reject) {
          callback = function(err, res) {
            if (err)
              reject(err);
            else
              resolve6(res);
          };
        });
        callback[symbol !== void 0 ? symbol : "promise"] = promise;
      } else if (typeof callback !== "function") {
        throw new TypeError("Callback must be a function");
      }
      return callback;
    };
    exports2.fromPromise = function(promise, callback) {
      if (callback === void 0)
        return promise;
      promise.then(function(res) {
        queueTick(() => callback(null, res));
      }).catch(function(err) {
        queueTick(() => callback(err));
      });
    };
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask2 = __commonJS({
  "node_modules/queue-microtask/index.js"(exports2, module2) {
    init_node_globals();
    var promise;
    module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(typeof window !== "undefined" ? window : global) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
      throw err;
    }, 0));
  }
});

// node_modules/abstract-leveldown/next-tick-browser.js
var require_next_tick_browser = __commonJS({
  "node_modules/abstract-leveldown/next-tick-browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var queueMicrotask2 = require_queue_microtask2();
    module2.exports = function(fn, ...args) {
      if (args.length === 0) {
        queueMicrotask2(fn);
      } else {
        queueMicrotask2(() => fn(...args));
      }
    };
  }
});

// node_modules/abstract-leveldown/abstract-iterator.js
var require_abstract_iterator = __commonJS({
  "node_modules/abstract-leveldown/abstract-iterator.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function AbstractIterator(db) {
      if (typeof db !== "object" || db === null) {
        throw new TypeError("First argument must be an abstract-leveldown compliant store");
      }
      this.db = db;
      this._ended = false;
      this._nexting = false;
    }
    AbstractIterator.prototype.next = function(callback) {
      let ret = this;
      if (callback === void 0) {
        ret = new Promise(function(resolve6, reject) {
          callback = function(err, key, value) {
            if (err)
              reject(err);
            else if (key === void 0 && value === void 0)
              resolve6();
            else
              resolve6([key, value]);
          };
        });
      } else if (typeof callback !== "function") {
        throw new Error("next() requires a callback argument");
      }
      if (this._ended) {
        this._nextTick(callback, new Error("cannot call next() after end()"));
        return ret;
      }
      if (this._nexting) {
        this._nextTick(callback, new Error("cannot call next() before previous next() has completed"));
        return ret;
      }
      this._nexting = true;
      this._next((err, ...rest) => {
        this._nexting = false;
        callback(err, ...rest);
      });
      return ret;
    };
    AbstractIterator.prototype._next = function(callback) {
      this._nextTick(callback);
    };
    AbstractIterator.prototype.seek = function(target) {
      if (this._ended) {
        throw new Error("cannot call seek() after end()");
      }
      if (this._nexting) {
        throw new Error("cannot call seek() before next() has completed");
      }
      target = this.db._serializeKey(target);
      this._seek(target);
    };
    AbstractIterator.prototype._seek = function(target) {
    };
    AbstractIterator.prototype.end = function(callback) {
      let promise;
      if (callback === void 0) {
        promise = new Promise(function(resolve6, reject) {
          callback = function(err) {
            if (err)
              reject(err);
            else
              resolve6();
          };
        });
      } else if (typeof callback !== "function") {
        throw new Error("end() requires a callback argument");
      }
      if (this._ended) {
        this._nextTick(callback, new Error("end() already called on iterator"));
        return promise;
      }
      this._ended = true;
      this._end(callback);
      return promise;
    };
    AbstractIterator.prototype._end = function(callback) {
      this._nextTick(callback);
    };
    AbstractIterator.prototype[Symbol.asyncIterator] = async function* () {
      try {
        let kv;
        while ((kv = await this.next()) !== void 0) {
          yield kv;
        }
      } finally {
        if (!this._ended)
          await this.end();
      }
    };
    AbstractIterator.prototype._nextTick = require_next_tick_browser();
    module2.exports = AbstractIterator;
  }
});

// node_modules/abstract-leveldown/abstract-chained-batch.js
var require_abstract_chained_batch = __commonJS({
  "node_modules/abstract-leveldown/abstract-chained-batch.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var emptyOptions = Object.freeze({});
    function AbstractChainedBatch(db) {
      if (typeof db !== "object" || db === null) {
        throw new TypeError("First argument must be an abstract-leveldown compliant store");
      }
      this.db = db;
      this._operations = [];
      this._written = false;
    }
    AbstractChainedBatch.prototype._checkWritten = function() {
      if (this._written) {
        throw new Error("write() already called on this batch");
      }
    };
    AbstractChainedBatch.prototype.put = function(key, value, options) {
      this._checkWritten();
      const err = this.db._checkKey(key) || this.db._checkValue(value);
      if (err)
        throw err;
      key = this.db._serializeKey(key);
      value = this.db._serializeValue(value);
      this._put(key, value, options != null ? options : emptyOptions);
      return this;
    };
    AbstractChainedBatch.prototype._put = function(key, value, options) {
      this._operations.push({ ...options, type: "put", key, value });
    };
    AbstractChainedBatch.prototype.del = function(key, options) {
      this._checkWritten();
      const err = this.db._checkKey(key);
      if (err)
        throw err;
      key = this.db._serializeKey(key);
      this._del(key, options != null ? options : emptyOptions);
      return this;
    };
    AbstractChainedBatch.prototype._del = function(key, options) {
      this._operations.push({ ...options, type: "del", key });
    };
    AbstractChainedBatch.prototype.clear = function() {
      this._checkWritten();
      this._clear();
      return this;
    };
    AbstractChainedBatch.prototype._clear = function() {
      this._operations = [];
    };
    AbstractChainedBatch.prototype.write = function(options, callback) {
      this._checkWritten();
      if (typeof options === "function") {
        callback = options;
      }
      if (typeof callback !== "function") {
        throw new Error("write() requires a callback argument");
      }
      if (typeof options !== "object" || options === null) {
        options = {};
      }
      this._written = true;
      this._write(options, callback);
    };
    AbstractChainedBatch.prototype._write = function(options, callback) {
      this.db._batch(this._operations, options, callback);
    };
    AbstractChainedBatch.prototype._nextTick = require_next_tick_browser();
    module2.exports = AbstractChainedBatch;
  }
});

// node_modules/abstract-leveldown/lib/common.js
var require_common5 = __commonJS({
  "node_modules/abstract-leveldown/lib/common.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.getCallback = function(options, callback) {
      return typeof options === "function" ? options : callback;
    };
    exports2.getOptions = function(options) {
      return typeof options === "object" && options !== null ? options : {};
    };
  }
});

// node_modules/abstract-leveldown/abstract-leveldown.js
var require_abstract_leveldown = __commonJS({
  "node_modules/abstract-leveldown/abstract-leveldown.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var supports = require_level_supports();
    var isBuffer3 = require_is_buffer();
    var catering = require_catering();
    var AbstractIterator = require_abstract_iterator();
    var AbstractChainedBatch = require_abstract_chained_batch();
    var getCallback = require_common5().getCallback;
    var getOptions = require_common5().getOptions;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var rangeOptions = ["lt", "lte", "gt", "gte"];
    function AbstractLevelDOWN(manifest) {
      this.status = "new";
      this.supports = supports(manifest, {
        status: true
      });
    }
    AbstractLevelDOWN.prototype.open = function(options, callback) {
      const oldStatus = this.status;
      if (typeof options === "function")
        callback = options;
      if (typeof callback !== "function") {
        throw new Error("open() requires a callback argument");
      }
      if (typeof options !== "object" || options === null)
        options = {};
      options.createIfMissing = options.createIfMissing !== false;
      options.errorIfExists = !!options.errorIfExists;
      this.status = "opening";
      this._open(options, (err) => {
        if (err) {
          this.status = oldStatus;
          return callback(err);
        }
        this.status = "open";
        callback();
      });
    };
    AbstractLevelDOWN.prototype._open = function(options, callback) {
      this._nextTick(callback);
    };
    AbstractLevelDOWN.prototype.close = function(callback) {
      const oldStatus = this.status;
      if (typeof callback !== "function") {
        throw new Error("close() requires a callback argument");
      }
      this.status = "closing";
      this._close((err) => {
        if (err) {
          this.status = oldStatus;
          return callback(err);
        }
        this.status = "closed";
        callback();
      });
    };
    AbstractLevelDOWN.prototype._close = function(callback) {
      this._nextTick(callback);
    };
    AbstractLevelDOWN.prototype.get = function(key, options, callback) {
      if (typeof options === "function")
        callback = options;
      if (typeof callback !== "function") {
        throw new Error("get() requires a callback argument");
      }
      const err = this._checkKey(key);
      if (err)
        return this._nextTick(callback, err);
      key = this._serializeKey(key);
      if (typeof options !== "object" || options === null)
        options = {};
      options.asBuffer = options.asBuffer !== false;
      this._get(key, options, callback);
    };
    AbstractLevelDOWN.prototype._get = function(key, options, callback) {
      this._nextTick(function() {
        callback(new Error("NotFound"));
      });
    };
    AbstractLevelDOWN.prototype.getMany = function(keys, options, callback) {
      callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      options = getOptions(options);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      if (!Array.isArray(keys)) {
        this._nextTick(callback, new Error("getMany() requires an array argument"));
        return callback.promise;
      }
      if (keys.length === 0) {
        this._nextTick(callback, null, []);
        return callback.promise;
      }
      if (typeof options.asBuffer !== "boolean") {
        options = { ...options, asBuffer: true };
      }
      const serialized = new Array(keys.length);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const err = this._checkKey(key);
        if (err) {
          this._nextTick(callback, err);
          return callback.promise;
        }
        serialized[i] = this._serializeKey(key);
      }
      this._getMany(serialized, options, callback);
      return callback.promise;
    };
    AbstractLevelDOWN.prototype._getMany = function(keys, options, callback) {
      this._nextTick(callback, null, new Array(keys.length).fill(void 0));
    };
    AbstractLevelDOWN.prototype.put = function(key, value, options, callback) {
      if (typeof options === "function")
        callback = options;
      if (typeof callback !== "function") {
        throw new Error("put() requires a callback argument");
      }
      const err = this._checkKey(key) || this._checkValue(value);
      if (err)
        return this._nextTick(callback, err);
      key = this._serializeKey(key);
      value = this._serializeValue(value);
      if (typeof options !== "object" || options === null)
        options = {};
      this._put(key, value, options, callback);
    };
    AbstractLevelDOWN.prototype._put = function(key, value, options, callback) {
      this._nextTick(callback);
    };
    AbstractLevelDOWN.prototype.del = function(key, options, callback) {
      if (typeof options === "function")
        callback = options;
      if (typeof callback !== "function") {
        throw new Error("del() requires a callback argument");
      }
      const err = this._checkKey(key);
      if (err)
        return this._nextTick(callback, err);
      key = this._serializeKey(key);
      if (typeof options !== "object" || options === null)
        options = {};
      this._del(key, options, callback);
    };
    AbstractLevelDOWN.prototype._del = function(key, options, callback) {
      this._nextTick(callback);
    };
    AbstractLevelDOWN.prototype.batch = function(array2, options, callback) {
      if (!arguments.length)
        return this._chainedBatch();
      if (typeof options === "function")
        callback = options;
      if (typeof array2 === "function")
        callback = array2;
      if (typeof callback !== "function") {
        throw new Error("batch(array) requires a callback argument");
      }
      if (!Array.isArray(array2)) {
        return this._nextTick(callback, new Error("batch(array) requires an array argument"));
      }
      if (array2.length === 0) {
        return this._nextTick(callback);
      }
      if (typeof options !== "object" || options === null)
        options = {};
      const serialized = new Array(array2.length);
      for (let i = 0; i < array2.length; i++) {
        if (typeof array2[i] !== "object" || array2[i] === null) {
          return this._nextTick(callback, new Error("batch(array) element must be an object and not `null`"));
        }
        const e = Object.assign({}, array2[i]);
        if (e.type !== "put" && e.type !== "del") {
          return this._nextTick(callback, new Error("`type` must be 'put' or 'del'"));
        }
        const err = this._checkKey(e.key);
        if (err)
          return this._nextTick(callback, err);
        e.key = this._serializeKey(e.key);
        if (e.type === "put") {
          const valueErr = this._checkValue(e.value);
          if (valueErr)
            return this._nextTick(callback, valueErr);
          e.value = this._serializeValue(e.value);
        }
        serialized[i] = e;
      }
      this._batch(serialized, options, callback);
    };
    AbstractLevelDOWN.prototype._batch = function(array2, options, callback) {
      this._nextTick(callback);
    };
    AbstractLevelDOWN.prototype.clear = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
      } else if (typeof callback !== "function") {
        throw new Error("clear() requires a callback argument");
      }
      options = cleanRangeOptions(this, options);
      options.reverse = !!options.reverse;
      options.limit = "limit" in options ? options.limit : -1;
      this._clear(options, callback);
    };
    AbstractLevelDOWN.prototype._clear = function(options, callback) {
      options.keys = true;
      options.values = false;
      options.keyAsBuffer = true;
      options.valueAsBuffer = true;
      const iterator = this._iterator(options);
      const emptyOptions = {};
      const next = (err) => {
        if (err) {
          return iterator.end(function() {
            callback(err);
          });
        }
        iterator.next((err2, key) => {
          if (err2)
            return next(err2);
          if (key === void 0)
            return iterator.end(callback);
          this._del(key, emptyOptions, next);
        });
      };
      next();
    };
    AbstractLevelDOWN.prototype._setupIteratorOptions = function(options) {
      options = cleanRangeOptions(this, options);
      options.reverse = !!options.reverse;
      options.keys = options.keys !== false;
      options.values = options.values !== false;
      options.limit = "limit" in options ? options.limit : -1;
      options.keyAsBuffer = options.keyAsBuffer !== false;
      options.valueAsBuffer = options.valueAsBuffer !== false;
      return options;
    };
    function cleanRangeOptions(db, options) {
      const result = {};
      for (const k in options) {
        if (!hasOwnProperty.call(options, k))
          continue;
        if (k === "start" || k === "end") {
          throw new Error('Legacy range options ("start" and "end") have been removed');
        }
        let opt = options[k];
        if (isRangeOption(k)) {
          opt = db._serializeKey(opt);
        }
        result[k] = opt;
      }
      return result;
    }
    function isRangeOption(k) {
      return rangeOptions.indexOf(k) !== -1;
    }
    AbstractLevelDOWN.prototype.iterator = function(options) {
      if (typeof options !== "object" || options === null)
        options = {};
      options = this._setupIteratorOptions(options);
      return this._iterator(options);
    };
    AbstractLevelDOWN.prototype._iterator = function(options) {
      return new AbstractIterator(this);
    };
    AbstractLevelDOWN.prototype._chainedBatch = function() {
      return new AbstractChainedBatch(this);
    };
    AbstractLevelDOWN.prototype._serializeKey = function(key) {
      return key;
    };
    AbstractLevelDOWN.prototype._serializeValue = function(value) {
      return value;
    };
    AbstractLevelDOWN.prototype._checkKey = function(key) {
      if (key === null || key === void 0) {
        return new Error("key cannot be `null` or `undefined`");
      } else if (isBuffer3(key) && key.length === 0) {
        return new Error("key cannot be an empty Buffer");
      } else if (key === "") {
        return new Error("key cannot be an empty String");
      } else if (Array.isArray(key) && key.length === 0) {
        return new Error("key cannot be an empty Array");
      }
    };
    AbstractLevelDOWN.prototype._checkValue = function(value) {
      if (value === null || value === void 0) {
        return new Error("value cannot be `null` or `undefined`");
      }
    };
    AbstractLevelDOWN.prototype.isOperational = function() {
      return this.status === "open" || this._isOperational();
    };
    AbstractLevelDOWN.prototype._isOperational = function() {
      return false;
    };
    AbstractLevelDOWN.prototype._nextTick = require_next_tick_browser();
    module2.exports = AbstractLevelDOWN;
    function maybeError(db, callback) {
      if (!db.isOperational()) {
        db._nextTick(callback, new Error("Database is not open"));
        return true;
      }
      return false;
    }
  }
});

// node_modules/abstract-leveldown/index.js
var require_abstract_leveldown2 = __commonJS({
  "node_modules/abstract-leveldown/index.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.AbstractLevelDOWN = require_abstract_leveldown();
    exports2.AbstractIterator = require_abstract_iterator();
    exports2.AbstractChainedBatch = require_abstract_chained_batch();
  }
});

// node_modules/deferred-leveldown/util.js
var require_util4 = __commonJS({
  "node_modules/deferred-leveldown/util.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.getCallback = function(args, symbol, map8) {
      let callback = args[args.length - 1];
      if (typeof callback !== "function") {
        const promise = new Promise((resolve6, reject) => {
          args.push(callback = function(err, ...results) {
            if (err)
              reject(err);
            else
              resolve6(map8 ? map8(...results) : results[0]);
          });
        });
        callback[symbol] = promise;
      }
      return callback;
    };
  }
});

// node_modules/deferred-leveldown/deferred-iterator.js
var require_deferred_iterator = __commonJS({
  "node_modules/deferred-leveldown/deferred-iterator.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { AbstractIterator } = require_abstract_leveldown2();
    var inherits = require_inherits_browser();
    var getCallback = require_util4().getCallback;
    var kOptions = Symbol("options");
    var kIterator = Symbol("iterator");
    var kOperations = Symbol("operations");
    var kPromise = Symbol("promise");
    function DeferredIterator(db, options) {
      AbstractIterator.call(this, db);
      this[kOptions] = options;
      this[kIterator] = null;
      this[kOperations] = [];
    }
    inherits(DeferredIterator, AbstractIterator);
    DeferredIterator.prototype.setDb = function(db) {
      this[kIterator] = db.iterator(this[kOptions]);
      for (const op of this[kOperations].splice(0, this[kOperations].length)) {
        this[kIterator][op.method](...op.args);
      }
    };
    DeferredIterator.prototype.next = function(...args) {
      if (this.db.status === "open") {
        return this[kIterator].next(...args);
      }
      const callback = getCallback(args, kPromise, function map8(key, value) {
        if (key === void 0 && value === void 0) {
          return void 0;
        } else {
          return [key, value];
        }
      });
      if (this.db.status === "opening") {
        this[kOperations].push({ method: "next", args });
      } else {
        this._nextTick(callback, new Error("Database is not open"));
      }
      return callback[kPromise] || this;
    };
    DeferredIterator.prototype.seek = function(...args) {
      if (this.db.status === "open") {
        this[kIterator].seek(...args);
      } else if (this.db.status === "opening") {
        this[kOperations].push({ method: "seek", args });
      } else {
        throw new Error("Database is not open");
      }
    };
    DeferredIterator.prototype.end = function(...args) {
      if (this.db.status === "open") {
        return this[kIterator].end(...args);
      }
      const callback = getCallback(args, kPromise);
      if (this.db.status === "opening") {
        this[kOperations].push({ method: "end", args });
      } else {
        this._nextTick(callback, new Error("Database is not open"));
      }
      return callback[kPromise] || this;
    };
    for (const method of ["next", "seek", "end"]) {
      DeferredIterator.prototype["_" + method] = function() {
        throw new Error("Did not expect private method to be called: " + method);
      };
    }
    module2.exports = DeferredIterator;
  }
});

// node_modules/deferred-leveldown/deferred-chained-batch.js
var require_deferred_chained_batch = __commonJS({
  "node_modules/deferred-leveldown/deferred-chained-batch.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { AbstractChainedBatch } = require_abstract_leveldown2();
    var kOperations = Symbol("operations");
    module2.exports = class DeferredChainedBatch extends AbstractChainedBatch {
      constructor(db) {
        super(db);
        this[kOperations] = [];
      }
      _put(key, value, options) {
        this[kOperations].push({ ...options, type: "put", key, value });
      }
      _del(key, options) {
        this[kOperations].push({ ...options, type: "del", key });
      }
      _clear() {
        this[kOperations] = [];
      }
      _write(options, callback) {
        this.db.batch(this[kOperations], options, callback);
      }
    };
  }
});

// node_modules/deferred-leveldown/deferred-leveldown.js
var require_deferred_leveldown = __commonJS({
  "node_modules/deferred-leveldown/deferred-leveldown.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { AbstractLevelDOWN } = require_abstract_leveldown2();
    var inherits = require_inherits_browser();
    var DeferredIterator = require_deferred_iterator();
    var DeferredChainedBatch = require_deferred_chained_batch();
    var getCallback = require_util4().getCallback;
    var deferrables = ["put", "get", "getMany", "del", "batch", "clear"];
    var optionalDeferrables = ["approximateSize", "compactRange"];
    var kInnerDb = Symbol("innerDb");
    var kOperations = Symbol("operations");
    var kPromise = Symbol("promise");
    function DeferredLevelDOWN(db) {
      AbstractLevelDOWN.call(this, db.supports || {});
      for (const m of optionalDeferrables) {
        if (typeof db[m] === "function" && !this.supports.additionalMethods[m]) {
          this.supports.additionalMethods[m] = true;
        }
      }
      this[kInnerDb] = db;
      this[kOperations] = [];
      implement(this);
    }
    inherits(DeferredLevelDOWN, AbstractLevelDOWN);
    DeferredLevelDOWN.prototype.type = "deferred-leveldown";
    Object.defineProperty(DeferredLevelDOWN.prototype, "_db", {
      enumerable: true,
      get() {
        return this[kInnerDb];
      }
    });
    DeferredLevelDOWN.prototype._open = function(options, callback) {
      const onopen = (err) => {
        if (err || this[kInnerDb].status !== "open") {
          return callback(err || new Error("Database is not open"));
        }
        const operations = this[kOperations];
        this[kOperations] = [];
        for (const op of operations) {
          if (op.iterator) {
            op.iterator.setDb(this[kInnerDb]);
          } else {
            this[kInnerDb][op.method](...op.args);
          }
        }
        if (this[kOperations].length > 0) {
          throw new Error("Did not expect further operations");
        }
        callback();
      };
      if (this[kInnerDb].status === "new" || this[kInnerDb].status === "closed") {
        this[kInnerDb].open(options, onopen);
      } else {
        this._nextTick(onopen);
      }
    };
    DeferredLevelDOWN.prototype._close = function(callback) {
      this[kInnerDb].close(callback);
    };
    DeferredLevelDOWN.prototype._isOperational = function() {
      return this.status === "opening";
    };
    function implement(self2) {
      const additionalMethods = Object.keys(self2.supports.additionalMethods);
      for (const method of deferrables.concat(additionalMethods)) {
        self2[method] = function(...args) {
          if (method === "batch" && args.length === 0) {
            return new DeferredChainedBatch(this);
          } else if (this.status === "open") {
            return this[kInnerDb][method](...args);
          }
          const callback = getCallback(args, kPromise);
          if (this.status === "opening") {
            this[kOperations].push({ method, args });
          } else {
            this._nextTick(callback, new Error("Database is not open"));
          }
          return callback[kPromise];
        };
      }
      self2.iterator = function(options) {
        if (this.status === "open") {
          return this[kInnerDb].iterator(options);
        } else if (this.status === "opening") {
          const iterator = new DeferredIterator(this, options);
          this[kOperations].push({ iterator });
          return iterator;
        } else {
          throw new Error("Database is not open");
        }
      };
      for (const method of deferrables.concat(["iterator"])) {
        self2["_" + method] = function() {
          throw new Error("Did not expect private method to be called: " + method);
        };
      }
    }
    module2.exports = DeferredLevelDOWN;
    module2.exports.DeferredIterator = DeferredIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream-browser.js"(exports2, module2) {
    init_node_globals();
    module2.exports = require_events().EventEmitter;
  }
});

// (disabled):node_modules/util/util.js
var require_util5 = __commonJS({
  "(disabled):node_modules/util/util.js"() {
    init_node_globals();
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
          });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(Object(source), true).forEach(function(key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var _require = require_buffer();
    var Buffer2 = _require.Buffer;
    var _require2 = require_util5();
    var inspect = _require2.inspect;
    var custom = inspect && inspect.custom || "inspect";
    function copyBuffer(src2, target, offset) {
      Buffer2.prototype.copy.call(src2, target, offset);
    }
    module2.exports = /* @__PURE__ */ function() {
      function BufferList3() {
        _classCallCheck(this, BufferList3);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      _createClass(BufferList3, [{
        key: "push",
        value: function push(v) {
          var entry = {
            data: v,
            next: null
          };
          if (this.length > 0)
            this.tail.next = entry;
          else
            this.head = entry;
          this.tail = entry;
          ++this.length;
        }
      }, {
        key: "unshift",
        value: function unshift(v) {
          var entry = {
            data: v,
            next: this.head
          };
          if (this.length === 0)
            this.tail = entry;
          this.head = entry;
          ++this.length;
        }
      }, {
        key: "shift",
        value: function shift() {
          if (this.length === 0)
            return;
          var ret = this.head.data;
          if (this.length === 1)
            this.head = this.tail = null;
          else
            this.head = this.head.next;
          --this.length;
          return ret;
        }
      }, {
        key: "clear",
        value: function clear() {
          this.head = this.tail = null;
          this.length = 0;
        }
      }, {
        key: "join",
        value: function join(s) {
          if (this.length === 0)
            return "";
          var p = this.head;
          var ret = "" + p.data;
          while (p = p.next) {
            ret += s + p.data;
          }
          return ret;
        }
      }, {
        key: "concat",
        value: function concat3(n) {
          if (this.length === 0)
            return Buffer2.alloc(0);
          var ret = Buffer2.allocUnsafe(n >>> 0);
          var p = this.head;
          var i = 0;
          while (p) {
            copyBuffer(p.data, ret, i);
            i += p.data.length;
            p = p.next;
          }
          return ret;
        }
      }, {
        key: "consume",
        value: function consume(n, hasStrings) {
          var ret;
          if (n < this.head.data.length) {
            ret = this.head.data.slice(0, n);
            this.head.data = this.head.data.slice(n);
          } else if (n === this.head.data.length) {
            ret = this.shift();
          } else {
            ret = hasStrings ? this._getString(n) : this._getBuffer(n);
          }
          return ret;
        }
      }, {
        key: "first",
        value: function first3() {
          return this.head.data;
        }
      }, {
        key: "_getString",
        value: function _getString(n) {
          var p = this.head;
          var c = 1;
          var ret = p.data;
          n -= ret.length;
          while (p = p.next) {
            var str = p.data;
            var nb = n > str.length ? str.length : n;
            if (nb === str.length)
              ret += str;
            else
              ret += str.slice(0, n);
            n -= nb;
            if (n === 0) {
              if (nb === str.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = str.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: "_getBuffer",
        value: function _getBuffer(n) {
          var ret = Buffer2.allocUnsafe(n);
          var p = this.head;
          var c = 1;
          p.data.copy(ret);
          n -= p.data.length;
          while (p = p.next) {
            var buf2 = p.data;
            var nb = n > buf2.length ? buf2.length : n;
            buf2.copy(ret, ret.length - n, 0, nb);
            n -= nb;
            if (n === 0) {
              if (nb === buf2.length) {
                ++c;
                if (p.next)
                  this.head = p.next;
                else
                  this.head = this.tail = null;
              } else {
                this.head = p;
                p.data = buf2.slice(nb);
              }
              break;
            }
            ++c;
          }
          this.length -= c;
          return ret;
        }
      }, {
        key: custom,
        value: function value(_, options) {
          return inspect(this, _objectSpread({}, options, {
            depth: 0,
            customInspect: false
          }));
        }
      }]);
      return BufferList3;
    }();
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose)
        return;
      if (self2._readableState && !self2._readableState.emitClose)
        return;
      self2.emit("close");
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy)
        stream.destroy(err);
      else
        stream.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors-browser.js
var require_errors_browser = __commonJS({
  "node_modules/readable-stream/errors-browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function _inheritsLoose(subClass, superClass) {
      subClass.prototype = Object.create(superClass.prototype);
      subClass.prototype.constructor = subClass;
      subClass.__proto__ = superClass;
    }
    var codes = {};
    function createErrorType(code5, message, Base) {
      if (!Base) {
        Base = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      var NodeError = /* @__PURE__ */ function(_Base) {
        _inheritsLoose(NodeError2, _Base);
        function NodeError2(arg1, arg2, arg3) {
          return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
        }
        return NodeError2;
      }(Base);
      NodeError.prototype.name = Base.name;
      NodeError.prototype.code = code5;
      codes[code5] = NodeError;
    }
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        var len = expected.length;
        expected = expected.map(function(i) {
          return String(i);
        });
        if (len > 2) {
          return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
        } else if (len === 2) {
          return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
        } else {
          return "of ".concat(thing, " ").concat(expected[0]);
        }
      } else {
        return "of ".concat(thing, " ").concat(String(expected));
      }
    }
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    createErrorType("ERR_INVALID_OPT_VALUE", function(name5, value) {
      return 'The value "' + value + '" is invalid for option "' + name5 + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name5, expected, actual) {
      var determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      var msg;
      if (endsWith(name5, " argument")) {
        msg = "The ".concat(name5, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      } else {
        var type = includes(name5, ".") ? "property" : "argument";
        msg = 'The "'.concat(name5, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
      }
      msg += ". Received type ".concat(typeof actual);
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name5) {
      return "The " + name5 + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name5) {
      return "Cannot call " + name5 + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state2 = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors_browser().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name5 = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name5, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/util-deprecate/browser.js
var require_browser6 = __commonJS({
  "node_modules/util-deprecate/browser.js"(exports2, module2) {
    init_node_globals();
    module2.exports = deprecate2;
    function deprecate2(fn, msg) {
      if (config2("noDeprecation")) {
        return fn;
      }
      var warned = false;
      function deprecated() {
        if (!warned) {
          if (config2("throwDeprecation")) {
            throw new Error(msg);
          } else if (config2("traceDeprecation")) {
            console.trace(msg);
          } else {
            console.warn(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }
      return deprecated;
    }
    function config2(name5) {
      try {
        if (!global.localStorage)
          return false;
      } catch (_) {
        return false;
      }
      var val = global.localStorage[name5];
      if (val == null)
        return false;
      return String(val).toLowerCase() === "true";
    }
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_browser6()
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits_browser()(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function value(object) {
          if (realHasInstance.call(this, object))
            return true;
          if (this !== Writable)
            return false;
          return object && object._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function realHasInstance2(object) {
        return object instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this))
        return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function")
          this._write = options.write;
        if (typeof options.writev === "function")
          this._writev = options.writev;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
        if (typeof options.final === "function")
          this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf)
        encoding = "buffer";
      else if (!encoding)
        encoding = state.defaultEncoding;
      if (typeof cb !== "function")
        cb = nop;
      if (state.ending)
        writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
          clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string")
        encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
        throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret)
        state.needDrain = true;
      if (state.writing || state.corked) {
        var last6 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last6) {
          last6.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed)
        state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev)
        stream._writev(chunk, state.onwrite);
      else
        stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function")
        throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er)
        onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    function afterWrite(stream, state, finished, cb) {
      if (!finished)
        onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer2 = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer2[count] = entry;
          if (!entry.isBuf)
            allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer2.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer2, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null)
          state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0)
        this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending)
        endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished)
          process.nextTick(cb);
        else
          stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      enumerable: false,
      get: function get2() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function set(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var objectKeys = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) {
        keys2.push(key);
      }
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits_browser()(Duplex, Readable);
    {
      keys = objectKeys(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method])
          Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex))
        return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false)
          this.readable = false;
        if (options.writable === false)
          this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      enumerable: false,
      get: function get2() {
        return this._writableState.highWaterMark;
      }
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      enumerable: false,
      get: function get2() {
        return this._writableState && this._writableState.getBuffer();
      }
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      enumerable: false,
      get: function get2() {
        return this._writableState.length;
      }
    });
    function onend() {
      if (this._writableState.ended)
        return;
      process.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function set(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports2, module2) {
    init_node_globals();
    var buffer2 = require_buffer();
    var Buffer2 = buffer2.Buffer;
    function copyProps(src2, dst) {
      for (var key in src2) {
        dst[key] = src2[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer2;
    } else {
      copyProps(buffer2, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length4) {
      return Buffer2(arg, encodingOrOffset, length4);
    }
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length4) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length4);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf2 = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf2.fill(fill, encoding);
        } else {
          buf2.fill(fill);
        }
      } else {
        buf2.fill(0);
      }
      return buf2;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer2.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    init_node_globals();
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc)
        return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried)
              return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
        throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf2) {
      if (buf2.length === 0)
        return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf2);
        if (r === void 0)
          return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf2.length)
        return r ? r + this.text(buf2, i) : this.text(buf2, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf2) {
      if (this.lastNeed <= buf2.length) {
        buf2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf2.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf2.length);
      this.lastNeed -= buf2.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127)
        return 0;
      else if (byte >> 5 === 6)
        return 2;
      else if (byte >> 4 === 14)
        return 3;
      else if (byte >> 3 === 30)
        return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf2, i) {
      var j = buf2.length - 1;
      if (j < i)
        return 0;
      var nb = utf8CheckByte(buf2[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf2[j]);
      if (nb >= 0) {
        if (nb > 0)
          self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2)
        return 0;
      nb = utf8CheckByte(buf2[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2)
            nb = 0;
          else
            self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf2, p) {
      if ((buf2[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf2.length > 1) {
        if ((buf2[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf2.length > 2) {
          if ((buf2[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf2) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf2, p);
      if (r !== void 0)
        return r;
      if (this.lastNeed <= buf2.length) {
        buf2.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf2.copy(this.lastChar, p, 0, buf2.length);
      this.lastNeed -= buf2.length;
    }
    function utf8Text(buf2, i) {
      var total = utf8CheckIncomplete(this, buf2, i);
      if (!this.lastNeed)
        return buf2.toString("utf8", i);
      this.lastTotal = total;
      var end = buf2.length - (total - this.lastNeed);
      buf2.copy(this.lastChar, 0, end);
      return buf2.toString("utf8", i, end);
    }
    function utf8End(buf2) {
      var r = buf2 && buf2.length ? this.write(buf2) : "";
      if (this.lastNeed)
        return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf2, i) {
      if ((buf2.length - i) % 2 === 0) {
        var r = buf2.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf2[buf2.length - 2];
            this.lastChar[1] = buf2[buf2.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf2[buf2.length - 1];
      return buf2.toString("utf16le", i, buf2.length - 1);
    }
    function utf16End(buf2) {
      var r = buf2 && buf2.length ? this.write(buf2) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf2, i) {
      var n = (buf2.length - i) % 3;
      if (n === 0)
        return buf2.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf2[buf2.length - 1];
      } else {
        this.lastChar[0] = buf2[buf2.length - 2];
        this.lastChar[1] = buf2[buf2.length - 1];
      }
      return buf2.toString("base64", i, buf2.length - n);
    }
    function base64End(buf2) {
      var r = buf2 && buf2.length ? this.write(buf2) : "";
      if (this.lastNeed)
        return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf2) {
      return buf2.toString(this.encoding);
    }
    function simpleEnd(buf2) {
      return buf2 && buf2.length ? this.write(buf2) : "";
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors_browser().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    function noop2() {
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function eos(stream, opts, callback) {
      if (typeof opts === "function")
        return eos(stream, null, opts);
      if (!opts)
        opts = {};
      callback = once(callback || noop2);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = function onlegacyfinish2() {
        if (!stream.writable)
          onfinish();
      };
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable)
          callback.call(stream);
      };
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable)
          callback.call(stream);
      };
      var onerror = function onerror2(err) {
        callback.call(stream, err);
      };
      var onclose = function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended)
            err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      };
      var onrequest = function onrequest2() {
        stream.req.on("finish", onfinish);
      };
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req)
          onrequest();
        else
          stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false)
        stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req)
          stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value, done) {
      return {
        value,
        done
      };
    }
    function readAndResolve(iter) {
      var resolve6 = iter[kLastResolve];
      if (resolve6 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve6(createIterResult(data, false));
        }
      }
    }
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    function wrapForNext(lastPromise, iter) {
      return function(resolve6, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve6(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve6, reject);
        }, reject);
      };
    }
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve6, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve6(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
      var _this2 = this;
      return new Promise(function(resolve6, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve6(createIterResult(void 0, true));
        });
      });
    }), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: function value(resolve6, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve6(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve6;
            iterator[kLastReject] = reject;
          }
        },
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve6 = iterator[kLastResolve];
        if (resolve6 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve6(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    };
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from-browser.js"(exports2, module2) {
    init_node_globals();
    module2.exports = function() {
      throw new Error("Readable.from is not available in the browser");
    };
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require_events().EventEmitter;
    var EElistenerCount = function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream_browser();
    var Buffer2 = require_buffer().Buffer;
    var OurUint8Array = global.Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var debugUtil = require_util5();
    var debug17;
    if (debugUtil && debugUtil.debuglog) {
      debug17 = debugUtil.debuglog("stream");
    } else {
      debug17 = function debug18() {
      };
    }
    var BufferList3 = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state2();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors_browser().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from3;
    require_inherits_browser()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function")
        return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event])
        emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event]))
        emitter._events[event].unshift(fn);
      else
        emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean")
        isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex)
        this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList3();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder)
          StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable))
        return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function")
          this._read = options.read;
        if (typeof options.destroy === "function")
          this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      enumerable: false,
      get: function get2() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function set(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug17("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck)
          er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted)
              errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else
              addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0)
                addChunk(stream, state, chunk, false);
              else
                maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront)
          state.buffer.unshift(chunk);
        else
          state.buffer.push(chunk);
        if (state.needReadable)
          emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
      }
      return er;
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "")
        this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended)
        return 0;
      if (state.objectMode)
        return 1;
      if (n !== n) {
        if (state.flowing && state.length)
          return state.buffer.head.data.length;
        else
          return state.length;
      }
      if (n > state.highWaterMark)
        state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length)
        return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug17("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0)
        state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug17("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended)
          endReadable(this);
        else
          emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0)
          endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug17("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug17("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug17("reading or ended", doRead);
      } else if (doRead) {
        debug17("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0)
          state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading)
          n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0)
        ret = fromList(n, state);
      else
        ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended)
          state.needReadable = true;
        if (nOrig !== n && state.ended)
          endReadable(this);
      }
      if (ret !== null)
        this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug17("onEofChunk");
      if (state.ended)
        return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      debug17("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug17("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug17("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug17("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src2 = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug17("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted)
        process.nextTick(endFn);
      else
        src2.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug17("onunpipe");
        if (readable === src2) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug17("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src2);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug17("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src2.removeListener("end", onend);
        src2.removeListener("end", unpipe);
        src2.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
          ondrain();
      }
      src2.on("data", ondata);
      function ondata(chunk) {
        debug17("ondata");
        var ret = dest.write(chunk);
        debug17("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug17("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src2.pause();
        }
      }
      function onerror(er) {
        debug17("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0)
          errorOrDestroy(dest, er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug17("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug17("unpipe");
        src2.unpipe(dest);
      }
      dest.emit("pipe", src2);
      if (!state.flowing) {
        debug17("pipe resume");
        src2.resume();
      }
      return dest;
    };
    function pipeOnDrain(src2) {
      return function pipeOnDrainFunctionResult() {
        var state = src2._readableState;
        debug17("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain)
          state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src2, "data")) {
          state.flowing = true;
          flow(src2);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0)
        return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes)
          return this;
        if (!dest)
          dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest)
          dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, {
            hasUnpiped: false
          });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1)
        return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1)
        state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false)
          this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug17("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self2) {
      var state = self2._readableState;
      state.readableListening = self2.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self2.listenerCount("data") > 0) {
        self2.resume();
      }
    }
    function nReadingNextTick(self2) {
      debug17("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug17("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      debug17("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading)
        stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug17("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug17("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug17("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
        ;
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug17("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length)
            _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug17("wrapped data");
        if (state.decoder)
          chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0))
          return;
        else if (!state.objectMode && (!chunk || !chunk.length))
          return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = function methodWrap(method) {
            return function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug17("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      enumerable: false,
      get: function get2() {
        return this._readableState.highWaterMark;
      }
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      enumerable: false,
      get: function get2() {
        return this._readableState && this._readableState.buffer;
      }
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      enumerable: false,
      get: function get2() {
        return this._readableState.flowing;
      },
      set: function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      enumerable: false,
      get: function get2() {
        return this._readableState.length;
      }
    });
    function fromList(n, state) {
      if (state.length === 0)
        return null;
      var ret;
      if (state.objectMode)
        ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder)
          ret = state.buffer.join("");
        else if (state.buffer.length === 1)
          ret = state.buffer.first();
        else
          ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      debug17("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      debug17("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from3 === void 0) {
          from3 = require_from_browser();
        }
        return from3(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x)
          return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors_browser().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits_browser()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform))
        return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function")
          this._transform = options.transform;
        if (typeof options.flush === "function")
          this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
          this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er)
        return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length)
        throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming)
        throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits_browser()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough))
        return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called)
          return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    var _require$codes = require_errors_browser().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop2(err) {
      if (err)
        throw err;
    }
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0)
        eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err)
          return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed)
          return;
        if (destroyed)
          return;
        destroyed = true;
        if (isRequest(stream))
          return stream.abort();
        if (typeof stream.destroy === "function")
          return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    function call(fn) {
      fn();
    }
    function pipe4(from3, to) {
      return from3.pipe(to);
    }
    function popCallback(streams) {
      if (!streams.length)
        return noop2;
      if (typeof streams[streams.length - 1] !== "function")
        return noop2;
      return streams.pop();
    }
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0]))
        streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error)
            error = err;
          if (err)
            destroys.forEach(call);
          if (reading)
            return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe4);
    }
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS({
  "node_modules/readable-stream/readable-browser.js"(exports2, module2) {
    init_node_globals();
    exports2 = module2.exports = require_stream_readable();
    exports2.Stream = exports2;
    exports2.Readable = exports2;
    exports2.Writable = require_stream_writable();
    exports2.Duplex = require_stream_duplex();
    exports2.Transform = require_stream_transform();
    exports2.PassThrough = require_stream_passthrough();
    exports2.finished = require_end_of_stream();
    exports2.pipeline = require_pipeline();
  }
});

// node_modules/level-iterator-stream/index.js
var require_level_iterator_stream = __commonJS({
  "node_modules/level-iterator-stream/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var inherits = require_inherits_browser();
    var { Readable } = require_readable_browser();
    module2.exports = ReadStream;
    inherits(ReadStream, Readable);
    function ReadStream(iterator, options) {
      if (!(this instanceof ReadStream))
        return new ReadStream(iterator, options);
      options = options || {};
      Readable.call(this, Object.assign({}, options, {
        objectMode: true
      }));
      this._iterator = iterator;
      this._options = options;
      this.on("end", this.destroy.bind(this, null, null));
    }
    ReadStream.prototype._read = function() {
      if (this.destroyed)
        return;
      this._iterator.next((err, key, value) => {
        if (this.destroyed)
          return;
        if (err)
          return this.destroy(err);
        if (key === void 0 && value === void 0) {
          this.push(null);
        } else if (this._options.keys !== false && this._options.values === false) {
          this.push(key);
        } else if (this._options.keys === false && this._options.values !== false) {
          this.push(value);
        } else {
          this.push({ key, value });
        }
      });
    };
    ReadStream.prototype._destroy = function(err, callback) {
      this._iterator.end(function(err2) {
        callback(err || err2);
      });
    };
  }
});

// node_modules/level-errors/errors.js
var require_errors2 = __commonJS({
  "node_modules/level-errors/errors.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function createError(type, Proto) {
      const Err = function(message, cause) {
        if (typeof message === "object" && message !== null) {
          cause = cause || message;
          message = message.message || message.name;
        }
        message = message || "";
        cause = cause || void 0;
        if (typeof cause === "object" && cause.type === type && cause.message === message) {
          return cause;
        }
        Object.defineProperty(this, "type", { value: type, enumerable: false, writable: true, configurable: true });
        Object.defineProperty(this, "name", { value: type, enumerable: false, writable: true, configurable: true });
        Object.defineProperty(this, "cause", { value: cause, enumerable: false, writable: true, configurable: true });
        Object.defineProperty(this, "message", { value: message, enumerable: false, writable: true, configurable: true });
        Error.call(this);
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, Err);
        }
      };
      Err.prototype = new Proto();
      return Err;
    }
    var LevelUPError = createError("LevelUPError", Error);
    module2.exports = {
      LevelUPError,
      InitializationError: createError("InitializationError", LevelUPError),
      OpenError: createError("OpenError", LevelUPError),
      ReadError: createError("ReadError", LevelUPError),
      WriteError: createError("WriteError", LevelUPError),
      NotFoundError: createError("NotFoundError", LevelUPError),
      EncodingError: createError("EncodingError", LevelUPError)
    };
    module2.exports.NotFoundError.prototype.notFound = true;
    module2.exports.NotFoundError.prototype.status = 404;
  }
});

// node_modules/levelup/lib/common.js
var require_common6 = __commonJS({
  "node_modules/levelup/lib/common.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.getCallback = function(options, callback) {
      return typeof options === "function" ? options : callback;
    };
    exports2.getOptions = function(options) {
      return typeof options === "object" && options !== null ? options : {};
    };
  }
});

// node_modules/levelup/lib/batch.js
var require_batch = __commonJS({
  "node_modules/levelup/lib/batch.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var WriteError = require_errors2().WriteError;
    var catering = require_catering();
    var getCallback = require_common6().getCallback;
    var getOptions = require_common6().getOptions;
    function Batch(levelup) {
      this.db = levelup;
      this.batch = levelup.db.batch();
      this.ops = [];
      this.length = 0;
    }
    Batch.prototype.put = function(key, value, options) {
      try {
        this.batch.put(key, value, options);
      } catch (e) {
        throw new WriteError(e);
      }
      this.ops.push({ ...options, type: "put", key, value });
      this.length++;
      return this;
    };
    Batch.prototype.del = function(key, options) {
      try {
        this.batch.del(key, options);
      } catch (err) {
        throw new WriteError(err);
      }
      this.ops.push({ ...options, type: "del", key });
      this.length++;
      return this;
    };
    Batch.prototype.clear = function() {
      try {
        this.batch.clear();
      } catch (err) {
        throw new WriteError(err);
      }
      this.ops = [];
      this.length = 0;
      return this;
    };
    Batch.prototype.write = function(options, callback) {
      const levelup = this.db;
      const ops = this.ops;
      callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      options = getOptions(options);
      try {
        this.batch.write(options, function(err) {
          if (err) {
            return callback(new WriteError(err));
          }
          levelup.emit("batch", ops);
          callback();
        });
      } catch (err) {
        throw new WriteError(err);
      }
      return callback.promise;
    };
    module2.exports = Batch;
  }
});

// node_modules/levelup/lib/next-tick-browser.js
var require_next_tick_browser2 = __commonJS({
  "node_modules/levelup/lib/next-tick-browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var queueMicrotask2 = require_queue_microtask2();
    module2.exports = function(fn, ...args) {
      if (args.length === 0) {
        queueMicrotask2(fn);
      } else {
        queueMicrotask2(() => fn(...args));
      }
    };
  }
});

// node_modules/levelup/lib/levelup.js
var require_levelup = __commonJS({
  "node_modules/levelup/lib/levelup.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var EventEmitter4 = require_events().EventEmitter;
    var inherits = require_util3().inherits;
    var DeferredLevelDOWN = require_deferred_leveldown();
    var IteratorStream = require_level_iterator_stream();
    var Batch = require_batch();
    var errors2 = require_errors2();
    var supports = require_level_supports();
    var catering = require_catering();
    var getCallback = require_common6().getCallback;
    var getOptions = require_common6().getOptions;
    var nextTick = require_next_tick_browser2();
    var WriteError = errors2.WriteError;
    var ReadError = errors2.ReadError;
    var NotFoundError2 = errors2.NotFoundError;
    var OpenError = errors2.OpenError;
    var InitializationError = errors2.InitializationError;
    function LevelUP(db, options, callback) {
      if (!(this instanceof LevelUP)) {
        return new LevelUP(db, options, callback);
      }
      let error;
      EventEmitter4.call(this);
      this.setMaxListeners(Infinity);
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if (!db || typeof db !== "object") {
        error = new InitializationError("First argument must be an abstract-leveldown compliant store");
        if (typeof callback === "function") {
          return nextTick(callback, error);
        }
        throw error;
      }
      if (typeof db.status !== "string") {
        throw new Error(".status required, old abstract-leveldown");
      }
      this.options = getOptions(options);
      this._db = db;
      this.db = null;
      this.open(callback || ((err) => {
        if (err)
          this.emit("error", err);
      }));
      this.supports = supports(this.db.supports, {
        status: true,
        deferredOpen: true,
        openCallback: true,
        promises: true,
        streams: true
      });
      for (const method of Object.keys(this.supports.additionalMethods)) {
        if (this[method] != null)
          continue;
        this[method] = function(...args) {
          return this.db[method](...args);
        };
      }
    }
    LevelUP.prototype.emit = EventEmitter4.prototype.emit;
    LevelUP.prototype.once = EventEmitter4.prototype.once;
    inherits(LevelUP, EventEmitter4);
    Object.defineProperty(LevelUP.prototype, "status", {
      enumerable: true,
      get() {
        return this.db.status;
      }
    });
    LevelUP.prototype.isOperational = function() {
      return this.db.status === "open" || this.db.status === "opening";
    };
    LevelUP.prototype.open = function(opts, callback) {
      if (typeof opts === "function") {
        callback = opts;
        opts = null;
      }
      callback = catering.fromCallback(callback);
      if (!opts) {
        opts = this.options;
      }
      if (this.db && this.isOpen()) {
        nextTick(callback, null, this);
        return callback.promise;
      }
      if (this.db && this._isOpening()) {
        this.once("open", () => {
          callback(null, this);
        });
        return callback.promise;
      }
      this.db = new DeferredLevelDOWN(this._db);
      this.emit("opening");
      this.db.open(opts, (err) => {
        if (err) {
          return callback(new OpenError(err));
        }
        this.db = this._db;
        callback(null, this);
        this.emit("open");
        this.emit("ready");
      });
      return callback.promise;
    };
    LevelUP.prototype.close = function(callback) {
      callback = catering.fromCallback(callback);
      if (this.isOpen()) {
        this.db.close((err, ...rest) => {
          this.emit("closed");
          callback(err, ...rest);
        });
        this.emit("closing");
      } else if (this.isClosed()) {
        nextTick(callback);
      } else if (this.db.status === "closing") {
        this.once("closed", callback);
      } else if (this._isOpening()) {
        this.once("open", () => {
          this.close(callback);
        });
      }
      return callback.promise;
    };
    LevelUP.prototype.isOpen = function() {
      return this.db.status === "open";
    };
    LevelUP.prototype._isOpening = function() {
      return this.db.status === "opening";
    };
    LevelUP.prototype.isClosed = function() {
      return /^clos|new/.test(this.db.status);
    };
    LevelUP.prototype.get = function(key, options, callback) {
      callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      options = getOptions(options);
      this.db.get(key, options, function(err, value) {
        if (err) {
          if (/notfound/i.test(err) || err.notFound) {
            err = new NotFoundError2("Key not found in database [" + key + "]", err);
          } else {
            err = new ReadError(err);
          }
          return callback(err);
        }
        callback(null, value);
      });
      return callback.promise;
    };
    LevelUP.prototype.getMany = function(keys, options, callback) {
      return this.db.getMany(keys, options, callback);
    };
    LevelUP.prototype.put = function(key, value, options, callback) {
      callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      options = getOptions(options);
      this.db.put(key, value, options, (err) => {
        if (err) {
          return callback(new WriteError(err));
        }
        this.emit("put", key, value);
        callback();
      });
      return callback.promise;
    };
    LevelUP.prototype.del = function(key, options, callback) {
      callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      options = getOptions(options);
      this.db.del(key, options, (err) => {
        if (err) {
          return callback(new WriteError(err));
        }
        this.emit("del", key);
        callback();
      });
      return callback.promise;
    };
    LevelUP.prototype.batch = function(arr, options, callback) {
      if (!arguments.length) {
        return new Batch(this);
      }
      if (typeof arr === "function")
        callback = arr;
      else
        callback = getCallback(options, callback);
      callback = catering.fromCallback(callback);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      options = getOptions(options);
      this.db.batch(arr, options, (err) => {
        if (err) {
          return callback(new WriteError(err));
        }
        this.emit("batch", arr);
        callback();
      });
      return callback.promise;
    };
    LevelUP.prototype.iterator = function(options) {
      return this.db.iterator(options);
    };
    LevelUP.prototype.clear = function(options, callback) {
      callback = getCallback(options, callback);
      options = getOptions(options);
      callback = catering.fromCallback(callback);
      if (maybeError(this, callback)) {
        return callback.promise;
      }
      this.db.clear(options, (err) => {
        if (err) {
          return callback(new WriteError(err));
        }
        this.emit("clear", options);
        callback();
      });
      return callback.promise;
    };
    LevelUP.prototype.readStream = LevelUP.prototype.createReadStream = function(options) {
      options = Object.assign({ keys: true, values: true }, options);
      if (typeof options.limit !== "number") {
        options.limit = -1;
      }
      return new IteratorStream(this.db.iterator(options), options);
    };
    LevelUP.prototype.keyStream = LevelUP.prototype.createKeyStream = function(options) {
      return this.createReadStream(Object.assign({}, options, { keys: true, values: false }));
    };
    LevelUP.prototype.valueStream = LevelUP.prototype.createValueStream = function(options) {
      return this.createReadStream(Object.assign({}, options, { keys: false, values: true }));
    };
    LevelUP.prototype.toString = function() {
      return "LevelUP";
    };
    LevelUP.prototype.type = "levelup";
    LevelUP.prototype._nextTick = nextTick;
    function maybeError(db, callback) {
      if (!db.isOperational()) {
        nextTick(callback, new ReadError("Database is not open"));
        return true;
      }
      return false;
    }
    LevelUP.errors = errors2;
    module2.exports = LevelUP;
  }
});

// node_modules/level-codec/lib/encodings.js
var require_encodings = __commonJS({
  "node_modules/level-codec/lib/encodings.js"(exports2) {
    init_node_globals();
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    exports2.utf8 = exports2["utf-8"] = {
      encode: function(data) {
        return isBinary2(data) ? data : String(data);
      },
      decode: identity3,
      buffer: false,
      type: "utf8"
    };
    exports2.json = {
      encode: JSON.stringify,
      decode: JSON.parse,
      buffer: false,
      type: "json"
    };
    exports2.binary = {
      encode: function(data) {
        return isBinary2(data) ? data : Buffer2.from(data);
      },
      decode: identity3,
      buffer: true,
      type: "binary"
    };
    exports2.none = {
      encode: identity3,
      decode: identity3,
      buffer: false,
      type: "id"
    };
    exports2.id = exports2.none;
    var bufferEncodings = [
      "hex",
      "ascii",
      "base64",
      "ucs2",
      "ucs-2",
      "utf16le",
      "utf-16le"
    ];
    for (const type of bufferEncodings) {
      exports2[type] = {
        encode: function(data) {
          return isBinary2(data) ? data : Buffer2.from(data, type);
        },
        decode: function(buffer2) {
          return buffer2.toString(type);
        },
        buffer: true,
        type
      };
    }
    function identity3(value) {
      return value;
    }
    function isBinary2(data) {
      return data === void 0 || data === null || Buffer2.isBuffer(data);
    }
  }
});

// node_modules/level-codec/index.js
var require_level_codec = __commonJS({
  "node_modules/level-codec/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var encodings = require_encodings();
    var rangeOptions = new Set(["lt", "gt", "lte", "gte"]);
    module2.exports = Codec2;
    function Codec2(opts) {
      if (!(this instanceof Codec2)) {
        return new Codec2(opts);
      }
      this.opts = opts || {};
      this.encodings = encodings;
    }
    Codec2.prototype._encoding = function(encoding) {
      if (typeof encoding === "string")
        encoding = encodings[encoding];
      if (!encoding)
        encoding = encodings.id;
      return encoding;
    };
    Codec2.prototype._keyEncoding = function(opts, batchOpts) {
      return this._encoding(batchOpts && batchOpts.keyEncoding || opts && opts.keyEncoding || this.opts.keyEncoding);
    };
    Codec2.prototype._valueEncoding = function(opts, batchOpts) {
      return this._encoding(batchOpts && (batchOpts.valueEncoding || batchOpts.encoding) || opts && (opts.valueEncoding || opts.encoding) || (this.opts.valueEncoding || this.opts.encoding));
    };
    Codec2.prototype.encodeKey = function(key, opts, batchOpts) {
      return this._keyEncoding(opts, batchOpts).encode(key);
    };
    Codec2.prototype.encodeValue = function(value, opts, batchOpts) {
      return this._valueEncoding(opts, batchOpts).encode(value);
    };
    Codec2.prototype.decodeKey = function(key, opts) {
      return this._keyEncoding(opts).decode(key);
    };
    Codec2.prototype.decodeValue = function(value, opts) {
      return this._valueEncoding(opts).decode(value);
    };
    Codec2.prototype.encodeBatch = function(ops, opts) {
      return ops.map((_op) => {
        const op = {
          type: _op.type,
          key: this.encodeKey(_op.key, opts, _op)
        };
        if (this.keyAsBuffer(opts, _op))
          op.keyEncoding = "binary";
        if (_op.prefix)
          op.prefix = _op.prefix;
        if ("value" in _op) {
          op.value = this.encodeValue(_op.value, opts, _op);
          if (this.valueAsBuffer(opts, _op))
            op.valueEncoding = "binary";
        }
        return op;
      });
    };
    Codec2.prototype.encodeLtgt = function(ltgt) {
      const ret = {};
      for (const key of Object.keys(ltgt)) {
        if (key === "start" || key === "end") {
          throw new Error('Legacy range options ("start" and "end") have been removed');
        }
        ret[key] = rangeOptions.has(key) ? this.encodeKey(ltgt[key], ltgt) : ltgt[key];
      }
      return ret;
    };
    Codec2.prototype.createStreamDecoder = function(opts) {
      if (opts.keys && opts.values) {
        return (key, value) => {
          return {
            key: this.decodeKey(key, opts),
            value: this.decodeValue(value, opts)
          };
        };
      } else if (opts.keys) {
        return (key) => {
          return this.decodeKey(key, opts);
        };
      } else if (opts.values) {
        return (_, value) => {
          return this.decodeValue(value, opts);
        };
      } else {
        return function() {
        };
      }
    };
    Codec2.prototype.keyAsBuffer = function(opts) {
      return this._keyEncoding(opts).buffer;
    };
    Codec2.prototype.valueAsBuffer = function(opts) {
      return this._valueEncoding(opts).buffer;
    };
  }
});

// node_modules/encoding-down/index.js
var require_encoding_down = __commonJS({
  "node_modules/encoding-down/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var AbstractLevelDOWN = require_abstract_leveldown2().AbstractLevelDOWN;
    var AbstractChainedBatch = require_abstract_leveldown2().AbstractChainedBatch;
    var AbstractIterator = require_abstract_leveldown2().AbstractIterator;
    var inherits = require_inherits_browser();
    var Codec2 = require_level_codec();
    var EncodingError = require_errors2().EncodingError;
    var rangeMethods = ["approximateSize", "compactRange"];
    module2.exports = DB;
    function DB(db, opts) {
      if (!(this instanceof DB))
        return new DB(db, opts);
      const manifest = db.supports || {};
      const additionalMethods = manifest.additionalMethods || {};
      AbstractLevelDOWN.call(this, manifest);
      this.supports.encodings = true;
      this.supports.additionalMethods = {};
      rangeMethods.forEach(function(m) {
        const fallback = typeof db[m] === "function";
        if (additionalMethods[m] || fallback) {
          this.supports.additionalMethods[m] = true;
          this[m] = function(start, end, opts2, cb) {
            start = this.codec.encodeKey(start, opts2);
            end = this.codec.encodeKey(end, opts2);
            return this.db[m](start, end, opts2, cb);
          };
        }
      }, this);
      opts = opts || {};
      if (typeof opts.keyEncoding === "undefined")
        opts.keyEncoding = "utf8";
      if (typeof opts.valueEncoding === "undefined")
        opts.valueEncoding = "utf8";
      this.db = db;
      this.codec = new Codec2(opts);
    }
    inherits(DB, AbstractLevelDOWN);
    DB.prototype.type = "encoding-down";
    DB.prototype._serializeKey = DB.prototype._serializeValue = function(datum) {
      return datum;
    };
    DB.prototype._open = function(opts, cb) {
      this.db.open(opts, cb);
    };
    DB.prototype._close = function(cb) {
      this.db.close(cb);
    };
    DB.prototype._put = function(key, value, opts, cb) {
      key = this.codec.encodeKey(key, opts);
      value = this.codec.encodeValue(value, opts);
      this.db.put(key, value, opts, cb);
    };
    DB.prototype._get = function(key, opts, cb) {
      key = this.codec.encodeKey(key, opts);
      opts.asBuffer = this.codec.valueAsBuffer(opts);
      this.db.get(key, opts, (err, value) => {
        if (err)
          return cb(err);
        try {
          value = this.codec.decodeValue(value, opts);
        } catch (err2) {
          return cb(new EncodingError(err2));
        }
        cb(null, value);
      });
    };
    DB.prototype._getMany = function(keys, opts, cb) {
      keys = keys.map((key) => this.codec.encodeKey(key, opts));
      opts.asBuffer = this.codec.valueAsBuffer(opts);
      this.db.getMany(keys, opts, (err, values) => {
        if (err)
          return cb(err);
        const decoded = new Array(values.length);
        for (let i = 0; i < values.length; i++) {
          if (values[i] === void 0) {
            decoded[i] = void 0;
            continue;
          }
          try {
            decoded[i] = this.codec.decodeValue(values[i], opts);
          } catch (err2) {
            return cb(new EncodingError(err2));
          }
        }
        cb(null, decoded);
      });
    };
    DB.prototype._del = function(key, opts, cb) {
      key = this.codec.encodeKey(key, opts);
      this.db.del(key, opts, cb);
    };
    DB.prototype._chainedBatch = function() {
      return new Batch(this);
    };
    DB.prototype._batch = function(ops, opts, cb) {
      ops = this.codec.encodeBatch(ops, opts);
      this.db.batch(ops, opts, cb);
    };
    DB.prototype._iterator = function(opts) {
      opts.keyAsBuffer = this.codec.keyAsBuffer(opts);
      opts.valueAsBuffer = this.codec.valueAsBuffer(opts);
      return new Iterator(this, opts);
    };
    DB.prototype._clear = function(opts, callback) {
      opts = this.codec.encodeLtgt(opts);
      this.db.clear(opts, callback);
    };
    function Iterator(db, opts) {
      AbstractIterator.call(this, db);
      this.codec = db.codec;
      this.keys = opts.keys;
      this.values = opts.values;
      this.opts = this.codec.encodeLtgt(opts);
      this.it = db.db.iterator(this.opts);
    }
    inherits(Iterator, AbstractIterator);
    Iterator.prototype._next = function(cb) {
      this.it.next((err, key, value) => {
        if (err)
          return cb(err);
        try {
          if (this.keys && typeof key !== "undefined") {
            key = this.codec.decodeKey(key, this.opts);
          } else {
            key = void 0;
          }
          if (this.values && typeof value !== "undefined") {
            value = this.codec.decodeValue(value, this.opts);
          } else {
            value = void 0;
          }
        } catch (err2) {
          return cb(new EncodingError(err2));
        }
        cb(null, key, value);
      });
    };
    Iterator.prototype._seek = function(key) {
      key = this.codec.encodeKey(key, this.opts);
      this.it.seek(key);
    };
    Iterator.prototype._end = function(cb) {
      this.it.end(cb);
    };
    function Batch(db, codec) {
      AbstractChainedBatch.call(this, db);
      this.codec = db.codec;
      this.batch = db.db.batch();
    }
    inherits(Batch, AbstractChainedBatch);
    Batch.prototype._put = function(key, value, options) {
      key = this.codec.encodeKey(key, options);
      value = this.codec.encodeValue(value, options);
      this.batch.put(key, value);
    };
    Batch.prototype._del = function(key, options) {
      key = this.codec.encodeKey(key, options);
      this.batch.del(key);
    };
    Batch.prototype._clear = function() {
      this.batch.clear();
    };
    Batch.prototype._write = function(opts, cb) {
      this.batch.write(opts, cb);
    };
  }
});

// node_modules/level-packager/level-packager.js
var require_level_packager = __commonJS({
  "node_modules/level-packager/level-packager.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var levelup = require_levelup();
    var encode10 = require_encoding_down();
    function packager(leveldown) {
      function Level2(location2, options, callback) {
        if (typeof location2 === "function") {
          callback = location2;
        } else if (typeof options === "function") {
          callback = options;
        }
        if (!isObject(options)) {
          options = isObject(location2) ? location2 : {};
        }
        return levelup(encode10(leveldown(location2, options), options), options, callback);
      }
      function isObject(o) {
        return typeof o === "object" && o !== null;
      }
      for (const m of ["destroy", "repair"]) {
        if (typeof leveldown[m] === "function") {
          Level2[m] = function(...args) {
            leveldown[m](...args);
          };
        }
      }
      Level2.errors = levelup.errors;
      return Level2;
    }
    module2.exports = packager;
  }
});

// node_modules/run-parallel-limit/index.js
var require_run_parallel_limit = __commonJS({
  "node_modules/run-parallel-limit/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = runParallelLimit;
    var queueMicrotask2 = require_queue_microtask2();
    function runParallelLimit(tasks, limit, cb) {
      if (typeof limit !== "number")
        throw new Error("second argument must be a Number");
      let results, len, pending, keys, isErrored;
      let isSync = true;
      let next;
      if (Array.isArray(tasks)) {
        results = [];
        pending = len = tasks.length;
      } else {
        keys = Object.keys(tasks);
        results = {};
        pending = len = keys.length;
      }
      function done(err) {
        function end() {
          if (cb)
            cb(err, results);
          cb = null;
        }
        if (isSync)
          queueMicrotask2(end);
        else
          end();
      }
      function each(i, err, result) {
        results[i] = result;
        if (err)
          isErrored = true;
        if (--pending === 0 || err) {
          done(err);
        } else if (!isErrored && next < len) {
          let key;
          if (keys) {
            key = keys[next];
            next += 1;
            tasks[key](function(err2, result2) {
              each(key, err2, result2);
            });
          } else {
            key = next;
            next += 1;
            tasks[key](function(err2, result2) {
              each(key, err2, result2);
            });
          }
        }
      }
      next = limit;
      if (!pending) {
        done(null);
      } else if (keys) {
        keys.some(function(key, i) {
          tasks[key](function(err, result) {
            each(key, err, result);
          });
          if (i === limit - 1)
            return true;
          return false;
        });
      } else {
        tasks.some(function(task, i) {
          task(function(err, result) {
            each(i, err, result);
          });
          if (i === limit - 1)
            return true;
          return false;
        });
      }
      isSync = false;
    }
  }
});

// node_modules/ltgt/index.js
var require_ltgt = __commonJS({
  "node_modules/ltgt/index.js"(exports2) {
    init_node_globals();
    exports2.compare = function(a, b) {
      if (Buffer.isBuffer(a)) {
        var l = Math.min(a.length, b.length);
        for (var i = 0; i < l; i++) {
          var cmp = a[i] - b[i];
          if (cmp)
            return cmp;
        }
        return a.length - b.length;
      }
      return a < b ? -1 : a > b ? 1 : 0;
    };
    function isDef(val) {
      return val !== void 0 && val !== "";
    }
    function has(range, name5) {
      return Object.hasOwnProperty.call(range, name5);
    }
    function hasKey(range, name5) {
      return Object.hasOwnProperty.call(range, name5) && name5;
    }
    var lowerBoundKey = exports2.lowerBoundKey = function(range) {
      return hasKey(range, "gt") || hasKey(range, "gte") || hasKey(range, "min") || (range.reverse ? hasKey(range, "end") : hasKey(range, "start")) || void 0;
    };
    var lowerBound = exports2.lowerBound = function(range, def) {
      var k = lowerBoundKey(range);
      return k ? range[k] : def;
    };
    var lowerBoundInclusive = exports2.lowerBoundInclusive = function(range) {
      return has(range, "gt") ? false : true;
    };
    var upperBoundInclusive = exports2.upperBoundInclusive = function(range) {
      return has(range, "lt") ? false : true;
    };
    var lowerBoundExclusive = exports2.lowerBoundExclusive = function(range) {
      return !lowerBoundInclusive(range);
    };
    var upperBoundExclusive = exports2.upperBoundExclusive = function(range) {
      return !upperBoundInclusive(range);
    };
    var upperBoundKey = exports2.upperBoundKey = function(range) {
      return hasKey(range, "lt") || hasKey(range, "lte") || hasKey(range, "max") || (range.reverse ? hasKey(range, "start") : hasKey(range, "end")) || void 0;
    };
    var upperBound = exports2.upperBound = function(range, def) {
      var k = upperBoundKey(range);
      return k ? range[k] : def;
    };
    exports2.start = function(range, def) {
      return range.reverse ? upperBound(range, def) : lowerBound(range, def);
    };
    exports2.end = function(range, def) {
      return range.reverse ? lowerBound(range, def) : upperBound(range, def);
    };
    exports2.startInclusive = function(range) {
      return range.reverse ? upperBoundInclusive(range) : lowerBoundInclusive(range);
    };
    exports2.endInclusive = function(range) {
      return range.reverse ? lowerBoundInclusive(range) : upperBoundInclusive(range);
    };
    function id(e) {
      return e;
    }
    exports2.toLtgt = function(range, _range, map8, lower, upper) {
      _range = _range || {};
      map8 = map8 || id;
      var defaults = arguments.length > 3;
      var lb = exports2.lowerBoundKey(range);
      var ub = exports2.upperBoundKey(range);
      if (lb) {
        if (lb === "gt")
          _range.gt = map8(range.gt, false);
        else
          _range.gte = map8(range[lb], false);
      } else if (defaults)
        _range.gte = map8(lower, false);
      if (ub) {
        if (ub === "lt")
          _range.lt = map8(range.lt, true);
        else
          _range.lte = map8(range[ub], true);
      } else if (defaults)
        _range.lte = map8(upper, true);
      if (range.reverse != null)
        _range.reverse = !!range.reverse;
      if (has(_range, "max"))
        delete _range.max;
      if (has(_range, "min"))
        delete _range.min;
      if (has(_range, "start"))
        delete _range.start;
      if (has(_range, "end"))
        delete _range.end;
      return _range;
    };
    exports2.contains = function(range, key, compare3) {
      compare3 = compare3 || exports2.compare;
      var lb = lowerBound(range);
      if (isDef(lb)) {
        var cmp = compare3(key, lb);
        if (cmp < 0 || cmp === 0 && lowerBoundExclusive(range))
          return false;
      }
      var ub = upperBound(range);
      if (isDef(ub)) {
        var cmp = compare3(key, ub);
        if (cmp > 0 || cmp === 0 && upperBoundExclusive(range))
          return false;
      }
      return true;
    };
    exports2.filter = function(range, compare3) {
      return function(key) {
        return exports2.contains(range, key, compare3);
      };
    };
  }
});

// node_modules/level-js/util/key-range.js
var require_key_range = __commonJS({
  "node_modules/level-js/util/key-range.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var ltgt = require_ltgt();
    var NONE = Symbol("none");
    module2.exports = function createKeyRange(options) {
      const lower = ltgt.lowerBound(options, NONE);
      const upper = ltgt.upperBound(options, NONE);
      const lowerOpen = ltgt.lowerBoundExclusive(options, NONE);
      const upperOpen = ltgt.upperBoundExclusive(options, NONE);
      if (lower !== NONE && upper !== NONE) {
        return IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen);
      } else if (lower !== NONE) {
        return IDBKeyRange.lowerBound(lower, lowerOpen);
      } else if (upper !== NONE) {
        return IDBKeyRange.upperBound(upper, upperOpen);
      } else {
        return null;
      }
    };
  }
});

// node_modules/level-js/util/deserialize.js
var require_deserialize = __commonJS({
  "node_modules/level-js/util/deserialize.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var Buffer2 = require_buffer().Buffer;
    var ta2str = function() {
      if (global.TextDecoder) {
        const decoder = new TextDecoder("utf-8");
        return decoder.decode.bind(decoder);
      } else {
        return function ta2str2(ta) {
          return ta2buf(ta).toString();
        };
      }
    }();
    var ab2str = function() {
      if (global.TextDecoder) {
        const decoder = new TextDecoder("utf-8");
        return decoder.decode.bind(decoder);
      } else {
        return function ab2str2(ab) {
          return Buffer2.from(ab).toString();
        };
      }
    }();
    function ta2buf(ta) {
      const buf2 = Buffer2.from(ta.buffer);
      if (ta.byteLength === ta.buffer.byteLength) {
        return buf2;
      } else {
        return buf2.slice(ta.byteOffset, ta.byteOffset + ta.byteLength);
      }
    }
    module2.exports = function(data, asBuffer) {
      if (data instanceof Uint8Array) {
        return asBuffer ? ta2buf(data) : ta2str(data);
      } else if (data instanceof ArrayBuffer) {
        return asBuffer ? Buffer2.from(data) : ab2str(data);
      } else {
        return asBuffer ? Buffer2.from(String(data)) : String(data);
      }
    };
  }
});

// node_modules/level-js/iterator.js
var require_iterator = __commonJS({
  "node_modules/level-js/iterator.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var inherits = require_inherits_browser();
    var AbstractIterator = require_abstract_leveldown2().AbstractIterator;
    var createKeyRange = require_key_range();
    var deserialize = require_deserialize();
    var noop2 = function() {
    };
    module2.exports = Iterator;
    function Iterator(db, location2, options) {
      AbstractIterator.call(this, db);
      this._limit = options.limit;
      this._count = 0;
      this._callback = null;
      this._cache = [];
      this._completed = false;
      this._aborted = false;
      this._error = null;
      this._transaction = null;
      this._keys = options.keys;
      this._values = options.values;
      this._keyAsBuffer = options.keyAsBuffer;
      this._valueAsBuffer = options.valueAsBuffer;
      if (this._limit === 0) {
        this._completed = true;
        return;
      }
      let keyRange;
      try {
        keyRange = createKeyRange(options);
      } catch (e) {
        this._completed = true;
        return;
      }
      this.createIterator(location2, keyRange, options.reverse);
    }
    inherits(Iterator, AbstractIterator);
    Iterator.prototype.createIterator = function(location2, keyRange, reverse) {
      const transaction = this.db.db.transaction([location2], "readonly");
      const store = transaction.objectStore(location2);
      const req = store.openCursor(keyRange, reverse ? "prev" : "next");
      req.onsuccess = (ev) => {
        const cursor = ev.target.result;
        if (cursor)
          this.onItem(cursor);
      };
      this._transaction = transaction;
      transaction.onabort = () => {
        this.onAbort(this._transaction.error || new Error("aborted by user"));
      };
      transaction.oncomplete = () => {
        this.onComplete();
      };
    };
    Iterator.prototype.onItem = function(cursor) {
      this._cache.push(cursor.key, cursor.value);
      if (this._limit <= 0 || ++this._count < this._limit) {
        cursor.continue();
      }
      this.maybeNext();
    };
    Iterator.prototype.onAbort = function(err) {
      this._aborted = true;
      this._error = err;
      this.maybeNext();
    };
    Iterator.prototype.onComplete = function() {
      this._completed = true;
      this.maybeNext();
    };
    Iterator.prototype.maybeNext = function() {
      if (this._callback) {
        this._next(this._callback);
        this._callback = null;
      }
    };
    Iterator.prototype._next = function(callback) {
      if (this._aborted) {
        const err = this._error;
        this._error = null;
        this._nextTick(callback, err);
      } else if (this._cache.length > 0) {
        let key = this._cache.shift();
        let value = this._cache.shift();
        if (this._keys && key !== void 0) {
          key = this._deserializeKey(key, this._keyAsBuffer);
        } else {
          key = void 0;
        }
        if (this._values && value !== void 0) {
          value = this._deserializeValue(value, this._valueAsBuffer);
        } else {
          value = void 0;
        }
        this._nextTick(callback, null, key, value);
      } else if (this._completed) {
        this._nextTick(callback);
      } else {
        this._callback = callback;
      }
    };
    Iterator.prototype._deserializeKey = deserialize;
    Iterator.prototype._deserializeValue = deserialize;
    Iterator.prototype._end = function(callback) {
      if (this._aborted || this._completed) {
        return this._nextTick(callback, this._error);
      }
      this.onItem = noop2;
      this.onAbort = callback;
      this.onComplete = callback;
    };
  }
});

// node_modules/level-js/util/serialize.js
var require_serialize = __commonJS({
  "node_modules/level-js/util/serialize.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var Buffer2 = require_buffer().Buffer;
    var str2bin = function() {
      if (global.TextEncoder) {
        const encoder = new TextEncoder("utf-8");
        return encoder.encode.bind(encoder);
      } else {
        return Buffer2.from;
      }
    }();
    module2.exports = function(data, asBuffer) {
      if (asBuffer) {
        return Buffer2.isBuffer(data) ? data : str2bin(String(data));
      } else {
        return String(data);
      }
    };
  }
});

// node_modules/level-js/util/support.js
var require_support = __commonJS({
  "node_modules/level-js/util/support.js"(exports2) {
    init_node_globals();
    "use strict";
    var Buffer2 = require_buffer().Buffer;
    exports2.test = function(key) {
      return function test(impl) {
        try {
          impl.cmp(key, 0);
          return true;
        } catch (err) {
          return false;
        }
      };
    };
    exports2.bufferKeys = exports2.test(Buffer2.alloc(0));
  }
});

// node_modules/level-js/util/clear.js
var require_clear2 = __commonJS({
  "node_modules/level-js/util/clear.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = function clear(db, location2, keyRange, options, callback) {
      if (options.limit === 0)
        return db._nextTick(callback);
      const transaction = db.db.transaction([location2], "readwrite");
      const store = transaction.objectStore(location2);
      let count = 0;
      transaction.oncomplete = function() {
        callback();
      };
      transaction.onabort = function() {
        callback(transaction.error || new Error("aborted by user"));
      };
      const method = store.openKeyCursor ? "openKeyCursor" : "openCursor";
      const direction = options.reverse ? "prev" : "next";
      store[method](keyRange, direction).onsuccess = function(ev) {
        const cursor = ev.target.result;
        if (cursor) {
          store.delete(cursor.key).onsuccess = function() {
            if (options.limit <= 0 || ++count < options.limit) {
              cursor.continue();
            }
          };
        }
      };
    };
  }
});

// node_modules/level-js/index.js
var require_level_js = __commonJS({
  "node_modules/level-js/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = Level2;
    var AbstractLevelDOWN = require_abstract_leveldown2().AbstractLevelDOWN;
    var inherits = require_inherits_browser();
    var parallel = require_run_parallel_limit();
    var Iterator = require_iterator();
    var serialize = require_serialize();
    var deserialize = require_deserialize();
    var support = require_support();
    var clear = require_clear2();
    var createKeyRange = require_key_range();
    var DEFAULT_PREFIX = "level-js-";
    function Level2(location2, opts) {
      if (!(this instanceof Level2))
        return new Level2(location2, opts);
      AbstractLevelDOWN.call(this, {
        bufferKeys: support.bufferKeys(indexedDB),
        snapshots: true,
        permanence: true,
        clear: true,
        getMany: true
      });
      opts = opts || {};
      if (typeof location2 !== "string") {
        throw new Error("constructor requires a location string argument");
      }
      this.location = location2;
      this.prefix = opts.prefix == null ? DEFAULT_PREFIX : opts.prefix;
      this.version = parseInt(opts.version || 1, 10);
    }
    inherits(Level2, AbstractLevelDOWN);
    Level2.prototype.type = "level-js";
    Level2.prototype._open = function(options, callback) {
      const req = indexedDB.open(this.prefix + this.location, this.version);
      req.onerror = function() {
        callback(req.error || new Error("unknown error"));
      };
      req.onsuccess = () => {
        this.db = req.result;
        callback();
      };
      req.onupgradeneeded = (ev) => {
        const db = ev.target.result;
        if (!db.objectStoreNames.contains(this.location)) {
          db.createObjectStore(this.location);
        }
      };
    };
    Level2.prototype.store = function(mode) {
      const transaction = this.db.transaction([this.location], mode);
      return transaction.objectStore(this.location);
    };
    Level2.prototype.await = function(request, callback) {
      const transaction = request.transaction;
      transaction.onabort = function() {
        callback(transaction.error || new Error("aborted by user"));
      };
      transaction.oncomplete = function() {
        callback(null, request.result);
      };
    };
    Level2.prototype._get = function(key, options, callback) {
      const store = this.store("readonly");
      let req;
      try {
        req = store.get(key);
      } catch (err) {
        return this._nextTick(callback, err);
      }
      this.await(req, function(err, value) {
        if (err)
          return callback(err);
        if (value === void 0) {
          return callback(new Error("NotFound"));
        }
        callback(null, deserialize(value, options.asBuffer));
      });
    };
    Level2.prototype._getMany = function(keys, options, callback) {
      const asBuffer = options.asBuffer;
      const store = this.store("readonly");
      const tasks = keys.map((key) => (next) => {
        let request;
        try {
          request = store.get(key);
        } catch (err) {
          return next(err);
        }
        request.onsuccess = () => {
          const value = request.result;
          next(null, value === void 0 ? value : deserialize(value, asBuffer));
        };
        request.onerror = (ev) => {
          ev.stopPropagation();
          next(request.error);
        };
      });
      parallel(tasks, 16, callback);
    };
    Level2.prototype._del = function(key, options, callback) {
      const store = this.store("readwrite");
      let req;
      try {
        req = store.delete(key);
      } catch (err) {
        return this._nextTick(callback, err);
      }
      this.await(req, callback);
    };
    Level2.prototype._put = function(key, value, options, callback) {
      const store = this.store("readwrite");
      let req;
      try {
        req = store.put(value, key);
      } catch (err) {
        return this._nextTick(callback, err);
      }
      this.await(req, callback);
    };
    Level2.prototype._serializeKey = function(key) {
      return serialize(key, this.supports.bufferKeys);
    };
    Level2.prototype._serializeValue = function(value) {
      return serialize(value, true);
    };
    Level2.prototype._iterator = function(options) {
      return new Iterator(this, this.location, options);
    };
    Level2.prototype._batch = function(operations, options, callback) {
      if (operations.length === 0)
        return this._nextTick(callback);
      const store = this.store("readwrite");
      const transaction = store.transaction;
      let index = 0;
      let error;
      transaction.onabort = function() {
        callback(error || transaction.error || new Error("aborted by user"));
      };
      transaction.oncomplete = function() {
        callback();
      };
      function loop() {
        const op = operations[index++];
        const key = op.key;
        let req;
        try {
          req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
        } catch (err) {
          error = err;
          transaction.abort();
          return;
        }
        if (index < operations.length) {
          req.onsuccess = loop;
        }
      }
      loop();
    };
    Level2.prototype._clear = function(options, callback) {
      let keyRange;
      let req;
      try {
        keyRange = createKeyRange(options);
      } catch (e) {
        return this._nextTick(callback);
      }
      if (options.limit >= 0) {
        return clear(this, this.location, keyRange, options, callback);
      }
      try {
        const store = this.store("readwrite");
        req = keyRange ? store.delete(keyRange) : store.clear();
      } catch (err) {
        return this._nextTick(callback, err);
      }
      this.await(req, callback);
    };
    Level2.prototype._close = function(callback) {
      this.db.close();
      this._nextTick(callback);
    };
    Level2.prototype.upgrade = function(callback) {
      if (this.status !== "open") {
        return this._nextTick(callback, new Error("cannot upgrade() before open()"));
      }
      const it = this.iterator();
      const batchOptions = {};
      const self2 = this;
      it._deserializeKey = it._deserializeValue = identity3;
      next();
      function next(err) {
        if (err)
          return finish(err);
        it.next(each);
      }
      function each(err, key, value) {
        if (err || key === void 0) {
          return finish(err);
        }
        const newKey = self2._serializeKey(deserialize(key, true));
        const newValue = self2._serializeValue(deserialize(value, true));
        self2._batch([
          { type: "del", key },
          { type: "put", key: newKey, value: newValue }
        ], batchOptions, next);
      }
      function finish(err) {
        it.end(function(err2) {
          callback(err || err2);
        });
      }
      function identity3(data) {
        return data;
      }
    };
    Level2.destroy = function(location2, prefix, callback) {
      if (typeof prefix === "function") {
        callback = prefix;
        prefix = DEFAULT_PREFIX;
      }
      const request = indexedDB.deleteDatabase(prefix + location2);
      request.onsuccess = function() {
        callback();
      };
      request.onerror = function(err) {
        callback(err);
      };
    };
  }
});

// node_modules/level/browser.js
var require_browser7 = __commonJS({
  "node_modules/level/browser.js"(exports2, module2) {
    init_node_globals();
    module2.exports = require_level_packager()(require_level_js());
  }
});

// node_modules/datastore-level/esm/src/index.js
function levelIteratorToIterator(li) {
  return {
    [Symbol.asyncIterator]() {
      return {
        next: () => new Promise((resolve6, reject) => {
          li.next((err, key, value) => {
            if (err)
              return reject(err);
            if (key == null) {
              return li.end((err2) => {
                if (err2)
                  return reject(err2);
                resolve6({
                  done: true,
                  value: void 0
                });
              });
            }
            resolve6({
              done: false,
              value: {
                key: new Key(key, false),
                value
              }
            });
          });
        }),
        return: () => new Promise((resolve6, reject) => {
          li.end((err) => {
            if (err)
              return reject(err);
            resolve6({
              done: true,
              value: void 0
            });
          });
        })
      };
    }
  };
}
var import_it_filter5, import_it_map6, import_it_take3, import_it_sort, import_level3, LevelDatastore;
var init_src12 = __esm({
  "node_modules/datastore-level/esm/src/index.js"() {
    init_node_globals();
    init_src5();
    init_src6();
    import_it_filter5 = __toModule(require_it_filter());
    import_it_map6 = __toModule(require_it_map());
    import_it_take3 = __toModule(require_it_take());
    import_it_sort = __toModule(require_it_sort());
    import_level3 = __toModule(require_browser7());
    LevelDatastore = class extends BaseDatastore {
      constructor(path, opts) {
        super();
        this.path = path;
        this.opts = opts;
        if (opts && opts.db) {
          this.database = opts.db;
          delete opts.db;
        } else {
          this.database = import_level3.default;
        }
      }
      _initDb() {
        return new Promise((resolve6, reject) => {
          this.db = this.database(this.path, {
            ...this.opts,
            valueEncoding: "binary",
            compression: false
          }, (err) => {
            if (err) {
              return reject(err);
            }
            resolve6(this.db);
          });
        });
      }
      async open() {
        try {
          if (this.db) {
            await this.db.open();
          } else {
            this.db = await this._initDb();
          }
        } catch (err) {
          throw Errors5.dbOpenFailedError(err);
        }
      }
      async put(key, value) {
        try {
          await this.db.put(key.toString(), value);
        } catch (err) {
          throw Errors5.dbWriteFailedError(err);
        }
      }
      async get(key) {
        let data;
        try {
          data = await this.db.get(key.toString());
        } catch (err) {
          if (err.notFound)
            throw Errors5.notFoundError(err);
          throw Errors5.dbWriteFailedError(err);
        }
        return data;
      }
      async has(key) {
        try {
          await this.db.get(key.toString());
        } catch (err) {
          if (err.notFound)
            return false;
          throw err;
        }
        return true;
      }
      async delete(key) {
        try {
          await this.db.del(key.toString());
        } catch (err) {
          throw Errors5.dbDeleteFailedError(err);
        }
      }
      close() {
        return this.db && this.db.close();
      }
      batch() {
        const ops = [];
        return {
          put: (key, value) => {
            ops.push({
              type: "put",
              key: key.toString(),
              value
            });
          },
          delete: (key) => {
            ops.push({
              type: "del",
              key: key.toString()
            });
          },
          commit: () => {
            return this.db.batch(ops);
          }
        };
      }
      query(q) {
        let it = this._query({
          values: true,
          prefix: q.prefix
        });
        if (Array.isArray(q.filters)) {
          it = q.filters.reduce((it2, f) => (0, import_it_filter5.default)(it2, f), it);
        }
        if (Array.isArray(q.orders)) {
          it = q.orders.reduce((it2, f) => (0, import_it_sort.default)(it2, f), it);
        }
        const { offset, limit } = q;
        if (offset) {
          let i = 0;
          it = (0, import_it_filter5.default)(it, () => i++ >= offset);
        }
        if (limit) {
          it = (0, import_it_take3.default)(it, limit);
        }
        return it;
      }
      queryKeys(q) {
        let it = (0, import_it_map6.default)(this._query({
          values: false,
          prefix: q.prefix
        }), ({ key }) => key);
        if (Array.isArray(q.filters)) {
          it = q.filters.reduce((it2, f) => (0, import_it_filter5.default)(it2, f), it);
        }
        if (Array.isArray(q.orders)) {
          it = q.orders.reduce((it2, f) => (0, import_it_sort.default)(it2, f), it);
        }
        const { offset, limit } = q;
        if (offset) {
          let i = 0;
          it = (0, import_it_filter5.default)(it, () => i++ >= offset);
        }
        if (limit) {
          it = (0, import_it_take3.default)(it, limit);
        }
        return it;
      }
      _query(opts) {
        const iteratorOpts = {
          keys: true,
          keyAsBuffer: true,
          values: opts.values
        };
        if (opts.prefix != null) {
          const prefix = opts.prefix.toString();
          iteratorOpts.gte = prefix;
          iteratorOpts.lt = prefix + "\xFF";
        }
        return levelIteratorToIterator(this.db.iterator(iteratorOpts));
      }
    };
  }
});

// node_modules/blockstore-core/esm/src/base.js
var import_it_drain4, import_it_filter6, import_it_take4, import_it_all4, sortAll2, BaseBlockstore;
var init_base4 = __esm({
  "node_modules/blockstore-core/esm/src/base.js"() {
    init_node_globals();
    import_it_drain4 = __toModule(require_it_drain());
    import_it_filter6 = __toModule(require_it_filter());
    import_it_take4 = __toModule(require_it_take());
    import_it_all4 = __toModule(require_it_all());
    sortAll2 = (iterable, sorter) => {
      return async function* () {
        const values = await (0, import_it_all4.default)(iterable);
        yield* values.sort(sorter);
      }();
    };
    BaseBlockstore = class {
      open() {
        return Promise.reject(new Error(".open is not implemented"));
      }
      close() {
        return Promise.reject(new Error(".close is not implemented"));
      }
      put(key, val, options) {
        return Promise.reject(new Error(".put is not implemented"));
      }
      get(key, options) {
        return Promise.reject(new Error(".get is not implemented"));
      }
      has(key, options) {
        return Promise.reject(new Error(".has is not implemented"));
      }
      delete(key, options) {
        return Promise.reject(new Error(".delete is not implemented"));
      }
      async *putMany(source, options = {}) {
        for await (const { key, value } of source) {
          await this.put(key, value, options);
          yield {
            key,
            value
          };
        }
      }
      async *getMany(source, options = {}) {
        for await (const key of source) {
          yield this.get(key, options);
        }
      }
      async *deleteMany(source, options = {}) {
        for await (const key of source) {
          await this.delete(key, options);
          yield key;
        }
      }
      batch() {
        let puts = [];
        let dels = [];
        return {
          put(key, value) {
            puts.push({
              key,
              value
            });
          },
          delete(key) {
            dels.push(key);
          },
          commit: async (options) => {
            await (0, import_it_drain4.default)(this.putMany(puts, options));
            puts = [];
            await (0, import_it_drain4.default)(this.deleteMany(dels, options));
            dels = [];
          }
        };
      }
      async *_all(q, options) {
        throw new Error("._all is not implemented");
      }
      async *_allKeys(q, options) {
        throw new Error("._allKeys is not implemented");
      }
      query(q, options) {
        let it = this._all(q, options);
        if (q.prefix != null) {
          it = (0, import_it_filter6.default)(it, (e) => e.key.toString().startsWith(q.prefix || ""));
        }
        if (Array.isArray(q.filters)) {
          it = q.filters.reduce((it2, f) => (0, import_it_filter6.default)(it2, f), it);
        }
        if (Array.isArray(q.orders)) {
          it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
        }
        if (q.offset != null) {
          let i = 0;
          it = (0, import_it_filter6.default)(it, () => i++ >= (q.offset || 0));
        }
        if (q.limit != null) {
          it = (0, import_it_take4.default)(it, q.limit);
        }
        return it;
      }
      queryKeys(q, options) {
        let it = this._allKeys(q, options);
        if (q.prefix != null) {
          it = (0, import_it_filter6.default)(it, (cid) => cid.toString().startsWith(q.prefix || ""));
        }
        if (Array.isArray(q.filters)) {
          it = q.filters.reduce((it2, f) => (0, import_it_filter6.default)(it2, f), it);
        }
        if (Array.isArray(q.orders)) {
          it = q.orders.reduce((it2, f) => sortAll2(it2, f), it);
        }
        if (q.offset != null) {
          let i = 0;
          it = (0, import_it_filter6.default)(it, () => i++ >= q.offset);
        }
        if (q.limit != null) {
          it = (0, import_it_take4.default)(it, q.limit);
        }
        return it;
      }
    };
  }
});

// node_modules/blockstore-datastore-adapter/esm/src/index.js
function cidToKey3(cid) {
  const c = CID.asCID(cid);
  if (!c) {
    throw (0, import_err_code28.default)(new Error("Not a valid cid"), "ERR_INVALID_CID");
  }
  return new Key("/" + base32.encode(c.multihash.bytes).slice(1).toUpperCase(), false);
}
function keyToCid2(key) {
  return CID.createV1(code3, decode3(base32.decode("b" + key.toString().slice(1).toLowerCase())));
}
function convertPrefix(prefix) {
  const firstChar = prefix.substring(0, 1);
  if (firstChar === "/") {
    return convertPrefix(prefix.substring(1));
  }
  let decoder;
  if (firstChar.toLowerCase() === "b") {
    decoder = (input) => base32.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar.toLowerCase() === "c") {
    decoder = (input) => base32pad.decode(input.toLowerCase()).subarray(2);
  } else if (firstChar === "z") {
    decoder = (input) => base58btc.decode(input).subarray(2);
  } else if (firstChar === "Q") {
    decoder = (input) => base58btc.decode("z" + input);
  } else {
    decoder = (input) => base32.decode("b" + input.toLowerCase()).subarray(2);
  }
  let bytes3;
  for (let i = 1; i < prefix.length; i++) {
    try {
      bytes3 = decoder(prefix.substring(0, i));
    } catch (err) {
      if (err.message !== "Unexpected end of data") {
        throw err;
      }
    }
  }
  let str = "/C";
  if (bytes3) {
    str = `/${base32.encode(bytes3).slice(1, -1).toUpperCase() || "C"}`;
  }
  return str;
}
function convertQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map((filter8) => (pair) => {
      return filter8({
        key: keyToCid2(pair.key),
        value: pair.value
      });
    }) : void 0,
    orders: query.orders ? query.orders.map((order) => (a, b) => {
      return order({
        key: keyToCid2(a.key),
        value: a.value
      }, {
        key: keyToCid2(b.key),
        value: b.value
      });
    }) : void 0
  };
}
function convertKeyQuery(query) {
  return {
    ...query,
    prefix: query.prefix ? convertPrefix(query.prefix) : void 0,
    filters: query.filters ? query.filters.map((filter8) => (key) => {
      return filter8(keyToCid2(key));
    }) : void 0,
    orders: query.orders ? query.orders.map((order) => (a, b) => {
      return order(keyToCid2(a), keyToCid2(b));
    }) : void 0
  };
}
var import_it_drain5, import_it_pushable3, import_err_code28, BlockstoreDatastoreAdapter;
var init_src13 = __esm({
  "node_modules/blockstore-datastore-adapter/esm/src/index.js"() {
    init_node_globals();
    import_it_drain5 = __toModule(require_it_drain());
    import_it_pushable3 = __toModule(require_it_pushable());
    init_key();
    init_cid();
    init_raw();
    init_digest();
    init_base32();
    init_base58();
    import_err_code28 = __toModule(require_err_code());
    init_base4();
    BlockstoreDatastoreAdapter = class extends BaseBlockstore {
      constructor(datastore) {
        super();
        this.child = datastore;
      }
      open() {
        return this.child.open();
      }
      close() {
        return this.child.close();
      }
      async *query(query, options) {
        for await (const { key, value } of this.child.query(convertQuery(query), options)) {
          yield {
            key: keyToCid2(key),
            value
          };
        }
      }
      async *queryKeys(query, options) {
        for await (const key of this.child.queryKeys(convertKeyQuery(query), options)) {
          yield keyToCid2(key);
        }
      }
      async get(cid, options) {
        return this.child.get(cidToKey3(cid), options);
      }
      async *getMany(cids, options) {
        for await (const cid of cids) {
          yield this.get(cid, options);
        }
      }
      async put(cid, value, options) {
        await this.child.put(cidToKey3(cid), value, options);
      }
      async *putMany(blocks, options) {
        const output = (0, import_it_pushable3.default)();
        const runner = globalThis.process && globalThis.process.nextTick ? globalThis.process.nextTick : globalThis.setImmediate || globalThis.setTimeout;
        runner(async () => {
          try {
            const store = this.child;
            await (0, import_it_drain5.default)(this.child.putMany(async function* () {
              for await (const block of blocks) {
                const key = cidToKey3(block.key);
                const exists = await store.has(key, options);
                if (!exists) {
                  yield {
                    key,
                    value: block.value
                  };
                }
                output.push(block);
              }
            }()));
            output.end();
          } catch (err) {
            output.end(err);
          }
        });
        yield* output;
      }
      has(cid, options) {
        return this.child.has(cidToKey3(cid), options);
      }
      delete(cid, options) {
        return this.child.delete(cidToKey3(cid), options);
      }
      deleteMany(cids, options) {
        const out = (0, import_it_pushable3.default)();
        (0, import_it_drain5.default)(this.child.deleteMany(async function* () {
          for await (const cid of cids) {
            yield cidToKey3(cid);
            out.push(cid);
          }
          out.end();
        }(), options)).catch((err) => {
          out.end(err);
        });
        return out;
      }
    };
  }
});

// node_modules/ipfs-core-config/esm/src/repo.browser.js
var repo_browser_exports = {};
__export(repo_browser_exports, {
  createRepo: () => createRepo2
});
function createRepo2(print, codecs2, options) {
  const repoPath = options.path || "ipfs";
  return createRepo(repoPath, (codeOrName) => codecs2.getCodec(codeOrName), {
    root: new LevelDatastore(repoPath, {
      prefix: "",
      version: 2
    }),
    blocks: new BlockstoreDatastoreAdapter(new LevelDatastore(`${repoPath}/blocks`, {
      prefix: "",
      version: 2
    })),
    datastore: new LevelDatastore(`${repoPath}/datastore`, {
      prefix: "",
      version: 2
    }),
    keys: new LevelDatastore(`${repoPath}/keys`, {
      prefix: "",
      version: 2
    }),
    pins: new LevelDatastore(`${repoPath}/pins`, {
      prefix: "",
      version: 2
    })
  }, {
    autoMigrate: options.autoMigrate,
    onMigrationProgress: options.onMigrationProgress || print,
    repoLock: MemoryLock
  });
}
var init_repo_browser = __esm({
  "node_modules/ipfs-core-config/esm/src/repo.browser.js"() {
    init_node_globals();
    init_src11();
    init_src12();
    init_src13();
    init_memory2();
  }
});

// node_modules/libp2p-interfaces/src/topology/index.js
var require_topology = __commonJS({
  "node_modules/libp2p-interfaces/src/topology/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var noop2 = () => {
    };
    var topologySymbol = Symbol.for("@libp2p/js-interfaces/topology");
    var Topology = class {
      constructor({
        min = 0,
        max = Infinity,
        handlers = {}
      }) {
        this.min = min;
        this.max = max;
        this._onConnect = handlers.onConnect || noop2;
        this._onDisconnect = handlers.onDisconnect || noop2;
        this.peers = new Set();
      }
      get [Symbol.toStringTag]() {
        return "Topology";
      }
      get [topologySymbol]() {
        return true;
      }
      static isTopology(other) {
        return Boolean(other && other[topologySymbol]);
      }
      set registrar(registrar) {
        this._registrar = registrar;
      }
      disconnect(peerId) {
        this._onDisconnect(peerId);
      }
    };
    module2.exports = Topology;
  }
});

// node_modules/libp2p-interfaces/src/topology/multicodec-topology.js
var require_multicodec_topology = __commonJS({
  "node_modules/libp2p-interfaces/src/topology/multicodec-topology.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var Topology = require_topology();
    var multicodecTopologySymbol = Symbol.for("@libp2p/js-interfaces/topology/multicodec-topology");
    var MulticodecTopology2 = class extends Topology {
      constructor({
        min,
        max,
        multicodecs,
        handlers
      }) {
        super({ min, max, handlers });
        if (!multicodecs) {
          throw new Error("one or more multicodec should be provided");
        }
        if (!handlers) {
          throw new Error("the handlers should be provided");
        }
        if (typeof handlers.onConnect !== "function") {
          throw new Error("the 'onConnect' handler must be provided");
        }
        if (typeof handlers.onDisconnect !== "function") {
          throw new Error("the 'onDisconnect' handler must be provided");
        }
        this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs];
        this._registrar = void 0;
        this._onProtocolChange = this._onProtocolChange.bind(this);
        this._onPeerConnect = this._onPeerConnect.bind(this);
      }
      get [Symbol.toStringTag]() {
        return "Topology";
      }
      get [multicodecTopologySymbol]() {
        return true;
      }
      static isMulticodecTopology(other) {
        return Boolean(other && other[multicodecTopologySymbol]);
      }
      set registrar(registrar) {
        this._registrar = registrar;
        this._registrar.peerStore.on("change:protocols", this._onProtocolChange);
        this._registrar.connectionManager.on("peer:connect", this._onPeerConnect);
        this._updatePeers(this._registrar.peerStore.peers.values());
      }
      _updatePeers(peerDataIterable) {
        for (const { id, protocols } of peerDataIterable) {
          if (this.multicodecs.filter((multicodec) => protocols.includes(multicodec)).length) {
            this.peers.add(id.toB58String());
            const connection = this._registrar.getConnection(id);
            connection && this._onConnect(id, connection);
          } else {
            this.peers.delete(id.toB58String());
          }
        }
      }
      _onProtocolChange({ peerId, protocols }) {
        const hadPeer = this.peers.has(peerId.toB58String());
        const hasProtocol = protocols.filter((protocol) => this.multicodecs.includes(protocol));
        if (hadPeer && hasProtocol.length === 0) {
          this._onDisconnect(peerId);
        }
        for (const protocol of protocols) {
          if (this.multicodecs.includes(protocol)) {
            const peerData = this._registrar.peerStore.get(peerId);
            this._updatePeers([peerData]);
            return;
          }
        }
      }
      _onPeerConnect(connection) {
        const peerId = connection.remotePeer;
        const protocols = this._registrar.peerStore.protoBook.get(peerId);
        if (!protocols) {
          return;
        }
        if (this.multicodecs.find((multicodec) => protocols.includes(multicodec))) {
          this.peers.add(peerId.toB58String());
          this._onConnect(peerId, connection);
        }
      }
    };
    module2.exports = MulticodecTopology2;
  }
});

// node_modules/libp2p-interfaces/src/pubsub/errors.js
var require_errors3 = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/errors.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.codes = {
      ERR_INVALID_SIGNATURE_POLICY: "ERR_INVALID_SIGNATURE_POLICY",
      ERR_UNHANDLED_SIGNATURE_POLICY: "ERR_UNHANDLED_SIGNATURE_POLICY",
      ERR_MISSING_SIGNATURE: "ERR_MISSING_SIGNATURE",
      ERR_MISSING_SEQNO: "ERR_MISSING_SEQNO",
      ERR_INVALID_SIGNATURE: "ERR_INVALID_SIGNATURE",
      ERR_UNEXPECTED_FROM: "ERR_UNEXPECTED_FROM",
      ERR_UNEXPECTED_SIGNATURE: "ERR_UNEXPECTED_SIGNATURE",
      ERR_UNEXPECTED_KEY: "ERR_UNEXPECTED_KEY",
      ERR_UNEXPECTED_SEQNO: "ERR_UNEXPECTED_SEQNO"
    };
  }
});

// node_modules/libp2p-interfaces/src/pubsub/message/rpc.js
var require_rpc2 = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/message/rpc.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var $protobuf5 = require_minimal2();
    var $Reader5 = $protobuf5.Reader;
    var $Writer5 = $protobuf5.Writer;
    var $util5 = $protobuf5.util;
    var $root5 = $protobuf5.roots["libp2p-pubsub-rpc"] || ($protobuf5.roots["libp2p-pubsub-rpc"] = {});
    $root5.RPC = function() {
      function RPC(p) {
        this.subscriptions = [];
        this.msgs = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      RPC.prototype.subscriptions = $util5.emptyArray;
      RPC.prototype.msgs = $util5.emptyArray;
      RPC.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        if (m.subscriptions != null && m.subscriptions.length) {
          for (var i = 0; i < m.subscriptions.length; ++i)
            $root5.RPC.SubOpts.encode(m.subscriptions[i], w.uint32(10).fork()).ldelim();
        }
        if (m.msgs != null && m.msgs.length) {
          for (var i = 0; i < m.msgs.length; ++i)
            $root5.RPC.Message.encode(m.msgs[i], w.uint32(18).fork()).ldelim();
        }
        return w;
      };
      RPC.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              if (!(m.subscriptions && m.subscriptions.length))
                m.subscriptions = [];
              m.subscriptions.push($root5.RPC.SubOpts.decode(r, r.uint32()));
              break;
            case 2:
              if (!(m.msgs && m.msgs.length))
                m.msgs = [];
              m.msgs.push($root5.RPC.Message.decode(r, r.uint32()));
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      RPC.fromObject = function fromObject(d) {
        if (d instanceof $root5.RPC)
          return d;
        var m = new $root5.RPC();
        if (d.subscriptions) {
          if (!Array.isArray(d.subscriptions))
            throw TypeError(".RPC.subscriptions: array expected");
          m.subscriptions = [];
          for (var i = 0; i < d.subscriptions.length; ++i) {
            if (typeof d.subscriptions[i] !== "object")
              throw TypeError(".RPC.subscriptions: object expected");
            m.subscriptions[i] = $root5.RPC.SubOpts.fromObject(d.subscriptions[i]);
          }
        }
        if (d.msgs) {
          if (!Array.isArray(d.msgs))
            throw TypeError(".RPC.msgs: array expected");
          m.msgs = [];
          for (var i = 0; i < d.msgs.length; ++i) {
            if (typeof d.msgs[i] !== "object")
              throw TypeError(".RPC.msgs: object expected");
            m.msgs[i] = $root5.RPC.Message.fromObject(d.msgs[i]);
          }
        }
        return m;
      };
      RPC.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.subscriptions = [];
          d.msgs = [];
        }
        if (m.subscriptions && m.subscriptions.length) {
          d.subscriptions = [];
          for (var j = 0; j < m.subscriptions.length; ++j) {
            d.subscriptions[j] = $root5.RPC.SubOpts.toObject(m.subscriptions[j], o);
          }
        }
        if (m.msgs && m.msgs.length) {
          d.msgs = [];
          for (var j = 0; j < m.msgs.length; ++j) {
            d.msgs[j] = $root5.RPC.Message.toObject(m.msgs[j], o);
          }
        }
        return d;
      };
      RPC.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      RPC.SubOpts = function() {
        function SubOpts(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        SubOpts.prototype.subscribe = null;
        SubOpts.prototype.topicID = null;
        var $oneOfFields;
        Object.defineProperty(SubOpts.prototype, "_subscribe", {
          get: $util5.oneOfGetter($oneOfFields = ["subscribe"]),
          set: $util5.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(SubOpts.prototype, "_topicID", {
          get: $util5.oneOfGetter($oneOfFields = ["topicID"]),
          set: $util5.oneOfSetter($oneOfFields)
        });
        SubOpts.encode = function encode10(m, w) {
          if (!w)
            w = $Writer5.create();
          if (m.subscribe != null && Object.hasOwnProperty.call(m, "subscribe"))
            w.uint32(8).bool(m.subscribe);
          if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
            w.uint32(18).string(m.topicID);
          return w;
        };
        SubOpts.decode = function decode12(r, l) {
          if (!(r instanceof $Reader5))
            r = $Reader5.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC.SubOpts();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.subscribe = r.bool();
                break;
              case 2:
                m.topicID = r.string();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        SubOpts.fromObject = function fromObject(d) {
          if (d instanceof $root5.RPC.SubOpts)
            return d;
          var m = new $root5.RPC.SubOpts();
          if (d.subscribe != null) {
            m.subscribe = Boolean(d.subscribe);
          }
          if (d.topicID != null) {
            m.topicID = String(d.topicID);
          }
          return m;
        };
        SubOpts.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (m.subscribe != null && m.hasOwnProperty("subscribe")) {
            d.subscribe = m.subscribe;
            if (o.oneofs)
              d._subscribe = "subscribe";
          }
          if (m.topicID != null && m.hasOwnProperty("topicID")) {
            d.topicID = m.topicID;
            if (o.oneofs)
              d._topicID = "topicID";
          }
          return d;
        };
        SubOpts.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
        };
        return SubOpts;
      }();
      RPC.Message = function() {
        function Message2(p) {
          this.topicIDs = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Message2.prototype.from = null;
        Message2.prototype.data = null;
        Message2.prototype.seqno = null;
        Message2.prototype.topicIDs = $util5.emptyArray;
        Message2.prototype.signature = null;
        Message2.prototype.key = null;
        var $oneOfFields;
        Object.defineProperty(Message2.prototype, "_from", {
          get: $util5.oneOfGetter($oneOfFields = ["from"]),
          set: $util5.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(Message2.prototype, "_data", {
          get: $util5.oneOfGetter($oneOfFields = ["data"]),
          set: $util5.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(Message2.prototype, "_seqno", {
          get: $util5.oneOfGetter($oneOfFields = ["seqno"]),
          set: $util5.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(Message2.prototype, "_signature", {
          get: $util5.oneOfGetter($oneOfFields = ["signature"]),
          set: $util5.oneOfSetter($oneOfFields)
        });
        Object.defineProperty(Message2.prototype, "_key", {
          get: $util5.oneOfGetter($oneOfFields = ["key"]),
          set: $util5.oneOfSetter($oneOfFields)
        });
        Message2.encode = function encode10(m, w) {
          if (!w)
            w = $Writer5.create();
          if (m.from != null && Object.hasOwnProperty.call(m, "from"))
            w.uint32(10).bytes(m.from);
          if (m.data != null && Object.hasOwnProperty.call(m, "data"))
            w.uint32(18).bytes(m.data);
          if (m.seqno != null && Object.hasOwnProperty.call(m, "seqno"))
            w.uint32(26).bytes(m.seqno);
          if (m.topicIDs != null && m.topicIDs.length) {
            for (var i = 0; i < m.topicIDs.length; ++i)
              w.uint32(34).string(m.topicIDs[i]);
          }
          if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
            w.uint32(42).bytes(m.signature);
          if (m.key != null && Object.hasOwnProperty.call(m, "key"))
            w.uint32(50).bytes(m.key);
          return w;
        };
        Message2.decode = function decode12(r, l) {
          if (!(r instanceof $Reader5))
            r = $Reader5.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC.Message();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.from = r.bytes();
                break;
              case 2:
                m.data = r.bytes();
                break;
              case 3:
                m.seqno = r.bytes();
                break;
              case 4:
                if (!(m.topicIDs && m.topicIDs.length))
                  m.topicIDs = [];
                m.topicIDs.push(r.string());
                break;
              case 5:
                m.signature = r.bytes();
                break;
              case 6:
                m.key = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        Message2.fromObject = function fromObject(d) {
          if (d instanceof $root5.RPC.Message)
            return d;
          var m = new $root5.RPC.Message();
          if (d.from != null) {
            if (typeof d.from === "string")
              $util5.base64.decode(d.from, m.from = $util5.newBuffer($util5.base64.length(d.from)), 0);
            else if (d.from.length)
              m.from = d.from;
          }
          if (d.data != null) {
            if (typeof d.data === "string")
              $util5.base64.decode(d.data, m.data = $util5.newBuffer($util5.base64.length(d.data)), 0);
            else if (d.data.length)
              m.data = d.data;
          }
          if (d.seqno != null) {
            if (typeof d.seqno === "string")
              $util5.base64.decode(d.seqno, m.seqno = $util5.newBuffer($util5.base64.length(d.seqno)), 0);
            else if (d.seqno.length)
              m.seqno = d.seqno;
          }
          if (d.topicIDs) {
            if (!Array.isArray(d.topicIDs))
              throw TypeError(".RPC.Message.topicIDs: array expected");
            m.topicIDs = [];
            for (var i = 0; i < d.topicIDs.length; ++i) {
              m.topicIDs[i] = String(d.topicIDs[i]);
            }
          }
          if (d.signature != null) {
            if (typeof d.signature === "string")
              $util5.base64.decode(d.signature, m.signature = $util5.newBuffer($util5.base64.length(d.signature)), 0);
            else if (d.signature.length)
              m.signature = d.signature;
          }
          if (d.key != null) {
            if (typeof d.key === "string")
              $util5.base64.decode(d.key, m.key = $util5.newBuffer($util5.base64.length(d.key)), 0);
            else if (d.key.length)
              m.key = d.key;
          }
          return m;
        };
        Message2.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.topicIDs = [];
          }
          if (m.from != null && m.hasOwnProperty("from")) {
            d.from = o.bytes === String ? $util5.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;
            if (o.oneofs)
              d._from = "from";
          }
          if (m.data != null && m.hasOwnProperty("data")) {
            d.data = o.bytes === String ? $util5.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
            if (o.oneofs)
              d._data = "data";
          }
          if (m.seqno != null && m.hasOwnProperty("seqno")) {
            d.seqno = o.bytes === String ? $util5.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;
            if (o.oneofs)
              d._seqno = "seqno";
          }
          if (m.topicIDs && m.topicIDs.length) {
            d.topicIDs = [];
            for (var j = 0; j < m.topicIDs.length; ++j) {
              d.topicIDs[j] = m.topicIDs[j];
            }
          }
          if (m.signature != null && m.hasOwnProperty("signature")) {
            d.signature = o.bytes === String ? $util5.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
            if (o.oneofs)
              d._signature = "signature";
          }
          if (m.key != null && m.hasOwnProperty("key")) {
            d.key = o.bytes === String ? $util5.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
            if (o.oneofs)
              d._key = "key";
          }
          return d;
        };
        Message2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
        };
        return Message2;
      }();
      return RPC;
    }();
    module2.exports = $root5;
  }
});

// node_modules/it-length-prefixed/src/varint-encode.js
var require_varint_encode = __commonJS({
  "node_modules/it-length-prefixed/src/varint-encode.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var Varint = require_varint();
    var { Buffer: Buffer2 } = require_buffer();
    var varintEncode = (value, target, offset) => {
      const ret = Varint.encode(value, target, offset);
      varintEncode.bytes = Varint.encode.bytes;
      return target || Buffer2.from(ret);
    };
    module2.exports = varintEncode;
  }
});

// node_modules/it-length-prefixed/src/encode.js
var require_encode2 = __commonJS({
  "node_modules/it-length-prefixed/src/encode.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var BufferList3 = require_BufferList();
    var varintEncode = require_varint_encode();
    var MIN_POOL_SIZE = 8;
    var DEFAULT_POOL_SIZE = 10 * 1024;
    function encode10(options) {
      options = options || {};
      const poolSize = Math.max(options.poolSize || DEFAULT_POOL_SIZE, options.minPoolSize || MIN_POOL_SIZE);
      const encodeLength = options.lengthEncoder || varintEncode;
      const encoder = async function* (source) {
        let pool = Buffer2.alloc(poolSize);
        let poolOffset = 0;
        for await (const chunk of source) {
          encodeLength(chunk.length, pool, poolOffset);
          const encodedLength = pool.slice(poolOffset, poolOffset + encodeLength.bytes);
          poolOffset += encodeLength.bytes;
          if (pool.length - poolOffset < MIN_POOL_SIZE) {
            pool = Buffer2.alloc(poolSize);
            poolOffset = 0;
          }
          yield new BufferList3().append(encodedLength).append(chunk);
        }
      };
      return encoder;
    }
    encode10.single = (chunk, options) => {
      options = options || {};
      const encodeLength = options.lengthEncoder || varintEncode;
      return new BufferList3([encodeLength(chunk.length), chunk.slice()]);
    };
    module2.exports = encode10;
    module2.exports.MIN_POOL_SIZE = MIN_POOL_SIZE;
    module2.exports.DEFAULT_POOL_SIZE = DEFAULT_POOL_SIZE;
  }
});

// node_modules/it-length-prefixed/src/varint-decode.js
var require_varint_decode = __commonJS({
  "node_modules/it-length-prefixed/src/varint-decode.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var Varint = require_varint();
    var { Buffer: Buffer2 } = require_buffer();
    var toBufferProxy = (bl) => new Proxy({}, {
      get: (_, prop) => {
        return prop[0] === "l" ? bl[prop] : bl.get(parseInt(prop));
      }
    });
    var varintDecode = (data) => {
      const len = Varint.decode(Buffer2.isBuffer(data) ? data : toBufferProxy(data));
      varintDecode.bytes = Varint.decode.bytes;
      return len;
    };
    module2.exports = varintDecode;
  }
});

// node_modules/it-length-prefixed/src/decode.js
var require_decode2 = __commonJS({
  "node_modules/it-length-prefixed/src/decode.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var BufferList3 = require_BufferList();
    var varintDecode = require_varint_decode();
    var MAX_LENGTH_LENGTH = 8;
    var MAX_DATA_LENGTH = 1024 * 1024 * 4;
    var Empty = Buffer2.alloc(0);
    var ReadModes = { LENGTH: "readLength", DATA: "readData" };
    var ReadHandlers = {
      [ReadModes.LENGTH]: (chunk, buffer2, state, options) => {
        buffer2 = buffer2.append(chunk);
        let dataLength;
        try {
          dataLength = options.lengthDecoder(buffer2);
        } catch (err) {
          if (buffer2.length > options.maxLengthLength) {
            throw Object.assign(err, { message: "message length too long", code: "ERR_MSG_LENGTH_TOO_LONG" });
          }
          if (err instanceof RangeError) {
            return { mode: ReadModes.LENGTH, buffer: buffer2, chunk: void 0, state: void 0, data: void 0 };
          }
          throw err;
        }
        if (dataLength > options.maxDataLength) {
          throw Object.assign(new Error("message data too long"), { code: "ERR_MSG_DATA_TOO_LONG" });
        }
        chunk = buffer2.shallowSlice(options.lengthDecoder.bytes);
        buffer2 = new BufferList3();
        if (options.onLength)
          options.onLength(dataLength);
        if (dataLength <= 0) {
          if (options.onData)
            options.onData(Empty);
          return { mode: ReadModes.LENGTH, chunk, buffer: buffer2, data: Empty };
        }
        return { mode: ReadModes.DATA, chunk, buffer: buffer2, state: { dataLength }, data: void 0 };
      },
      [ReadModes.DATA]: (chunk, buffer2, state, options) => {
        buffer2 = buffer2.append(chunk);
        if (!state) {
          throw new Error("state is required");
        }
        if (buffer2.length < state.dataLength) {
          return { mode: ReadModes.DATA, buffer: buffer2, state, chunk: void 0, data: void 0 };
        }
        const { dataLength } = state;
        const data = buffer2.shallowSlice(0, dataLength);
        const nextChunk = buffer2.length > dataLength ? buffer2.shallowSlice(dataLength) : void 0;
        buffer2 = new BufferList3();
        if (options.onData)
          options.onData(data);
        return { mode: ReadModes.LENGTH, chunk: nextChunk, buffer: buffer2, state: void 0, data };
      }
    };
    function decode12(options) {
      options = options || {};
      const opts = {
        lengthDecoder: options.lengthDecoder || varintDecode,
        maxLengthLength: options.maxLengthLength || MAX_LENGTH_LENGTH,
        maxDataLength: options.maxDataLength || MAX_DATA_LENGTH,
        onLength: options.onLength,
        onData: options.onData
      };
      const decoder = async function* (source) {
        let buffer2 = new BufferList3();
        let mode = ReadModes.LENGTH;
        let state;
        for await (const chunk of source) {
          let nextChunk = chunk;
          while (nextChunk) {
            const result = ReadHandlers[mode](nextChunk, buffer2, state, opts);
            mode = result.mode;
            nextChunk = result.chunk;
            buffer2 = result.buffer;
            state = result.state;
            if (result.data) {
              yield result.data;
            }
          }
        }
        if (buffer2.length) {
          throw Object.assign(new Error("unexpected end of input"), { code: "ERR_UNEXPECTED_EOF" });
        }
      };
      return decoder;
    }
    decode12.fromReader = (reader, options) => {
      let byteLength = 1;
      const varByteSource = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next: async () => {
          try {
            return await reader.next(byteLength);
          } catch (err) {
            if (err.code === "ERR_UNDER_READ") {
              return { done: true, value: null };
            }
            throw err;
          } finally {
            byteLength = 1;
          }
        }
      };
      const onLength = (l) => {
        byteLength = l;
      };
      return decode12({
        ...options || {},
        onLength
      })(varByteSource);
    };
    module2.exports = decode12;
    module2.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;
    module2.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;
  }
});

// node_modules/it-length-prefixed/src/int32BE-encode.js
var require_int32BE_encode = __commonJS({
  "node_modules/it-length-prefixed/src/int32BE-encode.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var int32BEEncode = (value, target, offset) => {
      target = target || Buffer2.allocUnsafe(4);
      target.writeInt32BE(value, offset);
      return target;
    };
    int32BEEncode.bytes = 4;
    module2.exports = int32BEEncode;
  }
});

// node_modules/it-length-prefixed/src/int32BE-decode.js
var require_int32BE_decode = __commonJS({
  "node_modules/it-length-prefixed/src/int32BE-decode.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var int32BEDecode = (data) => {
      if (data.length < 4)
        throw RangeError("Could not decode int32BE");
      return data.readInt32BE(0);
    };
    int32BEDecode.bytes = 4;
    module2.exports = int32BEDecode;
  }
});

// node_modules/it-length-prefixed/src/index.js
var require_src12 = __commonJS({
  "node_modules/it-length-prefixed/src/index.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.encode = require_encode2();
    exports2.decode = require_decode2();
    exports2.varintEncode = require_varint_encode();
    exports2.varintDecode = require_varint_decode();
    exports2.int32BEEncode = require_int32BE_encode();
    exports2.int32BEDecode = require_int32BE_decode();
  }
});

// node_modules/get-iterator/index.js
var require_get_iterator = __commonJS({
  "node_modules/get-iterator/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = function getIterator(obj) {
      if (obj) {
        if (typeof obj[Symbol.iterator] === "function") {
          return obj[Symbol.iterator]();
        }
        if (typeof obj[Symbol.asyncIterator] === "function") {
          return obj[Symbol.asyncIterator]();
        }
        if (typeof obj.next === "function") {
          return obj;
        }
      }
      throw new Error("argument is not an iterator or iterable");
    };
  }
});

// node_modules/abortable-iterator/AbortError.js
var require_AbortError = __commonJS({
  "node_modules/abortable-iterator/AbortError.js"(exports2, module2) {
    init_node_globals();
    module2.exports = class AbortError extends Error {
      constructor(message, code5) {
        super(message || "The operation was aborted");
        this.type = "aborted";
        this.code = code5 || "ABORT_ERR";
      }
    };
  }
});

// node_modules/abortable-iterator/index.js
var require_abortable_iterator = __commonJS({
  "node_modules/abortable-iterator/index.js"(exports2, module2) {
    init_node_globals();
    var getIterator = require_get_iterator();
    var AbortError = require_AbortError();
    var toAbortableSource = (source, signal, options) => toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{ signal, options }]);
    var toMultiAbortableSource = (source, signals) => {
      source = getIterator(source);
      signals = signals.map(({ signal, options }) => ({ signal, options: options || {} }));
      async function* abortable() {
        let nextAbortHandler;
        const abortHandler = () => {
          if (nextAbortHandler)
            nextAbortHandler();
        };
        for (const { signal } of signals) {
          signal.addEventListener("abort", abortHandler);
        }
        while (true) {
          let result;
          try {
            for (const { signal, options } of signals) {
              if (signal.aborted) {
                const { abortMessage, abortCode } = options;
                throw new AbortError(abortMessage, abortCode);
              }
            }
            const abort = new Promise((resolve6, reject) => {
              nextAbortHandler = () => {
                const { options } = signals.find(({ signal }) => signal.aborted);
                const { abortMessage, abortCode } = options;
                reject(new AbortError(abortMessage, abortCode));
              };
            });
            result = await Promise.race([abort, source.next()]);
            nextAbortHandler = null;
          } catch (err) {
            for (const { signal } of signals) {
              signal.removeEventListener("abort", abortHandler);
            }
            const aborter = signals.find(({ signal }) => signal.aborted);
            const isKnownAborter = err.type === "aborted" && aborter;
            if (isKnownAborter && aborter.options.onAbort) {
              await aborter.options.onAbort(source);
            }
            if (typeof source.return === "function") {
              await source.return();
            }
            if (isKnownAborter && aborter.options.returnOnAbort) {
              return;
            }
            throw err;
          }
          if (result.done)
            break;
          yield result.value;
        }
        for (const { signal } of signals) {
          signal.removeEventListener("abort", abortHandler);
        }
      }
      return abortable();
    };
    var toAbortableSink = (sink, signal, options) => toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{ signal, options }]);
    var toMultiAbortableSink = (sink, signals) => (source) => sink(toMultiAbortableSource(source, signals));
    var toAbortableDuplex = (duplex, signal, options) => toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{ signal, options }]);
    var toMultiAbortableDuplex = (duplex, signals) => ({
      sink: toMultiAbortableSink(duplex.sink, signals),
      source: toMultiAbortableSource(duplex.source, signals)
    });
    module2.exports = toAbortableSource;
    module2.exports.AbortError = AbortError;
    module2.exports.source = toAbortableSource;
    module2.exports.sink = toAbortableSink;
    module2.exports.transform = toAbortableSink;
    module2.exports.duplex = toAbortableDuplex;
  }
});

// node_modules/libp2p-interfaces/src/pubsub/peer-streams.js
var require_peer_streams = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/peer-streams.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p-pubsub:peer-streams"), {
      error: debug17("libp2p-pubsub:peer-streams:err")
    });
    var { EventEmitter: EventEmitter4 } = require_events();
    var lp2 = require_src12();
    var pushable4 = require_it_pushable();
    var { pipe: pipe4 } = require_it_pipe();
    var { source: abortable } = require_abortable_iterator();
    var AbortController13 = require_browser3().default;
    var PeerStreams = class extends EventEmitter4 {
      constructor({ id, protocol }) {
        super();
        this.id = id;
        this.protocol = protocol;
        this._rawOutboundStream = null;
        this._rawInboundStream = null;
        this._inboundAbortController = new AbortController13();
        this.outboundStream = null;
        this.inboundStream = null;
      }
      get isReadable() {
        return Boolean(this.inboundStream);
      }
      get isWritable() {
        return Boolean(this.outboundStream);
      }
      write(data) {
        if (!this.outboundStream) {
          const id = this.id.toB58String();
          throw new Error("No writable connection to " + id);
        }
        this.outboundStream.push(data);
      }
      attachInboundStream(stream) {
        this._rawInboundStream = stream;
        this.inboundStream = abortable(pipe4(this._rawInboundStream, lp2.decode()), this._inboundAbortController.signal, { returnOnAbort: true });
        this.emit("stream:inbound");
        return this.inboundStream;
      }
      async attachOutboundStream(stream) {
        const _prevStream = this.outboundStream;
        if (this.outboundStream) {
          await this.outboundStream.end();
        }
        this._rawOutboundStream = stream;
        this.outboundStream = pushable4({
          onEnd: (shouldEmit) => {
            this._rawOutboundStream && this._rawOutboundStream.reset && this._rawOutboundStream.reset();
            this._rawOutboundStream = null;
            this.outboundStream = null;
            if (shouldEmit) {
              this.emit("close");
            }
          }
        });
        pipe4(this.outboundStream, lp2.encode(), this._rawOutboundStream).catch((err) => {
          log15.error(err);
        });
        if (!_prevStream) {
          this.emit("stream:outbound");
        }
      }
      close() {
        if (this.outboundStream) {
          this.outboundStream.end();
        }
        if (this.inboundStream) {
          this._inboundAbortController.abort();
        }
        this._rawOutboundStream = null;
        this.outboundStream = null;
        this._rawInboundStream = null;
        this.inboundStream = null;
        this.emit("close");
      }
    };
    module2.exports = PeerStreams;
  }
});

// node_modules/libp2p-interfaces/src/pubsub/signature-policy.js
var require_signature_policy = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/signature-policy.js"(exports2) {
    init_node_globals();
    "use strict";
    var SignaturePolicy = {
      StrictSign: "StrictSign",
      StrictNoSign: "StrictNoSign"
    };
    exports2.SignaturePolicy = SignaturePolicy;
  }
});

// node_modules/libp2p-interfaces/src/pubsub/utils.js
var require_utils11 = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/utils.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var randomBytes = require_random_bytes();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var PeerId2 = require_src6();
    var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
    var randomSeqno = () => {
      return randomBytes(8);
    };
    var msgId = (from3, seqno) => {
      let fromBytes2;
      if (from3 instanceof Uint8Array) {
        fromBytes2 = PeerId2.createFromBytes(from3).id;
      } else {
        fromBytes2 = PeerId2.parse(from3).id;
      }
      const msgId2 = new Uint8Array(fromBytes2.length + seqno.length);
      msgId2.set(fromBytes2, 0);
      msgId2.set(seqno, fromBytes2.length);
      return msgId2;
    };
    var noSignMsgId = (data) => sha2562.encode(data);
    var anyMatch = (a, b) => {
      let bHas;
      if (Array.isArray(b)) {
        bHas = (val) => b.indexOf(val) > -1;
      } else {
        bHas = (val) => b.has(val);
      }
      for (const val of a) {
        if (bHas(val)) {
          return true;
        }
      }
      return false;
    };
    var ensureArray = (maybeArray) => {
      if (!Array.isArray(maybeArray)) {
        return [maybeArray];
      }
      return maybeArray;
    };
    var normalizeInRpcMessage = (message, peerId) => {
      const m = Object.assign({}, message);
      if (message.from instanceof Uint8Array) {
        m.from = uint8ArrayToString(message.from, "base58btc");
      }
      if (peerId) {
        m.receivedFrom = peerId;
      }
      return m;
    };
    var normalizeOutRpcMessage = (message) => {
      const m = Object.assign({}, message);
      if (typeof message.from === "string") {
        m.from = uint8ArrayFromString(message.from, "base58btc");
      }
      if (typeof message.data === "string") {
        m.data = uint8ArrayFromString(message.data);
      }
      return m;
    };
    module2.exports = {
      randomSeqno,
      msgId,
      noSignMsgId,
      anyMatch,
      ensureArray,
      normalizeInRpcMessage,
      normalizeOutRpcMessage
    };
  }
});

// node_modules/libp2p-interfaces/src/pubsub/message/sign.js
var require_sign = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/message/sign.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var PeerId2 = require_src6();
    var { RPC } = require_rpc2();
    var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var SignPrefix = uint8ArrayFromString("libp2p-pubsub:");
    var { normalizeOutRpcMessage } = require_utils11();
    async function signMessage(peerId, message) {
      const bytes3 = uint8ArrayConcat([
        SignPrefix,
        RPC.Message.encode(normalizeOutRpcMessage(message)).finish()
      ]);
      const signature = await peerId.privKey.sign(bytes3);
      return {
        ...message,
        signature,
        key: peerId.pubKey.bytes
      };
    }
    async function verifySignature(message) {
      if (!message.signature) {
        throw new Error("Message must contain a signature to be verified");
      }
      if (!message.from) {
        throw new Error("Message must contain a from property to be verified");
      }
      const bytes3 = uint8ArrayConcat([
        SignPrefix,
        RPC.Message.encode({
          ...message,
          from: PeerId2.createFromB58String(message.from).toBytes(),
          signature: void 0,
          key: void 0
        }).finish()
      ]);
      const pubKey = await messagePublicKey(message);
      return pubKey.verify(bytes3, message.signature);
    }
    async function messagePublicKey(message) {
      if (!message.from) {
        throw new Error("Could not get the public key from the originator id");
      }
      const from3 = PeerId2.createFromB58String(message.from);
      if (message.key) {
        const keyPeerId = await PeerId2.createFromPubKey(message.key);
        if (keyPeerId.equals(from3))
          return keyPeerId.pubKey;
        throw new Error("Public Key does not match the originator");
      } else if (from3.pubKey) {
        return from3.pubKey;
      } else {
        throw new Error("Could not get the public key from the originator id");
      }
    }
    module2.exports = {
      messagePublicKey,
      signMessage,
      SignPrefix,
      verifySignature
    };
  }
});

// node_modules/libp2p-interfaces/src/pubsub/index.js
var require_pubsub2 = __commonJS({
  "node_modules/libp2p-interfaces/src/pubsub/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var { EventEmitter: EventEmitter4 } = require_events();
    var errcode7 = require_err_code();
    var { pipe: pipe4 } = require_it_pipe();
    var { default: Queue4 } = require_dist();
    var MulticodecTopology2 = require_multicodec_topology();
    var { codes } = require_errors3();
    var { RPC } = require_rpc2();
    var PeerStreams = require_peer_streams();
    var { SignaturePolicy } = require_signature_policy();
    var utils = require_utils11();
    var {
      signMessage,
      verifySignature
    } = require_sign();
    var PubsubBaseProtocol = class extends EventEmitter4 {
      constructor({
        debugName,
        multicodecs,
        libp2p,
        globalSignaturePolicy = SignaturePolicy.StrictSign,
        canRelayMessage = false,
        emitSelf = false,
        messageProcessingConcurrency = 10
      }) {
        if (typeof debugName !== "string") {
          throw new Error("a debugname `string` is required");
        }
        if (!multicodecs) {
          throw new Error("multicodecs are required");
        }
        if (!libp2p) {
          throw new Error("libp2p is required");
        }
        super();
        this.log = Object.assign(debug17(debugName), {
          err: debug17(`${debugName}:error`)
        });
        this.multicodecs = utils.ensureArray(multicodecs);
        this._libp2p = libp2p;
        this.registrar = libp2p.registrar;
        this.peerId = libp2p.peerId;
        this.started = false;
        this.topics = new Map();
        this.subscriptions = new Set();
        this.peers = new Map();
        if (!SignaturePolicy[globalSignaturePolicy]) {
          throw errcode7(new Error("Invalid global signature policy"), codes.ERR_INVALID_SIGNATURE_POLICY);
        }
        this.globalSignaturePolicy = globalSignaturePolicy;
        this.canRelayMessage = canRelayMessage;
        this.emitSelf = emitSelf;
        this.topicValidators = new Map();
        this.queue = new Queue4({ concurrency: messageProcessingConcurrency });
        this._registrarId = void 0;
        this._onIncomingStream = this._onIncomingStream.bind(this);
        this._onPeerConnected = this._onPeerConnected.bind(this);
        this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
      }
      start() {
        if (this.started) {
          return;
        }
        this.log("starting");
        this.registrar.handle(this.multicodecs, this._onIncomingStream);
        const topology = new MulticodecTopology2({
          multicodecs: this.multicodecs,
          handlers: {
            onConnect: this._onPeerConnected,
            onDisconnect: this._onPeerDisconnected
          }
        });
        this._registrarId = this.registrar.register(topology);
        this.log("started");
        this.started = true;
      }
      stop() {
        if (!this.started) {
          return;
        }
        this.registrar.unregister(this._registrarId);
        this.log("stopping");
        this.peers.forEach((peerStreams) => peerStreams.close());
        this.peers = new Map();
        this.subscriptions = new Set();
        this.started = false;
        this.log("stopped");
      }
      _onIncomingStream({ protocol, stream, connection }) {
        const peerId = connection.remotePeer;
        const idB58Str = peerId.toB58String();
        const peer = this._addPeer(peerId, protocol);
        const inboundStream = peer.attachInboundStream(stream);
        this._processMessages(idB58Str, inboundStream, peer);
      }
      async _onPeerConnected(peerId, conn) {
        const idB58Str = peerId.toB58String();
        this.log("connected", idB58Str);
        try {
          const { stream, protocol } = await conn.newStream(this.multicodecs);
          const peer = this._addPeer(peerId, protocol);
          await peer.attachOutboundStream(stream);
        } catch (err) {
          this.log.err(err);
        }
        this._sendSubscriptions(idB58Str, Array.from(this.subscriptions), true);
      }
      _onPeerDisconnected(peerId, err) {
        const idB58Str = peerId.toB58String();
        this.log("connection ended", idB58Str, err ? err.message : "");
        this._removePeer(peerId);
      }
      _addPeer(peerId, protocol) {
        const id = peerId.toB58String();
        const existing = this.peers.get(id);
        if (existing) {
          return existing;
        }
        this.log("new peer", id);
        const peerStreams = new PeerStreams({
          id: peerId,
          protocol
        });
        this.peers.set(id, peerStreams);
        peerStreams.once("close", () => this._removePeer(peerId));
        return peerStreams;
      }
      _removePeer(peerId) {
        if (!peerId)
          return;
        const id = peerId.toB58String();
        const peerStreams = this.peers.get(id);
        if (!peerStreams)
          return;
        peerStreams.removeAllListeners();
        peerStreams.close();
        this.log("delete peer", id);
        this.peers.delete(id);
        for (const peers of this.topics.values()) {
          peers.delete(id);
        }
        return peerStreams;
      }
      async _processMessages(idB58Str, stream, peerStreams) {
        try {
          await pipe4(stream, async (source) => {
            for await (const data of source) {
              const rpcBytes = data instanceof Uint8Array ? data : data.slice();
              const rpcMsg = this._decodeRpc(rpcBytes);
              (async () => {
                try {
                  await this._processRpc(idB58Str, peerStreams, rpcMsg);
                } catch (err) {
                  this.log.err(err);
                }
              })();
            }
          });
        } catch (err) {
          this._onPeerDisconnected(peerStreams.id, err);
        }
      }
      async _processRpc(idB58Str, peerStreams, rpc) {
        this.log("rpc from", idB58Str);
        const subs = rpc.subscriptions;
        const msgs = rpc.msgs;
        if (subs.length) {
          subs.forEach((subOpt) => {
            this._processRpcSubOpt(idB58Str, subOpt);
          });
          this.emit("pubsub:subscription-change", peerStreams.id, subs);
        }
        if (!this._acceptFrom(idB58Str)) {
          this.log("received message from unacceptable peer %s", idB58Str);
          return false;
        }
        if (msgs.length) {
          this.queue.addAll(msgs.map((message) => async () => {
            if (!(this.canRelayMessage || message.topicIDs && message.topicIDs.some((topic) => this.subscriptions.has(topic)))) {
              this.log("received message we didn't subscribe to. Dropping.");
              return;
            }
            try {
              const msg = utils.normalizeInRpcMessage(message, idB58Str);
              await this._processRpcMessage(msg);
            } catch (err) {
              this.log.err(err);
            }
          }));
        }
        return true;
      }
      _processRpcSubOpt(id, subOpt) {
        const t = subOpt.topicID;
        if (!t) {
          return;
        }
        let topicSet = this.topics.get(t);
        if (!topicSet) {
          topicSet = new Set();
          this.topics.set(t, topicSet);
        }
        if (subOpt.subscribe) {
          topicSet.add(id);
        } else {
          topicSet.delete(id);
        }
      }
      async _processRpcMessage(msg) {
        if (this.peerId.toB58String() === msg.from && !this.emitSelf) {
          return;
        }
        try {
          await this.validate(msg);
        } catch (err) {
          this.log("Message is invalid, dropping it. %O", err);
          return;
        }
        this._emitMessage(msg);
        return this._publish(utils.normalizeOutRpcMessage(msg));
      }
      _emitMessage(message) {
        message.topicIDs.forEach((topic) => {
          if (this.subscriptions.has(topic)) {
            this.emit(topic, message);
          }
        });
      }
      getMsgId(msg) {
        const signaturePolicy = this.globalSignaturePolicy;
        switch (signaturePolicy) {
          case SignaturePolicy.StrictSign:
            return utils.msgId(msg.from, msg.seqno);
          case SignaturePolicy.StrictNoSign:
            return utils.noSignMsgId(msg.data);
          default:
            throw errcode7(new Error("Cannot get message id: unhandled signature policy: " + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);
        }
      }
      _acceptFrom(id) {
        return true;
      }
      _decodeRpc(bytes3) {
        return RPC.decode(bytes3);
      }
      _encodeRpc(rpc) {
        return RPC.encode(rpc).finish();
      }
      _sendRpc(id, rpc) {
        const peerStreams = this.peers.get(id);
        if (!peerStreams || !peerStreams.isWritable) {
          const msg = `Cannot send RPC to ${id} as there is no open stream to it available`;
          this.log.err(msg);
          return;
        }
        peerStreams.write(this._encodeRpc(rpc));
      }
      _sendSubscriptions(id, topics, subscribe) {
        return this._sendRpc(id, {
          subscriptions: topics.map((t) => ({ topicID: t, subscribe }))
        });
      }
      async validate(message) {
        const signaturePolicy = this.globalSignaturePolicy;
        switch (signaturePolicy) {
          case SignaturePolicy.StrictNoSign:
            if (message.from) {
              throw errcode7(new Error("StrictNoSigning: from should not be present"), codes.ERR_UNEXPECTED_FROM);
            }
            if (message.signature) {
              throw errcode7(new Error("StrictNoSigning: signature should not be present"), codes.ERR_UNEXPECTED_SIGNATURE);
            }
            if (message.key) {
              throw errcode7(new Error("StrictNoSigning: key should not be present"), codes.ERR_UNEXPECTED_KEY);
            }
            if (message.seqno) {
              throw errcode7(new Error("StrictNoSigning: seqno should not be present"), codes.ERR_UNEXPECTED_SEQNO);
            }
            break;
          case SignaturePolicy.StrictSign:
            if (!message.signature) {
              throw errcode7(new Error("StrictSigning: Signing required and no signature was present"), codes.ERR_MISSING_SIGNATURE);
            }
            if (!message.seqno) {
              throw errcode7(new Error("StrictSigning: Signing required and no seqno was present"), codes.ERR_MISSING_SEQNO);
            }
            if (!await verifySignature(message)) {
              throw errcode7(new Error("StrictSigning: Invalid message signature"), codes.ERR_INVALID_SIGNATURE);
            }
            break;
          default:
            throw errcode7(new Error("Cannot validate message: unhandled signature policy: " + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);
        }
        for (const topic of message.topicIDs) {
          const validatorFn = this.topicValidators.get(topic);
          if (validatorFn) {
            await validatorFn(topic, message);
          }
        }
      }
      _buildMessage(message) {
        const signaturePolicy = this.globalSignaturePolicy;
        switch (signaturePolicy) {
          case SignaturePolicy.StrictSign:
            message.from = this.peerId.toB58String();
            message.seqno = utils.randomSeqno();
            return signMessage(this.peerId, message);
          case SignaturePolicy.StrictNoSign:
            return Promise.resolve(message);
          default:
            throw errcode7(new Error("Cannot build message: unhandled signature policy: " + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);
        }
      }
      getSubscribers(topic) {
        if (!this.started) {
          throw errcode7(new Error("not started yet"), "ERR_NOT_STARTED_YET");
        }
        if (!topic || typeof topic !== "string") {
          throw errcode7(new Error("a string topic must be provided"), "ERR_NOT_VALID_TOPIC");
        }
        const peersInTopic = this.topics.get(topic);
        if (!peersInTopic) {
          return [];
        }
        return Array.from(peersInTopic);
      }
      async publish(topic, message) {
        if (!this.started) {
          throw new Error("Pubsub has not started");
        }
        this.log("publish", topic, message);
        const from3 = this.peerId.toB58String();
        const msgObject = {
          receivedFrom: from3,
          data: message,
          topicIDs: [topic]
        };
        const outMsg = await this._buildMessage(msgObject);
        const msg = utils.normalizeInRpcMessage(outMsg);
        this.emitSelf && this._emitMessage(msg);
        await this._publish(msg);
      }
      _publish(message) {
        throw errcode7(new Error("publish must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED");
      }
      subscribe(topic) {
        if (!this.started) {
          throw new Error("Pubsub has not started");
        }
        if (!this.subscriptions.has(topic)) {
          this.subscriptions.add(topic);
          this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], true));
        }
      }
      unsubscribe(topic) {
        if (!this.started) {
          throw new Error("Pubsub is not started");
        }
        if (this.subscriptions.has(topic) && this.listenerCount(topic) === 0) {
          this.subscriptions.delete(topic);
          this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], false));
        }
      }
      getTopics() {
        if (!this.started) {
          throw new Error("Pubsub is not started");
        }
        return Array.from(this.subscriptions);
      }
    };
    PubsubBaseProtocol.utils = utils;
    PubsubBaseProtocol.SignaturePolicy = SignaturePolicy;
    module2.exports = PubsubBaseProtocol;
  }
});

// node_modules/libp2p-gossipsub/src/utils/create-gossip-rpc.js
var require_create_gossip_rpc = __commonJS({
  "node_modules/libp2p-gossipsub/src/utils/create-gossip-rpc.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.createGossipRpc = void 0;
    function createGossipRpc(msgs = [], control = {}) {
      return {
        subscriptions: [],
        msgs,
        control: Object.assign({ ihave: [], iwant: [], graft: [], prune: [] }, control)
      };
    }
    exports2.createGossipRpc = createGossipRpc;
  }
});

// node_modules/libp2p-gossipsub/src/utils/shuffle.js
var require_shuffle = __commonJS({
  "node_modules/libp2p-gossipsub/src/utils/shuffle.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.shuffle = void 0;
    function shuffle(arr) {
      if (arr.length <= 1) {
        return arr;
      }
      const randInt = () => {
        return Math.floor(Math.random() * Math.floor(arr.length));
      };
      for (let i = 0; i < arr.length; i++) {
        const j = randInt();
        const tmp = arr[i];
        arr[i] = arr[j];
        arr[j] = tmp;
      }
      return arr;
    }
    exports2.shuffle = shuffle;
  }
});

// node_modules/libp2p-gossipsub/src/constants.js
var require_constants3 = __commonJS({
  "node_modules/libp2p-gossipsub/src/constants.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ERR_TOPIC_VALIDATOR_IGNORE = exports2.ERR_TOPIC_VALIDATOR_REJECT = exports2.TimeCacheDuration = exports2.GossipsubSeenTTL = exports2.GossipsubIWantFollowupTime = exports2.GossipsubMaxIHaveMessages = exports2.GossipsubMaxIHaveLength = exports2.GossipsubGraftFloodThreshold = exports2.GossipsubOpportunisticGraftPeers = exports2.GossipsubOpportunisticGraftTicks = exports2.GossipsubDirectConnectInitialDelay = exports2.GossipsubDirectConnectTicks = exports2.GossipsubConnectionTimeout = exports2.GossipsubMaxPendingConnections = exports2.GossipsubConnectors = exports2.GossipsubPruneBackoffTicks = exports2.GossipsubPruneBackoff = exports2.GossipsubPrunePeers = exports2.GossipsubFanoutTTL = exports2.GossipsubHeartbeatInterval = exports2.GossipsubHeartbeatInitialDelay = exports2.GossipsubGossipRetransmission = exports2.GossipsubGossipFactor = exports2.GossipsubDlazy = exports2.GossipsubHistoryGossip = exports2.GossipsubHistoryLength = exports2.GossipsubDout = exports2.GossipsubDscore = exports2.GossipsubDhi = exports2.GossipsubDlo = exports2.GossipsubD = exports2.GossipsubIDv11 = exports2.GossipsubIDv10 = exports2.FloodsubID = exports2.minute = exports2.second = void 0;
    exports2.second = 1e3;
    exports2.minute = 60 * exports2.second;
    exports2.FloodsubID = "/floodsub/1.0.0";
    exports2.GossipsubIDv10 = "/meshsub/1.0.0";
    exports2.GossipsubIDv11 = "/meshsub/1.1.0";
    exports2.GossipsubD = 6;
    exports2.GossipsubDlo = 4;
    exports2.GossipsubDhi = 12;
    exports2.GossipsubDscore = 4;
    exports2.GossipsubDout = 2;
    exports2.GossipsubHistoryLength = 5;
    exports2.GossipsubHistoryGossip = 3;
    exports2.GossipsubDlazy = 6;
    exports2.GossipsubGossipFactor = 0.25;
    exports2.GossipsubGossipRetransmission = 3;
    exports2.GossipsubHeartbeatInitialDelay = 100;
    exports2.GossipsubHeartbeatInterval = exports2.second;
    exports2.GossipsubFanoutTTL = exports2.minute;
    exports2.GossipsubPrunePeers = 16;
    exports2.GossipsubPruneBackoff = exports2.minute;
    exports2.GossipsubPruneBackoffTicks = 15;
    exports2.GossipsubConnectors = 8;
    exports2.GossipsubMaxPendingConnections = 128;
    exports2.GossipsubConnectionTimeout = 30 * exports2.second;
    exports2.GossipsubDirectConnectTicks = 300;
    exports2.GossipsubDirectConnectInitialDelay = exports2.second;
    exports2.GossipsubOpportunisticGraftTicks = 60;
    exports2.GossipsubOpportunisticGraftPeers = 2;
    exports2.GossipsubGraftFloodThreshold = 10 * exports2.second;
    exports2.GossipsubMaxIHaveLength = 5e3;
    exports2.GossipsubMaxIHaveMessages = 10;
    exports2.GossipsubIWantFollowupTime = 3 * exports2.second;
    exports2.GossipsubSeenTTL = 30 * exports2.second;
    exports2.TimeCacheDuration = 120 * 1e3;
    exports2.ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
    exports2.ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
  }
});

// node_modules/libp2p-gossipsub/src/utils/has-gossip-protocol.js
var require_has_gossip_protocol = __commonJS({
  "node_modules/libp2p-gossipsub/src/utils/has-gossip-protocol.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasGossipProtocol = void 0;
    var constants_1 = require_constants3();
    function hasGossipProtocol(protocol) {
      return protocol === constants_1.GossipsubIDv10 || protocol === constants_1.GossipsubIDv11;
    }
    exports2.hasGossipProtocol = hasGossipProtocol;
  }
});

// node_modules/libp2p-gossipsub/src/utils/messageIdToString.js
var require_messageIdToString = __commonJS({
  "node_modules/libp2p-gossipsub/src/utils/messageIdToString.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.messageIdToString = void 0;
    var to_string_1 = (init_to_string(), to_string_exports);
    function messageIdToString(msgId) {
      return to_string_1.toString(msgId, "base64");
    }
    exports2.messageIdToString = messageIdToString;
  }
});

// node_modules/libp2p-gossipsub/src/utils/index.js
var require_utils12 = __commonJS({
  "node_modules/libp2p-gossipsub/src/utils/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_create_gossip_rpc(), exports2);
    __exportStar(require_shuffle(), exports2);
    __exportStar(require_has_gossip_protocol(), exports2);
    __exportStar(require_messageIdToString(), exports2);
  }
});

// node_modules/libp2p-gossipsub/src/message-cache.js
var require_message_cache = __commonJS({
  "node_modules/libp2p-gossipsub/src/message-cache.js"(exports2) {
    init_node_globals();
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve6) {
          resolve6(value);
        });
      }
      return new (P || (P = Promise))(function(resolve6, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve6(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessageCache = void 0;
    var utils_1 = require_utils12();
    var MessageCache = class {
      constructor(gossip, history, msgIdFn) {
        this.msgs = new Map();
        this.peertx = new Map();
        this.history = [];
        for (let i = 0; i < history; i++) {
          this.history[i] = [];
        }
        this.gossip = gossip;
        this.msgIdFn = msgIdFn;
      }
      put(msg) {
        return __awaiter(this, void 0, void 0, function* () {
          const msgID = yield this.getMsgId(msg);
          const msgIdStr = utils_1.messageIdToString(msgID);
          this.msgs.set(msgIdStr, msg);
          this.history[0].push({ msgID, topics: msg.topicIDs });
        });
      }
      getMsgId(msg) {
        return this.msgIdFn(msg);
      }
      get(msgID) {
        return this.msgs.get(utils_1.messageIdToString(msgID));
      }
      getForPeer(msgID, p) {
        const msgIdStr = utils_1.messageIdToString(msgID);
        const msg = this.msgs.get(msgIdStr);
        if (!msg) {
          return [void 0, 0];
        }
        let peertx = this.peertx.get(msgIdStr);
        if (!peertx) {
          peertx = new Map();
          this.peertx.set(msgIdStr, peertx);
        }
        const count = (peertx.get(p) || 0) + 1;
        peertx.set(p, count);
        return [msg, count];
      }
      getGossipIDs(topic) {
        const msgIDs = [];
        for (let i = 0; i < this.gossip; i++) {
          this.history[i].forEach((entry) => {
            for (const t of entry.topics) {
              if (t === topic) {
                msgIDs.push(entry.msgID);
                break;
              }
            }
          });
        }
        return msgIDs;
      }
      shift() {
        const last6 = this.history[this.history.length - 1];
        last6.forEach((entry) => {
          const msgIdStr = utils_1.messageIdToString(entry.msgID);
          this.msgs.delete(msgIdStr);
          this.peertx.delete(msgIdStr);
        });
        this.history.pop();
        this.history.unshift([]);
      }
    };
    exports2.MessageCache = MessageCache;
  }
});

// node_modules/libp2p-gossipsub/src/message/rpc.js
var require_rpc3 = __commonJS({
  "node_modules/libp2p-gossipsub/src/message/rpc.js"(exports2, module2) {
    init_node_globals();
    (function(global2, factory) {
      if (typeof define === "function" && define.amd)
        define(["protobufjs/minimal"], factory);
      else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2.exports)
        module2.exports = factory(require_minimal2());
    })(exports2, function($protobuf5) {
      "use strict";
      var $Reader5 = $protobuf5.Reader, $Writer5 = $protobuf5.Writer, $util5 = $protobuf5.util;
      var $root5 = $protobuf5.roots["default"] || ($protobuf5.roots["default"] = {});
      $root5.RPC = function() {
        function RPC(p) {
          this.subscriptions = [];
          this.msgs = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        RPC.prototype.subscriptions = $util5.emptyArray;
        RPC.prototype.msgs = $util5.emptyArray;
        RPC.prototype.control = null;
        var $oneOfFields;
        Object.defineProperty(RPC.prototype, "_control", {
          get: $util5.oneOfGetter($oneOfFields = ["control"]),
          set: $util5.oneOfSetter($oneOfFields)
        });
        RPC.encode = function encode10(m, w) {
          if (!w)
            w = $Writer5.create();
          if (m.subscriptions != null && m.subscriptions.length) {
            for (var i = 0; i < m.subscriptions.length; ++i)
              $root5.RPC.SubOpts.encode(m.subscriptions[i], w.uint32(10).fork()).ldelim();
          }
          if (m.msgs != null && m.msgs.length) {
            for (var i = 0; i < m.msgs.length; ++i)
              $root5.RPC.Message.encode(m.msgs[i], w.uint32(18).fork()).ldelim();
          }
          if (m.control != null && Object.hasOwnProperty.call(m, "control"))
            $root5.RPC.ControlMessage.encode(m.control, w.uint32(26).fork()).ldelim();
          return w;
        };
        RPC.decode = function decode12(r, l) {
          if (!(r instanceof $Reader5))
            r = $Reader5.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.subscriptions && m.subscriptions.length))
                  m.subscriptions = [];
                m.subscriptions.push($root5.RPC.SubOpts.decode(r, r.uint32()));
                break;
              case 2:
                if (!(m.msgs && m.msgs.length))
                  m.msgs = [];
                m.msgs.push($root5.RPC.Message.decode(r, r.uint32()));
                break;
              case 3:
                m.control = $root5.RPC.ControlMessage.decode(r, r.uint32());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        RPC.fromObject = function fromObject(d) {
          if (d instanceof $root5.RPC)
            return d;
          var m = new $root5.RPC();
          if (d.subscriptions) {
            if (!Array.isArray(d.subscriptions))
              throw TypeError(".RPC.subscriptions: array expected");
            m.subscriptions = [];
            for (var i = 0; i < d.subscriptions.length; ++i) {
              if (typeof d.subscriptions[i] !== "object")
                throw TypeError(".RPC.subscriptions: object expected");
              m.subscriptions[i] = $root5.RPC.SubOpts.fromObject(d.subscriptions[i]);
            }
          }
          if (d.msgs) {
            if (!Array.isArray(d.msgs))
              throw TypeError(".RPC.msgs: array expected");
            m.msgs = [];
            for (var i = 0; i < d.msgs.length; ++i) {
              if (typeof d.msgs[i] !== "object")
                throw TypeError(".RPC.msgs: object expected");
              m.msgs[i] = $root5.RPC.Message.fromObject(d.msgs[i]);
            }
          }
          if (d.control != null) {
            if (typeof d.control !== "object")
              throw TypeError(".RPC.control: object expected");
            m.control = $root5.RPC.ControlMessage.fromObject(d.control);
          }
          return m;
        };
        RPC.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.subscriptions = [];
            d.msgs = [];
          }
          if (m.subscriptions && m.subscriptions.length) {
            d.subscriptions = [];
            for (var j = 0; j < m.subscriptions.length; ++j) {
              d.subscriptions[j] = $root5.RPC.SubOpts.toObject(m.subscriptions[j], o);
            }
          }
          if (m.msgs && m.msgs.length) {
            d.msgs = [];
            for (var j = 0; j < m.msgs.length; ++j) {
              d.msgs[j] = $root5.RPC.Message.toObject(m.msgs[j], o);
            }
          }
          if (m.control != null && m.hasOwnProperty("control")) {
            d.control = $root5.RPC.ControlMessage.toObject(m.control, o);
            if (o.oneofs)
              d._control = "control";
          }
          return d;
        };
        RPC.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
        };
        RPC.SubOpts = function() {
          function SubOpts(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          SubOpts.prototype.subscribe = null;
          SubOpts.prototype.topicID = null;
          var $oneOfFields2;
          Object.defineProperty(SubOpts.prototype, "_subscribe", {
            get: $util5.oneOfGetter($oneOfFields2 = ["subscribe"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(SubOpts.prototype, "_topicID", {
            get: $util5.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          SubOpts.encode = function encode10(m, w) {
            if (!w)
              w = $Writer5.create();
            if (m.subscribe != null && Object.hasOwnProperty.call(m, "subscribe"))
              w.uint32(8).bool(m.subscribe);
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(18).string(m.topicID);
            return w;
          };
          SubOpts.decode = function decode12(r, l) {
            if (!(r instanceof $Reader5))
              r = $Reader5.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC.SubOpts();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.subscribe = r.bool();
                  break;
                case 2:
                  m.topicID = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          SubOpts.fromObject = function fromObject(d) {
            if (d instanceof $root5.RPC.SubOpts)
              return d;
            var m = new $root5.RPC.SubOpts();
            if (d.subscribe != null) {
              m.subscribe = Boolean(d.subscribe);
            }
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            return m;
          };
          SubOpts.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.subscribe != null && m.hasOwnProperty("subscribe")) {
              d.subscribe = m.subscribe;
              if (o.oneofs)
                d._subscribe = "subscribe";
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            return d;
          };
          SubOpts.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
          };
          return SubOpts;
        }();
        RPC.Message = function() {
          function Message2(p) {
            this.topicIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          Message2.prototype.from = null;
          Message2.prototype.data = null;
          Message2.prototype.seqno = null;
          Message2.prototype.topicIDs = $util5.emptyArray;
          Message2.prototype.signature = null;
          Message2.prototype.key = null;
          var $oneOfFields2;
          Object.defineProperty(Message2.prototype, "_from", {
            get: $util5.oneOfGetter($oneOfFields2 = ["from"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message2.prototype, "_data", {
            get: $util5.oneOfGetter($oneOfFields2 = ["data"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message2.prototype, "_seqno", {
            get: $util5.oneOfGetter($oneOfFields2 = ["seqno"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message2.prototype, "_signature", {
            get: $util5.oneOfGetter($oneOfFields2 = ["signature"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(Message2.prototype, "_key", {
            get: $util5.oneOfGetter($oneOfFields2 = ["key"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          Message2.encode = function encode10(m, w) {
            if (!w)
              w = $Writer5.create();
            if (m.from != null && Object.hasOwnProperty.call(m, "from"))
              w.uint32(10).bytes(m.from);
            if (m.data != null && Object.hasOwnProperty.call(m, "data"))
              w.uint32(18).bytes(m.data);
            if (m.seqno != null && Object.hasOwnProperty.call(m, "seqno"))
              w.uint32(26).bytes(m.seqno);
            if (m.topicIDs != null && m.topicIDs.length) {
              for (var i = 0; i < m.topicIDs.length; ++i)
                w.uint32(34).string(m.topicIDs[i]);
            }
            if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
              w.uint32(42).bytes(m.signature);
            if (m.key != null && Object.hasOwnProperty.call(m, "key"))
              w.uint32(50).bytes(m.key);
            return w;
          };
          Message2.decode = function decode12(r, l) {
            if (!(r instanceof $Reader5))
              r = $Reader5.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC.Message();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.from = r.bytes();
                  break;
                case 2:
                  m.data = r.bytes();
                  break;
                case 3:
                  m.seqno = r.bytes();
                  break;
                case 4:
                  if (!(m.topicIDs && m.topicIDs.length))
                    m.topicIDs = [];
                  m.topicIDs.push(r.string());
                  break;
                case 5:
                  m.signature = r.bytes();
                  break;
                case 6:
                  m.key = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          Message2.fromObject = function fromObject(d) {
            if (d instanceof $root5.RPC.Message)
              return d;
            var m = new $root5.RPC.Message();
            if (d.from != null) {
              if (typeof d.from === "string")
                $util5.base64.decode(d.from, m.from = $util5.newBuffer($util5.base64.length(d.from)), 0);
              else if (d.from.length)
                m.from = d.from;
            }
            if (d.data != null) {
              if (typeof d.data === "string")
                $util5.base64.decode(d.data, m.data = $util5.newBuffer($util5.base64.length(d.data)), 0);
              else if (d.data.length)
                m.data = d.data;
            }
            if (d.seqno != null) {
              if (typeof d.seqno === "string")
                $util5.base64.decode(d.seqno, m.seqno = $util5.newBuffer($util5.base64.length(d.seqno)), 0);
              else if (d.seqno.length)
                m.seqno = d.seqno;
            }
            if (d.topicIDs) {
              if (!Array.isArray(d.topicIDs))
                throw TypeError(".RPC.Message.topicIDs: array expected");
              m.topicIDs = [];
              for (var i = 0; i < d.topicIDs.length; ++i) {
                m.topicIDs[i] = String(d.topicIDs[i]);
              }
            }
            if (d.signature != null) {
              if (typeof d.signature === "string")
                $util5.base64.decode(d.signature, m.signature = $util5.newBuffer($util5.base64.length(d.signature)), 0);
              else if (d.signature.length)
                m.signature = d.signature;
            }
            if (d.key != null) {
              if (typeof d.key === "string")
                $util5.base64.decode(d.key, m.key = $util5.newBuffer($util5.base64.length(d.key)), 0);
              else if (d.key.length)
                m.key = d.key;
            }
            return m;
          };
          Message2.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.topicIDs = [];
            }
            if (m.from != null && m.hasOwnProperty("from")) {
              d.from = o.bytes === String ? $util5.base64.encode(m.from, 0, m.from.length) : o.bytes === Array ? Array.prototype.slice.call(m.from) : m.from;
              if (o.oneofs)
                d._from = "from";
            }
            if (m.data != null && m.hasOwnProperty("data")) {
              d.data = o.bytes === String ? $util5.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
              if (o.oneofs)
                d._data = "data";
            }
            if (m.seqno != null && m.hasOwnProperty("seqno")) {
              d.seqno = o.bytes === String ? $util5.base64.encode(m.seqno, 0, m.seqno.length) : o.bytes === Array ? Array.prototype.slice.call(m.seqno) : m.seqno;
              if (o.oneofs)
                d._seqno = "seqno";
            }
            if (m.topicIDs && m.topicIDs.length) {
              d.topicIDs = [];
              for (var j = 0; j < m.topicIDs.length; ++j) {
                d.topicIDs[j] = m.topicIDs[j];
              }
            }
            if (m.signature != null && m.hasOwnProperty("signature")) {
              d.signature = o.bytes === String ? $util5.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
              if (o.oneofs)
                d._signature = "signature";
            }
            if (m.key != null && m.hasOwnProperty("key")) {
              d.key = o.bytes === String ? $util5.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
              if (o.oneofs)
                d._key = "key";
            }
            return d;
          };
          Message2.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
          };
          return Message2;
        }();
        RPC.ControlMessage = function() {
          function ControlMessage(p) {
            this.ihave = [];
            this.iwant = [];
            this.graft = [];
            this.prune = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlMessage.prototype.ihave = $util5.emptyArray;
          ControlMessage.prototype.iwant = $util5.emptyArray;
          ControlMessage.prototype.graft = $util5.emptyArray;
          ControlMessage.prototype.prune = $util5.emptyArray;
          ControlMessage.encode = function encode10(m, w) {
            if (!w)
              w = $Writer5.create();
            if (m.ihave != null && m.ihave.length) {
              for (var i = 0; i < m.ihave.length; ++i)
                $root5.RPC.ControlIHave.encode(m.ihave[i], w.uint32(10).fork()).ldelim();
            }
            if (m.iwant != null && m.iwant.length) {
              for (var i = 0; i < m.iwant.length; ++i)
                $root5.RPC.ControlIWant.encode(m.iwant[i], w.uint32(18).fork()).ldelim();
            }
            if (m.graft != null && m.graft.length) {
              for (var i = 0; i < m.graft.length; ++i)
                $root5.RPC.ControlGraft.encode(m.graft[i], w.uint32(26).fork()).ldelim();
            }
            if (m.prune != null && m.prune.length) {
              for (var i = 0; i < m.prune.length; ++i)
                $root5.RPC.ControlPrune.encode(m.prune[i], w.uint32(34).fork()).ldelim();
            }
            return w;
          };
          ControlMessage.decode = function decode12(r, l) {
            if (!(r instanceof $Reader5))
              r = $Reader5.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC.ControlMessage();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.ihave && m.ihave.length))
                    m.ihave = [];
                  m.ihave.push($root5.RPC.ControlIHave.decode(r, r.uint32()));
                  break;
                case 2:
                  if (!(m.iwant && m.iwant.length))
                    m.iwant = [];
                  m.iwant.push($root5.RPC.ControlIWant.decode(r, r.uint32()));
                  break;
                case 3:
                  if (!(m.graft && m.graft.length))
                    m.graft = [];
                  m.graft.push($root5.RPC.ControlGraft.decode(r, r.uint32()));
                  break;
                case 4:
                  if (!(m.prune && m.prune.length))
                    m.prune = [];
                  m.prune.push($root5.RPC.ControlPrune.decode(r, r.uint32()));
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlMessage.fromObject = function fromObject(d) {
            if (d instanceof $root5.RPC.ControlMessage)
              return d;
            var m = new $root5.RPC.ControlMessage();
            if (d.ihave) {
              if (!Array.isArray(d.ihave))
                throw TypeError(".RPC.ControlMessage.ihave: array expected");
              m.ihave = [];
              for (var i = 0; i < d.ihave.length; ++i) {
                if (typeof d.ihave[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.ihave: object expected");
                m.ihave[i] = $root5.RPC.ControlIHave.fromObject(d.ihave[i]);
              }
            }
            if (d.iwant) {
              if (!Array.isArray(d.iwant))
                throw TypeError(".RPC.ControlMessage.iwant: array expected");
              m.iwant = [];
              for (var i = 0; i < d.iwant.length; ++i) {
                if (typeof d.iwant[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.iwant: object expected");
                m.iwant[i] = $root5.RPC.ControlIWant.fromObject(d.iwant[i]);
              }
            }
            if (d.graft) {
              if (!Array.isArray(d.graft))
                throw TypeError(".RPC.ControlMessage.graft: array expected");
              m.graft = [];
              for (var i = 0; i < d.graft.length; ++i) {
                if (typeof d.graft[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.graft: object expected");
                m.graft[i] = $root5.RPC.ControlGraft.fromObject(d.graft[i]);
              }
            }
            if (d.prune) {
              if (!Array.isArray(d.prune))
                throw TypeError(".RPC.ControlMessage.prune: array expected");
              m.prune = [];
              for (var i = 0; i < d.prune.length; ++i) {
                if (typeof d.prune[i] !== "object")
                  throw TypeError(".RPC.ControlMessage.prune: object expected");
                m.prune[i] = $root5.RPC.ControlPrune.fromObject(d.prune[i]);
              }
            }
            return m;
          };
          ControlMessage.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.ihave = [];
              d.iwant = [];
              d.graft = [];
              d.prune = [];
            }
            if (m.ihave && m.ihave.length) {
              d.ihave = [];
              for (var j = 0; j < m.ihave.length; ++j) {
                d.ihave[j] = $root5.RPC.ControlIHave.toObject(m.ihave[j], o);
              }
            }
            if (m.iwant && m.iwant.length) {
              d.iwant = [];
              for (var j = 0; j < m.iwant.length; ++j) {
                d.iwant[j] = $root5.RPC.ControlIWant.toObject(m.iwant[j], o);
              }
            }
            if (m.graft && m.graft.length) {
              d.graft = [];
              for (var j = 0; j < m.graft.length; ++j) {
                d.graft[j] = $root5.RPC.ControlGraft.toObject(m.graft[j], o);
              }
            }
            if (m.prune && m.prune.length) {
              d.prune = [];
              for (var j = 0; j < m.prune.length; ++j) {
                d.prune[j] = $root5.RPC.ControlPrune.toObject(m.prune[j], o);
              }
            }
            return d;
          };
          ControlMessage.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
          };
          return ControlMessage;
        }();
        RPC.ControlIHave = function() {
          function ControlIHave(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlIHave.prototype.topicID = null;
          ControlIHave.prototype.messageIDs = $util5.emptyArray;
          var $oneOfFields2;
          Object.defineProperty(ControlIHave.prototype, "_topicID", {
            get: $util5.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          ControlIHave.encode = function encode10(m, w) {
            if (!w)
              w = $Writer5.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i = 0; i < m.messageIDs.length; ++i)
                w.uint32(18).bytes(m.messageIDs[i]);
            }
            return w;
          };
          ControlIHave.decode = function decode12(r, l) {
            if (!(r instanceof $Reader5))
              r = $Reader5.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC.ControlIHave();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIHave.fromObject = function fromObject(d) {
            if (d instanceof $root5.RPC.ControlIHave)
              return d;
            var m = new $root5.RPC.ControlIHave();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIHave.messageIDs: array expected");
              m.messageIDs = [];
              for (var i = 0; i < d.messageIDs.length; ++i) {
                if (typeof d.messageIDs[i] === "string")
                  $util5.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util5.newBuffer($util5.base64.length(d.messageIDs[i])), 0);
                else if (d.messageIDs[i].length)
                  m.messageIDs[i] = d.messageIDs[i];
              }
            }
            return m;
          };
          ControlIHave.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util5.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIHave.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
          };
          return ControlIHave;
        }();
        RPC.ControlIWant = function() {
          function ControlIWant(p) {
            this.messageIDs = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlIWant.prototype.messageIDs = $util5.emptyArray;
          ControlIWant.encode = function encode10(m, w) {
            if (!w)
              w = $Writer5.create();
            if (m.messageIDs != null && m.messageIDs.length) {
              for (var i = 0; i < m.messageIDs.length; ++i)
                w.uint32(10).bytes(m.messageIDs[i]);
            }
            return w;
          };
          ControlIWant.decode = function decode12(r, l) {
            if (!(r instanceof $Reader5))
              r = $Reader5.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC.ControlIWant();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  if (!(m.messageIDs && m.messageIDs.length))
                    m.messageIDs = [];
                  m.messageIDs.push(r.bytes());
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlIWant.fromObject = function fromObject(d) {
            if (d instanceof $root5.RPC.ControlIWant)
              return d;
            var m = new $root5.RPC.ControlIWant();
            if (d.messageIDs) {
              if (!Array.isArray(d.messageIDs))
                throw TypeError(".RPC.ControlIWant.messageIDs: array expected");
              m.messageIDs = [];
              for (var i = 0; i < d.messageIDs.length; ++i) {
                if (typeof d.messageIDs[i] === "string")
                  $util5.base64.decode(d.messageIDs[i], m.messageIDs[i] = $util5.newBuffer($util5.base64.length(d.messageIDs[i])), 0);
                else if (d.messageIDs[i].length)
                  m.messageIDs[i] = d.messageIDs[i];
              }
            }
            return m;
          };
          ControlIWant.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.messageIDs = [];
            }
            if (m.messageIDs && m.messageIDs.length) {
              d.messageIDs = [];
              for (var j = 0; j < m.messageIDs.length; ++j) {
                d.messageIDs[j] = o.bytes === String ? $util5.base64.encode(m.messageIDs[j], 0, m.messageIDs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.messageIDs[j]) : m.messageIDs[j];
              }
            }
            return d;
          };
          ControlIWant.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
          };
          return ControlIWant;
        }();
        RPC.ControlGraft = function() {
          function ControlGraft(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlGraft.prototype.topicID = null;
          var $oneOfFields2;
          Object.defineProperty(ControlGraft.prototype, "_topicID", {
            get: $util5.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          ControlGraft.encode = function encode10(m, w) {
            if (!w)
              w = $Writer5.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            return w;
          };
          ControlGraft.decode = function decode12(r, l) {
            if (!(r instanceof $Reader5))
              r = $Reader5.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC.ControlGraft();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlGraft.fromObject = function fromObject(d) {
            if (d instanceof $root5.RPC.ControlGraft)
              return d;
            var m = new $root5.RPC.ControlGraft();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            return m;
          };
          ControlGraft.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            return d;
          };
          ControlGraft.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
          };
          return ControlGraft;
        }();
        RPC.ControlPrune = function() {
          function ControlPrune(p) {
            this.peers = [];
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          ControlPrune.prototype.topicID = null;
          ControlPrune.prototype.peers = $util5.emptyArray;
          ControlPrune.prototype.backoff = null;
          var $oneOfFields2;
          Object.defineProperty(ControlPrune.prototype, "_topicID", {
            get: $util5.oneOfGetter($oneOfFields2 = ["topicID"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(ControlPrune.prototype, "_backoff", {
            get: $util5.oneOfGetter($oneOfFields2 = ["backoff"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          ControlPrune.encode = function encode10(m, w) {
            if (!w)
              w = $Writer5.create();
            if (m.topicID != null && Object.hasOwnProperty.call(m, "topicID"))
              w.uint32(10).string(m.topicID);
            if (m.peers != null && m.peers.length) {
              for (var i = 0; i < m.peers.length; ++i)
                $root5.RPC.PeerInfo.encode(m.peers[i], w.uint32(18).fork()).ldelim();
            }
            if (m.backoff != null && Object.hasOwnProperty.call(m, "backoff"))
              w.uint32(24).uint64(m.backoff);
            return w;
          };
          ControlPrune.decode = function decode12(r, l) {
            if (!(r instanceof $Reader5))
              r = $Reader5.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC.ControlPrune();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.topicID = r.string();
                  break;
                case 2:
                  if (!(m.peers && m.peers.length))
                    m.peers = [];
                  m.peers.push($root5.RPC.PeerInfo.decode(r, r.uint32()));
                  break;
                case 3:
                  m.backoff = r.uint64();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          ControlPrune.fromObject = function fromObject(d) {
            if (d instanceof $root5.RPC.ControlPrune)
              return d;
            var m = new $root5.RPC.ControlPrune();
            if (d.topicID != null) {
              m.topicID = String(d.topicID);
            }
            if (d.peers) {
              if (!Array.isArray(d.peers))
                throw TypeError(".RPC.ControlPrune.peers: array expected");
              m.peers = [];
              for (var i = 0; i < d.peers.length; ++i) {
                if (typeof d.peers[i] !== "object")
                  throw TypeError(".RPC.ControlPrune.peers: object expected");
                m.peers[i] = $root5.RPC.PeerInfo.fromObject(d.peers[i]);
              }
            }
            if (d.backoff != null) {
              if ($util5.Long)
                (m.backoff = $util5.Long.fromValue(d.backoff)).unsigned = true;
              else if (typeof d.backoff === "string")
                m.backoff = parseInt(d.backoff, 10);
              else if (typeof d.backoff === "number")
                m.backoff = d.backoff;
              else if (typeof d.backoff === "object")
                m.backoff = new $util5.LongBits(d.backoff.low >>> 0, d.backoff.high >>> 0).toNumber(true);
            }
            return m;
          };
          ControlPrune.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.arrays || o.defaults) {
              d.peers = [];
            }
            if (m.topicID != null && m.hasOwnProperty("topicID")) {
              d.topicID = m.topicID;
              if (o.oneofs)
                d._topicID = "topicID";
            }
            if (m.peers && m.peers.length) {
              d.peers = [];
              for (var j = 0; j < m.peers.length; ++j) {
                d.peers[j] = $root5.RPC.PeerInfo.toObject(m.peers[j], o);
              }
            }
            if (m.backoff != null && m.hasOwnProperty("backoff")) {
              if (typeof m.backoff === "number")
                d.backoff = o.longs === String ? String(m.backoff) : m.backoff;
              else
                d.backoff = o.longs === String ? $util5.Long.prototype.toString.call(m.backoff) : o.longs === Number ? new $util5.LongBits(m.backoff.low >>> 0, m.backoff.high >>> 0).toNumber(true) : m.backoff;
              if (o.oneofs)
                d._backoff = "backoff";
            }
            return d;
          };
          ControlPrune.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
          };
          return ControlPrune;
        }();
        RPC.PeerInfo = function() {
          function PeerInfo(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          PeerInfo.prototype.peerID = null;
          PeerInfo.prototype.signedPeerRecord = null;
          var $oneOfFields2;
          Object.defineProperty(PeerInfo.prototype, "_peerID", {
            get: $util5.oneOfGetter($oneOfFields2 = ["peerID"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          Object.defineProperty(PeerInfo.prototype, "_signedPeerRecord", {
            get: $util5.oneOfGetter($oneOfFields2 = ["signedPeerRecord"]),
            set: $util5.oneOfSetter($oneOfFields2)
          });
          PeerInfo.encode = function encode10(m, w) {
            if (!w)
              w = $Writer5.create();
            if (m.peerID != null && Object.hasOwnProperty.call(m, "peerID"))
              w.uint32(10).bytes(m.peerID);
            if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord"))
              w.uint32(18).bytes(m.signedPeerRecord);
            return w;
          };
          PeerInfo.decode = function decode12(r, l) {
            if (!(r instanceof $Reader5))
              r = $Reader5.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root5.RPC.PeerInfo();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.peerID = r.bytes();
                  break;
                case 2:
                  m.signedPeerRecord = r.bytes();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          PeerInfo.fromObject = function fromObject(d) {
            if (d instanceof $root5.RPC.PeerInfo)
              return d;
            var m = new $root5.RPC.PeerInfo();
            if (d.peerID != null) {
              if (typeof d.peerID === "string")
                $util5.base64.decode(d.peerID, m.peerID = $util5.newBuffer($util5.base64.length(d.peerID)), 0);
              else if (d.peerID.length)
                m.peerID = d.peerID;
            }
            if (d.signedPeerRecord != null) {
              if (typeof d.signedPeerRecord === "string")
                $util5.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util5.newBuffer($util5.base64.length(d.signedPeerRecord)), 0);
              else if (d.signedPeerRecord.length)
                m.signedPeerRecord = d.signedPeerRecord;
            }
            return m;
          };
          PeerInfo.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (m.peerID != null && m.hasOwnProperty("peerID")) {
              d.peerID = o.bytes === String ? $util5.base64.encode(m.peerID, 0, m.peerID.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerID) : m.peerID;
              if (o.oneofs)
                d._peerID = "peerID";
            }
            if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
              d.signedPeerRecord = o.bytes === String ? $util5.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
              if (o.oneofs)
                d._signedPeerRecord = "signedPeerRecord";
            }
            return d;
          };
          PeerInfo.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
          };
          return PeerInfo;
        }();
        return RPC;
      }();
      return $root5;
    });
  }
});

// node_modules/libp2p-gossipsub/src/get-gossip-peers.js
var require_get_gossip_peers = __commonJS({
  "node_modules/libp2p-gossipsub/src/get-gossip-peers.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGossipPeers = void 0;
    var utils_1 = require_utils12();
    function getGossipPeers(router, topic, count, filter8 = () => true) {
      const peersInTopic = router.topics.get(topic);
      if (!peersInTopic) {
        return new Set();
      }
      let peers = [];
      peersInTopic.forEach((id) => {
        const peerStreams = router.peers.get(id);
        if (!peerStreams) {
          return;
        }
        if (utils_1.hasGossipProtocol(peerStreams.protocol) && filter8(id)) {
          peers.push(id);
        }
      });
      peers = utils_1.shuffle(peers);
      if (count > 0 && peers.length > count) {
        peers = peers.slice(0, count);
      }
      return new Set(peers);
    }
    exports2.getGossipPeers = getGossipPeers;
  }
});

// node_modules/libp2p-gossipsub/src/heartbeat.js
var require_heartbeat = __commonJS({
  "node_modules/libp2p-gossipsub/src/heartbeat.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Heartbeat = void 0;
    var constants = __importStar(require_constants3());
    var get_gossip_peers_1 = require_get_gossip_peers();
    var utils_1 = require_utils12();
    var Heartbeat = class {
      constructor(gossipsub) {
        this.gossipsub = gossipsub;
      }
      start() {
        if (this._heartbeatTimer) {
          return;
        }
        const heartbeat = this._heartbeat.bind(this);
        const timeout = setTimeout(() => {
          heartbeat();
          this._heartbeatTimer.runPeriodically(heartbeat, this.gossipsub._options.heartbeatInterval);
        }, constants.GossipsubHeartbeatInitialDelay);
        this._heartbeatTimer = {
          _intervalId: void 0,
          runPeriodically: (fn, period) => {
            this._heartbeatTimer._intervalId = setInterval(fn, period);
          },
          cancel: () => {
            clearTimeout(timeout);
            clearInterval(this._heartbeatTimer._intervalId);
          }
        };
      }
      stop() {
        if (!this._heartbeatTimer) {
          return;
        }
        this._heartbeatTimer.cancel();
        this._heartbeatTimer = null;
      }
      _heartbeat() {
        const { D, Dlo, Dhi, Dscore, Dout, fanoutTTL } = this.gossipsub._options;
        this.gossipsub.heartbeatTicks++;
        const scores = new Map();
        const getScore = (id) => {
          let s = scores.get(id);
          if (s === void 0) {
            s = this.gossipsub.score.score(id);
            scores.set(id, s);
          }
          return s;
        };
        const tograft = new Map();
        const toprune = new Map();
        const noPX = new Map();
        this.gossipsub._clearBackoff();
        this.gossipsub.peerhave.clear();
        this.gossipsub.iasked.clear();
        this.gossipsub._applyIwantPenalties();
        this.gossipsub._directConnect();
        this.gossipsub.mesh.forEach((peers, topic) => {
          const prunePeer = (id) => {
            this.gossipsub.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
            this.gossipsub.score.prune(id, topic);
            this.gossipsub._addBackoff(id, topic);
            peers.delete(id);
            const topics = toprune.get(id);
            if (!topics) {
              toprune.set(id, [topic]);
            } else {
              topics.push(topic);
            }
          };
          const graftPeer = (id) => {
            this.gossipsub.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
            this.gossipsub.score.graft(id, topic);
            peers.add(id);
            const topics = tograft.get(id);
            if (!topics) {
              tograft.set(id, [topic]);
            } else {
              topics.push(topic);
            }
          };
          peers.forEach((id) => {
            const score = getScore(id);
            if (score < 0) {
              this.gossipsub.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
              prunePeer(id);
              noPX.set(id, true);
            }
          });
          if (peers.size < Dlo) {
            const backoff = this.gossipsub.backoff.get(topic);
            const ineed = D - peers.size;
            const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {
              return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;
            });
            peersSet.forEach(graftPeer);
          }
          if (peers.size > Dhi) {
            let peersArray = Array.from(peers);
            peersArray.sort((a, b) => getScore(b) - getScore(a));
            peersArray = peersArray.slice(0, Dscore).concat(utils_1.shuffle(peersArray.slice(Dscore)));
            let outbound = 0;
            peersArray.slice(0, D).forEach((p) => {
              if (this.gossipsub.outbound.get(p)) {
                outbound++;
              }
            });
            if (outbound < Dout) {
              const rotate = (i) => {
                const p = peersArray[i];
                for (let j = i; j > 0; j--) {
                  peersArray[j] = peersArray[j - 1];
                }
                peersArray[0] = p;
              };
              if (outbound > 0) {
                let ihave = outbound;
                for (let i = 1; i < D && ihave > 0; i++) {
                  if (this.gossipsub.outbound.get(peersArray[i])) {
                    rotate(i);
                    ihave--;
                  }
                }
              }
              let ineed = D - outbound;
              for (let i = D; i < peersArray.length && ineed > 0; i++) {
                if (this.gossipsub.outbound.get(peersArray[i])) {
                  rotate(i);
                  ineed--;
                }
              }
            }
            peersArray.slice(D).forEach(prunePeer);
          }
          if (peers.size >= Dlo) {
            let outbound = 0;
            peers.forEach((p) => {
              if (this.gossipsub.outbound.get(p)) {
                outbound++;
              }
            });
            if (outbound < Dout) {
              const ineed = Dout - outbound;
              const backoff = this.gossipsub.backoff.get(topic);
              get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {
                return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;
              }).forEach(graftPeer);
            }
          }
          if (this.gossipsub.heartbeatTicks % constants.GossipsubOpportunisticGraftTicks === 0 && peers.size > 1) {
            const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
            const medianIndex = Math.floor(peers.size / 2);
            const medianScore = getScore(peersList[medianIndex]);
            if (medianScore < this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {
              const backoff = this.gossipsub.backoff.get(topic);
              const peersToGraft = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, constants.GossipsubOpportunisticGraftPeers, (id) => {
                return peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) > medianScore;
              });
              peersToGraft.forEach((id) => {
                this.gossipsub.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
                graftPeer(id);
              });
            }
          }
          this.gossipsub._emitGossip(topic, peers);
        });
        const now = this.gossipsub._now();
        this.gossipsub.lastpub.forEach((lastpb, topic) => {
          if (lastpb + fanoutTTL < now) {
            this.gossipsub.fanout.delete(topic);
            this.gossipsub.lastpub.delete(topic);
          }
        });
        this.gossipsub.fanout.forEach((fanoutPeers, topic) => {
          const topicPeers = this.gossipsub.topics.get(topic);
          fanoutPeers.forEach((id) => {
            if (!topicPeers.has(id) || getScore(id) < this.gossipsub._options.scoreThresholds.publishThreshold) {
              fanoutPeers.delete(id);
            }
          });
          if (fanoutPeers.size < D) {
            const ineed = D - fanoutPeers.size;
            const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {
              return !fanoutPeers.has(id) && !this.gossipsub.direct.has(id) && getScore(id) >= this.gossipsub._options.scoreThresholds.publishThreshold;
            });
            peersSet.forEach((id) => {
              fanoutPeers.add(id);
            });
          }
          this.gossipsub._emitGossip(topic, fanoutPeers);
        });
        this.gossipsub._sendGraftPrune(tograft, toprune, noPX);
        this.gossipsub._flush();
        this.gossipsub.messageCache.shift();
        this.gossipsub.emit("gossipsub:heartbeat");
      }
    };
    exports2.Heartbeat = Heartbeat;
  }
});

// node_modules/libp2p-gossipsub/src/score/constants.js
var require_constants4 = __commonJS({
  "node_modules/libp2p-gossipsub/src/score/constants.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ERR_INVALID_PEER_SCORE_THRESHOLDS = exports2.ERR_INVALID_PEER_SCORE_PARAMS = void 0;
    exports2.ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS";
    exports2.ERR_INVALID_PEER_SCORE_THRESHOLDS = "ERR_INVALID_PEER_SCORE_THRESHOLDS";
  }
});

// node_modules/libp2p-gossipsub/src/score/peer-score-params.js
var require_peer_score_params = __commonJS({
  "node_modules/libp2p-gossipsub/src/score/peer-score-params.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validateTopicScoreParams = exports2.validatePeerScoreParams = exports2.createTopicScoreParams = exports2.createPeerScoreParams = exports2.defaultTopicScoreParams = exports2.defaultPeerScoreParams = void 0;
    var constants_1 = require_constants4();
    var errcode7 = require_err_code();
    exports2.defaultPeerScoreParams = {
      topics: {},
      topicScoreCap: 10,
      appSpecificScore: () => 0,
      appSpecificWeight: 10,
      IPColocationFactorWeight: -5,
      IPColocationFactorThreshold: 10,
      IPColocationFactorWhitelist: new Set(),
      behaviourPenaltyWeight: -10,
      behaviourPenaltyDecay: 0.2,
      decayInterval: 1e3,
      decayToZero: 0.1,
      retainScore: 3600 * 1e3
    };
    exports2.defaultTopicScoreParams = {
      topicWeight: 0.5,
      timeInMeshWeight: 1,
      timeInMeshQuantum: 1,
      timeInMeshCap: 3600,
      firstMessageDeliveriesWeight: 1,
      firstMessageDeliveriesDecay: 0.5,
      firstMessageDeliveriesCap: 2e3,
      meshMessageDeliveriesWeight: -1,
      meshMessageDeliveriesDecay: 0.5,
      meshMessageDeliveriesCap: 100,
      meshMessageDeliveriesThreshold: 20,
      meshMessageDeliveriesWindow: 10,
      meshMessageDeliveriesActivation: 5e3,
      meshFailurePenaltyWeight: -1,
      meshFailurePenaltyDecay: 0.5,
      invalidMessageDeliveriesWeight: -1,
      invalidMessageDeliveriesDecay: 0.3
    };
    function createPeerScoreParams(p = {}) {
      return Object.assign(Object.assign(Object.assign({}, exports2.defaultPeerScoreParams), p), { topics: p.topics ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {
        topics[topic] = createTopicScoreParams(topicScoreParams);
        return topics;
      }, {}) : {} });
    }
    exports2.createPeerScoreParams = createPeerScoreParams;
    function createTopicScoreParams(p = {}) {
      return Object.assign(Object.assign({}, exports2.defaultTopicScoreParams), p);
    }
    exports2.createTopicScoreParams = createTopicScoreParams;
    function validatePeerScoreParams(p) {
      for (const [topic, params] of Object.entries(p.topics)) {
        try {
          validateTopicScoreParams(params);
        } catch (e) {
          throw errcode7(new Error(`invalid score parameters for topic ${topic}: ${e.message}`), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
        }
      }
      if (p.topicScoreCap < 0) {
        throw errcode7(new Error("invalid topic score cap; must be positive (or 0 for no cap)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.appSpecificScore === null || p.appSpecificScore === void 0) {
        throw errcode7(new Error("missing application specific score function"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.IPColocationFactorWeight > 0) {
        throw errcode7(new Error("invalid IPColocationFactorWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {
        throw errcode7(new Error("invalid IPColocationFactorThreshold; must be at least 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.behaviourPenaltyWeight > 0) {
        throw errcode7(new Error("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {
        throw errcode7(new Error("invalid BehaviourPenaltyDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.decayInterval < 1e3) {
        throw errcode7(new Error("invalid DecayInterval; must be at least 1s"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.decayToZero <= 0 || p.decayToZero >= 1) {
        throw errcode7(new Error("invalid DecayToZero; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
    }
    exports2.validatePeerScoreParams = validatePeerScoreParams;
    function validateTopicScoreParams(p) {
      if (p.topicWeight < 0) {
        throw errcode7(new Error("invalid topic weight; must be >= 0"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.timeInMeshQuantum === 0) {
        throw errcode7(new Error("invalid TimeInMeshQuantum; must be non zero"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.timeInMeshWeight < 0) {
        throw errcode7(new Error("invalid TimeInMeshWeight; must be positive (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {
        throw errcode7(new Error("invalid TimeInMeshQuantum; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {
        throw errcode7(new Error("invalid TimeInMeshCap; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.firstMessageDeliveriesWeight < 0) {
        throw errcode7(new Error("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.firstMessageDeliveriesWeight !== 0 && (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {
        throw errcode7(new Error("invalid FirstMessageDeliveriesDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {
        throw errcode7(new Error("invalid FirstMessageDeliveriesCap; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWeight > 0) {
        throw errcode7(new Error("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {
        throw errcode7(new Error("invalid MeshMessageDeliveriesDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {
        throw errcode7(new Error("invalid MeshMessageDeliveriesCap; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {
        throw errcode7(new Error("invalid MeshMessageDeliveriesThreshold; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWindow < 0) {
        throw errcode7(new Error("invalid MeshMessageDeliveriesWindow; must be non-negative"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1e3) {
        throw errcode7(new Error("invalid MeshMessageDeliveriesActivation; must be at least 1s"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshFailurePenaltyWeight > 0) {
        throw errcode7(new Error("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {
        throw errcode7(new Error("invalid MeshFailurePenaltyDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.invalidMessageDeliveriesWeight > 0) {
        throw errcode7(new Error("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
      if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {
        throw errcode7(new Error("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
    }
    exports2.validateTopicScoreParams = validateTopicScoreParams;
  }
});

// node_modules/libp2p-gossipsub/src/score/peer-score-thresholds.js
var require_peer_score_thresholds = __commonJS({
  "node_modules/libp2p-gossipsub/src/score/peer-score-thresholds.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.validatePeerScoreThresholds = exports2.createPeerScoreThresholds = exports2.defaultPeerScoreThresholds = void 0;
    var constants_1 = require_constants4();
    var errcode7 = require_err_code();
    exports2.defaultPeerScoreThresholds = {
      gossipThreshold: -10,
      publishThreshold: -50,
      graylistThreshold: -80,
      acceptPXThreshold: 10,
      opportunisticGraftThreshold: 20
    };
    function createPeerScoreThresholds(p = {}) {
      return Object.assign(Object.assign({}, exports2.defaultPeerScoreThresholds), p);
    }
    exports2.createPeerScoreThresholds = createPeerScoreThresholds;
    function validatePeerScoreThresholds(p) {
      if (p.gossipThreshold > 0) {
        throw errcode7(new Error("invalid gossip threshold; it must be <= 0"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
      }
      if (p.publishThreshold > 0 || p.publishThreshold > p.gossipThreshold) {
        throw errcode7(new Error("invalid publish threshold; it must be <= 0 and <= gossip threshold"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
      }
      if (p.graylistThreshold > 0 || p.graylistThreshold > p.publishThreshold) {
        throw errcode7(new Error("invalid graylist threshold; it must be <= 0 and <= publish threshold"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
      }
      if (p.acceptPXThreshold < 0) {
        throw errcode7(new Error("invalid accept PX threshold; it must be >= 0"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
      }
      if (p.opportunisticGraftThreshold < 0) {
        throw errcode7(new Error("invalid opportunistic grafting threshold; it must be >= 0"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
      }
    }
    exports2.validatePeerScoreThresholds = validatePeerScoreThresholds;
  }
});

// node_modules/libp2p-gossipsub/src/score/peer-stats.js
var require_peer_stats = __commonJS({
  "node_modules/libp2p-gossipsub/src/score/peer-stats.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ensureTopicStats = exports2.createTopicStats = exports2.createPeerStats = void 0;
    function createPeerStats(ps = {}) {
      return Object.assign(Object.assign({ connected: false, expire: 0, ips: [], behaviourPenalty: 0 }, ps), { topics: ps.topics ? Object.entries(ps.topics).reduce((topics, [topic, topicStats]) => {
        topics[topic] = createTopicStats(topicStats);
        return topics;
      }, {}) : {} });
    }
    exports2.createPeerStats = createPeerStats;
    function createTopicStats(ts = {}) {
      return Object.assign({ inMesh: false, graftTime: 0, meshTime: 0, firstMessageDeliveries: 0, meshMessageDeliveries: 0, meshMessageDeliveriesActive: false, meshFailurePenalty: 0, invalidMessageDeliveries: 0 }, ts);
    }
    exports2.createTopicStats = createTopicStats;
    function ensureTopicStats(topic, ps, params) {
      let ts = ps.topics[topic];
      if (ts) {
        return ts;
      }
      if (!params.topics[topic]) {
        return void 0;
      }
      ps.topics[topic] = ts = createTopicStats();
      return ts;
    }
    exports2.ensureTopicStats = ensureTopicStats;
  }
});

// node_modules/libp2p-gossipsub/src/score/compute-score.js
var require_compute_score = __commonJS({
  "node_modules/libp2p-gossipsub/src/score/compute-score.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.computeScore = void 0;
    function computeScore(peer, pstats, params, peerIPs) {
      let score = 0;
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        const topicParams = params.topics[topic];
        if (!topicParams) {
          return;
        }
        let topicScore = 0;
        if (tstats.inMesh) {
          let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
          if (p1 > topicParams.timeInMeshCap) {
            p1 = topicParams.timeInMeshCap;
          }
          topicScore += p1 * topicParams.timeInMeshWeight;
        }
        const p2 = tstats.firstMessageDeliveries;
        topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
        if (tstats.meshMessageDeliveriesActive) {
          if (tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
            const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
            const p3 = deficit * deficit;
            topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
          }
        }
        const p3b = tstats.meshFailurePenalty;
        topicScore += p3b * topicParams.meshFailurePenaltyWeight;
        const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
        topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
        score += topicScore * topicParams.topicWeight;
      });
      if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
        score = params.topicScoreCap;
      }
      const p5 = params.appSpecificScore(peer);
      score += p5 * params.appSpecificWeight;
      pstats.ips.forEach((ip) => {
        if (params.IPColocationFactorWhitelist.has(ip)) {
          return;
        }
        const peersInIP = peerIPs.get(ip);
        const numPeersInIP = peersInIP ? peersInIP.size : 0;
        if (numPeersInIP > params.IPColocationFactorThreshold) {
          const surplus = numPeersInIP - params.IPColocationFactorThreshold;
          const p6 = surplus * surplus;
          score += p6 * params.IPColocationFactorWeight;
        }
      });
      const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
      score += p7 * params.behaviourPenaltyWeight;
      return score;
    }
    exports2.computeScore = computeScore;
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function Denque(array2, options) {
      var options = options || {};
      this._head = 0;
      this._tail = 0;
      this._capacity = options.capacity;
      this._capacityMask = 3;
      this._list = new Array(4);
      if (Array.isArray(array2)) {
        this._fromArray(array2);
      }
    }
    Denque.prototype.peekAt = function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len)
        return void 0;
      if (i < 0)
        i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get2(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail)
        return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length4() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail)
        return 0;
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (item === void 0)
        return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head)
        this._growArray();
      if (this._capacity && this.size() > this._capacity)
        this.pop();
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail)
        return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (item === void 0)
        return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail)
        return this._tail - this._head;
      else
        return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head)
        return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
        this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size)
        return void 0;
      if (i < 0)
        i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail)
        return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1)
        return void 0;
      if (i < 0)
        i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size)
        count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0)
          this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
        this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0)
        i += size;
      if (i > size)
        return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array2) {
      for (var i = 0; i < array2.length; i++)
        this.push(array2[i]);
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy) {
      var newArray = [];
      var list = this._list;
      var len = list.length;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < len; i++)
          newArray.push(list[i]);
        for (i = 0; i < this._tail; i++)
          newArray.push(list[i]);
      } else {
        for (i = this._head; i < this._tail; i++)
          newArray.push(list[i]);
      }
      return newArray;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head) {
        this._list = this._copyArray(true);
        this._head = 0;
      }
      this._tail = this._list.length;
      this._list.length <<= 1;
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    module2.exports = Denque;
  }
});

// node_modules/libp2p-gossipsub/src/score/message-deliveries.js
var require_message_deliveries = __commonJS({
  "node_modules/libp2p-gossipsub/src/score/message-deliveries.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.MessageDeliveries = exports2.DeliveryRecordStatus = void 0;
    var constants_1 = require_constants3();
    var denque_1 = __importDefault(require_denque());
    var utils_1 = require_utils12();
    var DeliveryRecordStatus;
    (function(DeliveryRecordStatus2) {
      DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
      DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
      DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
      DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
    })(DeliveryRecordStatus = exports2.DeliveryRecordStatus || (exports2.DeliveryRecordStatus = {}));
    var MessageDeliveries = class {
      constructor() {
        this.records = new Map();
        this.queue = new denque_1.default();
      }
      ensureRecord(msgId) {
        const msgIdStr = utils_1.messageIdToString(msgId);
        let drec = this.records.get(msgIdStr);
        if (drec) {
          return drec;
        }
        drec = {
          status: DeliveryRecordStatus.unknown,
          firstSeen: Date.now(),
          validated: 0,
          peers: new Set()
        };
        this.records.set(msgIdStr, drec);
        const entry = {
          msgId: msgIdStr,
          expire: Date.now() + constants_1.TimeCacheDuration
        };
        this.queue.push(entry);
        return drec;
      }
      gc() {
        const now = Date.now();
        let head = this.queue.peekFront();
        while (head && head.expire < now) {
          this.records.delete(head.msgId);
          this.queue.shift();
          head = this.queue.peekFront();
        }
      }
      clear() {
        this.records.clear();
        this.queue.clear();
      }
    };
    exports2.MessageDeliveries = MessageDeliveries;
  }
});

// node_modules/libp2p-gossipsub/src/score/peer-score.js
var require_peer_score = __commonJS({
  "node_modules/libp2p-gossipsub/src/score/peer-score.js"(exports2) {
    init_node_globals();
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve6) {
          resolve6(value);
        });
      }
      return new (P || (P = Promise))(function(resolve6, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve6(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PeerScore = void 0;
    var peer_score_params_1 = require_peer_score_params();
    var peer_stats_1 = require_peer_stats();
    var compute_score_1 = require_compute_score();
    var message_deliveries_1 = require_message_deliveries();
    var constants_1 = require_constants3();
    var peer_id_1 = __importDefault(require_src6());
    var debug17 = require_browser2();
    var pubsubErrors = require_errors3();
    var { ERR_INVALID_SIGNATURE, ERR_MISSING_SIGNATURE } = pubsubErrors.codes;
    var log15 = debug17("libp2p:gossipsub:score");
    var PeerScore = class {
      constructor(params, connectionManager, msgId) {
        peer_score_params_1.validatePeerScoreParams(params);
        this.params = params;
        this._connectionManager = connectionManager;
        this.peerStats = new Map();
        this.peerIPs = new Map();
        this.deliveryRecords = new message_deliveries_1.MessageDeliveries();
        this.msgId = msgId;
      }
      start() {
        if (this._backgroundInterval) {
          log15("Peer score already running");
          return;
        }
        this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);
        log15("started");
      }
      stop() {
        if (!this._backgroundInterval) {
          log15("Peer score already stopped");
          return;
        }
        clearInterval(this._backgroundInterval);
        delete this._backgroundInterval;
        this.peerIPs.clear();
        this.peerStats.clear();
        this.deliveryRecords.clear();
        log15("stopped");
      }
      background() {
        this._refreshScores();
        this._updateIPs();
        this.deliveryRecords.gc();
      }
      _refreshScores() {
        const now = Date.now();
        const decayToZero = this.params.decayToZero;
        this.peerStats.forEach((pstats, id) => {
          if (!pstats.connected) {
            if (now > pstats.expire) {
              this._removeIPs(id, pstats.ips);
              this.peerStats.delete(id);
            }
            return;
          }
          Object.entries(pstats.topics).forEach(([topic, tstats]) => {
            const tparams = this.params.topics[topic];
            if (!tparams) {
              return;
            }
            tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
            if (tstats.firstMessageDeliveries < decayToZero) {
              tstats.firstMessageDeliveries = 0;
            }
            tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
            if (tstats.meshMessageDeliveries < decayToZero) {
              tstats.meshMessageDeliveries = 0;
            }
            tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
            if (tstats.meshFailurePenalty < decayToZero) {
              tstats.meshFailurePenalty = 0;
            }
            tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
            if (tstats.invalidMessageDeliveries < decayToZero) {
              tstats.invalidMessageDeliveries = 0;
            }
            if (tstats.inMesh) {
              tstats.meshTime = now - tstats.graftTime;
              if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
                tstats.meshMessageDeliveriesActive = true;
              }
            }
          });
          pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
          if (pstats.behaviourPenalty < decayToZero) {
            pstats.behaviourPenalty = 0;
          }
        });
      }
      score(id) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return 0;
        }
        return compute_score_1.computeScore(id, pstats, this.params, this.peerIPs);
      }
      addPenalty(id, penalty) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        pstats.behaviourPenalty += penalty;
      }
      addPeer(id) {
        const pstats = peer_stats_1.createPeerStats({
          connected: true
        });
        this.peerStats.set(id, pstats);
        const ips = this._getIPs(id);
        this._setIPs(id, ips, pstats.ips);
        pstats.ips = ips;
      }
      removePeer(id) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        if (this.score(id) > 0) {
          this._removeIPs(id, pstats.ips);
          this.peerStats.delete(id);
          return;
        }
        Object.entries(pstats.topics).forEach(([topic, tstats]) => {
          tstats.firstMessageDeliveries = 0;
          const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
          if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
            const deficit = threshold - tstats.meshMessageDeliveries;
            tstats.meshFailurePenalty += deficit * deficit;
          }
          tstats.inMesh = false;
        });
        pstats.connected = false;
        pstats.expire = Date.now() + this.params.retainScore;
      }
      graft(id, topic) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
        if (!tstats) {
          return;
        }
        tstats.inMesh = true;
        tstats.graftTime = Date.now();
        tstats.meshTime = 0;
        tstats.meshMessageDeliveriesActive = false;
      }
      prune(id, topic) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
        if (!tstats) {
          return;
        }
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.inMesh = false;
      }
      validateMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
          this.deliveryRecords.ensureRecord(yield this.msgId(message));
        });
      }
      deliverMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
          const id = message.receivedFrom;
          this._markFirstMessageDelivery(id, message);
          const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));
          const now = Date.now();
          if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {
            log15("unexpected delivery: message from %s was first seen %s ago and has delivery status %d", id, now - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);
            return;
          }
          drec.status = message_deliveries_1.DeliveryRecordStatus.valid;
          drec.validated = now;
          drec.peers.forEach((p) => {
            if (p !== id) {
              this._markDuplicateMessageDelivery(p, message);
            }
          });
        });
      }
      rejectMessage(message, reason) {
        return __awaiter(this, void 0, void 0, function* () {
          const id = message.receivedFrom;
          switch (reason) {
            case ERR_MISSING_SIGNATURE:
            case ERR_INVALID_SIGNATURE:
              this._markInvalidMessageDelivery(id, message);
              return;
          }
          const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));
          if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {
            log15("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", id, Date.now() - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);
            return;
          }
          switch (reason) {
            case constants_1.ERR_TOPIC_VALIDATOR_IGNORE:
              drec.status = message_deliveries_1.DeliveryRecordStatus.ignored;
              return;
          }
          drec.status = message_deliveries_1.DeliveryRecordStatus.invalid;
          this._markInvalidMessageDelivery(id, message);
          drec.peers.forEach((p) => {
            this._markInvalidMessageDelivery(p, message);
          });
        });
      }
      duplicateMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
          const id = message.receivedFrom;
          const drec = this.deliveryRecords.ensureRecord(yield this.msgId(message));
          if (drec.peers.has(id)) {
            return;
          }
          switch (drec.status) {
            case message_deliveries_1.DeliveryRecordStatus.unknown:
              drec.peers.add(id);
              break;
            case message_deliveries_1.DeliveryRecordStatus.valid:
              drec.peers.add(id);
              this._markDuplicateMessageDelivery(id, message, drec.validated);
              break;
            case message_deliveries_1.DeliveryRecordStatus.invalid:
              this._markInvalidMessageDelivery(id, message);
              break;
          }
        });
      }
      _markInvalidMessageDelivery(id, message) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        message.topicIDs.forEach((topic) => {
          const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
          if (!tstats) {
            return;
          }
          tstats.invalidMessageDeliveries += 1;
        });
      }
      _markFirstMessageDelivery(id, message) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        message.topicIDs.forEach((topic) => {
          const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
          if (!tstats) {
            return;
          }
          let cap = this.params.topics[topic].firstMessageDeliveriesCap;
          tstats.firstMessageDeliveries += 1;
          if (tstats.firstMessageDeliveries > cap) {
            tstats.firstMessageDeliveries = cap;
          }
          if (!tstats.inMesh) {
            return;
          }
          cap = this.params.topics[topic].meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries += 1;
          if (tstats.meshMessageDeliveries > cap) {
            tstats.meshMessageDeliveries = cap;
          }
        });
      }
      _markDuplicateMessageDelivery(id, message, validatedTime = 0) {
        const pstats = this.peerStats.get(id);
        if (!pstats) {
          return;
        }
        const now = validatedTime ? Date.now() : 0;
        message.topicIDs.forEach((topic) => {
          const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
          if (!tstats) {
            return;
          }
          if (!tstats.inMesh) {
            return;
          }
          const tparams = this.params.topics[topic];
          if (validatedTime && now > validatedTime + tparams.meshMessageDeliveriesWindow) {
            return;
          }
          const cap = tparams.meshMessageDeliveriesCap;
          tstats.meshMessageDeliveries += 1;
          if (tstats.meshMessageDeliveries > cap) {
            tstats.meshMessageDeliveries = cap;
          }
        });
      }
      _getIPs(id) {
        return this._connectionManager.getAll(peer_id_1.default.createFromB58String(id)).map((c) => c.remoteAddr.toOptions().host);
      }
      _setIPs(id, newIPs, oldIPs) {
        addNewIPs:
          for (const ip of newIPs) {
            for (const xip of oldIPs) {
              if (ip === xip) {
                continue addNewIPs;
              }
            }
            let peers = this.peerIPs.get(ip);
            if (!peers) {
              peers = new Set();
              this.peerIPs.set(ip, peers);
            }
            peers.add(id);
          }
        removeOldIPs:
          for (const ip of oldIPs) {
            for (const xip of newIPs) {
              if (ip === xip) {
                continue removeOldIPs;
              }
            }
            const peers = this.peerIPs.get(ip);
            if (!peers) {
              continue;
            }
            peers.delete(id);
            if (!peers.size) {
              this.peerIPs.delete(ip);
            }
          }
      }
      _removeIPs(id, ips) {
        ips.forEach((ip) => {
          const peers = this.peerIPs.get(ip);
          if (!peers) {
            return;
          }
          peers.delete(id);
          if (!peers.size) {
            this.peerIPs.delete(ip);
          }
        });
      }
      _updateIPs() {
        this.peerStats.forEach((pstats, id) => {
          const newIPs = this._getIPs(id);
          this._setIPs(id, newIPs, pstats.ips);
          pstats.ips = newIPs;
        });
      }
    };
    exports2.PeerScore = PeerScore;
  }
});

// node_modules/libp2p-gossipsub/src/score/index.js
var require_score = __commonJS({
  "node_modules/libp2p-gossipsub/src/score/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    __exportStar(require_peer_score_params(), exports2);
    __exportStar(require_peer_score_thresholds(), exports2);
    __exportStar(require_peer_score(), exports2);
  }
});

// node_modules/libp2p-gossipsub/src/tracer.js
var require_tracer = __commonJS({
  "node_modules/libp2p-gossipsub/src/tracer.js"(exports2) {
    init_node_globals();
    "use strict";
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve6) {
          resolve6(value);
        });
      }
      return new (P || (P = Promise))(function(resolve6, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve6(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IWantTracer = void 0;
    var constants_1 = require_constants3();
    var utils_1 = require_utils12();
    var pubsubErrors = require_errors3();
    var { ERR_INVALID_SIGNATURE, ERR_MISSING_SIGNATURE } = pubsubErrors.codes;
    var IWantTracer = class {
      constructor(getMsgId) {
        this.getMsgId = getMsgId;
        this.promises = new Map();
      }
      addPromise(p, msgIds) {
        const ix = Math.floor(Math.random() * msgIds.length);
        const msgId = msgIds[ix];
        const msgIdStr = utils_1.messageIdToString(msgId);
        let peers = this.promises.get(msgIdStr);
        if (!peers) {
          peers = new Map();
          this.promises.set(msgIdStr, peers);
        }
        if (!peers.has(p)) {
          peers.set(p, Date.now() + constants_1.GossipsubIWantFollowupTime);
        }
      }
      getBrokenPromises() {
        const now = Date.now();
        const result = new Map();
        this.promises.forEach((peers, msgId) => {
          peers.forEach((expire, p) => {
            if (expire < now) {
              result.set(p, (result.get(p) || 0) + 1);
              peers.delete(p);
            }
          });
          if (!peers.size) {
            this.promises.delete(msgId);
          }
        });
        return result;
      }
      deliverMessage(msg) {
        return __awaiter(this, void 0, void 0, function* () {
          const msgId = yield this.getMsgId(msg);
          const msgIdStr = utils_1.messageIdToString(msgId);
          this.promises.delete(msgIdStr);
        });
      }
      rejectMessage(msg, reason) {
        return __awaiter(this, void 0, void 0, function* () {
          switch (reason) {
            case ERR_INVALID_SIGNATURE:
            case ERR_MISSING_SIGNATURE:
              return;
          }
          const msgId = yield this.getMsgId(msg);
          const msgIdStr = utils_1.messageIdToString(msgId);
          this.promises.delete(msgIdStr);
        });
      }
      clear() {
        this.promises.clear();
      }
    };
    exports2.IWantTracer = IWantTracer;
  }
});

// node_modules/lodash.throttle/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.throttle/index.js"(exports2, module2) {
    init_node_globals();
    var FUNC_ERROR_TEXT = "Expected a function";
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var nativeMax = Math.max;
    var nativeMin = Math.min;
    var now = function() {
      return root.Date.now();
    };
    function debounce2(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
        return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush2() {
        return timerId === void 0 ? result : trailingEdge(now());
      }
      function debounced() {
        var time = now(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush2;
      return debounced;
    }
    function throttle(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce2(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    function isObject(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isSymbol(value) {
      return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
    }
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary2 = reIsBinary.test(value);
      return isBinary2 || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary2 ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    module2.exports = throttle;
  }
});

// node_modules/time-cache/src/index.js
var require_src13 = __commonJS({
  "node_modules/time-cache/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var throttle = require_lodash();
    exports2 = module2.exports = TimeCache;
    function TimeCache(options) {
      if (!(this instanceof TimeCache)) {
        return new TimeCache(options);
      }
      options = options || {};
      const validity = options.validity || 30;
      const entries = new Map();
      const sweep = throttle(() => {
        entries.forEach((entry, key) => {
          const v = entry.validity || validity;
          const delta = getTimeElapsed(entry.timestamp);
          if (delta > v) {
            entries.delete(key);
          }
        });
      }, 200);
      this.put = (key, value, validity2) => {
        if (!this.has(key)) {
          entries.set(key, {
            value,
            timestamp: new Date(),
            validity: validity2
          });
        }
        sweep();
      };
      this.get = (key) => {
        if (entries.has(key)) {
          return entries.get(key).value;
        } else {
          throw new Error("key does not exist");
        }
      };
      this.has = (key) => {
        return entries.has(key);
      };
    }
    function getTimeElapsed(prevTime) {
      const currentTime = new Date();
      const a = currentTime.getTime() - prevTime.getTime();
      return Math.floor(a / 1e3);
    }
  }
});

// node_modules/libp2p/src/errors.js
var require_errors4 = __commonJS({
  "node_modules/libp2p/src/errors.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.messages = {
      NOT_STARTED_YET: "The libp2p node is not started yet",
      DHT_DISABLED: "DHT is not available",
      CONN_ENCRYPTION_REQUIRED: "At least one connection encryption module is required"
    };
    exports2.codes = {
      DHT_DISABLED: "ERR_DHT_DISABLED",
      PUBSUB_NOT_STARTED: "ERR_PUBSUB_NOT_STARTED",
      DHT_NOT_STARTED: "ERR_DHT_NOT_STARTED",
      CONN_ENCRYPTION_REQUIRED: "ERR_CONN_ENCRYPTION_REQUIRED",
      ERR_INVALID_PROTOCOLS_FOR_STREAM: "ERR_INVALID_PROTOCOLS_FOR_STREAM",
      ERR_CONNECTION_ENDED: "ERR_CONNECTION_ENDED",
      ERR_CONNECTION_FAILED: "ERR_CONNECTION_FAILED",
      ERR_NODE_NOT_STARTED: "ERR_NODE_NOT_STARTED",
      ERR_ALREADY_ABORTED: "ERR_ALREADY_ABORTED",
      ERR_TOO_MANY_ADDRESSES: "ERR_TOO_MANY_ADDRESSES",
      ERR_NO_VALID_ADDRESSES: "ERR_NO_VALID_ADDRESSES",
      ERR_RELAYED_DIAL: "ERR_RELAYED_DIAL",
      ERR_DIALED_SELF: "ERR_DIALED_SELF",
      ERR_DISCOVERED_SELF: "ERR_DISCOVERED_SELF",
      ERR_DUPLICATE_TRANSPORT: "ERR_DUPLICATE_TRANSPORT",
      ERR_ENCRYPTION_FAILED: "ERR_ENCRYPTION_FAILED",
      ERR_HOP_REQUEST_FAILED: "ERR_HOP_REQUEST_FAILED",
      ERR_INVALID_KEY: "ERR_INVALID_KEY",
      ERR_INVALID_MESSAGE: "ERR_INVALID_MESSAGE",
      ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS",
      ERR_INVALID_PEER: "ERR_INVALID_PEER",
      ERR_MUXER_UNAVAILABLE: "ERR_MUXER_UNAVAILABLE",
      ERR_TIMEOUT: "ERR_TIMEOUT",
      ERR_TRANSPORT_UNAVAILABLE: "ERR_TRANSPORT_UNAVAILABLE",
      ERR_TRANSPORT_DIAL_FAILED: "ERR_TRANSPORT_DIAL_FAILED",
      ERR_UNSUPPORTED_PROTOCOL: "ERR_UNSUPPORTED_PROTOCOL",
      ERR_INVALID_MULTIADDR: "ERR_INVALID_MULTIADDR",
      ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
    };
  }
});

// node_modules/libp2p/src/record/envelope/envelope.js
var require_envelope = __commonJS({
  "node_modules/libp2p/src/record/envelope/envelope.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var $protobuf5 = require_minimal2();
    var $Reader5 = $protobuf5.Reader;
    var $Writer5 = $protobuf5.Writer;
    var $util5 = $protobuf5.util;
    var $root5 = $protobuf5.roots["libp2p-envelope"] || ($protobuf5.roots["libp2p-envelope"] = {});
    $root5.Envelope = function() {
      function Envelope(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Envelope.prototype.publicKey = $util5.newBuffer([]);
      Envelope.prototype.payloadType = $util5.newBuffer([]);
      Envelope.prototype.payload = $util5.newBuffer([]);
      Envelope.prototype.signature = $util5.newBuffer([]);
      Envelope.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
          w.uint32(10).bytes(m.publicKey);
        if (m.payloadType != null && Object.hasOwnProperty.call(m, "payloadType"))
          w.uint32(18).bytes(m.payloadType);
        if (m.payload != null && Object.hasOwnProperty.call(m, "payload"))
          w.uint32(26).bytes(m.payload);
        if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
          w.uint32(42).bytes(m.signature);
        return w;
      };
      Envelope.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Envelope();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.publicKey = r.bytes();
              break;
            case 2:
              m.payloadType = r.bytes();
              break;
            case 3:
              m.payload = r.bytes();
              break;
            case 5:
              m.signature = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Envelope.fromObject = function fromObject(d) {
        if (d instanceof $root5.Envelope)
          return d;
        var m = new $root5.Envelope();
        if (d.publicKey != null) {
          if (typeof d.publicKey === "string")
            $util5.base64.decode(d.publicKey, m.publicKey = $util5.newBuffer($util5.base64.length(d.publicKey)), 0);
          else if (d.publicKey.length)
            m.publicKey = d.publicKey;
        }
        if (d.payloadType != null) {
          if (typeof d.payloadType === "string")
            $util5.base64.decode(d.payloadType, m.payloadType = $util5.newBuffer($util5.base64.length(d.payloadType)), 0);
          else if (d.payloadType.length)
            m.payloadType = d.payloadType;
        }
        if (d.payload != null) {
          if (typeof d.payload === "string")
            $util5.base64.decode(d.payload, m.payload = $util5.newBuffer($util5.base64.length(d.payload)), 0);
          else if (d.payload.length)
            m.payload = d.payload;
        }
        if (d.signature != null) {
          if (typeof d.signature === "string")
            $util5.base64.decode(d.signature, m.signature = $util5.newBuffer($util5.base64.length(d.signature)), 0);
          else if (d.signature.length)
            m.signature = d.signature;
        }
        return m;
      };
      Envelope.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          if (o.bytes === String)
            d.publicKey = "";
          else {
            d.publicKey = [];
            if (o.bytes !== Array)
              d.publicKey = $util5.newBuffer(d.publicKey);
          }
          if (o.bytes === String)
            d.payloadType = "";
          else {
            d.payloadType = [];
            if (o.bytes !== Array)
              d.payloadType = $util5.newBuffer(d.payloadType);
          }
          if (o.bytes === String)
            d.payload = "";
          else {
            d.payload = [];
            if (o.bytes !== Array)
              d.payload = $util5.newBuffer(d.payload);
          }
          if (o.bytes === String)
            d.signature = "";
          else {
            d.signature = [];
            if (o.bytes !== Array)
              d.signature = $util5.newBuffer(d.signature);
          }
        }
        if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
          d.publicKey = o.bytes === String ? $util5.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
        }
        if (m.payloadType != null && m.hasOwnProperty("payloadType")) {
          d.payloadType = o.bytes === String ? $util5.base64.encode(m.payloadType, 0, m.payloadType.length) : o.bytes === Array ? Array.prototype.slice.call(m.payloadType) : m.payloadType;
        }
        if (m.payload != null && m.hasOwnProperty("payload")) {
          d.payload = o.bytes === String ? $util5.base64.encode(m.payload, 0, m.payload.length) : o.bytes === Array ? Array.prototype.slice.call(m.payload) : m.payload;
        }
        if (m.signature != null && m.hasOwnProperty("signature")) {
          d.signature = o.bytes === String ? $util5.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
        }
        return d;
      };
      Envelope.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      return Envelope;
    }();
    module2.exports = $root5;
  }
});

// node_modules/libp2p/src/record/envelope/index.js
var require_envelope2 = __commonJS({
  "node_modules/libp2p/src/record/envelope/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errCode32 = require_err_code();
    var { concat: uint8arraysConcat } = (init_concat(), concat_exports);
    var { fromString: uint8arraysFromString } = (init_from_string(), from_string_exports);
    var cryptoKeys = require_keys2();
    var PeerId2 = require_src6();
    var varint7 = require_varint();
    var { equals: uint8arraysEquals } = (init_equals(), equals_exports);
    var { codes } = require_errors4();
    var { Envelope: Protobuf } = require_envelope();
    var Envelope = class {
      constructor({ peerId, payloadType, payload, signature }) {
        this.peerId = peerId;
        this.payloadType = payloadType;
        this.payload = payload;
        this.signature = signature;
        this._marshal = void 0;
      }
      marshal() {
        if (this._marshal) {
          return this._marshal;
        }
        const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey);
        this._marshal = Protobuf.encode({
          publicKey,
          payloadType: this.payloadType,
          payload: this.payload,
          signature: this.signature
        }).finish();
        return this._marshal;
      }
      equals(other) {
        return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) && uint8arraysEquals(this.payloadType, other.payloadType) && uint8arraysEquals(this.payload, other.payload) && uint8arraysEquals(this.signature, other.signature);
      }
      validate(domain) {
        const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
        return this.peerId.pubKey.verify(signData, this.signature);
      }
    };
    var formatSignaturePayload = (domain, payloadType, payload) => {
      const domainUint8Array = uint8arraysFromString(domain);
      const domainLength = varint7.encode(domainUint8Array.byteLength);
      const payloadTypeLength = varint7.encode(payloadType.length);
      const payloadLength = varint7.encode(payload.length);
      return uint8arraysConcat([
        new Uint8Array(domainLength),
        domainUint8Array,
        new Uint8Array(payloadTypeLength),
        payloadType,
        new Uint8Array(payloadLength),
        payload
      ]);
    };
    Envelope.createFromProtobuf = async (data) => {
      const envelopeData = Protobuf.decode(data);
      const peerId = await PeerId2.createFromPubKey(envelopeData.publicKey);
      return new Envelope({
        peerId,
        payloadType: envelopeData.payloadType,
        payload: envelopeData.payload,
        signature: envelopeData.signature
      });
    };
    Envelope.seal = async (record, peerId) => {
      const domain = record.domain;
      const payloadType = record.codec;
      const payload = record.marshal();
      const signData = formatSignaturePayload(domain, payloadType, payload);
      const signature = await peerId.privKey.sign(signData);
      return new Envelope({
        peerId,
        payloadType,
        payload,
        signature
      });
    };
    Envelope.openAndCertify = async (data, domain) => {
      const envelope = await Envelope.createFromProtobuf(data);
      const valid = await envelope.validate(domain);
      if (!valid) {
        throw errCode32(new Error("envelope signature is not valid for the given domain"), codes.ERR_SIGNATURE_NOT_VALID);
      }
      return envelope;
    };
    module2.exports = Envelope;
  }
});

// node_modules/libp2p-gossipsub/src/index.js
var require_src14 = __commonJS({
  "node_modules/libp2p-gossipsub/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve6) {
          resolve6(value);
        });
      }
      return new (P || (P = Promise))(function(resolve6, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve6(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var pubsub_1 = __importStar(require_pubsub2());
    var message_cache_1 = require_message_cache();
    var rpc_1 = require_rpc3();
    var constants = __importStar(require_constants3());
    var heartbeat_1 = require_heartbeat();
    var get_gossip_peers_1 = require_get_gossip_peers();
    var utils_1 = require_utils12();
    var score_1 = require_score();
    var tracer_1 = require_tracer();
    var TimeCache = require_src13();
    var PeerId2 = require_src6();
    var Envelope = require_envelope2();
    var Gossipsub = class extends pubsub_1.default {
      constructor(libp2p, options = {}) {
        const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];
        const opts = Object.assign(Object.assign({ gossipIncoming: true, fallbackToFloodsub: true, floodPublish: true, doPX: false, directPeers: [], D: constants.GossipsubD, Dlo: constants.GossipsubDlo, Dhi: constants.GossipsubDhi, Dscore: constants.GossipsubDscore, Dout: constants.GossipsubDout, Dlazy: constants.GossipsubDlazy, heartbeatInterval: constants.GossipsubHeartbeatInterval, fanoutTTL: constants.GossipsubFanoutTTL, mcacheLength: constants.GossipsubHistoryLength, mcacheGossip: constants.GossipsubHistoryGossip, seenTTL: constants.GossipsubSeenTTL }, options), { scoreParams: score_1.createPeerScoreParams(options.scoreParams), scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds) });
        if (opts.fallbackToFloodsub) {
          multicodecs.push(constants.FloodsubID);
        }
        super(Object.assign({
          debugName: "libp2p:gossipsub",
          multicodecs,
          libp2p
        }, opts));
        this._options = opts;
        this.direct = new Set(opts.directPeers.map((p) => p.id.toB58String()));
        opts.directPeers.forEach((p) => {
          libp2p.peerStore.addressBook.add(p.id, p.addrs);
        });
        this.seenCache = new TimeCache({ validity: opts.seenTTL / 1e3 });
        this.mesh = new Map();
        this.fanout = new Map();
        this.lastpub = new Map();
        this.gossip = new Map();
        this.control = new Map();
        this.peerhave = new Map();
        this.iasked = new Map();
        this.backoff = new Map();
        this.outbound = new Map();
        this.messageCache = options.messageCache || new message_cache_1.MessageCache(opts.mcacheGossip, opts.mcacheLength, this.getMsgId.bind(this));
        this.heartbeat = new heartbeat_1.Heartbeat(this);
        this.heartbeatTicks = 0;
        this.gossipTracer = new tracer_1.IWantTracer(this.getMsgId.bind(this));
        this._libp2p = libp2p;
        this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager, this.getMsgId.bind(this));
      }
      _decodeRpc(bytes3) {
        return rpc_1.RPC.decode(bytes3);
      }
      _encodeRpc(rpc) {
        return rpc_1.RPC.encode(rpc).finish();
      }
      _addPeer(peerId, protocol) {
        const p = super._addPeer(peerId, protocol);
        this.score.addPeer(peerId.toB58String());
        let outbound = false;
        for (const c of this._libp2p.connectionManager.getAll(peerId)) {
          if (c.stat.direction === "outbound") {
            if (Array.from(c.registry.values()).some((rvalue) => protocol === rvalue.protocol)) {
              outbound = true;
              break;
            }
          }
        }
        this.outbound.set(p.id.toB58String(), outbound);
        return p;
      }
      _removePeer(peerId) {
        const peerStreams = super._removePeer(peerId);
        const id = peerId.toB58String();
        for (const peers of this.mesh.values()) {
          peers.delete(id);
        }
        for (const peers of this.fanout.values()) {
          peers.delete(id);
        }
        this.gossip.delete(id);
        this.control.delete(id);
        this.outbound.delete(id);
        this.score.removePeer(id);
        return peerStreams;
      }
      _processRpc(id, peerStreams, rpc) {
        const _super = Object.create(null, {
          _processRpc: { get: () => super._processRpc }
        });
        return __awaiter(this, void 0, void 0, function* () {
          if (yield _super._processRpc.call(this, id, peerStreams, rpc)) {
            if (rpc.control) {
              this._processRpcControlMessage(id, rpc.control);
            }
            return true;
          }
          return false;
        });
      }
      _processRpcControlMessage(id, controlMsg) {
        if (!controlMsg) {
          return;
        }
        const iwant = controlMsg.ihave ? this._handleIHave(id, controlMsg.ihave) : [];
        const ihave = controlMsg.iwant ? this._handleIWant(id, controlMsg.iwant) : [];
        const prune = controlMsg.graft ? this._handleGraft(id, controlMsg.graft) : [];
        controlMsg.prune && this._handlePrune(id, controlMsg.prune);
        if (!iwant.length && !ihave.length && !prune.length) {
          return;
        }
        const outRpc = utils_1.createGossipRpc(ihave, { iwant, prune });
        this._sendRpc(id, outRpc);
      }
      _processRpcMessage(msg) {
        const _super = Object.create(null, {
          _processRpcMessage: { get: () => super._processRpcMessage }
        });
        return __awaiter(this, void 0, void 0, function* () {
          const msgID = yield this.getMsgId(msg);
          const msgIdStr = utils_1.messageIdToString(msgID);
          if (this.seenCache.has(msgIdStr)) {
            this.score.duplicateMessage(msg);
            return;
          }
          this.seenCache.put(msgIdStr);
          yield this.score.validateMessage(msg);
          yield _super._processRpcMessage.call(this, msg);
        });
      }
      _acceptFrom(id) {
        return this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.graylistThreshold;
      }
      validate(message) {
        const _super = Object.create(null, {
          validate: { get: () => super.validate }
        });
        return __awaiter(this, void 0, void 0, function* () {
          try {
            yield _super.validate.call(this, message);
          } catch (e) {
            this.score.rejectMessage(message, e.code);
            this.gossipTracer.rejectMessage(message, e.code);
            throw e;
          }
        });
      }
      _handleIHave(id, ihave) {
        if (!ihave.length) {
          return [];
        }
        const score = this.score.score(id);
        if (score < this._options.scoreThresholds.gossipThreshold) {
          this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
          return [];
        }
        const peerhave = (this.peerhave.get(id) || 0) + 1;
        this.peerhave.set(id, peerhave);
        if (peerhave > constants.GossipsubMaxIHaveMessages) {
          this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
          return [];
        }
        const iasked = this.iasked.get(id) || 0;
        if (iasked >= constants.GossipsubMaxIHaveLength) {
          this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
          return [];
        }
        const iwant = new Map();
        ihave.forEach(({ topicID, messageIDs }) => {
          if (!topicID || !messageIDs || !this.mesh.has(topicID)) {
            return;
          }
          messageIDs.forEach((msgID) => {
            const msgIdStr = utils_1.messageIdToString(msgID);
            if (this.seenCache.has(msgIdStr)) {
              return;
            }
            iwant.set(msgIdStr, msgID);
          });
        });
        if (!iwant.size) {
          return [];
        }
        let iask = iwant.size;
        if (iask + iasked > constants.GossipsubMaxIHaveLength) {
          iask = constants.GossipsubMaxIHaveLength - iasked;
        }
        this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
        let iwantList = Array.from(iwant.values());
        utils_1.shuffle(iwantList);
        iwantList = iwantList.slice(0, iask);
        this.iasked.set(id, iasked + iask);
        this.gossipTracer.addPromise(id, iwantList);
        return [{
          messageIDs: iwantList
        }];
      }
      _handleIWant(id, iwant) {
        if (!iwant.length) {
          return [];
        }
        const score = this.score.score(id);
        if (score < this._options.scoreThresholds.gossipThreshold) {
          this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
          return [];
        }
        const ihave = new Map();
        iwant.forEach(({ messageIDs }) => {
          messageIDs && messageIDs.forEach((msgID) => {
            const [msg, count] = this.messageCache.getForPeer(msgID, id);
            if (!msg) {
              return;
            }
            if (count > constants.GossipsubGossipRetransmission) {
              this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgID);
              return;
            }
            ihave.set(utils_1.messageIdToString(msgID), msg);
          });
        });
        if (!ihave.size) {
          return [];
        }
        this.log("IWANT: Sending %d messages to %s", ihave.size, id);
        return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);
      }
      _handleGraft(id, graft) {
        const prune = [];
        const score = this.score.score(id);
        const now = this._now();
        let doPX = this._options.doPX;
        graft.forEach(({ topicID }) => {
          var _a;
          if (!topicID) {
            return;
          }
          const peersInMesh = this.mesh.get(topicID);
          if (!peersInMesh) {
            doPX = false;
            return;
          }
          if (peersInMesh.has(id)) {
            return;
          }
          if (this.direct.has(id)) {
            this.log("GRAFT: ignoring request from direct peer %s", id);
            prune.push(topicID);
            doPX = false;
            return;
          }
          const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);
          if (typeof expire === "number" && now < expire) {
            this.log("GRAFT: ignoring backed off peer %s", id);
            this.score.addPenalty(id, 1);
            doPX = false;
            const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;
            if (now < floodCutoff) {
              this.score.addPenalty(id, 1);
            }
            this._addBackoff(id, topicID);
            prune.push(topicID);
            return;
          }
          if (score < 0) {
            this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
            prune.push(topicID);
            doPX = false;
            this._addBackoff(id, topicID);
            return;
          }
          if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {
            prune.push(topicID);
            this._addBackoff(id, topicID);
            return;
          }
          this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
          this.score.graft(id, topicID);
          peersInMesh.add(id);
        });
        if (!prune.length) {
          return [];
        }
        return prune.map((topic) => this._makePrune(id, topic, doPX));
      }
      _handlePrune(id, prune) {
        const score = this.score.score(id);
        prune.forEach(({ topicID, backoff, peers }) => {
          if (!topicID) {
            return;
          }
          const peersInMesh = this.mesh.get(topicID);
          if (!peersInMesh) {
            return;
          }
          this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
          this.score.prune(id, topicID);
          peersInMesh.delete(id);
          if (typeof backoff === "number" && backoff > 0) {
            this._doAddBackoff(id, topicID, backoff * 1e3);
          } else {
            this._addBackoff(id, topicID);
          }
          if (peers && peers.length) {
            if (score < this._options.scoreThresholds.acceptPXThreshold) {
              this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
              return;
            }
            this._pxConnect(peers);
          }
        });
      }
      _addBackoff(id, topic) {
        this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);
      }
      _doAddBackoff(id, topic, interval) {
        let backoff = this.backoff.get(topic);
        if (!backoff) {
          backoff = new Map();
          this.backoff.set(topic, backoff);
        }
        const expire = this._now() + interval;
        const existingExpire = backoff.get(id) || 0;
        if (existingExpire < expire) {
          backoff.set(id, expire);
        }
      }
      _applyIwantPenalties() {
        this.gossipTracer.getBrokenPromises().forEach((count, p) => {
          this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p, count);
          this.score.addPenalty(p, count);
        });
      }
      _clearBackoff() {
        if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {
          return;
        }
        const now = this._now();
        this.backoff.forEach((backoff, topic) => {
          backoff.forEach((expire, id) => {
            if (expire < now) {
              backoff.delete(id);
            }
          });
          if (backoff.size === 0) {
            this.backoff.delete(topic);
          }
        });
      }
      _directConnect() {
        if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {
          return;
        }
        const toconnect = [];
        this.direct.forEach((id) => {
          const peer = this.peers.get(id);
          if (!peer || !peer.isWritable) {
            toconnect.push(id);
          }
        });
        if (toconnect.length) {
          toconnect.forEach((id) => {
            this._connect(id);
          });
        }
      }
      _pxConnect(peers) {
        return __awaiter(this, void 0, void 0, function* () {
          if (peers.length > constants.GossipsubPrunePeers) {
            utils_1.shuffle(peers);
            peers = peers.slice(0, constants.GossipsubPrunePeers);
          }
          const toconnect = [];
          yield Promise.all(peers.map((pi) => __awaiter(this, void 0, void 0, function* () {
            if (!pi.peerID) {
              return;
            }
            const p = PeerId2.createFromBytes(pi.peerID);
            const id = p.toB58String();
            if (this.peers.has(id)) {
              return;
            }
            if (!pi.signedPeerRecord) {
              toconnect.push(id);
              return;
            }
            try {
              const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, "libp2p-peer-record");
              const eid = envelope.peerId.toB58String();
              if (id !== eid) {
                this.log("bogus peer record obtained through px: peer ID %s doesn't match expected peer %s", eid, id);
                return;
              }
              if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {
                this.log("bogus peer record obtained through px: could not add peer record to address book");
                return;
              }
              toconnect.push(id);
            } catch (e) {
              this.log("bogus peer record obtained through px: invalid signature or not a peer record");
            }
          })));
          if (!toconnect.length) {
            return;
          }
          toconnect.forEach((id) => this._connect(id));
        });
      }
      start() {
        super.start();
        this.heartbeat.start();
        this.score.start();
        this._directPeerInitial = setTimeout(() => {
          this.direct.forEach((id) => {
            this._connect(id);
          });
        }, constants.GossipsubDirectConnectInitialDelay);
      }
      stop() {
        super.stop();
        this.heartbeat.stop();
        this.score.stop();
        this.mesh = new Map();
        this.fanout = new Map();
        this.lastpub = new Map();
        this.gossip = new Map();
        this.control = new Map();
        this.peerhave = new Map();
        this.iasked = new Map();
        this.backoff = new Map();
        this.outbound = new Map();
        this.gossipTracer.clear();
        clearTimeout(this._directPeerInitial);
      }
      _connect(id) {
        this.log("Initiating connection with %s", id);
        this._libp2p.dialProtocol(PeerId2.createFromB58String(id), this.multicodecs);
      }
      subscribe(topic) {
        super.subscribe(topic);
        this.join(topic);
      }
      unsubscribe(topic) {
        super.unsubscribe(topic);
        this.leave(topic);
      }
      join(topic) {
        if (!this.started) {
          throw new Error("Gossipsub has not started");
        }
        this.log("JOIN %s", topic);
        const fanoutPeers = this.fanout.get(topic);
        if (fanoutPeers) {
          fanoutPeers.forEach((id) => {
            if (this.score.score(id) < 0) {
              fanoutPeers.delete(id);
            }
          });
          if (fanoutPeers.size < this._options.D) {
            get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {
              return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;
            }).forEach((id) => fanoutPeers.add(id));
          }
          this.mesh.set(topic, fanoutPeers);
          this.fanout.delete(topic);
          this.lastpub.delete(topic);
        } else {
          const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, (id) => {
            return !this.direct.has(id) && this.score.score(id) >= 0;
          });
          this.mesh.set(topic, peers);
        }
        this.mesh.get(topic).forEach((id) => {
          this.log("JOIN: Add mesh link to %s in %s", id, topic);
          this._sendGraft(id, topic);
        });
      }
      leave(topic) {
        if (!this.started) {
          throw new Error("Gossipsub has not started");
        }
        this.log("LEAVE %s", topic);
        const meshPeers = this.mesh.get(topic);
        if (meshPeers) {
          meshPeers.forEach((id) => {
            this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
            this._sendPrune(id, topic);
          });
          this.mesh.delete(topic);
        }
      }
      _publish(msg) {
        return __awaiter(this, void 0, void 0, function* () {
          if (msg.receivedFrom !== this.peerId.toB58String()) {
            this.score.deliverMessage(msg);
            this.gossipTracer.deliverMessage(msg);
          }
          const msgID = yield this.getMsgId(msg);
          const msgIdStr = utils_1.messageIdToString(msgID);
          this.seenCache.put(msgIdStr);
          this.messageCache.put(msg);
          const tosend = new Set();
          msg.topicIDs.forEach((topic) => {
            const peersInTopic = this.topics.get(topic);
            if (!peersInTopic) {
              return;
            }
            if (this._options.floodPublish && msg.from === this.peerId.toB58String()) {
              peersInTopic.forEach((id) => {
                if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {
                  tosend.add(id);
                }
              });
            } else {
              this.direct.forEach((id) => {
                tosend.add(id);
              });
              peersInTopic.forEach((id) => {
                const score = this.score.score(id);
                const peerStreams = this.peers.get(id);
                if (!peerStreams) {
                  return;
                }
                if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {
                  tosend.add(id);
                }
              });
              let meshPeers = this.mesh.get(topic);
              if (!meshPeers || !meshPeers.size) {
                meshPeers = this.fanout.get(topic);
                if (!meshPeers) {
                  const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, (id) => {
                    return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;
                  });
                  if (peers.size > 0) {
                    meshPeers = peers;
                    this.fanout.set(topic, peers);
                  } else {
                    meshPeers = new Set();
                  }
                }
                this.lastpub.set(topic, this._now());
              }
              meshPeers.forEach((peer) => {
                tosend.add(peer);
              });
            }
          });
          const rpc = utils_1.createGossipRpc([
            pubsub_1.utils.normalizeOutRpcMessage(msg)
          ]);
          tosend.forEach((id) => {
            if (id === msg.from) {
              return;
            }
            this._sendRpc(id, rpc);
          });
        });
      }
      _sendGraft(id, topic) {
        const graft = [{
          topicID: topic
        }];
        const out = utils_1.createGossipRpc([], { graft });
        this._sendRpc(id, out);
      }
      _sendPrune(id, topic) {
        const prune = [
          this._makePrune(id, topic, this._options.doPX)
        ];
        const out = utils_1.createGossipRpc([], { prune });
        this._sendRpc(id, out);
      }
      _sendRpc(id, outRpc) {
        const peerStreams = this.peers.get(id);
        if (!peerStreams || !peerStreams.isWritable) {
          return;
        }
        const ctrl = this.control.get(id);
        if (ctrl) {
          this._piggybackControl(id, outRpc, ctrl);
          this.control.delete(id);
        }
        const ihave = this.gossip.get(id);
        if (ihave) {
          this._piggybackGossip(id, outRpc, ihave);
          this.gossip.delete(id);
        }
        peerStreams.write(rpc_1.RPC.encode(outRpc).finish());
      }
      _piggybackControl(id, outRpc, ctrl) {
        const tograft = (ctrl.graft || []).filter(({ topicID }) => (topicID && this.mesh.get(topicID) || new Set()).has(id));
        const toprune = (ctrl.prune || []).filter(({ topicID }) => !(topicID && this.mesh.get(topicID) || new Set()).has(id));
        if (!tograft.length && !toprune.length) {
          return;
        }
        if (outRpc.control) {
          outRpc.control.graft = outRpc.control.graft && outRpc.control.graft.concat(tograft);
          outRpc.control.prune = outRpc.control.prune && outRpc.control.prune.concat(toprune);
        } else {
          outRpc.control = { ihave: [], iwant: [], graft: tograft, prune: toprune };
        }
      }
      _piggybackGossip(id, outRpc, ihave) {
        if (!outRpc.control) {
          outRpc.control = { ihave: [], iwant: [], graft: [], prune: [] };
        }
        outRpc.control.ihave = ihave;
      }
      _sendGraftPrune(tograft, toprune, noPX) {
        const doPX = this._options.doPX;
        for (const [id, topics] of tograft) {
          const graft = topics.map((topicID) => ({ topicID }));
          let prune = [];
          const pruning = toprune.get(id);
          if (pruning) {
            prune = pruning.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));
            toprune.delete(id);
          }
          const outRpc = utils_1.createGossipRpc([], { graft, prune });
          this._sendRpc(id, outRpc);
        }
        for (const [id, topics] of toprune) {
          const prune = topics.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));
          const outRpc = utils_1.createGossipRpc([], { prune });
          this._sendRpc(id, outRpc);
        }
      }
      _emitGossip(topic, exclude) {
        const messageIDs = this.messageCache.getGossipIDs(topic);
        if (!messageIDs.length) {
          return;
        }
        utils_1.shuffle(messageIDs);
        if (messageIDs.length > constants.GossipsubMaxIHaveLength) {
          this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
        }
        const peersToGossip = [];
        const topicPeers = this.topics.get(topic);
        if (!topicPeers) {
          return;
        }
        topicPeers.forEach((id) => {
          const peerStreams = this.peers.get(id);
          if (!peerStreams) {
            return;
          }
          if (!exclude.has(id) && !this.direct.has(id) && utils_1.hasGossipProtocol(peerStreams.protocol) && this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {
            peersToGossip.push(id);
          }
        });
        let target = this._options.Dlazy;
        const factor = constants.GossipsubGossipFactor * peersToGossip.length;
        if (factor > target) {
          target = factor;
        }
        if (target > peersToGossip.length) {
          target = peersToGossip.length;
        } else {
          utils_1.shuffle(peersToGossip);
        }
        peersToGossip.slice(0, target).forEach((id) => {
          let peerMessageIDs = messageIDs;
          if (messageIDs.length > constants.GossipsubMaxIHaveLength) {
            peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);
          }
          this._pushGossip(id, {
            topicID: topic,
            messageIDs: peerMessageIDs
          });
        });
      }
      _flush() {
        for (const [peer, ihave] of this.gossip.entries()) {
          this.gossip.delete(peer);
          const out = utils_1.createGossipRpc([], { ihave });
          this._sendRpc(peer, out);
        }
        for (const [peer, control] of this.control.entries()) {
          this.control.delete(peer);
          const out = utils_1.createGossipRpc([], { graft: control.graft, prune: control.prune });
          this._sendRpc(peer, out);
        }
      }
      _pushGossip(id, controlIHaveMsgs) {
        this.log("Add gossip to %s", id);
        const gossip = this.gossip.get(id) || [];
        this.gossip.set(id, gossip.concat(controlIHaveMsgs));
      }
      _now() {
        return Date.now();
      }
      _makePrune(id, topic, doPX) {
        if (this.peers.get(id).protocol === constants.GossipsubIDv10) {
          return {
            topicID: topic,
            peers: []
          };
        }
        const backoff = constants.GossipsubPruneBackoff / 1e3;
        const px = [];
        if (doPX) {
          const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, (xid) => {
            return xid !== id && this.score.score(xid) >= 0;
          });
          peers.forEach((p) => {
            const peerId = PeerId2.createFromB58String(p);
            px.push({
              peerID: peerId.toBytes(),
              signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)
            });
          });
        }
        return {
          topicID: topic,
          peers: px,
          backoff
        };
      }
    };
    Gossipsub.multicodec = constants.GossipsubIDv11;
    module2.exports = Gossipsub;
  }
});

// node_modules/ipfs-core-config/esm/src/libp2p-pubsub-routers.browser.js
var libp2p_pubsub_routers_browser_exports = {};
__export(libp2p_pubsub_routers_browser_exports, {
  routers: () => routers
});
var import_libp2p_gossipsub, routers;
var init_libp2p_pubsub_routers_browser = __esm({
  "node_modules/ipfs-core-config/esm/src/libp2p-pubsub-routers.browser.js"() {
    init_node_globals();
    import_libp2p_gossipsub = __toModule(require_src14());
    routers = { gossipsub: import_libp2p_gossipsub.default };
  }
});

// node_modules/libp2p-delegated-peer-routing/src/index.js
var require_src15 = __commonJS({
  "node_modules/libp2p-delegated-peer-routing/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var PeerId2 = require_src6();
    var { base58btc: base58btc2 } = (init_base58(), base58_exports);
    var { default: PQueue4 } = require_dist();
    var defer = require_p_defer();
    var debug17 = require_browser2();
    var log15 = debug17("libp2p-delegated-peer-routing");
    log15.error = debug17("libp2p-delegated-peer-routing:error");
    var DEFAULT_TIMEOUT = 3e4;
    var CONCURRENT_HTTP_REQUESTS = 4;
    var DelegatedPeerRouting = class {
      constructor(client) {
        if (client == null) {
          throw new Error("missing ipfs http client");
        }
        this._client = client;
        this._httpQueue = new PQueue4({
          concurrency: CONCURRENT_HTTP_REQUESTS
        });
        const {
          protocol,
          host,
          port
        } = client.getEndpointConfig();
        log15(`enabled DelegatedPeerRouting via ${protocol}://${host}:${port}`);
      }
      async findPeer(id, options = {}) {
        let idStr = id;
        if (PeerId2.isPeerId(idStr)) {
          idStr = id.toB58String();
        }
        log15("findPeer starts: " + id);
        options.timeout = options.timeout || DEFAULT_TIMEOUT;
        try {
          return await this._httpQueue.add(async () => {
            const { addrs } = await this._client.dht.findPeer(idStr, {
              timeout: options.timeout
            });
            return {
              id,
              multiaddrs: addrs
            };
          });
        } catch (err) {
          if (err.message.includes("not found")) {
            return void 0;
          }
          throw err;
        } finally {
          log15("findPeer finished: " + id);
        }
      }
      async *getClosestPeers(key, options = {}) {
        const keyStr = base58btc2.encode(key).substring(1);
        log15("getClosestPeers starts:", keyStr);
        options.timeout = options.timeout || DEFAULT_TIMEOUT;
        const onStart = defer();
        const onFinish = defer();
        this._httpQueue.add(() => {
          onStart.resolve();
          return onFinish.promise;
        });
        try {
          await onStart.promise;
          const peers = new Map();
          for await (const result of this._client.dht.query(keyStr, {
            timeout: options.timeout
          })) {
            switch (result.type) {
              case 1:
                result.responses.forEach((response) => {
                  peers.set(response.id, {
                    id: PeerId2.parse(response.id),
                    multiaddrs: response.addrs
                  });
                });
                break;
              case 2:
                yield peers.get(result.id.string) || {
                  id: PeerId2.createFromCID(result.id),
                  multiaddrs: []
                };
                break;
              default:
                log15("getClosestPeers unhandled response", result);
            }
          }
        } catch (err) {
          log15.error("getClosestPeers errored:", err);
          throw err;
        } finally {
          onFinish.resolve();
          log15("getClosestPeers finished:", keyStr);
        }
      }
    };
    module2.exports = DelegatedPeerRouting;
  }
});

// node_modules/libp2p-delegated-content-routing/src/index.js
var require_src16 = __commonJS({
  "node_modules/libp2p-delegated-content-routing/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var PeerId2 = require_src6();
    var drain6 = require_it_drain();
    var { default: PQueue4 } = require_dist();
    var defer = require_p_defer();
    var log15 = debug17("libp2p-delegated-content-routing");
    log15.error = debug17("libp2p-delegated-content-routing:error");
    var DEFAULT_TIMEOUT = 3e4;
    var CONCURRENT_HTTP_REQUESTS = 4;
    var DelegatedContentRouting = class {
      constructor(peerId, client) {
        if (peerId == null) {
          throw new Error("missing self peerId");
        }
        if (client == null) {
          throw new Error("missing ipfs http client");
        }
        this._client = client;
        this.peerId = peerId;
        const concurrency = { concurrency: CONCURRENT_HTTP_REQUESTS };
        this._httpQueue = new PQueue4(concurrency);
        this._httpQueueRefs = new PQueue4(Object.assign({}, concurrency, {
          concurrency: 2
        }));
        const {
          protocol,
          host,
          port
        } = client.getEndpointConfig();
        log15(`enabled DelegatedContentRouting via ${protocol}://${host}:${port}`);
      }
      async *findProviders(key, options = {}) {
        log15(`findProviders starts: ${key}`);
        options.timeout = options.timeout || DEFAULT_TIMEOUT;
        let providers = 0;
        const onStart = defer();
        const onFinish = defer();
        this._httpQueue.add(() => {
          onStart.resolve();
          return onFinish.promise;
        });
        try {
          await onStart.promise;
          for await (const { id, addrs } of this._client.dht.findProvs(key, {
            numProviders: options.numProviders,
            timeout: options.timeout
          })) {
            yield {
              id: PeerId2.parse(id),
              multiaddrs: addrs
            };
            providers++;
          }
        } catch (err) {
          log15.error("findProviders errored:", err);
          throw err;
        } finally {
          onFinish.resolve();
          log15(`findProviders finished: ${key} found ${providers} providers`);
        }
      }
      async provide(key) {
        log15(`provide starts: ${key}`);
        await this._httpQueueRefs.add(async () => {
          await this._client.block.stat(key);
          await drain6(this._client.dht.provide(key));
        });
        log15(`provide finished: ${key}`);
      }
    };
    module2.exports = DelegatedContentRouting;
  }
});

// node_modules/ipfs-core-utils/esm/src/multibases.js
var multibases_exports = {};
__export(multibases_exports, {
  Multibases: () => Multibases
});
var LOAD_BASE, Multibases;
var init_multibases = __esm({
  "node_modules/ipfs-core-utils/esm/src/multibases.js"() {
    init_node_globals();
    LOAD_BASE = (name5) => Promise.reject(new Error(`No base found for "${name5}"`));
    Multibases = class {
      constructor(options) {
        this._basesByName = {};
        this._basesByPrefix = {};
        this._loadBase = options.loadBase || LOAD_BASE;
        for (const base3 of options.bases) {
          this.addBase(base3);
        }
      }
      addBase(base3) {
        if (this._basesByName[base3.name] || this._basesByPrefix[base3.prefix]) {
          throw new Error(`Codec already exists for codec "${base3.name}"`);
        }
        this._basesByName[base3.name] = base3;
        this._basesByPrefix[base3.prefix] = base3;
      }
      removeBase(base3) {
        delete this._basesByName[base3.name];
        delete this._basesByPrefix[base3.prefix];
      }
      async getBase(nameOrPrefix) {
        if (this._basesByName[nameOrPrefix]) {
          return this._basesByName[nameOrPrefix];
        }
        if (this._basesByPrefix[nameOrPrefix]) {
          return this._basesByPrefix[nameOrPrefix];
        }
        const base3 = await this._loadBase(nameOrPrefix);
        if (this._basesByName[base3.name] == null && this._basesByPrefix[base3.prefix] == null) {
          this.addBase(base3);
        }
        return base3;
      }
      listBases() {
        return Object.values(this._basesByName);
      }
    };
  }
});

// node_modules/ipfs-core-utils/esm/src/multicodecs.js
var multicodecs_exports = {};
__export(multicodecs_exports, {
  Multicodecs: () => Multicodecs
});
var LOAD_CODEC, Multicodecs;
var init_multicodecs = __esm({
  "node_modules/ipfs-core-utils/esm/src/multicodecs.js"() {
    init_node_globals();
    LOAD_CODEC = (codeOrName) => Promise.reject(new Error(`No codec found for "${codeOrName}"`));
    Multicodecs = class {
      constructor(options) {
        this._codecsByName = {};
        this._codecsByCode = {};
        this._loadCodec = options.loadCodec || LOAD_CODEC;
        for (const codec of options.codecs) {
          this.addCodec(codec);
        }
      }
      addCodec(codec) {
        if (this._codecsByName[codec.name] || this._codecsByCode[codec.code]) {
          throw new Error(`Resolver already exists for codec "${codec.name}"`);
        }
        this._codecsByName[codec.name] = codec;
        this._codecsByCode[codec.code] = codec;
      }
      removeCodec(codec) {
        delete this._codecsByName[codec.name];
        delete this._codecsByCode[codec.code];
      }
      async getCodec(code5) {
        const table = typeof code5 === "string" ? this._codecsByName : this._codecsByCode;
        if (table[code5]) {
          return table[code5];
        }
        const codec = await this._loadCodec(code5);
        if (table[code5] == null) {
          this.addCodec(codec);
        }
        return codec;
      }
      listCodecs() {
        return Object.values(this._codecsByName);
      }
    };
  }
});

// node_modules/ipfs-core-utils/esm/src/multihashes.js
var multihashes_exports = {};
__export(multihashes_exports, {
  Multihashes: () => Multihashes
});
var LOAD_HASHER, Multihashes;
var init_multihashes = __esm({
  "node_modules/ipfs-core-utils/esm/src/multihashes.js"() {
    init_node_globals();
    LOAD_HASHER = (codeOrName) => Promise.reject(new Error(`No hasher found for "${codeOrName}"`));
    Multihashes = class {
      constructor(options) {
        this._hashersByName = {};
        this._hashersByCode = {};
        this._loadHasher = options.loadHasher || LOAD_HASHER;
        for (const hasher of options.hashers) {
          this.addHasher(hasher);
        }
      }
      addHasher(hasher) {
        if (this._hashersByName[hasher.name] || this._hashersByCode[hasher.code]) {
          throw new Error(`Resolver already exists for codec "${hasher.name}"`);
        }
        this._hashersByName[hasher.name] = hasher;
        this._hashersByCode[hasher.code] = hasher;
      }
      removeHasher(hasher) {
        delete this._hashersByName[hasher.name];
        delete this._hashersByCode[hasher.code];
      }
      async getHasher(code5) {
        const table = typeof code5 === "string" ? this._hashersByName : this._hashersByCode;
        if (table[code5]) {
          return table[code5];
        }
        const hasher = await this._loadHasher(code5);
        if (table[code5] == null) {
          this.addHasher(hasher);
        }
        return hasher;
      }
      listHashers() {
        return Object.values(this._hashersByName);
      }
    };
  }
});

// node_modules/ipfs-core-utils/esm/src/to-url-string.js
function toUrlString(url) {
  try {
    url = (0, import_multiaddr_to_uri.default)(new import_multiaddr.Multiaddr(url));
  } catch (err) {
  }
  url = url.toString();
  return url;
}
var import_multiaddr, import_multiaddr_to_uri;
var init_to_url_string = __esm({
  "node_modules/ipfs-core-utils/esm/src/to-url-string.js"() {
    init_node_globals();
    import_multiaddr = __toModule(require_src());
    import_multiaddr_to_uri = __toModule(require_multiaddr_to_uri());
  }
});

// node_modules/ipfs-core-utils/esm/src/agent.browser.js
var agent_browser_default;
var init_agent_browser = __esm({
  "node_modules/ipfs-core-utils/esm/src/agent.browser.js"() {
    init_node_globals();
    agent_browser_default = () => {
    };
  }
});

// node_modules/ipfs-http-client/esm/src/lib/core.js
var import_multiaddr2, import_env, import_debug14, import_http3, log13, merge3, DEFAULT_PROTOCOL, DEFAULT_HOST, DEFAULT_PORT, normalizeOptions, errorHandler, KEBAB_REGEX, kebabCase, parseTimeout, Client, HTTPError;
var init_core = __esm({
  "node_modules/ipfs-http-client/esm/src/lib/core.js"() {
    init_node_globals();
    import_multiaddr2 = __toModule(require_src());
    import_env = __toModule(require_env());
    init_parse_duration();
    import_debug14 = __toModule(require_browser2());
    import_http3 = __toModule(require_http());
    init_merge_options();
    init_to_url_string();
    init_agent_browser();
    log13 = (0, import_debug14.default)("ipfs-http-client:lib:error-handler");
    merge3 = merge_options_default.bind({ ignoreUndefined: true });
    DEFAULT_PROTOCOL = import_env.isBrowser || import_env.isWebWorker ? location.protocol : "http";
    DEFAULT_HOST = import_env.isBrowser || import_env.isWebWorker ? location.hostname : "localhost";
    DEFAULT_PORT = import_env.isBrowser || import_env.isWebWorker ? location.port : "5001";
    normalizeOptions = (options = {}) => {
      let url;
      let opts = {};
      let agent;
      if (typeof options === "string" || import_multiaddr2.Multiaddr.isMultiaddr(options)) {
        url = new URL(toUrlString(options));
      } else if (options instanceof URL) {
        url = options;
      } else if (typeof options.url === "string" || import_multiaddr2.Multiaddr.isMultiaddr(options.url)) {
        url = new URL(toUrlString(options.url));
        opts = options;
      } else if (options.url instanceof URL) {
        url = options.url;
        opts = options;
      } else {
        opts = options || {};
        const protocol = (opts.protocol || DEFAULT_PROTOCOL).replace(":", "");
        const host = (opts.host || DEFAULT_HOST).split(":")[0];
        const port = opts.port || DEFAULT_PORT;
        url = new URL(`${protocol}://${host}:${port}`);
      }
      if (opts.apiPath) {
        url.pathname = opts.apiPath;
      } else if (url.pathname === "/" || url.pathname === void 0) {
        url.pathname = "api/v0";
      }
      if (import_env.isNode) {
        const Agent = agent_browser_default(url);
        agent = opts.agent || new Agent({
          keepAlive: true,
          maxSockets: 6
        });
      }
      return {
        ...opts,
        host: url.host,
        protocol: url.protocol.replace(":", ""),
        port: Number(url.port),
        apiPath: url.pathname,
        url,
        agent
      };
    };
    errorHandler = async (response) => {
      let msg;
      try {
        if ((response.headers.get("Content-Type") || "").startsWith("application/json")) {
          const data = await response.json();
          log13(data);
          msg = data.Message || data.message;
        } else {
          msg = await response.text();
        }
      } catch (err) {
        log13("Failed to parse error response", err);
        msg = err.message;
      }
      let error = new import_http3.default.HTTPError(response);
      if (msg) {
        if (msg.includes("deadline has elapsed")) {
          error = new import_http3.default.TimeoutError();
        }
        if (msg && msg.includes("context deadline exceeded")) {
          error = new import_http3.default.TimeoutError();
        }
      }
      if (msg && msg.includes("request timed out")) {
        error = new import_http3.default.TimeoutError();
      }
      if (msg) {
        error.message = msg;
      }
      throw error;
    };
    KEBAB_REGEX = /[A-Z\u00C0-\u00D6\u00D8-\u00DE]/g;
    kebabCase = (str) => {
      return str.replace(KEBAB_REGEX, function(match) {
        return "-" + match.toLowerCase();
      });
    };
    parseTimeout = (value) => {
      return typeof value === "string" ? parse_duration_default(value) : value;
    };
    Client = class extends import_http3.default {
      constructor(options = {}) {
        const opts = normalizeOptions(options);
        super({
          timeout: parseTimeout(opts.timeout || 0) || void 0,
          headers: opts.headers,
          base: `${opts.url}`,
          handleError: errorHandler,
          transformSearchParams: (search) => {
            const out = new URLSearchParams();
            for (const [key, value] of search) {
              if (value !== "undefined" && value !== "null" && key !== "signal") {
                out.append(kebabCase(key), value);
              }
              if (key === "timeout" && !isNaN(value)) {
                out.append(kebabCase(key), value);
              }
            }
            return out;
          },
          agent: opts.agent
        });
        delete this.get;
        delete this.put;
        delete this.delete;
        delete this.options;
        const fetch = this.fetch;
        this.fetch = (resource, options2 = {}) => {
          if (typeof resource === "string" && !resource.startsWith("/")) {
            resource = `${opts.url}/${resource}`;
          }
          return fetch.call(this, resource, merge3(options2, { method: "POST" }));
        };
      }
    };
    HTTPError = import_http3.default.HTTPError;
  }
});

// node_modules/ipfs-http-client/esm/src/lib/configure.js
var configure;
var init_configure = __esm({
  "node_modules/ipfs-http-client/esm/src/lib/configure.js"() {
    init_node_globals();
    init_core();
    configure = (fn) => {
      return (options) => {
        return fn(new Client(options), options);
      };
    };
  }
});

// node_modules/ipfs-http-client/esm/src/lib/mode-to-string.js
function modeToString(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}
var init_mode_to_string = __esm({
  "node_modules/ipfs-http-client/esm/src/lib/mode-to-string.js"() {
    init_node_globals();
  }
});

// node_modules/ipfs-http-client/esm/src/lib/parse-mtime.js
function parseMtime2(input) {
  if (input == null) {
    return void 0;
  }
  let mtime;
  if (input.secs != null) {
    mtime = {
      secs: input.secs,
      nsecs: input.nsecs
    };
  }
  if (input.Seconds != null) {
    mtime = {
      secs: input.Seconds,
      nsecs: input.FractionalNanoseconds
    };
  }
  if (Array.isArray(input)) {
    mtime = {
      secs: input[0],
      nsecs: input[1]
    };
  }
  if (input instanceof Date) {
    const ms = input.getTime();
    const secs = Math.floor(ms / 1e3);
    mtime = {
      secs,
      nsecs: (ms - secs * 1e3) * 1e3
    };
  }
  if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
    return void 0;
  }
  if (mtime != null && mtime.nsecs != null && (mtime.nsecs < 0 || mtime.nsecs > 999999999)) {
    throw (0, import_err_code29.default)(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
  }
  return mtime;
}
var import_err_code29;
var init_parse_mtime = __esm({
  "node_modules/ipfs-http-client/esm/src/lib/parse-mtime.js"() {
    init_node_globals();
    import_err_code29 = __toModule(require_err_code());
  }
});

// node_modules/ipfs-http-client/esm/src/lib/to-url-search-params.js
function toUrlSearchParams({ arg, searchParams, hashAlg, mtime, mode, ...options } = {}) {
  if (searchParams) {
    options = {
      ...options,
      ...searchParams
    };
  }
  if (hashAlg) {
    options.hash = hashAlg;
  }
  if (mtime != null) {
    mtime = parseMtime2(mtime);
    options.mtime = mtime.secs;
    options.mtimeNsecs = mtime.nsecs;
  }
  if (mode != null) {
    options.mode = modeToString(mode);
  }
  if (options.timeout && !isNaN(options.timeout)) {
    options.timeout = `${options.timeout}ms`;
  }
  if (arg === void 0 || arg === null) {
    arg = [];
  } else if (!Array.isArray(arg)) {
    arg = [arg];
  }
  const urlSearchParams = new URLSearchParams(options);
  arg.forEach((arg2) => urlSearchParams.append("arg", arg2));
  return urlSearchParams;
}
var init_to_url_search_params = __esm({
  "node_modules/ipfs-http-client/esm/src/lib/to-url-search-params.js"() {
    init_node_globals();
    init_mode_to_string();
    init_parse_mtime();
  }
});

// node_modules/ipfs-http-client/esm/src/bitswap/wantlist.js
var createWantlist;
var init_wantlist = __esm({
  "node_modules/ipfs-http-client/esm/src/bitswap/wantlist.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createWantlist = configure((api) => {
      async function wantlist(options = {}) {
        const res = await (await api.post("bitswap/wantlist", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        })).json();
        return (res.Keys || []).map((k) => CID.parse(k["/"]));
      }
      return wantlist;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/bitswap/wantlist-for-peer.js
var createWantlistForPeer;
var init_wantlist_for_peer = __esm({
  "node_modules/ipfs-http-client/esm/src/bitswap/wantlist-for-peer.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createWantlistForPeer = configure((api) => {
      async function wantlistForPeer(peerId, options = {}) {
        const res = await (await api.post("bitswap/wantlist", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            peer: peerId.toString()
          }),
          headers: options.headers
        })).json();
        return (res.Keys || []).map((k) => CID.parse(k["/"]));
      }
      return wantlistForPeer;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/bitswap/stat.js
function toCoreInterface(res) {
  return {
    provideBufLen: res.ProvideBufLen,
    wantlist: (res.Wantlist || []).map((k) => CID.parse(k["/"])),
    peers: res.Peers || [],
    blocksReceived: BigInt(res.BlocksReceived),
    dataReceived: BigInt(res.DataReceived),
    blocksSent: BigInt(res.BlocksSent),
    dataSent: BigInt(res.DataSent),
    dupBlksReceived: BigInt(res.DupBlksReceived),
    dupDataReceived: BigInt(res.DupDataReceived)
  };
}
var createStat;
var init_stat = __esm({
  "node_modules/ipfs-http-client/esm/src/bitswap/stat.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createStat = configure((api) => {
      async function stat(options = {}) {
        const res = await api.post("bitswap/stat", {
          searchParams: toUrlSearchParams(options),
          signal: options.signal,
          headers: options.headers
        });
        return toCoreInterface(await res.json());
      }
      return stat;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/bitswap/unwant.js
var createUnwant;
var init_unwant = __esm({
  "node_modules/ipfs-http-client/esm/src/bitswap/unwant.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createUnwant = configure((api) => {
      async function unwant(cid, options = {}) {
        const res = await api.post("bitswap/unwant", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        return res.json();
      }
      return unwant;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/bitswap/index.js
function createBitswap(config2) {
  return {
    wantlist: createWantlist(config2),
    wantlistForPeer: createWantlistForPeer(config2),
    unwant: createUnwant(config2),
    stat: createStat(config2)
  };
}
var init_bitswap = __esm({
  "node_modules/ipfs-http-client/esm/src/bitswap/index.js"() {
    init_node_globals();
    init_wantlist();
    init_wantlist_for_peer();
    init_stat();
    init_unwant();
  }
});

// node_modules/ipfs-http-client/esm/src/block/get.js
var createGet;
var init_get = __esm({
  "node_modules/ipfs-http-client/esm/src/block/get.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createGet = configure((api) => {
      async function get2(cid, options = {}) {
        const res = await api.post("block/get", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        return new Uint8Array(await res.arrayBuffer());
      }
      return get2;
    });
  }
});

// node_modules/ipfs-core-utils/esm/src/files/normalise-content.browser.js
async function normaliseContent2(input) {
  if (isBytes(input)) {
    return new Blob([input]);
  }
  if (typeof input === "string" || input instanceof String) {
    return new Blob([input.toString()]);
  }
  if (isBlob(input)) {
    return input;
  }
  if (isReadableStream(input)) {
    input = (0, import_browser_readablestream_to_it3.default)(input);
  }
  if (Symbol.iterator in input || Symbol.asyncIterator in input) {
    const peekable = (0, import_it_peekable3.default)(input);
    const { value, done } = await peekable.peek();
    if (done) {
      return itToBlob(peekable);
    }
    peekable.push(value);
    if (Number.isInteger(value)) {
      return new Blob([Uint8Array.from(await (0, import_it_all5.default)(peekable))]);
    }
    if (isBytes(value) || typeof value === "string" || value instanceof String) {
      return itToBlob(peekable);
    }
  }
  throw (0, import_err_code30.default)(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
}
async function itToBlob(stream) {
  const parts = [];
  for await (const chunk of stream) {
    parts.push(chunk);
  }
  return new Blob(parts);
}
var import_err_code30, import_it_peekable3, import_browser_readablestream_to_it3, import_it_all5;
var init_normalise_content_browser = __esm({
  "node_modules/ipfs-core-utils/esm/src/files/normalise-content.browser.js"() {
    init_node_globals();
    import_err_code30 = __toModule(require_err_code());
    import_it_peekable3 = __toModule(require_it_peekable());
    import_browser_readablestream_to_it3 = __toModule(require_browser_readablestream_to_it());
    import_it_all5 = __toModule(require_it_all());
    init_utils4();
  }
});

// node_modules/ipfs-core-utils/esm/src/files/normalise-input.browser.js
function normaliseInput3(input) {
  return normalise(input, normaliseContent2);
}
var init_normalise_input_browser = __esm({
  "node_modules/ipfs-core-utils/esm/src/files/normalise-input.browser.js"() {
    init_node_globals();
    init_normalise_content_browser();
    init_normalise();
  }
});

// node_modules/ipfs-core-utils/esm/src/mode-to-string.js
function modeToString2(mode) {
  if (mode == null) {
    return void 0;
  }
  if (typeof mode === "string") {
    return mode;
  }
  return mode.toString(8).padStart(4, "0");
}
var init_mode_to_string2 = __esm({
  "node_modules/ipfs-core-utils/esm/src/mode-to-string.js"() {
    init_node_globals();
  }
});

// node_modules/ipfs-core-utils/esm/src/multipart-request.browser.js
async function multipartRequest(source, abortController, headers = {}) {
  const parts = [];
  const formData = new FormData();
  let index = 0;
  let total = 0;
  for await (const { content, path, mode, mtime } of normaliseInput3(source)) {
    let fileSuffix = "";
    const type = content ? "file" : "dir";
    if (index > 0) {
      fileSuffix = `-${index}`;
    }
    let fieldName = type + fileSuffix;
    const qs = [];
    if (mode !== null && mode !== void 0) {
      qs.push(`mode=${modeToString2(mode)}`);
    }
    if (mtime != null) {
      const { secs, nsecs } = mtime;
      qs.push(`mtime=${secs}`);
      if (nsecs != null) {
        qs.push(`mtime-nsecs=${nsecs}`);
      }
    }
    if (qs.length) {
      fieldName = `${fieldName}?${qs.join("&")}`;
    }
    if (content) {
      formData.set(fieldName, content, path != null ? encodeURIComponent(path) : void 0);
      const end = total + content.size;
      parts.push({
        name: path,
        start: total,
        end
      });
      total = end;
    } else if (path != null) {
      formData.set(fieldName, new File([""], encodeURIComponent(path), { type: "application/x-directory" }));
    } else {
      throw new Error("path or content or both must be set");
    }
    index++;
  }
  return {
    total,
    parts,
    headers,
    body: formData
  };
}
var init_multipart_request_browser = __esm({
  "node_modules/ipfs-core-utils/esm/src/multipart-request.browser.js"() {
    init_node_globals();
    init_normalise_input_browser();
    init_mode_to_string2();
  }
});

// node_modules/ipfs-http-client/esm/src/lib/abort-signal.js
function filter7(signals) {
  return signals.filter(Boolean);
}
function abortSignal(...signals) {
  return (0, import_any_signal2.anySignal)(filter7(signals));
}
var import_any_signal2;
var init_abort_signal = __esm({
  "node_modules/ipfs-http-client/esm/src/lib/abort-signal.js"() {
    init_node_globals();
    import_any_signal2 = __toModule(require_any_signal());
  }
});

// node_modules/ipfs-http-client/esm/src/block/put.js
var import_native_abort_controller, createPut;
var init_put = __esm({
  "node_modules/ipfs-http-client/esm/src/block/put.js"() {
    init_node_globals();
    init_cid();
    init_multipart_request_browser();
    init_configure();
    init_to_url_search_params();
    init_abort_signal();
    import_native_abort_controller = __toModule(require_src4());
    createPut = configure((api) => {
      async function put(data, options = {}) {
        const controller = new import_native_abort_controller.AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        let res;
        try {
          const response = await api.post("block/put", {
            signal,
            searchParams: toUrlSearchParams(options),
            ...await multipartRequest(data, controller, options.headers)
          });
          res = await response.json();
        } catch (err) {
          if (options.format === "dag-pb") {
            return put(data, {
              ...options,
              format: "protobuf"
            });
          } else if (options.format === "dag-cbor") {
            return put(data, {
              ...options,
              format: "cbor"
            });
          }
          throw err;
        }
        return CID.parse(res.Key);
      }
      return put;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/block/rm.js
function toCoreInterface2(removed) {
  const out = { cid: CID.parse(removed.Hash) };
  if (removed.Error) {
    out.error = new Error(removed.Error);
  }
  return out;
}
var createRm;
var init_rm = __esm({
  "node_modules/ipfs-http-client/esm/src/block/rm.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createRm = configure((api) => {
      async function* rm(cid, options = {}) {
        if (!Array.isArray(cid)) {
          cid = [cid];
        }
        const res = await api.post("block/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.map((cid2) => cid2.toString()),
            "stream-channels": true,
            ...options
          }),
          headers: options.headers
        });
        for await (const removed of res.ndjson()) {
          yield toCoreInterface2(removed);
        }
      }
      return rm;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/block/stat.js
var createStat2;
var init_stat2 = __esm({
  "node_modules/ipfs-http-client/esm/src/block/stat.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createStat2 = configure((api) => {
      async function stat(cid, options = {}) {
        const res = await api.post("block/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          cid: CID.parse(data.Key),
          size: data.Size
        };
      }
      return stat;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/block/index.js
function createBlock(config2) {
  return {
    get: createGet(config2),
    put: createPut(config2),
    rm: createRm(config2),
    stat: createStat2(config2)
  };
}
var init_block2 = __esm({
  "node_modules/ipfs-http-client/esm/src/block/index.js"() {
    init_node_globals();
    init_get();
    init_put();
    init_rm();
    init_stat2();
  }
});

// node_modules/ipfs-http-client/esm/src/bootstrap/add.js
var import_multiaddr3, createAdd;
var init_add = __esm({
  "node_modules/ipfs-http-client/esm/src/bootstrap/add.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    import_multiaddr3 = __toModule(require_src());
    createAdd = configure((api) => {
      async function add(addr, options = {}) {
        const res = await api.post("bootstrap/add", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr3.Multiaddr(ma)) };
      }
      return add;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/bootstrap/clear.js
var import_multiaddr4, createClear;
var init_clear = __esm({
  "node_modules/ipfs-http-client/esm/src/bootstrap/clear.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    import_multiaddr4 = __toModule(require_src());
    createClear = configure((api) => {
      async function clear(options = {}) {
        const res = await api.post("bootstrap/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            all: true
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr4.Multiaddr(ma)) };
      }
      return clear;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/bootstrap/list.js
var import_multiaddr5, createList;
var init_list = __esm({
  "node_modules/ipfs-http-client/esm/src/bootstrap/list.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    import_multiaddr5 = __toModule(require_src());
    createList = configure((api) => {
      async function list(options = {}) {
        const res = await api.post("bootstrap/list", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr5.Multiaddr(ma)) };
      }
      return list;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/bootstrap/reset.js
var import_multiaddr6, createReset;
var init_reset = __esm({
  "node_modules/ipfs-http-client/esm/src/bootstrap/reset.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    import_multiaddr6 = __toModule(require_src());
    createReset = configure((api) => {
      async function reset(options = {}) {
        const res = await api.post("bootstrap/add", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            default: true
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr6.Multiaddr(ma)) };
      }
      return reset;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/bootstrap/rm.js
var import_multiaddr7, createRm2;
var init_rm2 = __esm({
  "node_modules/ipfs-http-client/esm/src/bootstrap/rm.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    import_multiaddr7 = __toModule(require_src());
    createRm2 = configure((api) => {
      async function rm(addr, options = {}) {
        const res = await api.post("bootstrap/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return { Peers: Peers.map((ma) => new import_multiaddr7.Multiaddr(ma)) };
      }
      return rm;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/bootstrap/index.js
function createBootstrap(config2) {
  return {
    add: createAdd(config2),
    clear: createClear(config2),
    list: createList(config2),
    reset: createReset(config2),
    rm: createRm2(config2)
  };
}
var init_bootstrap = __esm({
  "node_modules/ipfs-http-client/esm/src/bootstrap/index.js"() {
    init_node_globals();
    init_add();
    init_clear();
    init_list();
    init_reset();
    init_rm2();
  }
});

// node_modules/ipfs-http-client/esm/src/config/profiles/apply.js
var createApply;
var init_apply = __esm({
  "node_modules/ipfs-http-client/esm/src/config/profiles/apply.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createApply = configure((api) => {
      async function apply(profile, options = {}) {
        const res = await api.post("config/profile/apply", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: profile,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          original: data.OldCfg,
          updated: data.NewCfg
        };
      }
      return apply;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/lib/object-to-camel.js
function objectToCamel(obj) {
  if (obj == null) {
    return obj;
  }
  const caps = /^[A-Z]+$/;
  const output = {};
  return Object.keys(obj).reduce((camelObj, k) => {
    if (caps.test(k)) {
      camelObj[k.toLowerCase()] = obj[k];
    } else if (caps.test(k[0])) {
      camelObj[k[0].toLowerCase() + k.slice(1)] = obj[k];
    } else {
      camelObj[k] = obj[k];
    }
    return camelObj;
  }, output);
}
var init_object_to_camel = __esm({
  "node_modules/ipfs-http-client/esm/src/lib/object-to-camel.js"() {
    init_node_globals();
  }
});

// node_modules/ipfs-http-client/esm/src/config/profiles/list.js
var createList2;
var init_list2 = __esm({
  "node_modules/ipfs-http-client/esm/src/config/profiles/list.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createList2 = configure((api) => {
      async function list(options = {}) {
        const res = await api.post("config/profile/list", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return data.map((profile) => objectToCamel(profile));
      }
      return list;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/config/profiles/index.js
function createProfiles(config2) {
  return {
    apply: createApply(config2),
    list: createList2(config2)
  };
}
var init_profiles = __esm({
  "node_modules/ipfs-http-client/esm/src/config/profiles/index.js"() {
    init_node_globals();
    init_apply();
    init_list2();
  }
});

// node_modules/ipfs-http-client/esm/src/config/get.js
var createGet2;
var init_get2 = __esm({
  "node_modules/ipfs-http-client/esm/src/config/get.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createGet2 = configure((api) => {
      const get2 = async (key, options = {}) => {
        if (!key) {
          throw new Error("key argument is required");
        }
        const res = await api.post("config", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: key,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return data.Value;
      };
      return get2;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/config/get-all.js
var createGetAll;
var init_get_all = __esm({
  "node_modules/ipfs-http-client/esm/src/config/get-all.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createGetAll = configure((api) => {
      const getAll = async (options = {}) => {
        const res = await api.post("config/show", {
          signal: options.signal,
          searchParams: toUrlSearchParams({ ...options }),
          headers: options.headers
        });
        const data = await res.json();
        return data;
      };
      return getAll;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/config/replace.js
var import_native_abort_controller2, createReplace;
var init_replace = __esm({
  "node_modules/ipfs-http-client/esm/src/config/replace.js"() {
    init_node_globals();
    init_from_string();
    init_multipart_request_browser();
    init_configure();
    init_to_url_search_params();
    init_abort_signal();
    import_native_abort_controller2 = __toModule(require_src4());
    createReplace = configure((api) => {
      const replace = async (config2, options = {}) => {
        const controller = new import_native_abort_controller2.AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("config/replace", {
          signal,
          searchParams: toUrlSearchParams(options),
          ...await multipartRequest(fromString3(JSON.stringify(config2)), controller, options.headers)
        });
        await res.text();
      };
      return replace;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/config/set.js
var createSet, encodeParam;
var init_set = __esm({
  "node_modules/ipfs-http-client/esm/src/config/set.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createSet = configure((api) => {
      const set = async (key, value, options = {}) => {
        if (typeof key !== "string") {
          throw new Error("Invalid key type");
        }
        const params = {
          ...options,
          ...encodeParam(key, value)
        };
        const res = await api.post("config", {
          signal: options.signal,
          searchParams: toUrlSearchParams(params),
          headers: options.headers
        });
        await res.text();
      };
      return set;
    });
    encodeParam = (key, value) => {
      switch (typeof value) {
        case "boolean":
          return {
            arg: [
              key,
              value.toString()
            ],
            bool: true
          };
        case "string":
          return {
            arg: [
              key,
              value
            ]
          };
        default:
          return {
            arg: [
              key,
              JSON.stringify(value)
            ],
            json: true
          };
      }
    };
  }
});

// node_modules/ipfs-http-client/esm/src/config/index.js
function createConfig(config2) {
  return {
    getAll: createGetAll(config2),
    get: createGet2(config2),
    set: createSet(config2),
    replace: createReplace(config2),
    profiles: createProfiles(config2)
  };
}
var init_config2 = __esm({
  "node_modules/ipfs-http-client/esm/src/config/index.js"() {
    init_node_globals();
    init_profiles();
    init_get2();
    init_get_all();
    init_replace();
    init_set();
  }
});

// node_modules/ipfs-http-client/esm/src/dag/export.js
var createExport;
var init_export = __esm({
  "node_modules/ipfs-http-client/esm/src/dag/export.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createExport = configure((api) => {
      async function* dagExport(root, options = {}) {
        const res = await api.post("dag/export", {
          signal: options.signal,
          searchParams: toUrlSearchParams({ arg: root.toString() }),
          headers: options.headers
        });
        yield* res.iterator();
      }
      return dagExport;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/lib/resolve.js
async function* resolve5(cid, path, codecs2, getBlock, options) {
  const load = async (cid2) => {
    const codec = await codecs2.getCodec(cid2.code);
    const block = await getBlock(cid2, options);
    return codec.decode(block);
  };
  const parts = path.split("/").filter(Boolean);
  let value = await load(cid);
  let lastCid = cid;
  if (!parts.length) {
    yield {
      value,
      remainderPath: ""
    };
  }
  while (parts.length) {
    const key = parts.shift();
    if (!key) {
      throw (0, import_err_code31.default)(new Error(`Could not resolve path "${path}"`), "ERR_INVALID_PATH");
    }
    if (Object.prototype.hasOwnProperty.call(value, key)) {
      value = value[key];
      yield {
        value,
        remainderPath: parts.join("/")
      };
    } else {
      throw (0, import_err_code31.default)(new Error(`no link named "${key}" under ${lastCid}`), "ERR_NO_LINK");
    }
    const cid2 = CID.asCID(value);
    if (cid2) {
      lastCid = cid2;
      value = await load(value);
    }
  }
}
var import_err_code31;
var init_resolve = __esm({
  "node_modules/ipfs-http-client/esm/src/lib/resolve.js"() {
    init_node_globals();
    init_cid();
    import_err_code31 = __toModule(require_err_code());
  }
});

// node_modules/ipfs-http-client/esm/src/dag/get.js
var import_it_first2, import_it_last2, import_err_code32, createGet3;
var init_get3 = __esm({
  "node_modules/ipfs-http-client/esm/src/dag/get.js"() {
    init_node_globals();
    init_configure();
    init_resolve();
    import_it_first2 = __toModule(require_it_first());
    import_it_last2 = __toModule(require_it_last());
    import_err_code32 = __toModule(require_err_code());
    init_get();
    createGet3 = (codecs2, options) => {
      const fn = configure((api, opts) => {
        const getBlock = createGet(opts);
        const get2 = async (cid, options2 = {}) => {
          if (options2.path) {
            const entry = options2.localResolve ? await (0, import_it_first2.default)(resolve5(cid, options2.path, codecs2, getBlock, options2)) : await (0, import_it_last2.default)(resolve5(cid, options2.path, codecs2, getBlock, options2));
            const result = entry;
            if (!result) {
              throw (0, import_err_code32.default)(new Error("Not found"), "ERR_NOT_FOUND");
            }
            return result;
          }
          const codec = await codecs2.getCodec(cid.code);
          const block = await getBlock(cid, options2);
          const node = codec.decode(block);
          return {
            value: node,
            remainderPath: ""
          };
        };
        return get2;
      });
      return fn(options);
    };
  }
});

// node_modules/ipfs-http-client/esm/src/dag/import.js
var import_native_abort_controller3, createImport;
var init_import = __esm({
  "node_modules/ipfs-http-client/esm/src/dag/import.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    init_abort_signal();
    init_multipart_request_browser();
    import_native_abort_controller3 = __toModule(require_src4());
    init_cid();
    createImport = configure((api) => {
      async function* dagImport(source, options = {}) {
        const controller = new import_native_abort_controller3.AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const { headers, body } = await multipartRequest(source, controller, options.headers);
        const res = await api.post("dag/import", {
          signal,
          headers,
          body,
          searchParams: toUrlSearchParams({ "pin-roots": options.pinRoots })
        });
        for await (const { Root: Root2 } of res.ndjson()) {
          if (Root2 !== void 0) {
            const {
              Cid: { "/": Cid },
              PinErrorMsg
            } = Root2;
            yield {
              root: {
                cid: CID.parse(Cid),
                pinErrorMsg: PinErrorMsg
              }
            };
          }
        }
      }
      return dagImport;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/dag/put.js
var import_native_abort_controller4, createPut2;
var init_put2 = __esm({
  "node_modules/ipfs-http-client/esm/src/dag/put.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_multipart_request_browser();
    init_to_url_search_params();
    init_abort_signal();
    import_native_abort_controller4 = __toModule(require_src4());
    createPut2 = (codecs2, options) => {
      const fn = configure((api) => {
        const put = async (dagNode, options2 = {}) => {
          const settings = {
            format: "dag-cbor",
            hashAlg: "sha2-256",
            inputEnc: "raw",
            ...options2
          };
          const codec = await codecs2.getCodec(settings.format);
          const serialized = codec.encode(dagNode);
          const controller = new import_native_abort_controller4.AbortController();
          const signal = abortSignal(controller.signal, settings.signal);
          const res = await api.post("dag/put", {
            timeout: settings.timeout,
            signal,
            searchParams: toUrlSearchParams(settings),
            ...await multipartRequest(serialized, controller, settings.headers)
          });
          const data = await res.json();
          return CID.parse(data.Cid["/"]);
        };
        return put;
      });
      return fn(options);
    };
  }
});

// node_modules/ipfs-http-client/esm/src/dag/resolve.js
var createResolve;
var init_resolve2 = __esm({
  "node_modules/ipfs-http-client/esm/src/dag/resolve.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createResolve = configure((api) => {
      const resolve6 = async (ipfsPath2, options = {}) => {
        const res = await api.post("dag/resolve", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${ipfsPath2}${options.path ? `/${options.path}`.replace(/\/[/]+/g, "/") : ""}`,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          cid: CID.parse(data.Cid["/"]),
          remainderPath: data.RemPath
        };
      };
      return resolve6;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/dag/index.js
function createDag(codecs2, config2) {
  return {
    export: createExport(config2),
    get: createGet3(codecs2, config2),
    import: createImport(config2),
    put: createPut2(codecs2, config2),
    resolve: createResolve(config2)
  };
}
var init_dag = __esm({
  "node_modules/ipfs-http-client/esm/src/dag/index.js"() {
    init_node_globals();
    init_export();
    init_get3();
    init_import();
    init_put2();
    init_resolve2();
  }
});

// node_modules/ipfs-http-client/esm/src/dht/response-types.js
var FinalPeer, Provider, Value;
var init_response_types = __esm({
  "node_modules/ipfs-http-client/esm/src/dht/response-types.js"() {
    init_node_globals();
    FinalPeer = 2;
    Provider = 4;
    Value = 5;
  }
});

// node_modules/ipfs-http-client/esm/src/dht/find-peer.js
var import_multiaddr8, createFindPeer;
var init_find_peer = __esm({
  "node_modules/ipfs-http-client/esm/src/dht/find-peer.js"() {
    init_node_globals();
    import_multiaddr8 = __toModule(require_src());
    init_configure();
    init_to_url_search_params();
    init_response_types();
    createFindPeer = configure((api) => {
      async function findPeer(peerId, options = {}) {
        const res = await api.post("dht/findpeer", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: peerId,
            ...options
          }),
          headers: options.headers
        });
        for await (const data of res.ndjson()) {
          if (data.Type === FinalPeer && data.Responses) {
            const { ID, Addrs } = data.Responses[0];
            return {
              id: ID,
              addrs: (Addrs || []).map((a) => new import_multiaddr8.Multiaddr(a))
            };
          }
        }
        throw new Error("not found");
      }
      return findPeer;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/dht/find-provs.js
var import_multiaddr9, createFindProvs;
var init_find_provs = __esm({
  "node_modules/ipfs-http-client/esm/src/dht/find-provs.js"() {
    init_node_globals();
    import_multiaddr9 = __toModule(require_src());
    init_configure();
    init_to_url_search_params();
    init_response_types();
    createFindProvs = configure((api) => {
      async function* findProvs(cid, options = {}) {
        const res = await api.post("dht/findprovs", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cid.toString(),
            ...options
          }),
          headers: options.headers
        });
        for await (const message of res.ndjson()) {
          if (message.Type === Provider && message.Responses) {
            for (const { ID, Addrs } of message.Responses) {
              yield {
                id: ID,
                addrs: (Addrs || []).map((a) => new import_multiaddr9.Multiaddr(a))
              };
            }
          }
        }
      }
      return findProvs;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/dht/get.js
var createGet4;
var init_get4 = __esm({
  "node_modules/ipfs-http-client/esm/src/dht/get.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    init_response_types();
    init_from_string();
    init_to_string();
    createGet4 = configure((api) => {
      async function get2(key, options = {}) {
        const res = await api.post("dht/get", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: key instanceof Uint8Array ? toString3(key) : key,
            ...options
          }),
          headers: options.headers
        });
        for await (const message of res.ndjson()) {
          if (message.Type === Value) {
            return fromString3(message.Extra, "base64pad");
          }
        }
        throw new Error("not found");
      }
      return get2;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/dht/provide.js
var import_multiaddr10, createProvide;
var init_provide = __esm({
  "node_modules/ipfs-http-client/esm/src/dht/provide.js"() {
    init_node_globals();
    import_multiaddr10 = __toModule(require_src());
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createProvide = configure((api) => {
      async function* provide(cids, options = { recursive: false }) {
        const cidArr = Array.isArray(cids) ? cids : [cids];
        const res = await api.post("dht/provide", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: cidArr.map((cid) => cid.toString()),
            ...options
          }),
          headers: options.headers
        });
        for await (let message of res.ndjson()) {
          message = objectToCamel(message);
          if (message.responses) {
            message.responses = message.responses.map(({ ID, Addrs }) => ({
              id: ID,
              addrs: (Addrs || []).map((a) => new import_multiaddr10.Multiaddr(a))
            }));
          } else {
            message.responses = [];
          }
          yield message;
        }
      }
      return provide;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/dht/put.js
var import_multiaddr11, import_native_abort_controller5, createPut3;
var init_put3 = __esm({
  "node_modules/ipfs-http-client/esm/src/dht/put.js"() {
    init_node_globals();
    import_multiaddr11 = __toModule(require_src());
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    init_multipart_request_browser();
    init_abort_signal();
    import_native_abort_controller5 = __toModule(require_src4());
    init_to_string();
    createPut3 = configure((api) => {
      async function* put(key, value, options = {}) {
        const controller = new import_native_abort_controller5.AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("dht/put", {
          signal,
          searchParams: toUrlSearchParams({
            arg: toString3(key),
            ...options
          }),
          ...await multipartRequest(value, controller, options.headers)
        });
        for await (let message of res.ndjson()) {
          message = objectToCamel(message);
          if (message.responses) {
            message.responses = message.responses.map(({ ID, Addrs }) => ({
              id: ID,
              addrs: (Addrs || []).map((a) => new import_multiaddr11.Multiaddr(a))
            }));
          }
          yield message;
        }
      }
      return put;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/dht/query.js
var import_multiaddr12, createQuery;
var init_query = __esm({
  "node_modules/ipfs-http-client/esm/src/dht/query.js"() {
    init_node_globals();
    import_multiaddr12 = __toModule(require_src());
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createQuery = configure((api) => {
      async function* query(peerId, options = {}) {
        const res = await api.post("dht/query", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: peerId.toString(),
            ...options
          }),
          headers: options.headers
        });
        for await (let message of res.ndjson()) {
          message = objectToCamel(message);
          message.responses = (message.responses || []).map(({ ID, Addrs }) => ({
            id: ID,
            addrs: (Addrs || []).map((a) => new import_multiaddr12.Multiaddr(a))
          }));
          yield message;
        }
      }
      return query;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/dht/index.js
function createDht(config2) {
  return {
    findPeer: createFindPeer(config2),
    findProvs: createFindProvs(config2),
    get: createGet4(config2),
    provide: createProvide(config2),
    put: createPut3(config2),
    query: createQuery(config2)
  };
}
var init_dht = __esm({
  "node_modules/ipfs-http-client/esm/src/dht/index.js"() {
    init_node_globals();
    init_find_peer();
    init_find_provs();
    init_get4();
    init_provide();
    init_put3();
    init_query();
  }
});

// node_modules/ipfs-http-client/esm/src/diag/cmds.js
var createCmds;
var init_cmds = __esm({
  "node_modules/ipfs-http-client/esm/src/diag/cmds.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createCmds = configure((api) => {
      async function cmds(options = {}) {
        const res = await api.post("diag/cmds", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      }
      return cmds;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/diag/net.js
var createNet;
var init_net = __esm({
  "node_modules/ipfs-http-client/esm/src/diag/net.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createNet = configure((api) => {
      async function net(options = {}) {
        const res = await api.post("diag/net", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      }
      return net;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/diag/sys.js
var createSys;
var init_sys = __esm({
  "node_modules/ipfs-http-client/esm/src/diag/sys.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createSys = configure((api) => {
      async function sys(options = {}) {
        const res = await api.post("diag/sys", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      }
      return sys;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/diag/index.js
function createDiag(config2) {
  return {
    cmds: createCmds(config2),
    net: createNet(config2),
    sys: createSys(config2)
  };
}
var init_diag = __esm({
  "node_modules/ipfs-http-client/esm/src/diag/index.js"() {
    init_node_globals();
    init_cmds();
    init_net();
    init_sys();
  }
});

// node_modules/ipfs-http-client/esm/src/files/chmod.js
var createChmod;
var init_chmod = __esm({
  "node_modules/ipfs-http-client/esm/src/files/chmod.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createChmod = configure((api) => {
      async function chmod(path, mode, options = {}) {
        const res = await api.post("files/chmod", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            mode,
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return chmod;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/files/cp.js
var createCp;
var init_cp = __esm({
  "node_modules/ipfs-http-client/esm/src/files/cp.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createCp = configure((api) => {
      async function cp(sources, destination, options = {}) {
        const sourceArr = Array.isArray(sources) ? sources : [sources];
        const res = await api.post("files/cp", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: sourceArr.concat(destination).map((src2) => CID.asCID(src2) ? `/ipfs/${src2}` : src2),
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return cp;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/files/flush.js
var createFlush;
var init_flush = __esm({
  "node_modules/ipfs-http-client/esm/src/files/flush.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createFlush = configure((api) => {
      async function flush2(path, options = {}) {
        if (!path || typeof path !== "string") {
          throw new Error("ipfs.files.flush requires a path");
        }
        const res = await api.post("files/flush", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return CID.parse(data.Cid);
      }
      return flush2;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/lib/object-to-camel-with-metadata.js
function objectToCamelWithMetadata(entry) {
  const file = objectToCamel(entry);
  if (Object.prototype.hasOwnProperty.call(file, "mode")) {
    file.mode = parseInt(file.mode, 8);
  }
  if (Object.prototype.hasOwnProperty.call(file, "mtime")) {
    file.mtime = {
      secs: file.mtime,
      nsecs: file.mtimeNsecs || 0
    };
    delete file.mtimeNsecs;
  }
  return file;
}
var init_object_to_camel_with_metadata = __esm({
  "node_modules/ipfs-http-client/esm/src/lib/object-to-camel-with-metadata.js"() {
    init_node_globals();
    init_object_to_camel();
  }
});

// node_modules/ipfs-http-client/esm/src/files/ls.js
function toCoreInterface3(entry) {
  if (entry.hash) {
    entry.cid = CID.parse(entry.hash);
  }
  delete entry.hash;
  entry.type = entry.type === 1 ? "directory" : "file";
  return entry;
}
var createLs;
var init_ls = __esm({
  "node_modules/ipfs-http-client/esm/src/files/ls.js"() {
    init_node_globals();
    init_cid();
    init_object_to_camel_with_metadata();
    init_configure();
    init_to_url_search_params();
    createLs = configure((api) => {
      async function* ls(path, options = {}) {
        if (!path) {
          throw new Error("ipfs.files.ls requires a path");
        }
        const res = await api.post("files/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: CID.asCID(path) ? `/ipfs/${path}` : path,
            long: true,
            ...options,
            stream: true
          }),
          headers: options.headers
        });
        for await (const result of res.ndjson()) {
          if ("Entries" in result) {
            for (const entry of result.Entries || []) {
              yield toCoreInterface3(objectToCamelWithMetadata(entry));
            }
          } else {
            yield toCoreInterface3(objectToCamelWithMetadata(result));
          }
        }
      }
      return ls;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/files/mkdir.js
var createMkdir;
var init_mkdir = __esm({
  "node_modules/ipfs-http-client/esm/src/files/mkdir.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createMkdir = configure((api) => {
      async function mkdir(path, options = {}) {
        const res = await api.post("files/mkdir", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return mkdir;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/files/mv.js
var createMv;
var init_mv = __esm({
  "node_modules/ipfs-http-client/esm/src/files/mv.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createMv = configure((api) => {
      async function mv(sources, destination, options = {}) {
        if (!Array.isArray(sources)) {
          sources = [sources];
        }
        const res = await api.post("files/mv", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: sources.concat(destination),
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return mv;
    });
  }
});

// node_modules/stream-to-it/source.js
var require_source = __commonJS({
  "node_modules/stream-to-it/source.js"(exports2, module2) {
    init_node_globals();
    module2.exports = (readable) => {
      if (readable[Symbol.asyncIterator])
        return readable;
      if (readable.getReader) {
        return async function* () {
          const reader = readable.getReader();
          try {
            while (true) {
              const { done, value } = await reader.read();
              if (done)
                return;
              yield value;
            }
          } finally {
            reader.releaseLock();
          }
        }();
      }
      throw new Error("unknown stream");
    };
  }
});

// node_modules/ipfs-http-client/esm/src/files/read.js
var import_source, createRead;
var init_read = __esm({
  "node_modules/ipfs-http-client/esm/src/files/read.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    import_source = __toModule(require_source());
    createRead = configure((api) => {
      async function* read2(path, options = {}) {
        const res = await api.post("files/read", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            count: options.length,
            ...options
          }),
          headers: options.headers
        });
        yield* (0, import_source.default)(res.body);
      }
      return read2;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/files/rm.js
var createRm3;
var init_rm3 = __esm({
  "node_modules/ipfs-http-client/esm/src/files/rm.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createRm3 = configure((api) => {
      async function rm(path, options = {}) {
        const res = await api.post("files/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return rm;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/files/stat.js
function toCoreInterface4(entry) {
  entry.cid = CID.parse(entry.hash);
  delete entry.hash;
  return entry;
}
var createStat3;
var init_stat3 = __esm({
  "node_modules/ipfs-http-client/esm/src/files/stat.js"() {
    init_node_globals();
    init_cid();
    init_object_to_camel_with_metadata();
    init_configure();
    init_to_url_search_params();
    createStat3 = configure((api) => {
      async function stat(path, options = {}) {
        const res = await api.post("files/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        data.WithLocality = data.WithLocality || false;
        return toCoreInterface4(objectToCamelWithMetadata(data));
      }
      return stat;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/files/touch.js
var createTouch;
var init_touch = __esm({
  "node_modules/ipfs-http-client/esm/src/files/touch.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createTouch = configure((api) => {
      async function touch(path, options = {}) {
        const res = await api.post("files/touch", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        await res.text();
      }
      return touch;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/files/write.js
var import_native_abort_controller6, createWrite;
var init_write = __esm({
  "node_modules/ipfs-http-client/esm/src/files/write.js"() {
    init_node_globals();
    init_mode_to_string();
    init_parse_mtime();
    init_configure();
    init_multipart_request_browser();
    init_to_url_search_params();
    init_abort_signal();
    import_native_abort_controller6 = __toModule(require_src4());
    createWrite = configure((api) => {
      async function write(path, input, options = {}) {
        const controller = new import_native_abort_controller6.AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("files/write", {
          signal,
          searchParams: toUrlSearchParams({
            arg: path,
            streamChannels: true,
            count: options.length,
            ...options
          }),
          ...await multipartRequest({
            content: input,
            path: "arg",
            mode: modeToString(options.mode),
            mtime: parseMtime2(options.mtime)
          }, controller, options.headers)
        });
        await res.text();
      }
      return write;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/files/index.js
function createFiles(config2) {
  return {
    chmod: createChmod(config2),
    cp: createCp(config2),
    flush: createFlush(config2),
    ls: createLs(config2),
    mkdir: createMkdir(config2),
    mv: createMv(config2),
    read: createRead(config2),
    rm: createRm3(config2),
    stat: createStat3(config2),
    touch: createTouch(config2),
    write: createWrite(config2)
  };
}
var init_files = __esm({
  "node_modules/ipfs-http-client/esm/src/files/index.js"() {
    init_node_globals();
    init_chmod();
    init_cp();
    init_flush();
    init_ls();
    init_mkdir();
    init_mv();
    init_read();
    init_rm3();
    init_stat3();
    init_touch();
    init_write();
  }
});

// node_modules/ipfs-http-client/esm/src/key/export.js
var import_err_code33, createExport2;
var init_export2 = __esm({
  "node_modules/ipfs-http-client/esm/src/key/export.js"() {
    init_node_globals();
    init_configure();
    import_err_code33 = __toModule(require_err_code());
    createExport2 = configure((api) => {
      const exportKey = async (name5, password, options = {}) => {
        throw (0, import_err_code33.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
      };
      return exportKey;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/key/gen.js
var createGen;
var init_gen = __esm({
  "node_modules/ipfs-http-client/esm/src/key/gen.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createGen = configure((api) => {
      async function gen(name5, options = {
        type: "rsa",
        size: 2048
      }) {
        const res = await api.post("key/gen", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name5,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return objectToCamel(data);
      }
      return gen;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/key/import.js
var createImport2;
var init_import2 = __esm({
  "node_modules/ipfs-http-client/esm/src/key/import.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createImport2 = configure((api) => {
      async function importKey(name5, pem, password, options = {}) {
        const res = await api.post("key/import", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name5,
            pem,
            password,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return objectToCamel(data);
      }
      return importKey;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/key/info.js
var import_err_code34, createInfo;
var init_info = __esm({
  "node_modules/ipfs-http-client/esm/src/key/info.js"() {
    init_node_globals();
    init_configure();
    import_err_code34 = __toModule(require_err_code());
    createInfo = configure((api) => {
      const info = async (name5, options = {}) => {
        throw (0, import_err_code34.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
      };
      return info;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/key/list.js
var createList3;
var init_list3 = __esm({
  "node_modules/ipfs-http-client/esm/src/key/list.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createList3 = configure((api) => {
      async function list(options = {}) {
        const res = await api.post("key/list", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return (data.Keys || []).map((k) => objectToCamel(k));
      }
      return list;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/key/rename.js
var createRename;
var init_rename = __esm({
  "node_modules/ipfs-http-client/esm/src/key/rename.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createRename = configure((api) => {
      async function rename(oldName, newName, options = {}) {
        const res = await api.post("key/rename", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              oldName,
              newName
            ],
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return rename;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/key/rm.js
var createRm4;
var init_rm4 = __esm({
  "node_modules/ipfs-http-client/esm/src/key/rm.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createRm4 = configure((api) => {
      async function rm(name5, options = {}) {
        const res = await api.post("key/rm", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name5,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return objectToCamel(data.Keys[0]);
      }
      return rm;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/key/index.js
function createKey(config2) {
  return {
    export: createExport2(config2),
    gen: createGen(config2),
    import: createImport2(config2),
    info: createInfo(config2),
    list: createList3(config2),
    rename: createRename(config2),
    rm: createRm4(config2)
  };
}
var init_key2 = __esm({
  "node_modules/ipfs-http-client/esm/src/key/index.js"() {
    init_node_globals();
    init_export2();
    init_gen();
    init_import2();
    init_info();
    init_list3();
    init_rename();
    init_rm4();
  }
});

// node_modules/ipfs-http-client/esm/src/log/level.js
var createLevel;
var init_level2 = __esm({
  "node_modules/ipfs-http-client/esm/src/log/level.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createLevel = configure((api) => {
      async function level(subsystem, level2, options = {}) {
        const res = await api.post("log/level", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              subsystem,
              level2
            ],
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return level;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/log/ls.js
var createLs2;
var init_ls2 = __esm({
  "node_modules/ipfs-http-client/esm/src/log/ls.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createLs2 = configure((api) => {
      async function ls(options = {}) {
        const res = await api.post("log/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return data.Strings;
      }
      return ls;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/log/tail.js
var createTail;
var init_tail = __esm({
  "node_modules/ipfs-http-client/esm/src/log/tail.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createTail = configure((api) => {
      async function* tail(options = {}) {
        const res = await api.post("log/tail", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        yield* res.ndjson();
      }
      return tail;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/log/index.js
function createLog(config2) {
  return {
    level: createLevel(config2),
    ls: createLs2(config2),
    tail: createTail(config2)
  };
}
var init_log = __esm({
  "node_modules/ipfs-http-client/esm/src/log/index.js"() {
    init_node_globals();
    init_level2();
    init_ls2();
    init_tail();
  }
});

// node_modules/ipfs-http-client/esm/src/name/publish.js
var createPublish;
var init_publish = __esm({
  "node_modules/ipfs-http-client/esm/src/name/publish.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createPublish = configure((api) => {
      async function publish(path, options = {}) {
        const res = await api.post("name/publish", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${path}`,
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return publish;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/name/resolve.js
var createResolve2;
var init_resolve3 = __esm({
  "node_modules/ipfs-http-client/esm/src/name/resolve.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createResolve2 = configure((api) => {
      async function* resolve6(path, options = {}) {
        const res = await api.post("name/resolve", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            stream: true,
            ...options
          }),
          headers: options.headers
        });
        for await (const result of res.ndjson()) {
          yield result.Path;
        }
      }
      return resolve6;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/name/pubsub/cancel.js
var createCancel;
var init_cancel = __esm({
  "node_modules/ipfs-http-client/esm/src/name/pubsub/cancel.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createCancel = configure((api) => {
      async function cancel(name5, options = {}) {
        const res = await api.post("name/pubsub/cancel", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: name5,
            ...options
          }),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return cancel;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/name/pubsub/state.js
var createState;
var init_state = __esm({
  "node_modules/ipfs-http-client/esm/src/name/pubsub/state.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createState = configure((api) => {
      async function state(options = {}) {
        const res = await api.post("name/pubsub/state", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return state;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/name/pubsub/subs.js
var createSubs;
var init_subs = __esm({
  "node_modules/ipfs-http-client/esm/src/name/pubsub/subs.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createSubs = configure((api) => {
      async function subs(options = {}) {
        const res = await api.post("name/pubsub/subs", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return data.Strings || [];
      }
      return subs;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/name/pubsub/index.js
function createPubsub(config2) {
  return {
    cancel: createCancel(config2),
    state: createState(config2),
    subs: createSubs(config2)
  };
}
var init_pubsub = __esm({
  "node_modules/ipfs-http-client/esm/src/name/pubsub/index.js"() {
    init_node_globals();
    init_cancel();
    init_state();
    init_subs();
  }
});

// node_modules/ipfs-http-client/esm/src/name/index.js
function createName(config2) {
  return {
    publish: createPublish(config2),
    resolve: createResolve2(config2),
    pubsub: createPubsub(config2)
  };
}
var init_name = __esm({
  "node_modules/ipfs-http-client/esm/src/name/index.js"() {
    init_node_globals();
    init_publish();
    init_resolve3();
    init_pubsub();
  }
});

// node_modules/ipfs-http-client/esm/src/object/data.js
var createData;
var init_data = __esm({
  "node_modules/ipfs-http-client/esm/src/object/data.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createData = configure((api) => {
      async function data(cid, options = {}) {
        const res = await api.post("object/data", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
            ...options
          }),
          headers: options.headers
        });
        const data2 = await res.arrayBuffer();
        return new Uint8Array(data2, 0, data2.byteLength);
      }
      return data;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/object/get.js
var createGet5;
var init_get5 = __esm({
  "node_modules/ipfs-http-client/esm/src/object/get.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    init_from_string();
    createGet5 = configure((api) => {
      async function get2(cid, options = {}) {
        const res = await api.post("object/get", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
            dataEncoding: "base64",
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return {
          Data: fromString3(data.Data, "base64pad"),
          Links: (data.Links || []).map((link) => ({
            Name: link.Name,
            Hash: CID.parse(link.Hash),
            Tsize: link.Size
          }))
        };
      }
      return get2;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/object/links.js
var createLinks;
var init_links = __esm({
  "node_modules/ipfs-http-client/esm/src/object/links.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createLinks = configure((api) => {
      async function links2(cid, options = {}) {
        const res = await api.post("object/links", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid instanceof Uint8Array ? CID.decode(cid) : cid}`,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return (data.Links || []).map((l) => ({
          Name: l.Name,
          Tsize: l.Size,
          Hash: CID.parse(l.Hash)
        }));
      }
      return links2;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/object/new.js
var createNew;
var init_new = __esm({
  "node_modules/ipfs-http-client/esm/src/object/new.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createNew = configure((api) => {
      async function newObject(options = {}) {
        const res = await api.post("object/new", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: options.template,
            ...options
          }),
          headers: options.headers
        });
        const { Hash } = await res.json();
        return CID.parse(Hash);
      }
      return newObject;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/object/put.js
var createPut4;
var init_put4 = __esm({
  "node_modules/ipfs-http-client/esm/src/object/put.js"() {
    init_node_globals();
    init_configure();
    init_put2();
    createPut4 = (codecs2, options) => {
      const fn = configure((api) => {
        const dagPut = createPut2(codecs2, options);
        async function put(obj, options2 = {}) {
          return dagPut(obj, {
            ...options2,
            format: "dag-pb",
            hashAlg: "sha2-256",
            version: 0
          });
        }
        return put;
      });
      return fn(options);
    };
  }
});

// node_modules/ipfs-http-client/esm/src/object/stat.js
var createStat4;
var init_stat4 = __esm({
  "node_modules/ipfs-http-client/esm/src/object/stat.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createStat4 = configure((api) => {
      async function stat(cid, options = {}) {
        const res = await api.post("object/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${cid}`,
            ...options
          }),
          headers: options.headers
        });
        const output = await res.json();
        return {
          ...output,
          Hash: CID.parse(output.Hash)
        };
      }
      return stat;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/object/patch/add-link.js
var createAddLink;
var init_add_link = __esm({
  "node_modules/ipfs-http-client/esm/src/object/patch/add-link.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createAddLink = configure((api) => {
      async function addLink(cid, dLink, options = {}) {
        const res = await api.post("object/patch/add-link", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              `${cid}`,
              dLink.Name || dLink.name || "",
              (dLink.Hash || dLink.cid || "").toString() || null
            ],
            ...options
          }),
          headers: options.headers
        });
        const { Hash } = await res.json();
        return CID.parse(Hash);
      }
      return addLink;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/object/patch/append-data.js
var import_native_abort_controller7, createAppendData;
var init_append_data = __esm({
  "node_modules/ipfs-http-client/esm/src/object/patch/append-data.js"() {
    init_node_globals();
    init_cid();
    init_multipart_request_browser();
    init_configure();
    init_to_url_search_params();
    init_abort_signal();
    import_native_abort_controller7 = __toModule(require_src4());
    createAppendData = configure((api) => {
      async function appendData(cid, data, options = {}) {
        const controller = new import_native_abort_controller7.AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("object/patch/append-data", {
          signal,
          searchParams: toUrlSearchParams({
            arg: `${cid}`,
            ...options
          }),
          ...await multipartRequest(data, controller, options.headers)
        });
        const { Hash } = await res.json();
        return CID.parse(Hash);
      }
      return appendData;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/object/patch/rm-link.js
var createRmLink;
var init_rm_link = __esm({
  "node_modules/ipfs-http-client/esm/src/object/patch/rm-link.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createRmLink = configure((api) => {
      async function rmLink(cid, dLink, options = {}) {
        const res = await api.post("object/patch/rm-link", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: [
              `${cid}`,
              dLink.Name || dLink.name || null
            ],
            ...options
          }),
          headers: options.headers
        });
        const { Hash } = await res.json();
        return CID.parse(Hash);
      }
      return rmLink;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/object/patch/set-data.js
var import_native_abort_controller8, createSetData;
var init_set_data = __esm({
  "node_modules/ipfs-http-client/esm/src/object/patch/set-data.js"() {
    init_node_globals();
    init_cid();
    init_multipart_request_browser();
    init_configure();
    init_to_url_search_params();
    init_abort_signal();
    import_native_abort_controller8 = __toModule(require_src4());
    createSetData = configure((api) => {
      async function setData(cid, data, options = {}) {
        const controller = new import_native_abort_controller8.AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("object/patch/set-data", {
          signal,
          searchParams: toUrlSearchParams({
            arg: [`${cid}`],
            ...options
          }),
          ...await multipartRequest(data, controller, options.headers)
        });
        const { Hash } = await res.json();
        return CID.parse(Hash);
      }
      return setData;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/object/patch/index.js
function createPatch(config2) {
  return {
    addLink: createAddLink(config2),
    appendData: createAppendData(config2),
    rmLink: createRmLink(config2),
    setData: createSetData(config2)
  };
}
var init_patch = __esm({
  "node_modules/ipfs-http-client/esm/src/object/patch/index.js"() {
    init_node_globals();
    init_add_link();
    init_append_data();
    init_rm_link();
    init_set_data();
  }
});

// node_modules/ipfs-http-client/esm/src/object/index.js
function createObject(codecs2, config2) {
  return {
    data: createData(config2),
    get: createGet5(config2),
    links: createLinks(config2),
    new: createNew(config2),
    put: createPut4(codecs2, config2),
    stat: createStat4(config2),
    patch: createPatch(config2)
  };
}
var init_object = __esm({
  "node_modules/ipfs-http-client/esm/src/object/index.js"() {
    init_node_globals();
    init_data();
    init_get5();
    init_links();
    init_new();
    init_put4();
    init_stat4();
    init_patch();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/add-all.js
var createAddAll;
var init_add_all = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/add-all.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_normalise_input();
    init_to_url_search_params();
    createAddAll = configure((api) => {
      async function* addAll(source, options = {}) {
        for await (const { path, recursive: recursive2, metadata } of normaliseInput(source)) {
          const res = await api.post("pin/add", {
            signal: options.signal,
            searchParams: toUrlSearchParams({
              ...options,
              arg: path,
              recursive: recursive2,
              metadata: metadata ? JSON.stringify(metadata) : void 0,
              stream: true
            }),
            headers: options.headers
          });
          for await (const pin of res.ndjson()) {
            if (pin.Pins) {
              for (const cid of pin.Pins) {
                yield CID.parse(cid);
              }
              continue;
            }
            yield CID.parse(pin);
          }
        }
      }
      return addAll;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/pin/add.js
function createAdd2(config2) {
  const all6 = createAddAll(config2);
  return configure(() => {
    async function add(path, options = {}) {
      return (0, import_it_last3.default)(all6([{
        path,
        ...options
      }], options));
    }
    return add;
  })(config2);
}
var import_it_last3;
var init_add2 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/add.js"() {
    init_node_globals();
    init_add_all();
    import_it_last3 = __toModule(require_it_last());
    init_configure();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/ls.js
function toPin2(type, cid, metadata) {
  const pin = {
    type,
    cid: CID.parse(cid)
  };
  if (metadata) {
    pin.metadata = metadata;
  }
  return pin;
}
var createLs3;
var init_ls3 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/ls.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createLs3 = configure((api) => {
      async function* ls(options = {}) {
        let paths = [];
        if (options.paths) {
          paths = Array.isArray(options.paths) ? options.paths : [options.paths];
        }
        const res = await api.post("pin/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            ...options,
            arg: paths.map((path) => `${path}`),
            stream: true
          }),
          headers: options.headers
        });
        for await (const pin of res.ndjson()) {
          if (pin.Keys) {
            for (const cid of Object.keys(pin.Keys)) {
              yield toPin2(pin.Keys[cid].Type, cid, pin.Keys[cid].Metadata);
            }
            return;
          }
          yield toPin2(pin.Type, pin.Cid, pin.Metadata);
        }
      }
      return ls;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/pin/rm-all.js
var createRmAll;
var init_rm_all = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/rm-all.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_normalise_input();
    init_to_url_search_params();
    createRmAll = configure((api) => {
      async function* rmAll(source, options = {}) {
        for await (const { path, recursive: recursive2 } of normaliseInput(source)) {
          const searchParams = new URLSearchParams(options.searchParams);
          searchParams.append("arg", `${path}`);
          if (recursive2 != null)
            searchParams.set("recursive", String(recursive2));
          const res = await api.post("pin/rm", {
            signal: options.signal,
            headers: options.headers,
            searchParams: toUrlSearchParams({
              ...options,
              arg: `${path}`,
              recursive: recursive2
            })
          });
          for await (const pin of res.ndjson()) {
            if (pin.Pins) {
              yield* pin.Pins.map((cid) => CID.parse(cid));
              continue;
            }
            yield CID.parse(pin);
          }
        }
      }
      return rmAll;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/pin/rm.js
var import_it_last4, createRm5;
var init_rm5 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/rm.js"() {
    init_node_globals();
    init_rm_all();
    import_it_last4 = __toModule(require_it_last());
    init_configure();
    createRm5 = (config2) => {
      const all6 = createRmAll(config2);
      return configure(() => {
        async function rm(path, options = {}) {
          return (0, import_it_last4.default)(all6([{
            path,
            ...options
          }], options));
        }
        return rm;
      })(config2);
    };
  }
});

// node_modules/ipfs-http-client/esm/src/pin/remote/utils.js
var decodePin, encodeService, encodeCID2, encodeQuery, encodeAddParams;
var init_utils7 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/remote/utils.js"() {
    init_node_globals();
    init_cid();
    init_to_url_search_params();
    decodePin = ({
      Name: name5,
      Status: status,
      Cid: cid
    }) => {
      return {
        cid: CID.parse(cid),
        name: name5,
        status
      };
    };
    encodeService = (service) => {
      if (typeof service === "string" && service !== "") {
        return service;
      } else {
        throw new TypeError("service name must be passed");
      }
    };
    encodeCID2 = (cid) => {
      if (CID.asCID(cid)) {
        return cid.toString();
      } else {
        throw new TypeError(`CID instance expected instead of ${typeof cid}`);
      }
    };
    encodeQuery = ({ service, cid, name: name5, status, all: all6 }) => {
      const query = toUrlSearchParams({
        service: encodeService(service),
        name: name5,
        force: all6 ? true : void 0
      });
      if (cid) {
        for (const value of cid) {
          query.append("cid", encodeCID2(value));
        }
      }
      if (status) {
        for (const value of status) {
          query.append("status", value);
        }
      }
      return query;
    };
    encodeAddParams = ({ cid, service, background, name: name5, origins }) => {
      const params = toUrlSearchParams({
        arg: encodeCID2(cid),
        service: encodeService(service),
        name: name5,
        background: background ? true : void 0
      });
      if (origins) {
        for (const origin of origins) {
          params.append("origin", origin.toString());
        }
      }
      return params;
    };
  }
});

// node_modules/ipfs-http-client/esm/src/pin/remote/add.js
function createAdd3(client) {
  async function add(cid, { timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/add", {
      timeout,
      signal,
      headers,
      searchParams: encodeAddParams({
        cid,
        ...query
      })
    });
    return decodePin(await response.json());
  }
  return add;
}
var init_add3 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/remote/add.js"() {
    init_node_globals();
    init_utils7();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/remote/ls.js
function createLs4(client) {
  async function* ls({ timeout, signal, headers, ...query }) {
    const response = await client.post("pin/remote/ls", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery(query)
    });
    for await (const pin of response.ndjson()) {
      yield decodePin(pin);
    }
  }
  return ls;
}
var init_ls4 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/remote/ls.js"() {
    init_node_globals();
    init_utils7();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/remote/rm.js
function createRm6(client) {
  async function rm({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: false
      })
    });
  }
  return rm;
}
var init_rm6 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/remote/rm.js"() {
    init_node_globals();
    init_utils7();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/remote/rm-all.js
function createRmAll2(client) {
  async function rmAll({ timeout, signal, headers, ...query }) {
    await client.post("pin/remote/rm", {
      timeout,
      signal,
      headers,
      searchParams: encodeQuery({
        ...query,
        all: true
      })
    });
  }
  return rmAll;
}
var init_rm_all2 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/remote/rm-all.js"() {
    init_node_globals();
    init_utils7();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/remote/service/utils.js
function encodeEndpoint(url) {
  const href = String(url);
  if (href === "undefined") {
    throw Error("endpoint is required");
  }
  return href[href.length - 1] === "/" ? href.slice(0, -1) : href;
}
function decodeRemoteService(json) {
  return {
    service: json.Service,
    endpoint: new URL(json.ApiEndpoint),
    ...json.Stat && { stat: decodeStat(json.Stat) }
  };
}
function decodeStat(json) {
  switch (json.Status) {
    case "valid": {
      const { Pinning, Pinned, Queued, Failed } = json.PinCount;
      return {
        status: "valid",
        pinCount: {
          queued: Queued,
          pinning: Pinning,
          pinned: Pinned,
          failed: Failed
        }
      };
    }
    case "invalid": {
      return { status: "invalid" };
    }
    default: {
      return { status: json.Status };
    }
  }
}
var init_utils8 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/remote/service/utils.js"() {
    init_node_globals();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/remote/service/add.js
function createAdd4(client) {
  async function add(name5, options) {
    const { endpoint, key, headers, timeout, signal } = options;
    await client.post("pin/remote/service/add", {
      timeout,
      signal,
      searchParams: toUrlSearchParams({
        arg: [
          name5,
          encodeEndpoint(endpoint),
          key
        ]
      }),
      headers
    });
  }
  return add;
}
var init_add4 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/remote/service/add.js"() {
    init_node_globals();
    init_to_url_search_params();
    init_utils8();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/remote/service/ls.js
function createLs5(client) {
  async function ls(options = {}) {
    const { stat, headers, timeout, signal } = options;
    const response = await client.post("pin/remote/service/ls", {
      timeout,
      signal,
      headers,
      searchParams: stat === true ? toUrlSearchParams({ stat }) : void 0
    });
    const { RemoteServices } = await response.json();
    return RemoteServices.map(decodeRemoteService);
  }
  return ls;
}
var init_ls5 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/remote/service/ls.js"() {
    init_node_globals();
    init_to_url_search_params();
    init_utils8();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/remote/service/rm.js
function createRm7(client) {
  async function rm(name5, options = {}) {
    await client.post("pin/remote/service/rm", {
      signal: options.signal,
      headers: options.headers,
      searchParams: toUrlSearchParams({ arg: name5 })
    });
  }
  return rm;
}
var init_rm7 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/remote/service/rm.js"() {
    init_node_globals();
    init_to_url_search_params();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/remote/service/index.js
function createService(config2) {
  const client = new Client(config2);
  return {
    add: createAdd4(client),
    ls: createLs5(client),
    rm: createRm7(client)
  };
}
var init_service = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/remote/service/index.js"() {
    init_node_globals();
    init_core();
    init_add4();
    init_ls5();
    init_rm7();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/remote/index.js
function createRemote(config2) {
  const client = new Client(config2);
  return {
    add: createAdd3(client),
    ls: createLs4(client),
    rm: createRm6(client),
    rmAll: createRmAll2(client),
    service: createService(config2)
  };
}
var init_remote = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/remote/index.js"() {
    init_node_globals();
    init_core();
    init_add3();
    init_ls4();
    init_rm6();
    init_rm_all2();
    init_service();
  }
});

// node_modules/ipfs-http-client/esm/src/pin/index.js
function createPin(config2) {
  return {
    addAll: createAddAll(config2),
    add: createAdd2(config2),
    ls: createLs3(config2),
    rmAll: createRmAll(config2),
    rm: createRm5(config2),
    remote: createRemote(config2)
  };
}
var init_pin2 = __esm({
  "node_modules/ipfs-http-client/esm/src/pin/index.js"() {
    init_node_globals();
    init_add_all();
    init_add2();
    init_ls3();
    init_rm_all();
    init_rm5();
    init_remote();
  }
});

// node_modules/ipfs-http-client/esm/src/pubsub/ls.js
var createLs6;
var init_ls6 = __esm({
  "node_modules/ipfs-http-client/esm/src/pubsub/ls.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createLs6 = configure((api) => {
      async function ls(options = {}) {
        const { Strings } = await (await api.post("pubsub/ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        })).json();
        return Strings || [];
      }
      return ls;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/pubsub/peers.js
var createPeers;
var init_peers = __esm({
  "node_modules/ipfs-http-client/esm/src/pubsub/peers.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createPeers = configure((api) => {
      async function peers(topic, options = {}) {
        const res = await api.post("pubsub/peers", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: topic,
            ...options
          }),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return Strings || [];
      }
      return peers;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/pubsub/publish.js
var import_native_abort_controller9, createPublish2;
var init_publish2 = __esm({
  "node_modules/ipfs-http-client/esm/src/pubsub/publish.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    init_multipart_request_browser();
    init_abort_signal();
    import_native_abort_controller9 = __toModule(require_src4());
    createPublish2 = configure((api) => {
      async function publish(topic, data, options = {}) {
        const searchParams = toUrlSearchParams({
          arg: topic,
          ...options
        });
        const controller = new import_native_abort_controller9.AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const res = await api.post("pubsub/pub", {
          signal,
          searchParams,
          ...await multipartRequest(data, controller, options.headers)
        });
        await res.text();
      }
      return publish;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/pubsub/subscribe.js
async function readMessages(response, { onMessage, onEnd, onError }) {
  onError = onError || log14;
  try {
    for await (const msg of response.ndjson()) {
      try {
        if (!msg.from) {
          continue;
        }
        onMessage({
          from: toString3(fromString3(msg.from, "base64pad"), "base58btc"),
          data: fromString3(msg.data, "base64pad"),
          seqno: fromString3(msg.seqno, "base64pad"),
          topicIDs: msg.topicIDs
        });
      } catch (err) {
        err.message = `Failed to parse pubsub message: ${err.message}`;
        onError(err, false, msg);
      }
    }
  } catch (err) {
    if (!isAbortError(err)) {
      onError(err, true);
    }
  } finally {
    onEnd();
  }
}
var import_debug15, log14, createSubscribe, isAbortError;
var init_subscribe = __esm({
  "node_modules/ipfs-http-client/esm/src/pubsub/subscribe.js"() {
    init_node_globals();
    init_from_string();
    init_to_string();
    import_debug15 = __toModule(require_browser2());
    init_configure();
    init_to_url_search_params();
    log14 = (0, import_debug15.default)("ipfs-http-client:pubsub:subscribe");
    createSubscribe = (options, subsTracker) => {
      return configure((api) => {
        async function subscribe(topic, handler, options2 = {}) {
          options2.signal = subsTracker.subscribe(topic, handler, options2.signal);
          let done;
          let fail;
          const result = new Promise((resolve6, reject) => {
            done = resolve6;
            fail = reject;
          });
          const ffWorkaround = setTimeout(() => done(), 1e3);
          api.post("pubsub/sub", {
            signal: options2.signal,
            searchParams: toUrlSearchParams({
              arg: topic,
              ...options2
            }),
            headers: options2.headers
          }).catch((err) => {
            subsTracker.unsubscribe(topic, handler);
            fail(err);
          }).then((response) => {
            clearTimeout(ffWorkaround);
            if (!response) {
              return;
            }
            readMessages(response, {
              onMessage: handler,
              onEnd: () => subsTracker.unsubscribe(topic, handler),
              onError: options2.onError
            });
            done();
          });
          return result;
        }
        return subscribe;
      })(options);
    };
    isAbortError = (error) => {
      switch (error.type) {
        case "aborted":
          return true;
        case "abort":
          return true;
        default:
          return error.name === "AbortError";
      }
    };
  }
});

// node_modules/ipfs-http-client/esm/src/pubsub/unsubscribe.js
var createUnsubscribe;
var init_unsubscribe = __esm({
  "node_modules/ipfs-http-client/esm/src/pubsub/unsubscribe.js"() {
    init_node_globals();
    createUnsubscribe = (options, subsTracker) => {
      async function unsubscribe(topic, handler) {
        subsTracker.unsubscribe(topic, handler);
      }
      return unsubscribe;
    };
  }
});

// node_modules/ipfs-http-client/esm/src/pubsub/subscription-tracker.js
var import_native_abort_controller10, SubscriptionTracker;
var init_subscription_tracker = __esm({
  "node_modules/ipfs-http-client/esm/src/pubsub/subscription-tracker.js"() {
    init_node_globals();
    import_native_abort_controller10 = __toModule(require_src4());
    SubscriptionTracker = class {
      constructor() {
        this._subs = new Map();
      }
      subscribe(topic, handler, signal) {
        const topicSubs = this._subs.get(topic) || [];
        if (topicSubs.find((s) => s.handler === handler)) {
          throw new Error(`Already subscribed to ${topic} with this handler`);
        }
        const controller = new import_native_abort_controller10.AbortController();
        this._subs.set(topic, [{
          handler,
          controller
        }].concat(topicSubs));
        if (signal) {
          signal.addEventListener("abort", () => this.unsubscribe(topic, handler));
        }
        return controller.signal;
      }
      unsubscribe(topic, handler) {
        const subs = this._subs.get(topic) || [];
        let unsubs;
        if (handler) {
          this._subs.set(topic, subs.filter((s) => s.handler !== handler));
          unsubs = subs.filter((s) => s.handler === handler);
        } else {
          this._subs.set(topic, []);
          unsubs = subs;
        }
        if (!(this._subs.get(topic) || []).length) {
          this._subs.delete(topic);
        }
        unsubs.forEach((s) => s.controller.abort());
      }
    };
  }
});

// node_modules/ipfs-http-client/esm/src/pubsub/index.js
function createPubsub2(config2) {
  const subscriptionTracker = new SubscriptionTracker();
  return {
    ls: createLs6(config2),
    peers: createPeers(config2),
    publish: createPublish2(config2),
    subscribe: createSubscribe(config2, subscriptionTracker),
    unsubscribe: createUnsubscribe(config2, subscriptionTracker)
  };
}
var init_pubsub2 = __esm({
  "node_modules/ipfs-http-client/esm/src/pubsub/index.js"() {
    init_node_globals();
    init_ls6();
    init_peers();
    init_publish2();
    init_subscribe();
    init_unsubscribe();
    init_subscription_tracker();
  }
});

// node_modules/ipfs-http-client/esm/src/refs/local.js
var createLocal;
var init_local = __esm({
  "node_modules/ipfs-http-client/esm/src/refs/local.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createLocal = configure((api) => {
      async function* refsLocal(options = {}) {
        const res = await api.post("refs/local", {
          signal: options.signal,
          transform: objectToCamel,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        yield* res.ndjson();
      }
      return refsLocal;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/refs/index.js
var createRefs;
var init_refs = __esm({
  "node_modules/ipfs-http-client/esm/src/refs/index.js"() {
    init_node_globals();
    init_cid();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    init_local();
    createRefs = configure((api, opts) => {
      const refs = async function* (args, options = {}) {
        const argsArr = Array.isArray(args) ? args : [args];
        const res = await api.post("refs", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: argsArr.map((arg) => `${arg instanceof Uint8Array ? CID.decode(arg) : arg}`),
            ...options
          }),
          headers: options.headers,
          transform: objectToCamel
        });
        yield* res.ndjson();
      };
      return Object.assign(refs, { local: createLocal(opts) });
    });
  }
});

// node_modules/ipfs-http-client/esm/src/repo/gc.js
var createGc;
var init_gc2 = __esm({
  "node_modules/ipfs-http-client/esm/src/repo/gc.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createGc = configure((api) => {
      async function* gc2(options = {}) {
        const res = await api.post("repo/gc", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers,
          transform: (res2) => {
            return {
              err: res2.Error ? new Error(res2.Error) : null,
              cid: (res2.Key || {})["/"] ? CID.parse(res2.Key["/"]) : null
            };
          }
        });
        yield* res.ndjson();
      }
      return gc2;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/repo/stat.js
var createStat5;
var init_stat5 = __esm({
  "node_modules/ipfs-http-client/esm/src/repo/stat.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createStat5 = configure((api) => {
      async function stat(options = {}) {
        const res = await api.post("repo/stat", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const data = await res.json();
        return {
          numObjects: BigInt(data.NumObjects),
          repoSize: BigInt(data.RepoSize),
          repoPath: data.RepoPath,
          version: data.Version,
          storageMax: BigInt(data.StorageMax)
        };
      }
      return stat;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/repo/version.js
var createVersion;
var init_version3 = __esm({
  "node_modules/ipfs-http-client/esm/src/repo/version.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createVersion = configure((api) => {
      async function version3(options = {}) {
        const res = await (await api.post("repo/version", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        })).json();
        return res.Version;
      }
      return version3;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/repo/index.js
function createRepo3(config2) {
  return {
    gc: createGc(config2),
    stat: createStat5(config2),
    version: createVersion(config2)
  };
}
var init_repo = __esm({
  "node_modules/ipfs-http-client/esm/src/repo/index.js"() {
    init_node_globals();
    init_gc2();
    init_stat5();
    init_version3();
  }
});

// node_modules/ipfs-http-client/esm/src/stats/bw.js
var createBw;
var init_bw = __esm({
  "node_modules/ipfs-http-client/esm/src/stats/bw.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createBw = configure((api) => {
      async function* bw(options = {}) {
        const res = await api.post("stats/bw", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers,
          transform: (stats) => ({
            totalIn: BigInt(stats.TotalIn),
            totalOut: BigInt(stats.TotalOut),
            rateIn: parseFloat(stats.RateIn),
            rateOut: parseFloat(stats.RateOut)
          })
        });
        yield* res.ndjson();
      }
      return bw;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/stats/index.js
function createStats(config2) {
  return {
    bitswap: createStat(config2),
    repo: createStat5(config2),
    bw: createBw(config2)
  };
}
var init_stats = __esm({
  "node_modules/ipfs-http-client/esm/src/stats/index.js"() {
    init_node_globals();
    init_stat();
    init_stat5();
    init_bw();
  }
});

// node_modules/ipfs-http-client/esm/src/swarm/addrs.js
var import_multiaddr13, createAddrs;
var init_addrs = __esm({
  "node_modules/ipfs-http-client/esm/src/swarm/addrs.js"() {
    init_node_globals();
    import_multiaddr13 = __toModule(require_src());
    init_configure();
    init_to_url_search_params();
    createAddrs = configure((api) => {
      async function addrs(options = {}) {
        const res = await api.post("swarm/addrs", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Addrs } = await res.json();
        return Object.keys(Addrs).map((id) => ({
          id,
          addrs: (Addrs[id] || []).map((a) => new import_multiaddr13.Multiaddr(a))
        }));
      }
      return addrs;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/swarm/connect.js
var createConnect;
var init_connect = __esm({
  "node_modules/ipfs-http-client/esm/src/swarm/connect.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createConnect = configure((api) => {
      async function connect(addr, options = {}) {
        const res = await api.post("swarm/connect", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return Strings || [];
      }
      return connect;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/swarm/disconnect.js
var createDisconnect;
var init_disconnect = __esm({
  "node_modules/ipfs-http-client/esm/src/swarm/disconnect.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createDisconnect = configure((api) => {
      async function disconnect(addr, options = {}) {
        const res = await api.post("swarm/disconnect", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: addr,
            ...options
          }),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return Strings || [];
      }
      return disconnect;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/swarm/local-addrs.js
var import_multiaddr14, createLocalAddrs;
var init_local_addrs = __esm({
  "node_modules/ipfs-http-client/esm/src/swarm/local-addrs.js"() {
    init_node_globals();
    import_multiaddr14 = __toModule(require_src());
    init_configure();
    init_to_url_search_params();
    createLocalAddrs = configure((api) => {
      async function localAddrs(options = {}) {
        const res = await api.post("swarm/addrs/local", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Strings } = await res.json();
        return (Strings || []).map((a) => new import_multiaddr14.Multiaddr(a));
      }
      return localAddrs;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/swarm/peers.js
var import_multiaddr15, createPeers2;
var init_peers2 = __esm({
  "node_modules/ipfs-http-client/esm/src/swarm/peers.js"() {
    init_node_globals();
    import_multiaddr15 = __toModule(require_src());
    init_configure();
    init_to_url_search_params();
    createPeers2 = configure((api) => {
      async function peers(options = {}) {
        const res = await api.post("swarm/peers", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        const { Peers } = await res.json();
        return (Peers || []).map((peer) => {
          return {
            addr: new import_multiaddr15.Multiaddr(peer.Addr),
            peer: peer.Peer,
            muxer: peer.Muxer,
            latency: peer.Latency,
            streams: peer.Streams,
            direction: peer.Direction == null ? void 0 : peer.Direction === 0 ? "inbound" : "outbound"
          };
        });
      }
      return peers;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/swarm/index.js
function createSwarm(config2) {
  return {
    addrs: createAddrs(config2),
    connect: createConnect(config2),
    disconnect: createDisconnect(config2),
    localAddrs: createLocalAddrs(config2),
    peers: createPeers2(config2)
  };
}
var init_swarm = __esm({
  "node_modules/ipfs-http-client/esm/src/swarm/index.js"() {
    init_node_globals();
    init_addrs();
    init_connect();
    init_disconnect();
    init_local_addrs();
    init_peers2();
  }
});

// node_modules/ipfs-http-client/esm/src/add-all.js
function toCoreInterface5({ name: name5, hash: hash2, size, mode, mtime, mtimeNsecs }) {
  const output = {
    path: name5,
    cid: CID.parse(hash2),
    size: parseInt(size)
  };
  if (mode != null) {
    output.mode = parseInt(mode, 8);
  }
  if (mtime != null) {
    output.mtime = {
      secs: mtime,
      nsecs: mtimeNsecs || 0
    };
  }
  return output;
}
var import_native_abort_controller11, createAddAll2, createProgressHandler, createOnUploadProgress;
var init_add_all2 = __esm({
  "node_modules/ipfs-http-client/esm/src/add-all.js"() {
    init_node_globals();
    init_cid();
    init_object_to_camel();
    init_configure();
    init_multipart_request_browser();
    init_to_url_search_params();
    init_abort_signal();
    import_native_abort_controller11 = __toModule(require_src4());
    createAddAll2 = configure((api) => {
      async function* addAll(source, options = {}) {
        const controller = new import_native_abort_controller11.AbortController();
        const signal = abortSignal(controller.signal, options.signal);
        const { headers, body, total, parts } = await multipartRequest(source, controller, options.headers);
        const [progressFn, onUploadProgress] = typeof options.progress === "function" ? createProgressHandler(total, parts, options.progress) : [
          void 0,
          void 0
        ];
        const res = await api.post("add", {
          searchParams: toUrlSearchParams({
            "stream-channels": true,
            ...options,
            progress: Boolean(progressFn)
          }),
          onUploadProgress,
          signal,
          headers,
          body
        });
        for await (let file of res.ndjson()) {
          file = objectToCamel(file);
          if (file.hash !== void 0) {
            yield toCoreInterface5(file);
          } else if (progressFn) {
            progressFn(file.bytes || 0, file.name);
          }
        }
      }
      return addAll;
    });
    createProgressHandler = (total, parts, progress) => parts ? [
      void 0,
      createOnUploadProgress(total, parts, progress)
    ] : [
      progress,
      void 0
    ];
    createOnUploadProgress = (size, parts, progress) => {
      let index = 0;
      const count = parts.length;
      return ({ loaded, total }) => {
        const position = Math.floor(loaded / total * size);
        while (index < count) {
          const { start, end, name: name5 } = parts[index];
          if (position < end) {
            progress(position - start, name5);
            break;
          } else {
            progress(end - start, name5);
            index += 1;
          }
        }
      };
    };
  }
});

// node_modules/ipfs-http-client/esm/src/add.js
function createAdd5(options) {
  const all6 = createAddAll2(options);
  return configure(() => {
    async function add(input, options2 = {}) {
      return await (0, import_it_last5.default)(all6(input, options2));
    }
    return add;
  })(options);
}
var import_it_last5;
var init_add5 = __esm({
  "node_modules/ipfs-http-client/esm/src/add.js"() {
    init_node_globals();
    init_add_all2();
    import_it_last5 = __toModule(require_it_last());
    init_configure();
  }
});

// node_modules/ipfs-http-client/esm/src/cat.js
var createCat;
var init_cat = __esm({
  "node_modules/ipfs-http-client/esm/src/cat.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createCat = configure((api) => {
      async function* cat(path, options = {}) {
        const res = await api.post("cat", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path.toString(),
            ...options
          }),
          headers: options.headers
        });
        yield* res.iterator();
      }
      return cat;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/commands.js
var createCommands;
var init_commands = __esm({
  "node_modules/ipfs-http-client/esm/src/commands.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createCommands = configure((api) => {
      const commands = async (options = {}) => {
        const res = await api.post("commands", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return res.json();
      };
      return commands;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/dns.js
var createDns;
var init_dns = __esm({
  "node_modules/ipfs-http-client/esm/src/dns.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createDns = configure((api) => {
      const dns = async (domain, options = {}) => {
        const res = await api.post("dns", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: domain,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        return data.Path;
      };
      return dns;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/get-endpoint-config.js
var createGetEndpointConfig;
var init_get_endpoint_config = __esm({
  "node_modules/ipfs-http-client/esm/src/get-endpoint-config.js"() {
    init_node_globals();
    init_configure();
    createGetEndpointConfig = configure((api) => {
      return () => {
        const url = new URL(api.opts.base || "");
        return {
          host: url.hostname,
          port: url.port,
          protocol: url.protocol,
          pathname: url.pathname,
          "api-path": url.pathname
        };
      };
    });
  }
});

// node_modules/ipfs-http-client/esm/src/get.js
var createGet6;
var init_get6 = __esm({
  "node_modules/ipfs-http-client/esm/src/get.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    createGet6 = configure((api) => {
      async function* get2(path, options = {}) {
        const opts = {
          arg: `${path instanceof Uint8Array ? CID.decode(path) : path}`,
          ...options
        };
        if (opts.compressionLevel) {
          opts["compression-level"] = opts.compressionLevel;
          delete opts.compressionLevel;
        }
        const res = await api.post("get", {
          signal: options.signal,
          searchParams: toUrlSearchParams(opts),
          headers: options.headers
        });
        yield* res.iterator();
      }
      return get2;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/id.js
var import_multiaddr16, createId;
var init_id = __esm({
  "node_modules/ipfs-http-client/esm/src/id.js"() {
    init_node_globals();
    init_object_to_camel();
    import_multiaddr16 = __toModule(require_src());
    init_configure();
    init_to_url_search_params();
    createId = configure((api) => {
      async function id(options = {}) {
        const res = await api.post("id", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: options.peerId ? options.peerId.toString() : void 0,
            ...options
          }),
          headers: options.headers
        });
        const data = await res.json();
        const output = { ...objectToCamel(data) };
        if (output.addresses) {
          output.addresses = output.addresses.map((ma) => new import_multiaddr16.Multiaddr(ma));
        }
        return output;
      }
      return id;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/is-online.js
var createIsOnline;
var init_is_online = __esm({
  "node_modules/ipfs-http-client/esm/src/is-online.js"() {
    init_node_globals();
    init_id();
    createIsOnline = (options) => {
      const id = createId(options);
      async function isOnline(options2 = {}) {
        const res = await id(options2);
        return Boolean(res && res.addresses && res.addresses.length);
      }
      return isOnline;
    };
  }
});

// node_modules/ipfs-http-client/esm/src/ls.js
function typeOf(link) {
  switch (link.Type) {
    case 1:
    case 5:
      return "dir";
    case 2:
      return "file";
    default:
      return "file";
  }
}
var createLs7;
var init_ls7 = __esm({
  "node_modules/ipfs-http-client/esm/src/ls.js"() {
    init_node_globals();
    init_cid();
    init_configure();
    init_to_url_search_params();
    init_stat3();
    createLs7 = configure((api, opts) => {
      async function* ls(path, options = {}) {
        const pathStr = `${path instanceof Uint8Array ? CID.decode(path) : path}`;
        async function mapLink(link) {
          let hash2 = link.Hash;
          if (hash2.includes("/")) {
            const ipfsPath2 = hash2.startsWith("/ipfs/") ? hash2 : `/ipfs/${hash2}`;
            const stats = await createStat3(opts)(ipfsPath2);
            hash2 = stats.cid;
          } else {
            hash2 = CID.parse(hash2);
          }
          const entry = {
            name: link.Name,
            path: pathStr + (link.Name ? `/${link.Name}` : ""),
            size: link.Size,
            cid: hash2,
            type: typeOf(link)
          };
          if (link.Mode) {
            entry.mode = parseInt(link.Mode, 8);
          }
          if (link.Mtime !== void 0 && link.Mtime !== null) {
            entry.mtime = { secs: link.Mtime };
            if (link.MtimeNsecs !== void 0 && link.MtimeNsecs !== null) {
              entry.mtime.nsecs = link.MtimeNsecs;
            }
          }
          return entry;
        }
        const res = await api.post("ls", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: pathStr,
            ...options
          }),
          headers: options.headers
        });
        for await (let result of res.ndjson()) {
          result = result.Objects;
          if (!result) {
            throw new Error("expected .Objects in results");
          }
          result = result[0];
          if (!result) {
            throw new Error("expected one array in results.Objects");
          }
          const links2 = result.Links;
          if (!Array.isArray(links2)) {
            throw new Error("expected one array in results.Objects[0].Links");
          }
          if (!links2.length) {
            yield mapLink(result);
            return;
          }
          yield* links2.map(mapLink);
        }
      }
      return ls;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/mount.js
var createMount;
var init_mount2 = __esm({
  "node_modules/ipfs-http-client/esm/src/mount.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createMount = configure((api) => {
      async function mount(options = {}) {
        const res = await api.post("dns", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return objectToCamel(await res.json());
      }
      return mount;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/ping.js
var createPing;
var init_ping = __esm({
  "node_modules/ipfs-http-client/esm/src/ping.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createPing = configure((api) => {
      async function* ping(peerId, options = {}) {
        const res = await api.post("ping", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: `${peerId}`,
            ...options
          }),
          headers: options.headers,
          transform: objectToCamel
        });
        yield* res.ndjson();
      }
      return ping;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/resolve.js
var createResolve3;
var init_resolve4 = __esm({
  "node_modules/ipfs-http-client/esm/src/resolve.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createResolve3 = configure((api) => {
      async function resolve6(path, options = {}) {
        const res = await api.post("resolve", {
          signal: options.signal,
          searchParams: toUrlSearchParams({
            arg: path,
            ...options
          }),
          headers: options.headers
        });
        const { Path } = await res.json();
        return Path;
      }
      return resolve6;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/start.js
var import_err_code35, createStart;
var init_start = __esm({
  "node_modules/ipfs-http-client/esm/src/start.js"() {
    init_node_globals();
    init_configure();
    import_err_code35 = __toModule(require_err_code());
    createStart = configure((api) => {
      const start = async (options = {}) => {
        throw (0, import_err_code35.default)(new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
      };
      return start;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/stop.js
var createStop;
var init_stop = __esm({
  "node_modules/ipfs-http-client/esm/src/stop.js"() {
    init_node_globals();
    init_configure();
    init_to_url_search_params();
    createStop = configure((api) => {
      async function stop(options = {}) {
        const res = await api.post("shutdown", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        await res.text();
      }
      return stop;
    });
  }
});

// node_modules/ipfs-http-client/esm/src/version.js
var createVersion2;
var init_version4 = __esm({
  "node_modules/ipfs-http-client/esm/src/version.js"() {
    init_node_globals();
    init_object_to_camel();
    init_configure();
    init_to_url_search_params();
    createVersion2 = configure((api) => {
      async function version3(options = {}) {
        const res = await api.post("version", {
          signal: options.signal,
          searchParams: toUrlSearchParams(options),
          headers: options.headers
        });
        return {
          ...objectToCamel(await res.json()),
          "ipfs-http-client": "1.0.0"
        };
      }
      return version3;
    });
  }
});

// (disabled):node_modules/ipfs-utils/src/files/glob-source.js
var require_glob_source = __commonJS({
  "(disabled):node_modules/ipfs-utils/src/files/glob-source.js"() {
    init_node_globals();
  }
});

// node_modules/ipfs-utils/src/files/url-source.js
var require_url_source = __commonJS({
  "node_modules/ipfs-utils/src/files/url-source.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var HTTP4 = require_http();
    var urlSource = (url, options) => {
      return {
        path: decodeURIComponent(new URL(url).pathname.split("/").pop() || ""),
        content: readURLContent(url, options)
      };
    };
    async function* readURLContent(url, options) {
      const http = new HTTP4();
      const response = await http.get(url, options);
      yield* response.iterator();
    }
    module2.exports = urlSource;
  }
});

// node_modules/ipfs-http-client/esm/src/index.js
var src_exports7 = {};
__export(src_exports7, {
  CID: () => CID,
  create: () => create6,
  globSource: () => globSource,
  multiaddr: () => import_multiaddr17.Multiaddr,
  urlSource: () => import_url_source.default
});
function create6(options = {}) {
  const id = {
    name: identity.name,
    code: identity.code,
    encode: (id2) => id2,
    decode: (id2) => id2
  };
  const multibaseCodecs = Object.values(bases);
  (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base3) => multibaseCodecs.push(base3));
  const multibases = new Multibases({
    bases: multibaseCodecs,
    loadBase: options.ipld && options.ipld.loadBase
  });
  const blockCodecs = Object.values(codecs);
  [
    src_exports2,
    esm_exports,
    id
  ].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
  const multicodecs = new Multicodecs({
    codecs: blockCodecs,
    loadCodec: options.ipld && options.ipld.loadCodec
  });
  const multihashHashers = Object.values(hashes);
  (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
  const multihashes = new Multihashes({
    hashers: multihashHashers,
    loadHasher: options.ipld && options.ipld.loadHasher
  });
  const client = {
    add: createAdd5(options),
    addAll: createAddAll2(options),
    bitswap: createBitswap(options),
    block: createBlock(options),
    bootstrap: createBootstrap(options),
    cat: createCat(options),
    commands: createCommands(options),
    config: createConfig(options),
    dag: createDag(multicodecs, options),
    dht: createDht(options),
    diag: createDiag(options),
    dns: createDns(options),
    files: createFiles(options),
    get: createGet6(options),
    getEndpointConfig: createGetEndpointConfig(options),
    id: createId(options),
    isOnline: createIsOnline(options),
    key: createKey(options),
    log: createLog(options),
    ls: createLs7(options),
    mount: createMount(options),
    name: createName(options),
    object: createObject(multicodecs, options),
    pin: createPin(options),
    ping: createPing(options),
    pubsub: createPubsub2(options),
    refs: createRefs(options),
    repo: createRepo3(options),
    resolve: createResolve3(options),
    start: createStart(options),
    stats: createStats(options),
    stop: createStop(options),
    swarm: createSwarm(options),
    version: createVersion2(options),
    bases: multibases,
    codecs: multicodecs,
    hashers: multihashes
  };
  return client;
}
var import_glob_source, import_multiaddr17, import_url_source, globSource;
var init_src14 = __esm({
  "node_modules/ipfs-http-client/esm/src/index.js"() {
    init_node_globals();
    init_multibases();
    init_multicodecs();
    init_multihashes();
    init_src2();
    init_esm();
    init_identity();
    init_basics();
    init_bitswap();
    init_block2();
    init_bootstrap();
    init_config2();
    init_dag();
    init_dht();
    init_diag();
    init_files();
    init_key2();
    init_log();
    init_name();
    init_object();
    init_pin2();
    init_pubsub2();
    init_refs();
    init_repo();
    init_stats();
    init_swarm();
    init_add5();
    init_add_all2();
    init_cat();
    init_commands();
    init_dns();
    init_get_endpoint_config();
    init_get6();
    init_id();
    init_is_online();
    init_ls7();
    init_mount2();
    init_ping();
    init_resolve4();
    init_start();
    init_stop();
    init_version4();
    import_glob_source = __toModule(require_glob_source());
    init_cid();
    import_multiaddr17 = __toModule(require_src());
    import_url_source = __toModule(require_url_source());
    globSource = import_glob_source.default;
  }
});

// (disabled):node_modules/ws/browser.js
var require_browser8 = __commonJS({
  "(disabled):node_modules/ws/browser.js"() {
    init_node_globals();
  }
});

// node_modules/it-ws/web-socket.js
var require_web_socket = __commonJS({
  "node_modules/it-ws/web-socket.js"(exports2, module2) {
    init_node_globals();
    module2.exports = typeof WebSocket === "undefined" ? require_browser8() : WebSocket;
  }
});

// node_modules/event-iterator/lib/event-iterator.js
var require_event_iterator = __commonJS({
  "node_modules/event-iterator/lib/event-iterator.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var EventQueue = class {
      constructor() {
        this.pullQueue = [];
        this.pushQueue = [];
        this.eventHandlers = {};
        this.isPaused = false;
        this.isStopped = false;
      }
      push(value) {
        if (this.isStopped)
          return;
        const resolution = { value, done: false };
        if (this.pullQueue.length) {
          const placeholder = this.pullQueue.shift();
          if (placeholder)
            placeholder.resolve(resolution);
        } else {
          this.pushQueue.push(Promise.resolve(resolution));
          if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
            this.isPaused = true;
            if (this.eventHandlers.highWater) {
              this.eventHandlers.highWater();
            } else if (console) {
              console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
            }
          }
        }
      }
      stop() {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        for (const placeholder of this.pullQueue) {
          placeholder.resolve({ value: void 0, done: true });
        }
        this.pullQueue.length = 0;
      }
      fail(error) {
        if (this.isStopped)
          return;
        this.isStopped = true;
        this.remove();
        if (this.pullQueue.length) {
          for (const placeholder of this.pullQueue) {
            placeholder.reject(error);
          }
          this.pullQueue.length = 0;
        } else {
          const rejection = Promise.reject(error);
          rejection.catch(() => {
          });
          this.pushQueue.push(rejection);
        }
      }
      remove() {
        Promise.resolve().then(() => {
          if (this.removeCallback)
            this.removeCallback();
        });
      }
      [Symbol.asyncIterator]() {
        return {
          next: (value) => {
            const result = this.pushQueue.shift();
            if (result) {
              if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
                this.isPaused = false;
                if (this.eventHandlers.lowWater) {
                  this.eventHandlers.lowWater();
                }
              }
              return result;
            } else if (this.isStopped) {
              return Promise.resolve({ value: void 0, done: true });
            } else {
              return new Promise((resolve6, reject) => {
                this.pullQueue.push({ resolve: resolve6, reject });
              });
            }
          },
          return: () => {
            this.isStopped = true;
            this.pushQueue.length = 0;
            this.remove();
            return Promise.resolve({ value: void 0, done: true });
          }
        };
      }
    };
    var EventIterator = class {
      constructor(listen, { highWaterMark = 100, lowWaterMark = 1 } = {}) {
        const queue = new EventQueue();
        queue.highWaterMark = highWaterMark;
        queue.lowWaterMark = lowWaterMark;
        queue.removeCallback = listen({
          push: (value) => queue.push(value),
          stop: () => queue.stop(),
          fail: (error) => queue.fail(error),
          on: (event, fn) => {
            queue.eventHandlers[event] = fn;
          }
        }) || (() => {
        });
        this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
        Object.freeze(this);
      }
    };
    exports2.EventIterator = EventIterator;
    exports2.default = EventIterator;
  }
});

// node_modules/event-iterator/lib/dom.js
var require_dom = __commonJS({
  "node_modules/event-iterator/lib/dom.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var event_iterator_1 = require_event_iterator();
    exports2.EventIterator = event_iterator_1.EventIterator;
    function subscribe(event, options, evOptions) {
      return new event_iterator_1.EventIterator(({ push }) => {
        this.addEventListener(event, push, options);
        return () => this.removeEventListener(event, push, options);
      }, evOptions);
    }
    exports2.subscribe = subscribe;
    exports2.default = event_iterator_1.EventIterator;
  }
});

// node_modules/it-ws/source.js
var require_source2 = __commonJS({
  "node_modules/it-ws/source.js"(exports2, module2) {
    init_node_globals();
    var { Buffer: Buffer2 } = require_buffer();
    var { EventIterator } = require_dom();
    function isArrayBuffer(obj) {
      return obj instanceof ArrayBuffer || obj != null && obj.constructor != null && obj.constructor.name === "ArrayBuffer" && typeof obj.byteLength === "number";
    }
    module2.exports = (socket) => {
      const removeListener = socket.removeEventListener || socket.removeListener;
      const source = async function* () {
        const messages = new EventIterator(({ push, stop, fail }) => {
          socket.addEventListener("message", push);
          socket.addEventListener("error", fail);
          socket.addEventListener("close", stop);
          return () => {
            removeListener.call(socket, "message", push);
            removeListener.call(socket, "error", fail);
            removeListener.call(socket, "close", stop);
          };
        }, { highWaterMark: Infinity });
        for await (const { data } of messages) {
          yield isArrayBuffer(data) ? Buffer2.from(data) : data;
        }
      }();
      let connected = socket.readyState === 1;
      let connError;
      socket.addEventListener("open", () => {
        connected = true;
        connError = null;
      });
      socket.addEventListener("close", () => {
        connected = false;
        connError = null;
      });
      socket.addEventListener("error", (err) => {
        if (!connected)
          connError = err;
      });
      source.connected = () => new Promise((resolve6, reject) => {
        if (connected)
          return resolve6();
        if (connError)
          return reject(connError);
        const cleanUp = (cont) => {
          removeListener.call(socket, "open", onOpen);
          removeListener.call(socket, "error", onError);
          cont();
        };
        const onOpen = () => cleanUp(resolve6);
        const onError = (err) => cleanUp(() => reject(err));
        socket.addEventListener("open", onOpen);
        socket.addEventListener("error", onError);
      });
      return source;
    };
  }
});

// node_modules/it-ws/ready.js
var require_ready = __commonJS({
  "node_modules/it-ws/ready.js"(exports2, module2) {
    init_node_globals();
    module2.exports = async (socket) => {
      if (socket.readyState >= 2) {
        throw new Error("socket closed");
      }
      if (socket.readyState === 1) {
        return;
      }
      return new Promise((resolve6, reject) => {
        const remove = socket && (socket.removeEventListener || socket.removeListener);
        function cleanup() {
          if (typeof remove === "function") {
            remove.call(socket, "open", handleOpen);
            remove.call(socket, "error", handleErr);
          }
        }
        function handleOpen() {
          cleanup();
          resolve6();
        }
        function handleErr(evt) {
          cleanup();
          reject(evt);
        }
        socket.addEventListener("open", handleOpen);
        socket.addEventListener("error", handleErr);
      });
    };
  }
});

// node_modules/it-ws/sink.js
var require_sink = __commonJS({
  "node_modules/it-ws/sink.js"(exports2, module2) {
    init_node_globals();
    var ready = require_ready();
    module2.exports = (socket, options) => {
      options = options || {};
      options.closeOnEnd = options.closeOnEnd !== false;
      return async (source) => {
        for await (const data of source) {
          try {
            await ready(socket);
          } catch (err) {
            if (err.message === "socket closed")
              break;
            throw err;
          }
          socket.send(data);
        }
        if (options.closeOnEnd && socket.readyState <= 1) {
          return new Promise((resolve6, reject) => {
            socket.addEventListener("close", (event) => {
              if (event.wasClean || event.code === 1006) {
                resolve6();
              } else {
                const err = Object.assign(new Error("ws error"), { event });
                reject(err);
              }
            });
            setTimeout(() => socket.close());
          });
        }
      };
    };
  }
});

// node_modules/it-ws/duplex.js
var require_duplex = __commonJS({
  "node_modules/it-ws/duplex.js"(exports2, module2) {
    init_node_globals();
    var source = require_source2();
    var sink = require_sink();
    module2.exports = (socket, options) => {
      options = options || {};
      if (options.binaryType) {
        socket.binaryType = options.binaryType;
      } else if (options.binary) {
        socket.binaryType = "arraybuffer";
      }
      const duplex = {
        sink: sink(socket, options),
        source: source(socket, options),
        connected: () => duplex.source.connected()
      };
      return duplex;
    };
  }
});

// node_modules/it-ws/ws-url.js
var require_ws_url = __commonJS({
  "node_modules/it-ws/ws-url.js"(exports2, module2) {
    init_node_globals();
    var { relative } = require_iso_url();
    var map8 = { http: "ws", https: "wss" };
    var def = "ws";
    module2.exports = (url, location2) => relative(url, location2, map8, def);
  }
});

// node_modules/it-ws/client.js
var require_client = __commonJS({
  "node_modules/it-ws/client.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var WebSocket2 = require_web_socket();
    var duplex = require_duplex();
    var wsurl = require_ws_url();
    module2.exports = function(addr, opts = {}) {
      const location2 = typeof window === "undefined" ? {} : window.location;
      const url = wsurl(addr, location2);
      const socket = new WebSocket2(url, opts.websocket);
      const stream = duplex(socket, opts);
      stream.remoteAddress = url;
      stream.close = () => new Promise((resolve6, reject) => {
        socket.addEventListener("close", resolve6);
        socket.close();
      });
      stream.destroy = () => {
        if (socket.terminate) {
          socket.terminate();
        } else {
          socket.close();
        }
      };
      stream.socket = socket;
      return stream;
    };
    module2.exports.connect = module2.exports;
  }
});

// node_modules/libp2p-websockets/src/listener.browser.js
var require_listener_browser = __commonJS({
  "node_modules/libp2p-websockets/src/listener.browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = function() {
      throw new Error("WebSocket Servers can not be created in the browser!");
    };
  }
});

// node_modules/libp2p-websockets/src/constants.js
var require_constants5 = __commonJS({
  "node_modules/libp2p-websockets/src/constants.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.CODE_P2P = 421;
    exports2.CODE_CIRCUIT = 290;
    exports2.CODE_TCP = 6;
    exports2.CODE_WS = 477;
    exports2.CODE_WSS = 478;
    exports2.CLOSE_TIMEOUT = 2e3;
  }
});

// node_modules/ip-address/dist/cjs/lib/common.js
var require_common7 = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/common.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isCorrect = exports2.isInSubnet = void 0;
    function isInSubnet(address) {
      if (this.subnetMask < address.subnetMask) {
        return false;
      }
      if (this.mask(address.subnetMask) === address.mask()) {
        return true;
      }
      return false;
    }
    exports2.isInSubnet = isInSubnet;
    function isCorrect(defaultBits) {
      return function() {
        if (this.addressMinusSuffix !== this.correctForm()) {
          return false;
        }
        if (this.subnetMask === defaultBits && !this.parsedSubnet) {
          return true;
        }
        return this.parsedSubnet === String(this.subnetMask);
      };
    }
    exports2.isCorrect = isCorrect;
  }
});

// node_modules/ip-address/dist/cjs/lib/v4/constants.js
var require_constants6 = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/v4/constants.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_SUBNET_STRING = exports2.RE_ADDRESS = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 32;
    exports2.GROUPS = 4;
    exports2.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
    exports2.RE_SUBNET_STRING = /\/\d{1,2}$/;
  }
});

// node_modules/ip-address/dist/cjs/lib/address-error.js
var require_address_error = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/address-error.js"(exports2) {
    init_node_globals();
    "use strict";
    var __extends = exports2 && exports2.__extends || function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2)
            if (Object.prototype.hasOwnProperty.call(b2, p))
              d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AddressError = void 0;
    var AddressError = function(_super) {
      __extends(AddressError2, _super);
      function AddressError2(message, parseMessage) {
        var _this = _super.call(this, message) || this;
        _this.name = "AddressError";
        if (parseMessage !== null) {
          _this.parseMessage = parseMessage;
        }
        return _this;
      }
      return AddressError2;
    }(Error);
    exports2.AddressError = AddressError;
  }
});

// node_modules/jsbn/index.js
var require_jsbn2 = __commonJS({
  "node_modules/jsbn/index.js"(exports2, module2) {
    init_node_globals();
    (function() {
      var dbits;
      var canary = 244837814094590;
      var j_lm = (canary & 16777215) == 15715070;
      function BigInteger(a, b, c) {
        if (a != null)
          if (typeof a == "number")
            this.fromNumber(a, b, c);
          else if (b == null && typeof a != "string")
            this.fromString(a, 256);
          else
            this.fromString(a, b);
      }
      function nbi() {
        return new BigInteger(null);
      }
      function am1(i, x, w, j, c, n) {
        while (--n >= 0) {
          var v = x * this[i++] + w[j] + c;
          c = Math.floor(v / 67108864);
          w[j++] = v & 67108863;
        }
        return c;
      }
      function am2(i, x, w, j, c, n) {
        var xl = x & 32767, xh = x >> 15;
        while (--n >= 0) {
          var l = this[i] & 32767;
          var h = this[i++] >> 15;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
          c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
          w[j++] = l & 1073741823;
        }
        return c;
      }
      function am3(i, x, w, j, c, n) {
        var xl = x & 16383, xh = x >> 14;
        while (--n >= 0) {
          var l = this[i] & 16383;
          var h = this[i++] >> 14;
          var m = xh * l + h * xl;
          l = xl * l + ((m & 16383) << 14) + w[j] + c;
          c = (l >> 28) + (m >> 14) + xh * h;
          w[j++] = l & 268435455;
        }
        return c;
      }
      var inBrowser = typeof navigator !== "undefined";
      if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
        BigInteger.prototype.am = am2;
        dbits = 30;
      } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
        BigInteger.prototype.am = am1;
        dbits = 26;
      } else {
        BigInteger.prototype.am = am3;
        dbits = 28;
      }
      BigInteger.prototype.DB = dbits;
      BigInteger.prototype.DM = (1 << dbits) - 1;
      BigInteger.prototype.DV = 1 << dbits;
      var BI_FP = 52;
      BigInteger.prototype.FV = Math.pow(2, BI_FP);
      BigInteger.prototype.F1 = BI_FP - dbits;
      BigInteger.prototype.F2 = 2 * dbits - BI_FP;
      var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
      var BI_RC = new Array();
      var rr, vv;
      rr = "0".charCodeAt(0);
      for (vv = 0; vv <= 9; ++vv)
        BI_RC[rr++] = vv;
      rr = "a".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      rr = "A".charCodeAt(0);
      for (vv = 10; vv < 36; ++vv)
        BI_RC[rr++] = vv;
      function int2char(n) {
        return BI_RM.charAt(n);
      }
      function intAt(s, i) {
        var c = BI_RC[s.charCodeAt(i)];
        return c == null ? -1 : c;
      }
      function bnpCopyTo(r) {
        for (var i = this.t - 1; i >= 0; --i)
          r[i] = this[i];
        r.t = this.t;
        r.s = this.s;
      }
      function bnpFromInt(x) {
        this.t = 1;
        this.s = x < 0 ? -1 : 0;
        if (x > 0)
          this[0] = x;
        else if (x < -1)
          this[0] = x + this.DV;
        else
          this.t = 0;
      }
      function nbv(i) {
        var r = nbi();
        r.fromInt(i);
        return r;
      }
      function bnpFromString(s, b) {
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 256)
          k = 8;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else {
          this.fromRadix(s, b);
          return;
        }
        this.t = 0;
        this.s = 0;
        var i = s.length, mi = false, sh = 0;
        while (--i >= 0) {
          var x = k == 8 ? s[i] & 255 : intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-")
              mi = true;
            continue;
          }
          mi = false;
          if (sh == 0)
            this[this.t++] = x;
          else if (sh + k > this.DB) {
            this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
            this[this.t++] = x >> this.DB - sh;
          } else
            this[this.t - 1] |= x << sh;
          sh += k;
          if (sh >= this.DB)
            sh -= this.DB;
        }
        if (k == 8 && (s[0] & 128) != 0) {
          this.s = -1;
          if (sh > 0)
            this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
        }
        this.clamp();
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpClamp() {
        var c = this.s & this.DM;
        while (this.t > 0 && this[this.t - 1] == c)
          --this.t;
      }
      function bnToString(b) {
        if (this.s < 0)
          return "-" + this.negate().toString(b);
        var k;
        if (b == 16)
          k = 4;
        else if (b == 8)
          k = 3;
        else if (b == 2)
          k = 1;
        else if (b == 32)
          k = 5;
        else if (b == 4)
          k = 2;
        else
          return this.toRadix(b);
        var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
        var p = this.DB - i * this.DB % k;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) > 0) {
            m = true;
            r = int2char(d);
          }
          while (i >= 0) {
            if (p < k) {
              d = (this[i] & (1 << p) - 1) << k - p;
              d |= this[--i] >> (p += this.DB - k);
            } else {
              d = this[i] >> (p -= k) & km;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if (d > 0)
              m = true;
            if (m)
              r += int2char(d);
          }
        }
        return m ? r : "0";
      }
      function bnNegate() {
        var r = nbi();
        BigInteger.ZERO.subTo(this, r);
        return r;
      }
      function bnAbs() {
        return this.s < 0 ? this.negate() : this;
      }
      function bnCompareTo(a) {
        var r = this.s - a.s;
        if (r != 0)
          return r;
        var i = this.t;
        r = i - a.t;
        if (r != 0)
          return this.s < 0 ? -r : r;
        while (--i >= 0)
          if ((r = this[i] - a[i]) != 0)
            return r;
        return 0;
      }
      function nbits(x) {
        var r = 1, t2;
        if ((t2 = x >>> 16) != 0) {
          x = t2;
          r += 16;
        }
        if ((t2 = x >> 8) != 0) {
          x = t2;
          r += 8;
        }
        if ((t2 = x >> 4) != 0) {
          x = t2;
          r += 4;
        }
        if ((t2 = x >> 2) != 0) {
          x = t2;
          r += 2;
        }
        if ((t2 = x >> 1) != 0) {
          x = t2;
          r += 1;
        }
        return r;
      }
      function bnBitLength() {
        if (this.t <= 0)
          return 0;
        return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
      }
      function bnpDLShiftTo(n, r) {
        var i;
        for (i = this.t - 1; i >= 0; --i)
          r[i + n] = this[i];
        for (i = n - 1; i >= 0; --i)
          r[i] = 0;
        r.t = this.t + n;
        r.s = this.s;
      }
      function bnpDRShiftTo(n, r) {
        for (var i = n; i < this.t; ++i)
          r[i - n] = this[i];
        r.t = Math.max(this.t - n, 0);
        r.s = this.s;
      }
      function bnpLShiftTo(n, r) {
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << cbs) - 1;
        var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
        for (i = this.t - 1; i >= 0; --i) {
          r[i + ds + 1] = this[i] >> cbs | c;
          c = (this[i] & bm) << bs;
        }
        for (i = ds - 1; i >= 0; --i)
          r[i] = 0;
        r[ds] = c;
        r.t = this.t + ds + 1;
        r.s = this.s;
        r.clamp();
      }
      function bnpRShiftTo(n, r) {
        r.s = this.s;
        var ds = Math.floor(n / this.DB);
        if (ds >= this.t) {
          r.t = 0;
          return;
        }
        var bs = n % this.DB;
        var cbs = this.DB - bs;
        var bm = (1 << bs) - 1;
        r[0] = this[ds] >> bs;
        for (var i = ds + 1; i < this.t; ++i) {
          r[i - ds - 1] |= (this[i] & bm) << cbs;
          r[i - ds] = this[i] >> bs;
        }
        if (bs > 0)
          r[this.t - ds - 1] |= (this.s & bm) << cbs;
        r.t = this.t - ds;
        r.clamp();
      }
      function bnpSubTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] - a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c -= a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c -= a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c -= a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c < -1)
          r[i++] = this.DV + c;
        else if (c > 0)
          r[i++] = c;
        r.t = i;
        r.clamp();
      }
      function bnpMultiplyTo(a, r) {
        var x = this.abs(), y = a.abs();
        var i = x.t;
        r.t = i + y.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < y.t; ++i)
          r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
        r.s = 0;
        r.clamp();
        if (this.s != a.s)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnpSquareTo(r) {
        var x = this.abs();
        var i = r.t = 2 * x.t;
        while (--i >= 0)
          r[i] = 0;
        for (i = 0; i < x.t - 1; ++i) {
          var c = x.am(i, x[i], r, 2 * i, 0, 1);
          if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
            r[i + x.t] -= x.DV;
            r[i + x.t + 1] = 1;
          }
        }
        if (r.t > 0)
          r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
        r.s = 0;
        r.clamp();
      }
      function bnpDivRemTo(m, q, r) {
        var pm = m.abs();
        if (pm.t <= 0)
          return;
        var pt = this.abs();
        if (pt.t < pm.t) {
          if (q != null)
            q.fromInt(0);
          if (r != null)
            this.copyTo(r);
          return;
        }
        if (r == null)
          r = nbi();
        var y = nbi(), ts = this.s, ms = m.s;
        var nsh = this.DB - nbits(pm[pm.t - 1]);
        if (nsh > 0) {
          pm.lShiftTo(nsh, y);
          pt.lShiftTo(nsh, r);
        } else {
          pm.copyTo(y);
          pt.copyTo(r);
        }
        var ys = y.t;
        var y0 = y[ys - 1];
        if (y0 == 0)
          return;
        var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
        var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
        var i = r.t, j = i - ys, t2 = q == null ? nbi() : q;
        y.dlShiftTo(j, t2);
        if (r.compareTo(t2) >= 0) {
          r[r.t++] = 1;
          r.subTo(t2, r);
        }
        BigInteger.ONE.dlShiftTo(ys, t2);
        t2.subTo(y, y);
        while (y.t < ys)
          y[y.t++] = 0;
        while (--j >= 0) {
          var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
          if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
            y.dlShiftTo(j, t2);
            r.subTo(t2, r);
            while (r[i] < --qd)
              r.subTo(t2, r);
          }
        }
        if (q != null) {
          r.drShiftTo(ys, q);
          if (ts != ms)
            BigInteger.ZERO.subTo(q, q);
        }
        r.t = ys;
        r.clamp();
        if (nsh > 0)
          r.rShiftTo(nsh, r);
        if (ts < 0)
          BigInteger.ZERO.subTo(r, r);
      }
      function bnMod(a) {
        var r = nbi();
        this.abs().divRemTo(a, null, r);
        if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          a.subTo(r, r);
        return r;
      }
      function Classic(m) {
        this.m = m;
      }
      function cConvert(x) {
        if (x.s < 0 || x.compareTo(this.m) >= 0)
          return x.mod(this.m);
        else
          return x;
      }
      function cRevert(x) {
        return x;
      }
      function cReduce(x) {
        x.divRemTo(this.m, null, x);
      }
      function cMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      function cSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      Classic.prototype.convert = cConvert;
      Classic.prototype.revert = cRevert;
      Classic.prototype.reduce = cReduce;
      Classic.prototype.mulTo = cMulTo;
      Classic.prototype.sqrTo = cSqrTo;
      function bnpInvDigit() {
        if (this.t < 1)
          return 0;
        var x = this[0];
        if ((x & 1) == 0)
          return 0;
        var y = x & 3;
        y = y * (2 - (x & 15) * y) & 15;
        y = y * (2 - (x & 255) * y) & 255;
        y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
        y = y * (2 - x * y % this.DV) % this.DV;
        return y > 0 ? this.DV - y : -y;
      }
      function Montgomery(m) {
        this.m = m;
        this.mp = m.invDigit();
        this.mpl = this.mp & 32767;
        this.mph = this.mp >> 15;
        this.um = (1 << m.DB - 15) - 1;
        this.mt2 = 2 * m.t;
      }
      function montConvert(x) {
        var r = nbi();
        x.abs().dlShiftTo(this.m.t, r);
        r.divRemTo(this.m, null, r);
        if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
          this.m.subTo(r, r);
        return r;
      }
      function montRevert(x) {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
      function montReduce(x) {
        while (x.t <= this.mt2)
          x[x.t++] = 0;
        for (var i = 0; i < this.m.t; ++i) {
          var j = x[i] & 32767;
          var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
          j = i + this.m.t;
          x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
          while (x[j] >= x.DV) {
            x[j] -= x.DV;
            x[++j]++;
          }
        }
        x.clamp();
        x.drShiftTo(this.m.t, x);
        if (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function montSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function montMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Montgomery.prototype.convert = montConvert;
      Montgomery.prototype.revert = montRevert;
      Montgomery.prototype.reduce = montReduce;
      Montgomery.prototype.mulTo = montMulTo;
      Montgomery.prototype.sqrTo = montSqrTo;
      function bnpIsEven() {
        return (this.t > 0 ? this[0] & 1 : this.s) == 0;
      }
      function bnpExp(e, z2) {
        if (e > 4294967295 || e < 1)
          return BigInteger.ONE;
        var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
        g.copyTo(r);
        while (--i >= 0) {
          z2.sqrTo(r, r2);
          if ((e & 1 << i) > 0)
            z2.mulTo(r2, g, r);
          else {
            var t2 = r;
            r = r2;
            r2 = t2;
          }
        }
        return z2.revert(r);
      }
      function bnModPowInt(e, m) {
        var z2;
        if (e < 256 || m.isEven())
          z2 = new Classic(m);
        else
          z2 = new Montgomery(m);
        return this.exp(e, z2);
      }
      BigInteger.prototype.copyTo = bnpCopyTo;
      BigInteger.prototype.fromInt = bnpFromInt;
      BigInteger.prototype.fromString = bnpFromString;
      BigInteger.prototype.clamp = bnpClamp;
      BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
      BigInteger.prototype.drShiftTo = bnpDRShiftTo;
      BigInteger.prototype.lShiftTo = bnpLShiftTo;
      BigInteger.prototype.rShiftTo = bnpRShiftTo;
      BigInteger.prototype.subTo = bnpSubTo;
      BigInteger.prototype.multiplyTo = bnpMultiplyTo;
      BigInteger.prototype.squareTo = bnpSquareTo;
      BigInteger.prototype.divRemTo = bnpDivRemTo;
      BigInteger.prototype.invDigit = bnpInvDigit;
      BigInteger.prototype.isEven = bnpIsEven;
      BigInteger.prototype.exp = bnpExp;
      BigInteger.prototype.toString = bnToString;
      BigInteger.prototype.negate = bnNegate;
      BigInteger.prototype.abs = bnAbs;
      BigInteger.prototype.compareTo = bnCompareTo;
      BigInteger.prototype.bitLength = bnBitLength;
      BigInteger.prototype.mod = bnMod;
      BigInteger.prototype.modPowInt = bnModPowInt;
      BigInteger.ZERO = nbv(0);
      BigInteger.ONE = nbv(1);
      function bnClone() {
        var r = nbi();
        this.copyTo(r);
        return r;
      }
      function bnIntValue() {
        if (this.s < 0) {
          if (this.t == 1)
            return this[0] - this.DV;
          else if (this.t == 0)
            return -1;
        } else if (this.t == 1)
          return this[0];
        else if (this.t == 0)
          return 0;
        return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
      }
      function bnByteValue() {
        return this.t == 0 ? this.s : this[0] << 24 >> 24;
      }
      function bnShortValue() {
        return this.t == 0 ? this.s : this[0] << 16 >> 16;
      }
      function bnpChunkSize(r) {
        return Math.floor(Math.LN2 * this.DB / Math.log(r));
      }
      function bnSigNum() {
        if (this.s < 0)
          return -1;
        else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
          return 0;
        else
          return 1;
      }
      function bnpToRadix(b) {
        if (b == null)
          b = 10;
        if (this.signum() == 0 || b < 2 || b > 36)
          return "0";
        var cs = this.chunkSize(b);
        var a = Math.pow(b, cs);
        var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
        this.divRemTo(d, y, z2);
        while (y.signum() > 0) {
          r = (a + z2.intValue()).toString(b).substr(1) + r;
          y.divRemTo(d, y, z2);
        }
        return z2.intValue().toString(b) + r;
      }
      function bnpFromRadix(s, b) {
        this.fromInt(0);
        if (b == null)
          b = 10;
        var cs = this.chunkSize(b);
        var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
        for (var i = 0; i < s.length; ++i) {
          var x = intAt(s, i);
          if (x < 0) {
            if (s.charAt(i) == "-" && this.signum() == 0)
              mi = true;
            continue;
          }
          w = b * w + x;
          if (++j >= cs) {
            this.dMultiply(d);
            this.dAddOffset(w, 0);
            j = 0;
            w = 0;
          }
        }
        if (j > 0) {
          this.dMultiply(Math.pow(b, j));
          this.dAddOffset(w, 0);
        }
        if (mi)
          BigInteger.ZERO.subTo(this, this);
      }
      function bnpFromNumber(a, b, c) {
        if (typeof b == "number") {
          if (a < 2)
            this.fromInt(1);
          else {
            this.fromNumber(a, c);
            if (!this.testBit(a - 1))
              this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
            if (this.isEven())
              this.dAddOffset(1, 0);
            while (!this.isProbablePrime(b)) {
              this.dAddOffset(2, 0);
              if (this.bitLength() > a)
                this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
            }
          }
        } else {
          var x = new Array(), t2 = a & 7;
          x.length = (a >> 3) + 1;
          b.nextBytes(x);
          if (t2 > 0)
            x[0] &= (1 << t2) - 1;
          else
            x[0] = 0;
          this.fromString(x, 256);
        }
      }
      function bnToByteArray() {
        var i = this.t, r = new Array();
        r[0] = this.s;
        var p = this.DB - i * this.DB % 8, d, k = 0;
        if (i-- > 0) {
          if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
            r[k++] = d | this.s << this.DB - p;
          while (i >= 0) {
            if (p < 8) {
              d = (this[i] & (1 << p) - 1) << 8 - p;
              d |= this[--i] >> (p += this.DB - 8);
            } else {
              d = this[i] >> (p -= 8) & 255;
              if (p <= 0) {
                p += this.DB;
                --i;
              }
            }
            if ((d & 128) != 0)
              d |= -256;
            if (k == 0 && (this.s & 128) != (d & 128))
              ++k;
            if (k > 0 || d != this.s)
              r[k++] = d;
          }
        }
        return r;
      }
      function bnEquals(a) {
        return this.compareTo(a) == 0;
      }
      function bnMin(a) {
        return this.compareTo(a) < 0 ? this : a;
      }
      function bnMax(a) {
        return this.compareTo(a) > 0 ? this : a;
      }
      function bnpBitwiseTo(a, op, r) {
        var i, f, m = Math.min(a.t, this.t);
        for (i = 0; i < m; ++i)
          r[i] = op(this[i], a[i]);
        if (a.t < this.t) {
          f = a.s & this.DM;
          for (i = m; i < this.t; ++i)
            r[i] = op(this[i], f);
          r.t = this.t;
        } else {
          f = this.s & this.DM;
          for (i = m; i < a.t; ++i)
            r[i] = op(f, a[i]);
          r.t = a.t;
        }
        r.s = op(this.s, a.s);
        r.clamp();
      }
      function op_and(x, y) {
        return x & y;
      }
      function bnAnd(a) {
        var r = nbi();
        this.bitwiseTo(a, op_and, r);
        return r;
      }
      function op_or(x, y) {
        return x | y;
      }
      function bnOr(a) {
        var r = nbi();
        this.bitwiseTo(a, op_or, r);
        return r;
      }
      function op_xor(x, y) {
        return x ^ y;
      }
      function bnXor(a) {
        var r = nbi();
        this.bitwiseTo(a, op_xor, r);
        return r;
      }
      function op_andnot(x, y) {
        return x & ~y;
      }
      function bnAndNot(a) {
        var r = nbi();
        this.bitwiseTo(a, op_andnot, r);
        return r;
      }
      function bnNot() {
        var r = nbi();
        for (var i = 0; i < this.t; ++i)
          r[i] = this.DM & ~this[i];
        r.t = this.t;
        r.s = ~this.s;
        return r;
      }
      function bnShiftLeft(n) {
        var r = nbi();
        if (n < 0)
          this.rShiftTo(-n, r);
        else
          this.lShiftTo(n, r);
        return r;
      }
      function bnShiftRight(n) {
        var r = nbi();
        if (n < 0)
          this.lShiftTo(-n, r);
        else
          this.rShiftTo(n, r);
        return r;
      }
      function lbit(x) {
        if (x == 0)
          return -1;
        var r = 0;
        if ((x & 65535) == 0) {
          x >>= 16;
          r += 16;
        }
        if ((x & 255) == 0) {
          x >>= 8;
          r += 8;
        }
        if ((x & 15) == 0) {
          x >>= 4;
          r += 4;
        }
        if ((x & 3) == 0) {
          x >>= 2;
          r += 2;
        }
        if ((x & 1) == 0)
          ++r;
        return r;
      }
      function bnGetLowestSetBit() {
        for (var i = 0; i < this.t; ++i)
          if (this[i] != 0)
            return i * this.DB + lbit(this[i]);
        if (this.s < 0)
          return this.t * this.DB;
        return -1;
      }
      function cbit(x) {
        var r = 0;
        while (x != 0) {
          x &= x - 1;
          ++r;
        }
        return r;
      }
      function bnBitCount() {
        var r = 0, x = this.s & this.DM;
        for (var i = 0; i < this.t; ++i)
          r += cbit(this[i] ^ x);
        return r;
      }
      function bnTestBit(n) {
        var j = Math.floor(n / this.DB);
        if (j >= this.t)
          return this.s != 0;
        return (this[j] & 1 << n % this.DB) != 0;
      }
      function bnpChangeBit(n, op) {
        var r = BigInteger.ONE.shiftLeft(n);
        this.bitwiseTo(r, op, r);
        return r;
      }
      function bnSetBit(n) {
        return this.changeBit(n, op_or);
      }
      function bnClearBit(n) {
        return this.changeBit(n, op_andnot);
      }
      function bnFlipBit(n) {
        return this.changeBit(n, op_xor);
      }
      function bnpAddTo(a, r) {
        var i = 0, c = 0, m = Math.min(a.t, this.t);
        while (i < m) {
          c += this[i] + a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        if (a.t < this.t) {
          c += a.s;
          while (i < this.t) {
            c += this[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += this.s;
        } else {
          c += this.s;
          while (i < a.t) {
            c += a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          c += a.s;
        }
        r.s = c < 0 ? -1 : 0;
        if (c > 0)
          r[i++] = c;
        else if (c < -1)
          r[i++] = this.DV + c;
        r.t = i;
        r.clamp();
      }
      function bnAdd(a) {
        var r = nbi();
        this.addTo(a, r);
        return r;
      }
      function bnSubtract(a) {
        var r = nbi();
        this.subTo(a, r);
        return r;
      }
      function bnMultiply(a) {
        var r = nbi();
        this.multiplyTo(a, r);
        return r;
      }
      function bnSquare() {
        var r = nbi();
        this.squareTo(r);
        return r;
      }
      function bnDivide(a) {
        var r = nbi();
        this.divRemTo(a, r, null);
        return r;
      }
      function bnRemainder(a) {
        var r = nbi();
        this.divRemTo(a, null, r);
        return r;
      }
      function bnDivideAndRemainder(a) {
        var q = nbi(), r = nbi();
        this.divRemTo(a, q, r);
        return new Array(q, r);
      }
      function bnpDMultiply(n) {
        this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
        ++this.t;
        this.clamp();
      }
      function bnpDAddOffset(n, w) {
        if (n == 0)
          return;
        while (this.t <= w)
          this[this.t++] = 0;
        this[w] += n;
        while (this[w] >= this.DV) {
          this[w] -= this.DV;
          if (++w >= this.t)
            this[this.t++] = 0;
          ++this[w];
        }
      }
      function NullExp() {
      }
      function nNop(x) {
        return x;
      }
      function nMulTo(x, y, r) {
        x.multiplyTo(y, r);
      }
      function nSqrTo(x, r) {
        x.squareTo(r);
      }
      NullExp.prototype.convert = nNop;
      NullExp.prototype.revert = nNop;
      NullExp.prototype.mulTo = nMulTo;
      NullExp.prototype.sqrTo = nSqrTo;
      function bnPow(e) {
        return this.exp(e, new NullExp());
      }
      function bnpMultiplyLowerTo(a, n, r) {
        var i = Math.min(this.t + a.t, n);
        r.s = 0;
        r.t = i;
        while (i > 0)
          r[--i] = 0;
        var j;
        for (j = r.t - this.t; i < j; ++i)
          r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
        for (j = Math.min(a.t, n); i < j; ++i)
          this.am(0, a[i], r, i, 0, n - i);
        r.clamp();
      }
      function bnpMultiplyUpperTo(a, n, r) {
        --n;
        var i = r.t = this.t + a.t - n;
        r.s = 0;
        while (--i >= 0)
          r[i] = 0;
        for (i = Math.max(n - this.t, 0); i < a.t; ++i)
          r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
        r.clamp();
        r.drShiftTo(1, r);
      }
      function Barrett(m) {
        this.r2 = nbi();
        this.q3 = nbi();
        BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
        this.mu = this.r2.divide(m);
        this.m = m;
      }
      function barrettConvert(x) {
        if (x.s < 0 || x.t > 2 * this.m.t)
          return x.mod(this.m);
        else if (x.compareTo(this.m) < 0)
          return x;
        else {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
      }
      function barrettRevert(x) {
        return x;
      }
      function barrettReduce(x) {
        x.drShiftTo(this.m.t - 1, this.r2);
        if (x.t > this.m.t + 1) {
          x.t = this.m.t + 1;
          x.clamp();
        }
        this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
        this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
        while (x.compareTo(this.r2) < 0)
          x.dAddOffset(1, this.m.t + 1);
        x.subTo(this.r2, x);
        while (x.compareTo(this.m) >= 0)
          x.subTo(this.m, x);
      }
      function barrettSqrTo(x, r) {
        x.squareTo(r);
        this.reduce(r);
      }
      function barrettMulTo(x, y, r) {
        x.multiplyTo(y, r);
        this.reduce(r);
      }
      Barrett.prototype.convert = barrettConvert;
      Barrett.prototype.revert = barrettRevert;
      Barrett.prototype.reduce = barrettReduce;
      Barrett.prototype.mulTo = barrettMulTo;
      Barrett.prototype.sqrTo = barrettSqrTo;
      function bnModPow(e, m) {
        var i = e.bitLength(), k, r = nbv(1), z2;
        if (i <= 0)
          return r;
        else if (i < 18)
          k = 1;
        else if (i < 48)
          k = 3;
        else if (i < 144)
          k = 4;
        else if (i < 768)
          k = 5;
        else
          k = 6;
        if (i < 8)
          z2 = new Classic(m);
        else if (m.isEven())
          z2 = new Barrett(m);
        else
          z2 = new Montgomery(m);
        var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
        g[1] = z2.convert(this);
        if (k > 1) {
          var g2 = nbi();
          z2.sqrTo(g[1], g2);
          while (n <= km) {
            g[n] = nbi();
            z2.mulTo(g2, g[n - 2], g[n]);
            n += 2;
          }
        }
        var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
        i = nbits(e[j]) - 1;
        while (j >= 0) {
          if (i >= k1)
            w = e[j] >> i - k1 & km;
          else {
            w = (e[j] & (1 << i + 1) - 1) << k1 - i;
            if (j > 0)
              w |= e[j - 1] >> this.DB + i - k1;
          }
          n = k;
          while ((w & 1) == 0) {
            w >>= 1;
            --n;
          }
          if ((i -= n) < 0) {
            i += this.DB;
            --j;
          }
          if (is1) {
            g[w].copyTo(r);
            is1 = false;
          } else {
            while (n > 1) {
              z2.sqrTo(r, r2);
              z2.sqrTo(r2, r);
              n -= 2;
            }
            if (n > 0)
              z2.sqrTo(r, r2);
            else {
              t2 = r;
              r = r2;
              r2 = t2;
            }
            z2.mulTo(r2, g[w], r);
          }
          while (j >= 0 && (e[j] & 1 << i) == 0) {
            z2.sqrTo(r, r2);
            t2 = r;
            r = r2;
            r2 = t2;
            if (--i < 0) {
              i = this.DB - 1;
              --j;
            }
          }
        }
        return z2.revert(r);
      }
      function bnGCD(a) {
        var x = this.s < 0 ? this.negate() : this.clone();
        var y = a.s < 0 ? a.negate() : a.clone();
        if (x.compareTo(y) < 0) {
          var t2 = x;
          x = y;
          y = t2;
        }
        var i = x.getLowestSetBit(), g = y.getLowestSetBit();
        if (g < 0)
          return x;
        if (i < g)
          g = i;
        if (g > 0) {
          x.rShiftTo(g, x);
          y.rShiftTo(g, y);
        }
        while (x.signum() > 0) {
          if ((i = x.getLowestSetBit()) > 0)
            x.rShiftTo(i, x);
          if ((i = y.getLowestSetBit()) > 0)
            y.rShiftTo(i, y);
          if (x.compareTo(y) >= 0) {
            x.subTo(y, x);
            x.rShiftTo(1, x);
          } else {
            y.subTo(x, y);
            y.rShiftTo(1, y);
          }
        }
        if (g > 0)
          y.lShiftTo(g, y);
        return y;
      }
      function bnpModInt(n) {
        if (n <= 0)
          return 0;
        var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
        if (this.t > 0)
          if (d == 0)
            r = this[0] % n;
          else
            for (var i = this.t - 1; i >= 0; --i)
              r = (d * r + this[i]) % n;
        return r;
      }
      function bnModInverse(m) {
        var ac = m.isEven();
        if (this.isEven() && ac || m.signum() == 0)
          return BigInteger.ZERO;
        var u = m.clone(), v = this.clone();
        var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
        while (u.signum() != 0) {
          while (u.isEven()) {
            u.rShiftTo(1, u);
            if (ac) {
              if (!a.isEven() || !b.isEven()) {
                a.addTo(this, a);
                b.subTo(m, b);
              }
              a.rShiftTo(1, a);
            } else if (!b.isEven())
              b.subTo(m, b);
            b.rShiftTo(1, b);
          }
          while (v.isEven()) {
            v.rShiftTo(1, v);
            if (ac) {
              if (!c.isEven() || !d.isEven()) {
                c.addTo(this, c);
                d.subTo(m, d);
              }
              c.rShiftTo(1, c);
            } else if (!d.isEven())
              d.subTo(m, d);
            d.rShiftTo(1, d);
          }
          if (u.compareTo(v) >= 0) {
            u.subTo(v, u);
            if (ac)
              a.subTo(c, a);
            b.subTo(d, b);
          } else {
            v.subTo(u, v);
            if (ac)
              c.subTo(a, c);
            d.subTo(b, d);
          }
        }
        if (v.compareTo(BigInteger.ONE) != 0)
          return BigInteger.ZERO;
        if (d.compareTo(m) >= 0)
          return d.subtract(m);
        if (d.signum() < 0)
          d.addTo(m, d);
        else
          return d;
        if (d.signum() < 0)
          return d.add(m);
        else
          return d;
      }
      var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
      var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
      function bnIsProbablePrime(t2) {
        var i, x = this.abs();
        if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
          for (i = 0; i < lowprimes.length; ++i)
            if (x[0] == lowprimes[i])
              return true;
          return false;
        }
        if (x.isEven())
          return false;
        i = 1;
        while (i < lowprimes.length) {
          var m = lowprimes[i], j = i + 1;
          while (j < lowprimes.length && m < lplim)
            m *= lowprimes[j++];
          m = x.modInt(m);
          while (i < j)
            if (m % lowprimes[i++] == 0)
              return false;
        }
        return x.millerRabin(t2);
      }
      function bnpMillerRabin(t2) {
        var n1 = this.subtract(BigInteger.ONE);
        var k = n1.getLowestSetBit();
        if (k <= 0)
          return false;
        var r = n1.shiftRight(k);
        t2 = t2 + 1 >> 1;
        if (t2 > lowprimes.length)
          t2 = lowprimes.length;
        var a = nbi();
        for (var i = 0; i < t2; ++i) {
          a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
          var y = a.modPow(r, this);
          if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
            var j = 1;
            while (j++ < k && y.compareTo(n1) != 0) {
              y = y.modPowInt(2, this);
              if (y.compareTo(BigInteger.ONE) == 0)
                return false;
            }
            if (y.compareTo(n1) != 0)
              return false;
          }
        }
        return true;
      }
      BigInteger.prototype.chunkSize = bnpChunkSize;
      BigInteger.prototype.toRadix = bnpToRadix;
      BigInteger.prototype.fromRadix = bnpFromRadix;
      BigInteger.prototype.fromNumber = bnpFromNumber;
      BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
      BigInteger.prototype.changeBit = bnpChangeBit;
      BigInteger.prototype.addTo = bnpAddTo;
      BigInteger.prototype.dMultiply = bnpDMultiply;
      BigInteger.prototype.dAddOffset = bnpDAddOffset;
      BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
      BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
      BigInteger.prototype.modInt = bnpModInt;
      BigInteger.prototype.millerRabin = bnpMillerRabin;
      BigInteger.prototype.clone = bnClone;
      BigInteger.prototype.intValue = bnIntValue;
      BigInteger.prototype.byteValue = bnByteValue;
      BigInteger.prototype.shortValue = bnShortValue;
      BigInteger.prototype.signum = bnSigNum;
      BigInteger.prototype.toByteArray = bnToByteArray;
      BigInteger.prototype.equals = bnEquals;
      BigInteger.prototype.min = bnMin;
      BigInteger.prototype.max = bnMax;
      BigInteger.prototype.and = bnAnd;
      BigInteger.prototype.or = bnOr;
      BigInteger.prototype.xor = bnXor;
      BigInteger.prototype.andNot = bnAndNot;
      BigInteger.prototype.not = bnNot;
      BigInteger.prototype.shiftLeft = bnShiftLeft;
      BigInteger.prototype.shiftRight = bnShiftRight;
      BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
      BigInteger.prototype.bitCount = bnBitCount;
      BigInteger.prototype.testBit = bnTestBit;
      BigInteger.prototype.setBit = bnSetBit;
      BigInteger.prototype.clearBit = bnClearBit;
      BigInteger.prototype.flipBit = bnFlipBit;
      BigInteger.prototype.add = bnAdd;
      BigInteger.prototype.subtract = bnSubtract;
      BigInteger.prototype.multiply = bnMultiply;
      BigInteger.prototype.divide = bnDivide;
      BigInteger.prototype.remainder = bnRemainder;
      BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
      BigInteger.prototype.modPow = bnModPow;
      BigInteger.prototype.modInverse = bnModInverse;
      BigInteger.prototype.pow = bnPow;
      BigInteger.prototype.gcd = bnGCD;
      BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
      BigInteger.prototype.square = bnSquare;
      BigInteger.prototype.Barrett = Barrett;
      var rng_state;
      var rng_pool;
      var rng_pptr;
      function rng_seed_int(x) {
        rng_pool[rng_pptr++] ^= x & 255;
        rng_pool[rng_pptr++] ^= x >> 8 & 255;
        rng_pool[rng_pptr++] ^= x >> 16 & 255;
        rng_pool[rng_pptr++] ^= x >> 24 & 255;
        if (rng_pptr >= rng_psize)
          rng_pptr -= rng_psize;
      }
      function rng_seed_time() {
        rng_seed_int(new Date().getTime());
      }
      if (rng_pool == null) {
        rng_pool = new Array();
        rng_pptr = 0;
        var t;
        if (typeof window !== "undefined" && window.crypto) {
          if (window.crypto.getRandomValues) {
            var ua = new Uint8Array(32);
            window.crypto.getRandomValues(ua);
            for (t = 0; t < 32; ++t)
              rng_pool[rng_pptr++] = ua[t];
          } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
            var z = window.crypto.random(32);
            for (t = 0; t < z.length; ++t)
              rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
          }
        }
        while (rng_pptr < rng_psize) {
          t = Math.floor(65536 * Math.random());
          rng_pool[rng_pptr++] = t >>> 8;
          rng_pool[rng_pptr++] = t & 255;
        }
        rng_pptr = 0;
        rng_seed_time();
      }
      function rng_get_byte() {
        if (rng_state == null) {
          rng_seed_time();
          rng_state = prng_newstate();
          rng_state.init(rng_pool);
          for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
            rng_pool[rng_pptr] = 0;
          rng_pptr = 0;
        }
        return rng_state.next();
      }
      function rng_get_bytes(ba) {
        var i;
        for (i = 0; i < ba.length; ++i)
          ba[i] = rng_get_byte();
      }
      function SecureRandom() {
      }
      SecureRandom.prototype.nextBytes = rng_get_bytes;
      function Arcfour() {
        this.i = 0;
        this.j = 0;
        this.S = new Array();
      }
      function ARC4init(key) {
        var i, j, t2;
        for (i = 0; i < 256; ++i)
          this.S[i] = i;
        j = 0;
        for (i = 0; i < 256; ++i) {
          j = j + this.S[i] + key[i % key.length] & 255;
          t2 = this.S[i];
          this.S[i] = this.S[j];
          this.S[j] = t2;
        }
        this.i = 0;
        this.j = 0;
      }
      function ARC4next() {
        var t2;
        this.i = this.i + 1 & 255;
        this.j = this.j + this.S[this.i] & 255;
        t2 = this.S[this.i];
        this.S[this.i] = this.S[this.j];
        this.S[this.j] = t2;
        return this.S[t2 + this.S[this.i] & 255];
      }
      Arcfour.prototype.init = ARC4init;
      Arcfour.prototype.next = ARC4next;
      function prng_newstate() {
        return new Arcfour();
      }
      var rng_psize = 256;
      if (typeof exports2 !== "undefined") {
        exports2 = module2.exports = {
          default: BigInteger,
          BigInteger,
          SecureRandom
        };
      } else {
        this.jsbn = {
          BigInteger,
          SecureRandom
        };
      }
    }).call(exports2);
  }
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS({
  "node_modules/sprintf-js/src/sprintf.js"(exports2) {
    init_node_globals();
    !function() {
      "use strict";
      var re = {
        not_string: /[^s]/,
        not_bool: /[^t]/,
        not_type: /[^T]/,
        not_primitive: /[^v]/,
        number: /[diefg]/,
        numeric_arg: /[bcdiefguxX]/,
        json: /[j]/,
        not_json: /[^j]/,
        text: /^[^\x25]+/,
        modulo: /^\x25{2}/,
        placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
        key: /^([a-z_][a-z_\d]*)/i,
        key_access: /^\.([a-z_][a-z_\d]*)/i,
        index_access: /^\[(\d+)\]/,
        sign: /^[+-]/
      };
      function sprintf(key) {
        return sprintf_format(sprintf_parse(key), arguments);
      }
      function vsprintf(fmt, argv) {
        return sprintf.apply(null, [fmt].concat(argv || []));
      }
      function sprintf_format(parse_tree, argv) {
        var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign2;
        for (i = 0; i < tree_length; i++) {
          if (typeof parse_tree[i] === "string") {
            output += parse_tree[i];
          } else if (typeof parse_tree[i] === "object") {
            ph = parse_tree[i];
            if (ph.keys) {
              arg = argv[cursor];
              for (k = 0; k < ph.keys.length; k++) {
                if (arg == void 0) {
                  throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
                }
                arg = arg[ph.keys[k]];
              }
            } else if (ph.param_no) {
              arg = argv[ph.param_no];
            } else {
              arg = argv[cursor++];
            }
            if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
              arg = arg();
            }
            if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
              throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
            }
            if (re.number.test(ph.type)) {
              is_positive = arg >= 0;
            }
            switch (ph.type) {
              case "b":
                arg = parseInt(arg, 10).toString(2);
                break;
              case "c":
                arg = String.fromCharCode(parseInt(arg, 10));
                break;
              case "d":
              case "i":
                arg = parseInt(arg, 10);
                break;
              case "j":
                arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
                break;
              case "e":
                arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
                break;
              case "f":
                arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
                break;
              case "g":
                arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
                break;
              case "o":
                arg = (parseInt(arg, 10) >>> 0).toString(8);
                break;
              case "s":
                arg = String(arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "t":
                arg = String(!!arg);
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "T":
                arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "u":
                arg = parseInt(arg, 10) >>> 0;
                break;
              case "v":
                arg = arg.valueOf();
                arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                break;
              case "x":
                arg = (parseInt(arg, 10) >>> 0).toString(16);
                break;
              case "X":
                arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                break;
            }
            if (re.json.test(ph.type)) {
              output += arg;
            } else {
              if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                sign2 = is_positive ? "+" : "-";
                arg = arg.toString().replace(re.sign, "");
              } else {
                sign2 = "";
              }
              pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
              pad_length = ph.width - (sign2 + arg).length;
              pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
              output += ph.align ? sign2 + arg + pad : pad_character === "0" ? sign2 + pad + arg : pad + sign2 + arg;
            }
          }
        }
        return output;
      }
      var sprintf_cache = Object.create(null);
      function sprintf_parse(fmt) {
        if (sprintf_cache[fmt]) {
          return sprintf_cache[fmt];
        }
        var _fmt = fmt, match, parse_tree = [], arg_names = 0;
        while (_fmt) {
          if ((match = re.text.exec(_fmt)) !== null) {
            parse_tree.push(match[0]);
          } else if ((match = re.modulo.exec(_fmt)) !== null) {
            parse_tree.push("%");
          } else if ((match = re.placeholder.exec(_fmt)) !== null) {
            if (match[2]) {
              arg_names |= 1;
              var field_list = [], replacement_field = match[2], field_match = [];
              if ((field_match = re.key.exec(replacement_field)) !== null) {
                field_list.push(field_match[1]);
                while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                  if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                  } else {
                    throw new SyntaxError("[sprintf] failed to parse named argument key");
                  }
                }
              } else {
                throw new SyntaxError("[sprintf] failed to parse named argument key");
              }
              match[2] = field_list;
            } else {
              arg_names |= 2;
            }
            if (arg_names === 3) {
              throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
            }
            parse_tree.push({
              placeholder: match[0],
              param_no: match[1],
              keys: match[2],
              sign: match[3],
              pad_char: match[4],
              align: match[5],
              width: match[6],
              precision: match[7],
              type: match[8]
            });
          } else {
            throw new SyntaxError("[sprintf] unexpected placeholder");
          }
          _fmt = _fmt.substring(match[0].length);
        }
        return sprintf_cache[fmt] = parse_tree;
      }
      if (typeof exports2 !== "undefined") {
        exports2["sprintf"] = sprintf;
        exports2["vsprintf"] = vsprintf;
      }
      if (typeof window !== "undefined") {
        window["sprintf"] = sprintf;
        window["vsprintf"] = vsprintf;
        if (typeof define === "function" && define["amd"]) {
          define(function() {
            return {
              "sprintf": sprintf,
              "vsprintf": vsprintf
            };
          });
        }
      }
    }();
  }
});

// node_modules/ip-address/dist/cjs/lib/ipv4.js
var require_ipv4 = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/ipv4.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address4 = void 0;
    var common = __importStar(require_common7());
    var constants = __importStar(require_constants6());
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn2();
    var sprintf_js_1 = require_sprintf();
    var Address4 = function() {
      function Address42(address) {
        this.groups = constants.GROUPS;
        this.parsedAddress = [];
        this.parsedSubnet = "";
        this.subnet = "/32";
        this.subnetMask = 32;
        this.v4 = true;
        this.isCorrect = common.isCorrect(constants.BITS);
        this.isInSubnet = common.isInSubnet;
        this.address = address;
        var subnet = constants.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = "/" + this.subnetMask;
          if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants.RE_SUBNET_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(address);
      }
      Address42.isValid = function(address) {
        try {
          new Address42(address);
          return true;
        } catch (e) {
          return false;
        }
      };
      Address42.prototype.parse = function(address) {
        var groups = address.split(".");
        if (!address.match(constants.RE_ADDRESS)) {
          throw new address_error_1.AddressError("Invalid IPv4 address.");
        }
        return groups;
      };
      Address42.prototype.correctForm = function() {
        return this.parsedAddress.map(function(part) {
          return parseInt(part, 10);
        }).join(".");
      };
      Address42.fromHex = function(hex) {
        var padded = hex.replace(/:/g, "").padStart(8, "0");
        var groups = [];
        var i;
        for (i = 0; i < 8; i += 2) {
          var h = padded.slice(i, i + 2);
          groups.push(parseInt(h, 16));
        }
        return new Address42(groups.join("."));
      };
      Address42.fromInteger = function(integer) {
        return Address42.fromHex(integer.toString(16));
      };
      Address42.fromArpa = function(arpaFormAddress) {
        var leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
        var address = leader.split(".").reverse().join(".");
        return new Address42(address);
      };
      Address42.prototype.toHex = function() {
        return this.parsedAddress.map(function(part) {
          return sprintf_js_1.sprintf("%02x", parseInt(part, 10));
        }).join(":");
      };
      Address42.prototype.toArray = function() {
        return this.parsedAddress.map(function(part) {
          return parseInt(part, 10);
        });
      };
      Address42.prototype.toGroup6 = function() {
        var output = [];
        var i;
        for (i = 0; i < constants.GROUPS; i += 2) {
          var hex = sprintf_js_1.sprintf("%02x%02x", parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
          output.push(sprintf_js_1.sprintf("%x", parseInt(hex, 16)));
        }
        return output.join(":");
      };
      Address42.prototype.bigInteger = function() {
        return new jsbn_1.BigInteger(this.parsedAddress.map(function(n) {
          return sprintf_js_1.sprintf("%02x", parseInt(n, 10));
        }).join(""), 16);
      };
      Address42.prototype._startAddress = function() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants.BITS - this.subnetMask), 2);
      };
      Address42.prototype.startAddress = function() {
        return Address42.fromBigInteger(this._startAddress());
      };
      Address42.prototype.startAddressExclusive = function() {
        var adjust = new jsbn_1.BigInteger("1");
        return Address42.fromBigInteger(this._startAddress().add(adjust));
      };
      Address42.prototype._endAddress = function() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants.BITS - this.subnetMask), 2);
      };
      Address42.prototype.endAddress = function() {
        return Address42.fromBigInteger(this._endAddress());
      };
      Address42.prototype.endAddressExclusive = function() {
        var adjust = new jsbn_1.BigInteger("1");
        return Address42.fromBigInteger(this._endAddress().subtract(adjust));
      };
      Address42.fromBigInteger = function(bigInteger) {
        return Address42.fromInteger(parseInt(bigInteger.toString(), 10));
      };
      Address42.prototype.mask = function(mask) {
        if (mask === void 0) {
          mask = this.subnetMask;
        }
        return this.getBitsBase2(0, mask);
      };
      Address42.prototype.getBitsBase2 = function(start, end) {
        return this.binaryZeroPad().slice(start, end);
      };
      Address42.prototype.reverseForm = function(options) {
        if (!options) {
          options = {};
        }
        var reversed = this.correctForm().split(".").reverse().join(".");
        if (options.omitSuffix) {
          return reversed;
        }
        return sprintf_js_1.sprintf("%s.in-addr.arpa.", reversed);
      };
      Address42.prototype.isMulticast = function() {
        return this.isInSubnet(new Address42("224.0.0.0/4"));
      };
      Address42.prototype.binaryZeroPad = function() {
        return this.bigInteger().toString(2).padStart(constants.BITS, "0");
      };
      Address42.prototype.groupForV6 = function() {
        var segments = this.parsedAddress;
        return this.address.replace(constants.RE_ADDRESS, sprintf_js_1.sprintf('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
      };
      return Address42;
    }();
    exports2.Address4 = Address4;
  }
});

// node_modules/ip-address/dist/cjs/lib/v6/constants.js
var require_constants7 = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/v6/constants.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RE_URL_WITH_PORT = exports2.RE_URL = exports2.RE_ZONE_STRING = exports2.RE_SUBNET_STRING = exports2.RE_BAD_ADDRESS = exports2.RE_BAD_CHARACTERS = exports2.TYPES = exports2.SCOPES = exports2.GROUPS = exports2.BITS = void 0;
    exports2.BITS = 128;
    exports2.GROUPS = 8;
    exports2.SCOPES = {
      0: "Reserved",
      1: "Interface local",
      2: "Link local",
      4: "Admin local",
      5: "Site local",
      8: "Organization local",
      14: "Global",
      15: "Reserved"
    };
    exports2.TYPES = {
      "ff01::1/128": "Multicast (All nodes on this interface)",
      "ff01::2/128": "Multicast (All routers on this interface)",
      "ff02::1/128": "Multicast (All nodes on this link)",
      "ff02::2/128": "Multicast (All routers on this link)",
      "ff05::2/128": "Multicast (All routers in this site)",
      "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
      "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
      "ff02::9/128": "Multicast (RIP routers)",
      "ff02::a/128": "Multicast (EIGRP routers)",
      "ff02::d/128": "Multicast (PIM routers)",
      "ff02::16/128": "Multicast (MLDv2 reports)",
      "ff01::fb/128": "Multicast (mDNSv6)",
      "ff02::fb/128": "Multicast (mDNSv6)",
      "ff05::fb/128": "Multicast (mDNSv6)",
      "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
      "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
      "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
      "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
      "::/128": "Unspecified",
      "::1/128": "Loopback",
      "ff00::/8": "Multicast",
      "fe80::/10": "Link-local unicast"
    };
    exports2.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
    exports2.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
    exports2.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
    exports2.RE_ZONE_STRING = /%.*$/;
    exports2.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
    exports2.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
  }
});

// node_modules/ip-address/dist/cjs/lib/v6/helpers.js
var require_helpers = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/v6/helpers.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.simpleGroup = exports2.spanLeadingZeroes = exports2.spanAll = exports2.spanAllZeroes = void 0;
    var sprintf_js_1 = require_sprintf();
    function spanAllZeroes(s) {
      return s.replace(/(0+)/g, '<span class="zero">$1</span>');
    }
    exports2.spanAllZeroes = spanAllZeroes;
    function spanAll(s, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var letters = s.split("");
      return letters.map(function(n, i) {
        return sprintf_js_1.sprintf('<span class="digit value-%s position-%d">%s</span>', n, i + offset, spanAllZeroes(n));
      }).join("");
    }
    exports2.spanAll = spanAll;
    function spanLeadingZeroesSimple(group) {
      return group.replace(/^(0+)/, '<span class="zero">$1</span>');
    }
    function spanLeadingZeroes(address) {
      var groups = address.split(":");
      return groups.map(function(g) {
        return spanLeadingZeroesSimple(g);
      }).join(":");
    }
    exports2.spanLeadingZeroes = spanLeadingZeroes;
    function simpleGroup(addressString, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var groups = addressString.split(":");
      return groups.map(function(g, i) {
        if (/group-v4/.test(g)) {
          return g;
        }
        return sprintf_js_1.sprintf('<span class="hover-group group-%d">%s</span>', i + offset, spanLeadingZeroesSimple(g));
      });
    }
    exports2.simpleGroup = simpleGroup;
  }
});

// node_modules/ip-address/dist/cjs/lib/v6/regular-expressions.js
var require_regular_expressions = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/v6/regular-expressions.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.possibleElisions = exports2.simpleRegularExpression = exports2.ADDRESS_BOUNDARY = exports2.padGroup = exports2.groupPossibilities = void 0;
    var v6 = __importStar(require_constants7());
    var sprintf_js_1 = require_sprintf();
    function groupPossibilities(possibilities) {
      return sprintf_js_1.sprintf("(%s)", possibilities.join("|"));
    }
    exports2.groupPossibilities = groupPossibilities;
    function padGroup(group) {
      if (group.length < 4) {
        return sprintf_js_1.sprintf("0{0,%d}%s", 4 - group.length, group);
      }
      return group;
    }
    exports2.padGroup = padGroup;
    exports2.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
    function simpleRegularExpression(groups) {
      var zeroIndexes = [];
      groups.forEach(function(group, i) {
        var groupInteger = parseInt(group, 16);
        if (groupInteger === 0) {
          zeroIndexes.push(i);
        }
      });
      var possibilities = zeroIndexes.map(function(zeroIndex) {
        return groups.map(function(group, i) {
          if (i === zeroIndex) {
            var elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
            return groupPossibilities([padGroup(group), elision]);
          }
          return padGroup(group);
        }).join(":");
      });
      possibilities.push(groups.map(padGroup).join(":"));
      return groupPossibilities(possibilities);
    }
    exports2.simpleRegularExpression = simpleRegularExpression;
    function possibleElisions(elidedGroups, moreLeft, moreRight) {
      var left = moreLeft ? "" : ":";
      var right = moreRight ? "" : ":";
      var possibilities = [];
      if (!moreLeft && !moreRight) {
        possibilities.push("::");
      }
      if (moreLeft && moreRight) {
        possibilities.push("");
      }
      if (moreRight && !moreLeft || !moreRight && moreLeft) {
        possibilities.push(":");
      }
      possibilities.push(sprintf_js_1.sprintf("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
      possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
      possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
      for (var groups = 1; groups < elidedGroups - 1; groups++) {
        for (var position = 1; position < elidedGroups - groups; position++) {
          possibilities.push(sprintf_js_1.sprintf("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
        }
      }
      return groupPossibilities(possibilities);
    }
    exports2.possibleElisions = possibleElisions;
  }
});

// node_modules/ip-address/dist/cjs/lib/ipv6.js
var require_ipv6 = __commonJS({
  "node_modules/ip-address/dist/cjs/lib/ipv6.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from3) {
      for (var i = 0, il = from3.length, j = to.length; i < il; i++, j++)
        to[j] = from3[i];
      return to;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Address6 = void 0;
    var common = __importStar(require_common7());
    var constants4 = __importStar(require_constants6());
    var constants6 = __importStar(require_constants7());
    var helpers = __importStar(require_helpers());
    var ipv4_1 = require_ipv4();
    var regular_expressions_1 = require_regular_expressions();
    var address_error_1 = require_address_error();
    var jsbn_1 = require_jsbn2();
    var sprintf_js_1 = require_sprintf();
    function assert(condition) {
      if (!condition) {
        throw new Error("Assertion failed.");
      }
    }
    function addCommas(number) {
      var r = /(\d+)(\d{3})/;
      while (r.test(number)) {
        number = number.replace(r, "$1,$2");
      }
      return number;
    }
    function spanLeadingZeroes4(n) {
      n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
      n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
      return n;
    }
    function compact(address, slice2) {
      var s1 = [];
      var s2 = [];
      var i;
      for (i = 0; i < address.length; i++) {
        if (i < slice2[0]) {
          s1.push(address[i]);
        } else if (i > slice2[1]) {
          s2.push(address[i]);
        }
      }
      return s1.concat(["compact"]).concat(s2);
    }
    function paddedHex(octet) {
      return sprintf_js_1.sprintf("%04x", parseInt(octet, 16));
    }
    function unsignByte(b) {
      return b & 255;
    }
    var Address6 = function() {
      function Address62(address, optionalGroups) {
        this.addressMinusSuffix = "";
        this.parsedSubnet = "";
        this.subnet = "/128";
        this.subnetMask = 128;
        this.v4 = false;
        this.zone = "";
        this.isInSubnet = common.isInSubnet;
        this.isCorrect = common.isCorrect(constants6.BITS);
        if (optionalGroups === void 0) {
          this.groups = constants6.GROUPS;
        } else {
          this.groups = optionalGroups;
        }
        this.address = address;
        var subnet = constants6.RE_SUBNET_STRING.exec(address);
        if (subnet) {
          this.parsedSubnet = subnet[0].replace("/", "");
          this.subnetMask = parseInt(this.parsedSubnet, 10);
          this.subnet = "/" + this.subnetMask;
          if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          address = address.replace(constants6.RE_SUBNET_STRING, "");
        } else if (/\//.test(address)) {
          throw new address_error_1.AddressError("Invalid subnet mask.");
        }
        var zone = constants6.RE_ZONE_STRING.exec(address);
        if (zone) {
          this.zone = zone[0];
          address = address.replace(constants6.RE_ZONE_STRING, "");
        }
        this.addressMinusSuffix = address;
        this.parsedAddress = this.parse(this.addressMinusSuffix);
      }
      Address62.isValid = function(address) {
        try {
          new Address62(address);
          return true;
        } catch (e) {
          return false;
        }
      };
      Address62.fromBigInteger = function(bigInteger) {
        var hex = bigInteger.toString(16).padStart(32, "0");
        var groups = [];
        var i;
        for (i = 0; i < constants6.GROUPS; i++) {
          groups.push(hex.slice(i * 4, (i + 1) * 4));
        }
        return new Address62(groups.join(":"));
      };
      Address62.fromURL = function(url) {
        var host;
        var port = null;
        var result;
        if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
          result = constants6.RE_URL_WITH_PORT.exec(url);
          if (result === null) {
            return {
              error: "failed to parse address with port",
              address: null,
              port: null
            };
          }
          host = result[1];
          port = result[2];
        } else if (url.indexOf("/") !== -1) {
          url = url.replace(/^[a-z0-9]+:\/\//, "");
          result = constants6.RE_URL.exec(url);
          if (result === null) {
            return {
              error: "failed to parse address from URL",
              address: null,
              port: null
            };
          }
          host = result[1];
        } else {
          host = url;
        }
        if (port) {
          port = parseInt(port, 10);
          if (port < 0 || port > 65536) {
            port = null;
          }
        } else {
          port = null;
        }
        return {
          address: new Address62(host),
          port
        };
      };
      Address62.fromAddress4 = function(address) {
        var address4 = new ipv4_1.Address4(address);
        var mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
        return new Address62("::ffff:" + address4.correctForm() + "/" + mask6);
      };
      Address62.fromArpa = function(arpaFormAddress) {
        var address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
        var semicolonAmount = 7;
        if (address.length !== 63) {
          throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
        }
        var parts = address.split(".").reverse();
        for (var i = semicolonAmount; i > 0; i--) {
          var insertIndex = i * 4;
          parts.splice(insertIndex, 0, ":");
        }
        address = parts.join("");
        return new Address62(address);
      };
      Address62.prototype.microsoftTranscription = function() {
        return sprintf_js_1.sprintf("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
      };
      Address62.prototype.mask = function(mask) {
        if (mask === void 0) {
          mask = this.subnetMask;
        }
        return this.getBitsBase2(0, mask);
      };
      Address62.prototype.possibleSubnets = function(subnetSize) {
        if (subnetSize === void 0) {
          subnetSize = 128;
        }
        var availableBits = constants6.BITS - this.subnetMask;
        var subnetBits = Math.abs(subnetSize - constants6.BITS);
        var subnetPowers = availableBits - subnetBits;
        if (subnetPowers < 0) {
          return "0";
        }
        return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
      };
      Address62.prototype._startAddress = function() {
        return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants6.BITS - this.subnetMask), 2);
      };
      Address62.prototype.startAddress = function() {
        return Address62.fromBigInteger(this._startAddress());
      };
      Address62.prototype.startAddressExclusive = function() {
        var adjust = new jsbn_1.BigInteger("1");
        return Address62.fromBigInteger(this._startAddress().add(adjust));
      };
      Address62.prototype._endAddress = function() {
        return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants6.BITS - this.subnetMask), 2);
      };
      Address62.prototype.endAddress = function() {
        return Address62.fromBigInteger(this._endAddress());
      };
      Address62.prototype.endAddressExclusive = function() {
        var adjust = new jsbn_1.BigInteger("1");
        return Address62.fromBigInteger(this._endAddress().subtract(adjust));
      };
      Address62.prototype.getScope = function() {
        var scope = constants6.SCOPES[this.getBits(12, 16).intValue()];
        if (this.getType() === "Global unicast" && scope !== "Link local") {
          scope = "Global";
        }
        return scope || "Unknown";
      };
      Address62.prototype.getType = function() {
        for (var _i = 0, _a = Object.keys(constants6.TYPES); _i < _a.length; _i++) {
          var subnet = _a[_i];
          if (this.isInSubnet(new Address62(subnet))) {
            return constants6.TYPES[subnet];
          }
        }
        return "Global unicast";
      };
      Address62.prototype.getBits = function(start, end) {
        return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
      };
      Address62.prototype.getBitsBase2 = function(start, end) {
        return this.binaryZeroPad().slice(start, end);
      };
      Address62.prototype.getBitsBase16 = function(start, end) {
        var length4 = end - start;
        if (length4 % 4 !== 0) {
          throw new Error("Length of bits to retrieve must be divisible by four");
        }
        return this.getBits(start, end).toString(16).padStart(length4 / 4, "0");
      };
      Address62.prototype.getBitsPastSubnet = function() {
        return this.getBitsBase2(this.subnetMask, constants6.BITS);
      };
      Address62.prototype.reverseForm = function(options) {
        if (!options) {
          options = {};
        }
        var characters = Math.floor(this.subnetMask / 4);
        var reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
        if (characters > 0) {
          if (options.omitSuffix) {
            return reversed;
          }
          return sprintf_js_1.sprintf("%s.ip6.arpa.", reversed);
        }
        if (options.omitSuffix) {
          return "";
        }
        return "ip6.arpa.";
      };
      Address62.prototype.correctForm = function() {
        var i;
        var groups = [];
        var zeroCounter = 0;
        var zeroes = [];
        for (i = 0; i < this.parsedAddress.length; i++) {
          var value = parseInt(this.parsedAddress[i], 16);
          if (value === 0) {
            zeroCounter++;
          }
          if (value !== 0 && zeroCounter > 0) {
            if (zeroCounter > 1) {
              zeroes.push([i - zeroCounter, i - 1]);
            }
            zeroCounter = 0;
          }
        }
        if (zeroCounter > 1) {
          zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
        }
        var zeroLengths = zeroes.map(function(n) {
          return n[1] - n[0] + 1;
        });
        if (zeroes.length > 0) {
          var index = zeroLengths.indexOf(Math.max.apply(Math, zeroLengths));
          groups = compact(this.parsedAddress, zeroes[index]);
        } else {
          groups = this.parsedAddress;
        }
        for (i = 0; i < groups.length; i++) {
          if (groups[i] !== "compact") {
            groups[i] = parseInt(groups[i], 16).toString(16);
          }
        }
        var correct = groups.join(":");
        correct = correct.replace(/^compact$/, "::");
        correct = correct.replace(/^compact|compact$/, ":");
        correct = correct.replace(/compact/, "");
        return correct;
      };
      Address62.prototype.binaryZeroPad = function() {
        return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
      };
      Address62.prototype.parse4in6 = function(address) {
        var groups = address.split(":");
        var lastGroup = groups.slice(-1)[0];
        var address4 = lastGroup.match(constants4.RE_ADDRESS);
        if (address4) {
          this.parsedAddress4 = address4[0];
          this.address4 = new ipv4_1.Address4(this.parsedAddress4);
          for (var i = 0; i < this.address4.groups; i++) {
            if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
              throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
            }
          }
          this.v4 = true;
          groups[groups.length - 1] = this.address4.toGroup6();
          address = groups.join(":");
        }
        return address;
      };
      Address62.prototype.parse = function(address) {
        address = this.parse4in6(address);
        var badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
        if (badCharacters) {
          throw new address_error_1.AddressError(sprintf_js_1.sprintf("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
        }
        var badAddress = address.match(constants6.RE_BAD_ADDRESS);
        if (badAddress) {
          throw new address_error_1.AddressError(sprintf_js_1.sprintf("Address failed regex: %s", badAddress.join("")), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
        }
        var groups = [];
        var halves = address.split("::");
        if (halves.length === 2) {
          var first3 = halves[0].split(":");
          var last6 = halves[1].split(":");
          if (first3.length === 1 && first3[0] === "") {
            first3 = [];
          }
          if (last6.length === 1 && last6[0] === "") {
            last6 = [];
          }
          var remaining = this.groups - (first3.length + last6.length);
          if (!remaining) {
            throw new address_error_1.AddressError("Error parsing groups");
          }
          this.elidedGroups = remaining;
          this.elisionBegin = first3.length;
          this.elisionEnd = first3.length + this.elidedGroups;
          groups = groups.concat(first3);
          for (var i = 0; i < remaining; i++) {
            groups.push("0");
          }
          groups = groups.concat(last6);
        } else if (halves.length === 1) {
          groups = address.split(":");
          this.elidedGroups = 0;
        } else {
          throw new address_error_1.AddressError("Too many :: groups found");
        }
        groups = groups.map(function(group) {
          return sprintf_js_1.sprintf("%x", parseInt(group, 16));
        });
        if (groups.length !== this.groups) {
          throw new address_error_1.AddressError("Incorrect number of groups found");
        }
        return groups;
      };
      Address62.prototype.canonicalForm = function() {
        return this.parsedAddress.map(paddedHex).join(":");
      };
      Address62.prototype.decimal = function() {
        return this.parsedAddress.map(function(n) {
          return sprintf_js_1.sprintf("%05d", parseInt(n, 16));
        }).join(":");
      };
      Address62.prototype.bigInteger = function() {
        return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
      };
      Address62.prototype.to4 = function() {
        var binary = this.binaryZeroPad().split("");
        return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
      };
      Address62.prototype.to4in6 = function() {
        var address4 = this.to4();
        var address6 = new Address62(this.parsedAddress.slice(0, 6).join(":"), 6);
        var correct = address6.correctForm();
        var infix = "";
        if (!/:$/.test(correct)) {
          infix = ":";
        }
        return correct + infix + address4.address;
      };
      Address62.prototype.inspectTeredo = function() {
        var prefix = this.getBitsBase16(0, 32);
        var udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
        var server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
        var client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
        var flags = this.getBits(64, 80);
        var flagsBase2 = this.getBitsBase2(64, 80);
        var coneNat = flags.testBit(15);
        var reserved = flags.testBit(14);
        var groupIndividual = flags.testBit(8);
        var universalLocal = flags.testBit(9);
        var nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
        return {
          prefix: sprintf_js_1.sprintf("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
          server4: server4.address,
          client4: client4.address,
          flags: flagsBase2,
          coneNat,
          microsoft: {
            reserved,
            universalLocal,
            groupIndividual,
            nonce
          },
          udpPort
        };
      };
      Address62.prototype.inspect6to4 = function() {
        var prefix = this.getBitsBase16(0, 16);
        var gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
        return {
          prefix: sprintf_js_1.sprintf("%s", prefix.slice(0, 4)),
          gateway: gateway.address
        };
      };
      Address62.prototype.to6to4 = function() {
        if (!this.is4()) {
          return null;
        }
        var addr6to4 = [
          "2002",
          this.getBitsBase16(96, 112),
          this.getBitsBase16(112, 128),
          "",
          "/16"
        ].join(":");
        return new Address62(addr6to4);
      };
      Address62.prototype.toByteArray = function() {
        var byteArray = this.bigInteger().toByteArray();
        if (byteArray.length === 17 && byteArray[0] === 0) {
          return byteArray.slice(1);
        }
        return byteArray;
      };
      Address62.prototype.toUnsignedByteArray = function() {
        return this.toByteArray().map(unsignByte);
      };
      Address62.fromByteArray = function(bytes3) {
        return this.fromUnsignedByteArray(bytes3.map(unsignByte));
      };
      Address62.fromUnsignedByteArray = function(bytes3) {
        var BYTE_MAX = new jsbn_1.BigInteger("256", 10);
        var result = new jsbn_1.BigInteger("0", 10);
        var multiplier = new jsbn_1.BigInteger("1", 10);
        for (var i = bytes3.length - 1; i >= 0; i--) {
          result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes3[i].toString(10), 10)));
          multiplier = multiplier.multiply(BYTE_MAX);
        }
        return Address62.fromBigInteger(result);
      };
      Address62.prototype.isCanonical = function() {
        return this.addressMinusSuffix === this.canonicalForm();
      };
      Address62.prototype.isLinkLocal = function() {
        if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
          return true;
        }
        return false;
      };
      Address62.prototype.isMulticast = function() {
        return this.getType() === "Multicast";
      };
      Address62.prototype.is4 = function() {
        return this.v4;
      };
      Address62.prototype.isTeredo = function() {
        return this.isInSubnet(new Address62("2001::/32"));
      };
      Address62.prototype.is6to4 = function() {
        return this.isInSubnet(new Address62("2002::/16"));
      };
      Address62.prototype.isLoopback = function() {
        return this.getType() === "Loopback";
      };
      Address62.prototype.href = function(optionalPort) {
        if (optionalPort === void 0) {
          optionalPort = "";
        } else {
          optionalPort = sprintf_js_1.sprintf(":%s", optionalPort);
        }
        return sprintf_js_1.sprintf("http://[%s]%s/", this.correctForm(), optionalPort);
      };
      Address62.prototype.link = function(options) {
        if (!options) {
          options = {};
        }
        if (options.className === void 0) {
          options.className = "";
        }
        if (options.prefix === void 0) {
          options.prefix = "/#address=";
        }
        if (options.v4 === void 0) {
          options.v4 = false;
        }
        var formFunction = this.correctForm;
        if (options.v4) {
          formFunction = this.to4in6;
        }
        if (options.className) {
          return sprintf_js_1.sprintf('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
        }
        return sprintf_js_1.sprintf('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
      };
      Address62.prototype.group = function() {
        if (this.elidedGroups === 0) {
          return helpers.simpleGroup(this.address).join(":");
        }
        assert(typeof this.elidedGroups === "number");
        assert(typeof this.elisionBegin === "number");
        var output = [];
        var _a = this.address.split("::"), left = _a[0], right = _a[1];
        if (left.length) {
          output.push.apply(output, helpers.simpleGroup(left));
        } else {
          output.push("");
        }
        var classes = ["hover-group"];
        for (var i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
          classes.push(sprintf_js_1.sprintf("group-%d", i));
        }
        output.push(sprintf_js_1.sprintf('<span class="%s"></span>', classes.join(" ")));
        if (right.length) {
          output.push.apply(output, helpers.simpleGroup(right, this.elisionEnd));
        } else {
          output.push("");
        }
        if (this.is4()) {
          assert(this.address4 instanceof ipv4_1.Address4);
          output.pop();
          output.push(this.address4.groupForV6());
        }
        return output.join(":");
      };
      Address62.prototype.regularExpressionString = function(substringSearch) {
        if (substringSearch === void 0) {
          substringSearch = false;
        }
        var output = [];
        var address6 = new Address62(this.correctForm());
        if (address6.elidedGroups === 0) {
          output.push(regular_expressions_1.simpleRegularExpression(address6.parsedAddress));
        } else if (address6.elidedGroups === constants6.GROUPS) {
          output.push(regular_expressions_1.possibleElisions(constants6.GROUPS));
        } else {
          var halves = address6.address.split("::");
          if (halves[0].length) {
            output.push(regular_expressions_1.simpleRegularExpression(halves[0].split(":")));
          }
          assert(typeof address6.elidedGroups === "number");
          output.push(regular_expressions_1.possibleElisions(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
          if (halves[1].length) {
            output.push(regular_expressions_1.simpleRegularExpression(halves[1].split(":")));
          }
          output = [output.join(":")];
        }
        if (!substringSearch) {
          output = __spreadArray(__spreadArray([
            "(?=^|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|[^\\w\\:])("
          ], output), [
            ")(?=[^\\w\\:]|",
            regular_expressions_1.ADDRESS_BOUNDARY,
            "|$)"
          ]);
        }
        return output.join("");
      };
      Address62.prototype.regularExpression = function(substringSearch) {
        if (substringSearch === void 0) {
          substringSearch = false;
        }
        return new RegExp(this.regularExpressionString(substringSearch), "i");
      };
      return Address62;
    }();
    exports2.Address6 = Address6;
  }
});

// node_modules/ip-address/dist/cjs/ip-address.js
var require_ip_address = __commonJS({
  "node_modules/ip-address/dist/cjs/ip-address.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.v6 = exports2.AddressError = exports2.Address6 = exports2.Address4 = void 0;
    var ipv4_1 = require_ipv4();
    Object.defineProperty(exports2, "Address4", { enumerable: true, get: function() {
      return ipv4_1.Address4;
    } });
    var ipv6_1 = require_ipv6();
    Object.defineProperty(exports2, "Address6", { enumerable: true, get: function() {
      return ipv6_1.Address6;
    } });
    var address_error_1 = require_address_error();
    Object.defineProperty(exports2, "AddressError", { enumerable: true, get: function() {
      return address_error_1.AddressError;
    } });
    var helpers = __importStar(require_helpers());
    exports2.v6 = { helpers };
  }
});

// node_modules/libp2p-utils/src/ip-port-to-multiaddr.js
var require_ip_port_to_multiaddr = __commonJS({
  "node_modules/libp2p-utils/src/ip-port-to-multiaddr.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:ip-port-to-multiaddr"), {
      error: debug17("libp2p:ip-port-to-multiaddr:err")
    });
    var { Multiaddr: Multiaddr18 } = require_src();
    var errCode32 = require_err_code();
    var { Address4, Address6 } = require_ip_address();
    var errors2 = {
      ERR_INVALID_IP_PARAMETER: "ERR_INVALID_IP_PARAMETER",
      ERR_INVALID_PORT_PARAMETER: "ERR_INVALID_PORT_PARAMETER",
      ERR_INVALID_IP: "ERR_INVALID_IP"
    };
    function ipPortToMultiaddr(ip, port) {
      if (typeof ip !== "string") {
        throw errCode32(new Error(`invalid ip provided: ${ip}`), errors2.ERR_INVALID_IP_PARAMETER);
      }
      if (typeof port === "string") {
        port = parseInt(port);
      }
      if (isNaN(port)) {
        throw errCode32(new Error(`invalid port provided: ${port}`), errors2.ERR_INVALID_PORT_PARAMETER);
      }
      try {
        new Address4(ip);
        return new Multiaddr18(`/ip4/${ip}/tcp/${port}`);
      } catch {
      }
      try {
        const ip6 = new Address6(ip);
        return ip6.is4() ? new Multiaddr18(`/ip4/${ip6.to4().correctForm()}/tcp/${port}`) : new Multiaddr18(`/ip6/${ip}/tcp/${port}`);
      } catch (err) {
        const errMsg = `invalid ip:port for creating a multiaddr: ${ip}:${port}`;
        log15.error(errMsg);
        throw errCode32(new Error(errMsg), errors2.ERR_INVALID_IP);
      }
    }
    module2.exports = ipPortToMultiaddr;
    module2.exports.Errors = errors2;
  }
});

// node_modules/p-timeout/index.js
var require_p_timeout2 = __commonJS({
  "node_modules/p-timeout/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var TimeoutError2 = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TimeoutError";
      }
    };
    var pTimeout = (promise, milliseconds, fallback, options) => {
      let timer;
      const cancelablePromise = new Promise((resolve6, reject) => {
        if (typeof milliseconds !== "number" || milliseconds < 0) {
          throw new TypeError("Expected `milliseconds` to be a positive number");
        }
        if (milliseconds === Infinity) {
          resolve6(promise);
          return;
        }
        options = {
          customTimers: { setTimeout, clearTimeout },
          ...options
        };
        timer = options.customTimers.setTimeout.call(void 0, () => {
          if (typeof fallback === "function") {
            try {
              resolve6(fallback());
            } catch (error) {
              reject(error);
            }
            return;
          }
          const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
          const timeoutError = fallback instanceof Error ? fallback : new TimeoutError2(message);
          if (typeof promise.cancel === "function") {
            promise.cancel();
          }
          reject(timeoutError);
        }, milliseconds);
        (async () => {
          try {
            resolve6(await promise);
          } catch (error) {
            reject(error);
          } finally {
            options.customTimers.clearTimeout.call(void 0, timer);
          }
        })();
      });
      cancelablePromise.clear = () => {
        clearTimeout(timer);
        timer = void 0;
      };
      return cancelablePromise;
    };
    module2.exports = pTimeout;
    module2.exports.default = pTimeout;
    module2.exports.TimeoutError = TimeoutError2;
  }
});

// node_modules/libp2p-websockets/src/socket-to-conn.js
var require_socket_to_conn = __commonJS({
  "node_modules/libp2p-websockets/src/socket-to-conn.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var abortable = require_abortable_iterator();
    var { CLOSE_TIMEOUT } = require_constants5();
    var toMultiaddr = require_ip_port_to_multiaddr();
    var pTimeout = require_p_timeout2();
    var debug17 = require_browser2();
    var log15 = debug17("libp2p:websockets:socket");
    log15.error = debug17("libp2p:websockets:socket:error");
    module2.exports = (stream, options = {}) => {
      const maConn = {
        async sink(source) {
          if (options.signal) {
            source = abortable(source, options.signal);
          }
          try {
            await stream.sink(async function* () {
              for await (const chunk of source) {
                yield chunk instanceof Uint8Array ? chunk : chunk.slice();
              }
            }());
          } catch (err) {
            if (err.type !== "aborted") {
              log15.error(err);
            }
          }
        },
        source: options.signal ? abortable(stream.source, options.signal) : stream.source,
        conn: stream,
        localAddr: options.localAddr || (stream.localAddress && stream.localPort ? toMultiaddr(stream.localAddress, stream.localPort) : void 0),
        remoteAddr: options.remoteAddr || toMultiaddr(stream.remoteAddress, stream.remotePort),
        timeline: { open: Date.now() },
        async close() {
          const start = Date.now();
          try {
            await pTimeout(stream.close(), CLOSE_TIMEOUT);
          } catch (err) {
            const { host, port } = maConn.remoteAddr.toOptions();
            log15("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
            stream.destroy();
          } finally {
            maConn.timeline.close = Date.now();
          }
        }
      };
      stream.socket.once && stream.socket.once("close", () => {
        if (!maConn.timeline.close) {
          maConn.timeline.close = Date.now();
        }
      });
      return maConn;
    };
  }
});

// node_modules/libp2p-websockets/src/filters.js
var require_filters = __commonJS({
  "node_modules/libp2p-websockets/src/filters.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var mafmt = require_src2();
    var {
      CODE_CIRCUIT,
      CODE_P2P,
      CODE_TCP,
      CODE_WS,
      CODE_WSS
    } = require_constants5();
    module2.exports = {
      all: (multiaddrs) => multiaddrs.filter((ma) => {
        if (ma.protoCodes().includes(CODE_CIRCUIT)) {
          return false;
        }
        const testMa = ma.decapsulateCode(CODE_P2P);
        return mafmt.WebSockets.matches(testMa) || mafmt.WebSocketsSecure.matches(testMa);
      }),
      dnsWss: (multiaddrs) => multiaddrs.filter((ma) => {
        if (ma.protoCodes().includes(CODE_CIRCUIT)) {
          return false;
        }
        const testMa = ma.decapsulateCode(CODE_P2P);
        return mafmt.WebSocketsSecure.matches(testMa) && mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
      }),
      dnsWsOrWss: (multiaddrs) => multiaddrs.filter((ma) => {
        if (ma.protoCodes().includes(CODE_CIRCUIT)) {
          return false;
        }
        const testMa = ma.decapsulateCode(CODE_P2P);
        if (mafmt.WebSockets.matches(testMa)) {
          return mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WS));
        }
        return mafmt.WebSocketsSecure.matches(testMa) && mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
      })
    };
  }
});

// node_modules/libp2p-websockets/src/index.js
var require_src17 = __commonJS({
  "node_modules/libp2p-websockets/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var connect = require_client();
    var withIs = require_class_is();
    var toUri = require_multiaddr_to_uri();
    var { AbortError } = require_abortable_iterator();
    var pDefer = require_p_defer();
    var debug17 = require_browser2();
    var log15 = debug17("libp2p:websockets");
    log15.error = debug17("libp2p:websockets:error");
    var env = require_env();
    var createListener = require_listener_browser();
    var toConnection = require_socket_to_conn();
    var filters = require_filters();
    var WebSockets = class {
      constructor({ upgrader, filter: filter8 }) {
        if (!upgrader) {
          throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");
        }
        this._upgrader = upgrader;
        this._filter = filter8;
      }
      async dial(ma, options = {}) {
        log15("dialing %s", ma);
        const socket = await this._connect(ma, options);
        const maConn = toConnection(socket, { remoteAddr: ma, signal: options.signal });
        log15("new outbound connection %s", maConn.remoteAddr);
        const conn = await this._upgrader.upgradeOutbound(maConn);
        log15("outbound connection %s upgraded", maConn.remoteAddr);
        return conn;
      }
      async _connect(ma, options = {}) {
        if (options.signal && options.signal.aborted) {
          throw new AbortError();
        }
        const cOpts = ma.toOptions();
        log15("dialing %s:%s", cOpts.host, cOpts.port);
        const errorPromise = pDefer();
        const errfn = (err) => {
          const msg = `connection error: ${err.message}`;
          log15.error(msg);
          errorPromise.reject(err);
        };
        const rawSocket = connect(toUri(ma), Object.assign({ binary: true }, options));
        if (rawSocket.socket.on) {
          rawSocket.socket.on("error", errfn);
        } else {
          rawSocket.socket.onerror = errfn;
        }
        if (!options.signal) {
          await Promise.race([rawSocket.connected(), errorPromise.promise]);
          log15("connected %s", ma);
          return rawSocket;
        }
        let onAbort;
        const abort = new Promise((resolve6, reject) => {
          onAbort = () => {
            reject(new AbortError());
            setTimeout(() => {
              rawSocket.close();
            });
          };
          if (options.signal.aborted)
            return onAbort();
          options.signal.addEventListener("abort", onAbort);
        });
        try {
          await Promise.race([abort, errorPromise.promise, rawSocket.connected()]);
        } finally {
          options.signal.removeEventListener("abort", onAbort);
        }
        log15("connected %s", ma);
        return rawSocket;
      }
      createListener(options = {}, handler) {
        if (typeof options === "function") {
          handler = options;
          options = {};
        }
        return createListener({ handler, upgrader: this._upgrader }, options);
      }
      filter(multiaddrs) {
        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
        if (this._filter) {
          return this._filter(multiaddrs);
        }
        if (env.isBrowser || env.isWebWorker) {
          return filters.dnsWss(multiaddrs);
        }
        return filters.all(multiaddrs);
      }
    };
    module2.exports = withIs(WebSockets, {
      className: "WebSockets",
      symbolName: "@libp2p/js-libp2p-websockets/websockets"
    });
  }
});

// node_modules/get-browser-rtc/index.js
var require_get_browser_rtc = __commonJS({
  "node_modules/get-browser-rtc/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = function getBrowserRTC() {
      if (typeof globalThis === "undefined")
        return null;
      var wrtc = {
        RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
        RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
        RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
      };
      if (!wrtc.RTCPeerConnection)
        return null;
      return wrtc;
    };
  }
});

// node_modules/randombytes/browser.js
var require_browser9 = __commonJS({
  "node_modules/randombytes/browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto3 = global.crypto || global.msCrypto;
    if (crypto3 && crypto3.getRandomValues) {
      module2.exports = randomBytes;
    } else {
      module2.exports = oldBrowser;
    }
    function randomBytes(size, cb) {
      if (size > MAX_UINT32)
        throw new RangeError("requested too many random bytes");
      var bytes3 = Buffer2.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto3.getRandomValues(bytes3.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto3.getRandomValues(bytes3);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes3);
        });
      }
      return bytes3;
    }
  }
});

// node_modules/libp2p-webrtc-peer/node_modules/err-code/index.js
var require_err_code2 = __commonJS({
  "node_modules/libp2p-webrtc-peer/node_modules/err-code/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function assign(obj, props) {
      for (const key in props) {
        Object.defineProperty(obj, key, {
          value: props[key],
          enumerable: true,
          configurable: true
        });
      }
      return obj;
    }
    function createError(err, code5, props) {
      if (!err || typeof err === "string") {
        throw new TypeError("Please pass an Error to err-code");
      }
      if (!props) {
        props = {};
      }
      if (typeof code5 === "object") {
        props = code5;
        code5 = void 0;
      }
      if (code5 != null) {
        props.code = code5;
      }
      try {
        return assign(err, props);
      } catch (_) {
        props.message = err.message;
        props.stack = err.stack;
        const ErrClass = function() {
        };
        ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
        return assign(new ErrClass(), props);
      }
    }
    module2.exports = createError;
  }
});

// node_modules/libp2p-webrtc-peer/index.js
var require_libp2p_webrtc_peer = __commonJS({
  "node_modules/libp2p-webrtc-peer/index.js"(exports2, module2) {
    init_node_globals();
    var debug17 = require_browser2()("simple-peer");
    var getBrowserRTC = require_get_browser_rtc();
    var randombytes = require_browser9();
    var stream = require_readable_browser();
    var queueMicrotask2 = require_queue_microtask2();
    var errCode32 = require_err_code2();
    var MAX_BUFFERED_AMOUNT = 64 * 1024;
    var ICECOMPLETE_TIMEOUT = 5 * 1e3;
    var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
    function filterTrickle(sdp) {
      return sdp.replace(/a=ice-options:trickle\s\n/g, "");
    }
    function warn(message) {
      console.warn(message);
    }
    var Peer = class extends stream.Duplex {
      constructor(opts) {
        opts = Object.assign({
          allowHalfOpen: false
        }, opts);
        super(opts);
        this._id = randombytes(4).toString("hex").slice(0, 7);
        this._debug("new peer %o", opts);
        this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString("hex") : null;
        this.initiator = opts.initiator || false;
        this.channelConfig = opts.channelConfig || Peer.channelConfig;
        this.negotiated = this.channelConfig.negotiated;
        this.config = Object.assign({}, Peer.config, opts.config);
        this.offerOptions = opts.offerOptions || {};
        this.answerOptions = opts.answerOptions || {};
        this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
        this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
        this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
        this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
        this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
        this._connected = false;
        this.remoteAddress = void 0;
        this.remoteFamily = void 0;
        this.remotePort = void 0;
        this.localAddress = void 0;
        this.localFamily = void 0;
        this.localPort = void 0;
        this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
        if (!this._wrtc) {
          if (typeof window === "undefined") {
            throw errCode32(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
          } else {
            throw errCode32(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
          }
        }
        this._pcReady = false;
        this._channelReady = false;
        this._iceComplete = false;
        this._iceCompleteTimer = null;
        this._channel = null;
        this._pendingCandidates = [];
        this._isNegotiating = this.negotiated ? false : !this.initiator;
        this._batchedNegotiation = false;
        this._queuedNegotiation = false;
        this._sendersAwaitingStable = [];
        this._senderMap = new Map();
        this._firstStable = true;
        this._closingInterval = null;
        this._remoteTracks = [];
        this._remoteStreams = [];
        this._chunk = null;
        this._cb = null;
        this._interval = null;
        try {
          this._pc = new this._wrtc.RTCPeerConnection(this.config);
        } catch (err) {
          queueMicrotask2(() => this.destroy(errCode32(err, "ERR_PC_CONSTRUCTOR")));
          return;
        }
        this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
        this._pc.oniceconnectionstatechange = () => {
          this._onIceStateChange();
        };
        this._pc.onicegatheringstatechange = () => {
          this._onIceStateChange();
        };
        this._pc.onconnectionstatechange = () => {
          this._onConnectionStateChange();
        };
        this._pc.onsignalingstatechange = () => {
          this._onSignalingStateChange();
        };
        this._pc.onicecandidate = (event) => {
          this._onIceCandidate(event);
        };
        if (this.initiator || this.negotiated) {
          this._setupData({
            channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
          });
        } else {
          this._pc.ondatachannel = (event) => {
            this._setupData(event);
          };
        }
        if (this.streams) {
          this.streams.forEach((stream2) => {
            this.addStream(stream2);
          });
        }
        this._pc.ontrack = (event) => {
          this._onTrack(event);
        };
        if (this.initiator) {
          this._needsNegotiation();
        }
        this._onFinishBound = () => {
          this._onFinish();
        };
        this.once("finish", this._onFinishBound);
      }
      get bufferSize() {
        return this._channel && this._channel.bufferedAmount || 0;
      }
      get connected() {
        return this._connected && this._channel.readyState === "open";
      }
      address() {
        return { port: this.localPort, family: this.localFamily, address: this.localAddress };
      }
      signal(data) {
        if (this.destroyed)
          throw errCode32(new Error("cannot signal after peer is destroyed"), "ERR_SIGNALING");
        if (typeof data === "string") {
          try {
            data = JSON.parse(data);
          } catch (err) {
            data = {};
          }
        }
        this._debug("signal()");
        if (data.renegotiate && this.initiator) {
          this._debug("got request to renegotiate");
          this._needsNegotiation();
        }
        if (data.transceiverRequest && this.initiator) {
          this._debug("got request for transceiver");
          this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
        }
        if (data.candidate) {
          if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
            this._addIceCandidate(data.candidate);
          } else {
            this._pendingCandidates.push(data.candidate);
          }
        }
        if (data.sdp) {
          this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {
            if (this.destroyed)
              return;
            this._pendingCandidates.forEach((candidate) => {
              this._addIceCandidate(candidate);
            });
            this._pendingCandidates = [];
            if (this._pc.remoteDescription.type === "offer")
              this._createAnswer();
          }).catch((err) => {
            this.destroy(errCode32(err, "ERR_SET_REMOTE_DESCRIPTION"));
          });
        }
        if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
          this.destroy(errCode32(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
        }
      }
      _addIceCandidate(candidate) {
        var iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
        this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
          if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
            warn("Ignoring unsupported ICE candidate.");
          } else {
            this.destroy(errCode32(err, "ERR_ADD_ICE_CANDIDATE"));
          }
        });
      }
      send(chunk) {
        this._channel.send(chunk);
      }
      addTransceiver(kind, init) {
        this._debug("addTransceiver()");
        if (this.initiator) {
          try {
            this._pc.addTransceiver(kind, init);
            this._needsNegotiation();
          } catch (err) {
            this.destroy(errCode32(err, "ERR_ADD_TRANSCEIVER"));
          }
        } else {
          this.emit("signal", {
            transceiverRequest: { kind, init }
          });
        }
      }
      addStream(stream2) {
        this._debug("addStream()");
        stream2.getTracks().forEach((track) => {
          this.addTrack(track, stream2);
        });
      }
      addTrack(track, stream2) {
        this._debug("addTrack()");
        var submap = this._senderMap.get(track) || new Map();
        var sender = submap.get(stream2);
        if (!sender) {
          sender = this._pc.addTrack(track, stream2);
          submap.set(stream2, sender);
          this._senderMap.set(track, submap);
          this._needsNegotiation();
        } else if (sender.removed) {
          throw errCode32(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
        } else {
          throw errCode32(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
        }
      }
      replaceTrack(oldTrack, newTrack, stream2) {
        this._debug("replaceTrack()");
        var submap = this._senderMap.get(oldTrack);
        var sender = submap ? submap.get(stream2) : null;
        if (!sender) {
          throw errCode32(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
        }
        if (newTrack)
          this._senderMap.set(newTrack, submap);
        if (sender.replaceTrack != null) {
          sender.replaceTrack(newTrack);
        } else {
          this.destroy(errCode32(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
        }
      }
      removeTrack(track, stream2) {
        this._debug("removeSender()");
        var submap = this._senderMap.get(track);
        var sender = submap ? submap.get(stream2) : null;
        if (!sender) {
          throw errCode32(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
        }
        try {
          sender.removed = true;
          this._pc.removeTrack(sender);
        } catch (err) {
          if (err.name === "NS_ERROR_UNEXPECTED") {
            this._sendersAwaitingStable.push(sender);
          } else {
            this.destroy(errCode32(err, "ERR_REMOVE_TRACK"));
          }
        }
        this._needsNegotiation();
      }
      removeStream(stream2) {
        this._debug("removeSenders()");
        stream2.getTracks().forEach((track) => {
          this.removeTrack(track, stream2);
        });
      }
      _needsNegotiation() {
        this._debug("_needsNegotiation");
        if (this._batchedNegotiation)
          return;
        this._batchedNegotiation = true;
        queueMicrotask2(() => {
          this._batchedNegotiation = false;
          this._debug("starting batched negotiation");
          this.negotiate();
        });
      }
      negotiate() {
        if (this.initiator) {
          if (this._isNegotiating) {
            this._queuedNegotiation = true;
            this._debug("already negotiating, queueing");
          } else {
            this._debug("start negotiation");
            setTimeout(() => {
              this._createOffer();
            }, 0);
          }
        } else {
          if (this._isNegotiating) {
            this._queuedNegotiation = true;
            this._debug("already negotiating, queueing");
          } else {
            this._debug("requesting negotiation from initiator");
            this.emit("signal", {
              renegotiate: true
            });
          }
        }
        this._isNegotiating = true;
      }
      _destroy(err, cb) {
        this._debug("destroy (error: %s)", err && (err.message || err));
        this.readable = this.writable = false;
        if (!this._readableState.ended)
          this.push(null);
        if (!this._writableState.finished)
          this.end();
        this._connected = false;
        this._pcReady = false;
        this._channelReady = false;
        this._remoteTracks = null;
        this._remoteStreams = null;
        this._senderMap = null;
        clearInterval(this._closingInterval);
        this._closingInterval = null;
        clearInterval(this._interval);
        this._interval = null;
        this._chunk = null;
        this._cb = null;
        if (this._onFinishBound)
          this.removeListener("finish", this._onFinishBound);
        this._onFinishBound = null;
        if (this._channel) {
          try {
            this._channel.close();
          } catch (err2) {
          }
          this._channel.onmessage = null;
          this._channel.onopen = null;
          this._channel.onclose = null;
          this._channel.onerror = null;
        }
        if (this._pc) {
          try {
            this._pc.close();
          } catch (err2) {
          }
          this._pc.oniceconnectionstatechange = null;
          this._pc.onicegatheringstatechange = null;
          this._pc.onsignalingstatechange = null;
          this._pc.onicecandidate = null;
          this._pc.ontrack = null;
          this._pc.ondatachannel = null;
        }
        this._pc = null;
        this._channel = null;
        cb(err);
      }
      _setupData(event) {
        if (!event.channel) {
          return this.destroy(errCode32(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
        }
        this._channel = event.channel;
        this._channel.binaryType = "arraybuffer";
        if (typeof this._channel.bufferedAmountLowThreshold === "number") {
          this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
        }
        this.channelName = this._channel.label;
        this._channel.onmessage = (event2) => {
          this._onChannelMessage(event2);
        };
        this._channel.onbufferedamountlow = () => {
          this._onChannelBufferedAmountLow();
        };
        this._channel.onopen = () => {
          this._onChannelOpen();
        };
        this._channel.onclose = () => {
          this._onChannelClose();
        };
        this._channel.onerror = (err) => {
          this.destroy(errCode32(err, "ERR_DATA_CHANNEL"));
        };
        var isClosing = false;
        this._closingInterval = setInterval(() => {
          if (this._channel && this._channel.readyState === "closing") {
            if (isClosing)
              this._onChannelClose();
            isClosing = true;
          } else {
            isClosing = false;
          }
        }, CHANNEL_CLOSING_TIMEOUT);
      }
      _read() {
      }
      _write(chunk, encoding, cb) {
        if (this.destroyed)
          return cb(errCode32(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
        if (this._connected) {
          try {
            this.send(chunk);
          } catch (err) {
            return this.destroy(errCode32(err, "ERR_DATA_CHANNEL"));
          }
          if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
            this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
            this._cb = cb;
          } else {
            cb(null);
          }
        } else {
          this._debug("write before connect");
          this._chunk = chunk;
          this._cb = cb;
        }
      }
      _onFinish() {
        if (this.destroyed)
          return;
        const destroySoon = () => {
          setTimeout(() => this.destroy(), 1e3);
        };
        if (this._connected) {
          destroySoon();
        } else {
          this.once("connect", destroySoon);
        }
      }
      _startIceCompleteTimeout() {
        if (this.destroyed)
          return;
        if (this._iceCompleteTimer)
          return;
        this._debug("started iceComplete timeout");
        this._iceCompleteTimer = setTimeout(() => {
          if (!this._iceComplete) {
            this._iceComplete = true;
            this._debug("iceComplete timeout completed");
            this.emit("iceTimeout");
            this.emit("_iceComplete");
          }
        }, this.iceCompleteTimeout);
      }
      _createOffer() {
        if (this.destroyed)
          return;
        this._pc.createOffer(this.offerOptions).then((offer) => {
          if (this.destroyed)
            return;
          if (!this.trickle && !this.allowHalfTrickle)
            offer.sdp = filterTrickle(offer.sdp);
          offer.sdp = this.sdpTransform(offer.sdp);
          const sendOffer = () => {
            if (this.destroyed)
              return;
            var signal = this._pc.localDescription || offer;
            this._debug("signal");
            this.emit("signal", {
              type: signal.type,
              sdp: signal.sdp
            });
          };
          const onSuccess = () => {
            this._debug("createOffer success");
            if (this.destroyed)
              return;
            if (this.trickle || this._iceComplete)
              sendOffer();
            else
              this.once("_iceComplete", sendOffer);
          };
          const onError = (err) => {
            this.destroy(errCode32(err, "ERR_SET_LOCAL_DESCRIPTION"));
          };
          this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
        }).catch((err) => {
          this.destroy(errCode32(err, "ERR_CREATE_OFFER"));
        });
      }
      _requestMissingTransceivers() {
        if (this._pc.getTransceivers) {
          this._pc.getTransceivers().forEach((transceiver) => {
            if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
              transceiver.requested = true;
              this.addTransceiver(transceiver.sender.track.kind);
            }
          });
        }
      }
      _createAnswer() {
        if (this.destroyed)
          return;
        this._pc.createAnswer(this.answerOptions).then((answer) => {
          if (this.destroyed)
            return;
          if (!this.trickle && !this.allowHalfTrickle)
            answer.sdp = filterTrickle(answer.sdp);
          answer.sdp = this.sdpTransform(answer.sdp);
          const sendAnswer = () => {
            if (this.destroyed)
              return;
            var signal = this._pc.localDescription || answer;
            this._debug("signal");
            this.emit("signal", {
              type: signal.type,
              sdp: signal.sdp
            });
            if (!this.initiator)
              this._requestMissingTransceivers();
          };
          const onSuccess = () => {
            if (this.destroyed)
              return;
            if (this.trickle || this._iceComplete)
              sendAnswer();
            else
              this.once("_iceComplete", sendAnswer);
          };
          const onError = (err) => {
            this.destroy(errCode32(err, "ERR_SET_LOCAL_DESCRIPTION"));
          };
          this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
        }).catch((err) => {
          this.destroy(errCode32(err, "ERR_CREATE_ANSWER"));
        });
      }
      _onConnectionStateChange() {
        if (this.destroyed)
          return;
        if (this._pc.connectionState === "failed") {
          this.destroy(errCode32(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
        }
      }
      _onIceStateChange() {
        if (this.destroyed)
          return;
        var iceConnectionState = this._pc.iceConnectionState;
        var iceGatheringState = this._pc.iceGatheringState;
        this._debug("iceStateChange (connection: %s) (gathering: %s)", iceConnectionState, iceGatheringState);
        this.emit("iceStateChange", iceConnectionState, iceGatheringState);
        if (iceConnectionState === "connected" || iceConnectionState === "completed") {
          this._pcReady = true;
          this._maybeReady();
        }
        if (iceConnectionState === "failed") {
          this.destroy(errCode32(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
        }
        if (iceConnectionState === "closed") {
          this.destroy(errCode32(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
        }
      }
      getStats(cb) {
        const flattenValues = (report) => {
          if (Object.prototype.toString.call(report.values) === "[object Array]") {
            report.values.forEach((value) => {
              Object.assign(report, value);
            });
          }
          return report;
        };
        if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
          this._pc.getStats().then((res) => {
            var reports = [];
            res.forEach((report) => {
              reports.push(flattenValues(report));
            });
            cb(null, reports);
          }, (err) => cb(err));
        } else if (this._pc.getStats.length > 0) {
          this._pc.getStats((res) => {
            if (this.destroyed)
              return;
            var reports = [];
            res.result().forEach((result) => {
              var report = {};
              result.names().forEach((name5) => {
                report[name5] = result.stat(name5);
              });
              report.id = result.id;
              report.type = result.type;
              report.timestamp = result.timestamp;
              reports.push(flattenValues(report));
            });
            cb(null, reports);
          }, (err) => cb(err));
        } else {
          cb(null, []);
        }
      }
      _maybeReady() {
        this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
        if (this._connected || this._connecting || !this._pcReady || !this._channelReady)
          return;
        this._connecting = true;
        const findCandidatePair = () => {
          if (this.destroyed)
            return;
          this.getStats((err, items) => {
            if (this.destroyed)
              return;
            if (err)
              items = [];
            var remoteCandidates = {};
            var localCandidates = {};
            var candidatePairs = {};
            var foundSelectedCandidatePair = false;
            items.forEach((item) => {
              if (item.type === "remotecandidate" || item.type === "remote-candidate") {
                remoteCandidates[item.id] = item;
              }
              if (item.type === "localcandidate" || item.type === "local-candidate") {
                localCandidates[item.id] = item;
              }
              if (item.type === "candidatepair" || item.type === "candidate-pair") {
                candidatePairs[item.id] = item;
              }
            });
            const setSelectedCandidatePair = (selectedCandidatePair) => {
              foundSelectedCandidatePair = true;
              var local = localCandidates[selectedCandidatePair.localCandidateId];
              if (local && (local.ip || local.address)) {
                this.localAddress = local.ip || local.address;
                this.localPort = Number(local.port);
              } else if (local && local.ipAddress) {
                this.localAddress = local.ipAddress;
                this.localPort = Number(local.portNumber);
              } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
                local = selectedCandidatePair.googLocalAddress.split(":");
                this.localAddress = local[0];
                this.localPort = Number(local[1]);
              }
              if (this.localAddress) {
                this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
              }
              var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
              if (remote && (remote.ip || remote.address)) {
                this.remoteAddress = remote.ip || remote.address;
                this.remotePort = Number(remote.port);
              } else if (remote && remote.ipAddress) {
                this.remoteAddress = remote.ipAddress;
                this.remotePort = Number(remote.portNumber);
              } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
                remote = selectedCandidatePair.googRemoteAddress.split(":");
                this.remoteAddress = remote[0];
                this.remotePort = Number(remote[1]);
              }
              if (this.remoteAddress) {
                this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
              }
              this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
            };
            items.forEach((item) => {
              if (item.type === "transport" && item.selectedCandidatePairId) {
                setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
              }
              if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
                setSelectedCandidatePair(item);
              }
            });
            if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
              setTimeout(findCandidatePair, 100);
              return;
            } else {
              this._connecting = false;
              this._connected = true;
            }
            if (this._chunk) {
              try {
                this.send(this._chunk);
              } catch (err2) {
                return this.destroy(errCode32(err2, "ERR_DATA_CHANNEL"));
              }
              this._chunk = null;
              this._debug('sent chunk from "write before connect"');
              var cb = this._cb;
              this._cb = null;
              cb(null);
            }
            if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
              this._interval = setInterval(() => this._onInterval(), 150);
              if (this._interval.unref)
                this._interval.unref();
            }
            this._debug("connect");
            this.emit("connect");
          });
        };
        findCandidatePair();
      }
      _onInterval() {
        if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
          return;
        }
        this._onChannelBufferedAmountLow();
      }
      _onSignalingStateChange() {
        if (this.destroyed)
          return;
        if (this._pc.signalingState === "stable" && !this._firstStable) {
          this._isNegotiating = false;
          this._debug("flushing sender queue", this._sendersAwaitingStable);
          this._sendersAwaitingStable.forEach((sender) => {
            this._pc.removeTrack(sender);
            this._queuedNegotiation = true;
          });
          this._sendersAwaitingStable = [];
          if (this._queuedNegotiation) {
            this._debug("flushing negotiation queue");
            this._queuedNegotiation = false;
            this._needsNegotiation();
          }
          this._debug("negotiate");
          this.emit("negotiate");
        }
        this._firstStable = false;
        this._debug("signalingStateChange %s", this._pc.signalingState);
        this.emit("signalingStateChange", this._pc.signalingState);
      }
      _onIceCandidate(event) {
        if (this.destroyed)
          return;
        if (event.candidate && this.trickle) {
          this.emit("signal", {
            candidate: {
              candidate: event.candidate.candidate,
              sdpMLineIndex: event.candidate.sdpMLineIndex,
              sdpMid: event.candidate.sdpMid
            }
          });
        } else if (!event.candidate && !this._iceComplete) {
          this._iceComplete = true;
          this.emit("_iceComplete");
        }
        if (event.candidate) {
          this._startIceCompleteTimeout();
        }
      }
      _onChannelMessage(event) {
        if (this.destroyed)
          return;
        var data = event.data;
        if (data instanceof ArrayBuffer)
          data = new Uint8Array(data);
        this.push(data);
      }
      _onChannelBufferedAmountLow() {
        if (this.destroyed || !this._cb)
          return;
        this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
        var cb = this._cb;
        this._cb = null;
        cb(null);
      }
      _onChannelOpen() {
        if (this._connected || this.destroyed)
          return;
        this._debug("on channel open");
        this._channelReady = true;
        this._maybeReady();
      }
      _onChannelClose() {
        if (this.destroyed)
          return;
        this._debug("on channel close");
        this.destroy();
      }
      _onTrack(event) {
        if (this.destroyed)
          return;
        event.streams.forEach((eventStream) => {
          this._debug("on track");
          this.emit("track", event.track, eventStream);
          this._remoteTracks.push({
            track: event.track,
            stream: eventStream
          });
          if (this._remoteStreams.some((remoteStream) => {
            return remoteStream.id === eventStream.id;
          }))
            return;
          this._remoteStreams.push(eventStream);
          queueMicrotask2(() => {
            this.emit("stream", eventStream);
          });
        });
      }
      _debug() {
        var args = [].slice.call(arguments);
        args[0] = "[" + this._id + "] " + args[0];
        debug17.apply(null, args);
      }
    };
    Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
    Peer.config = {
      iceServers: [
        {
          urls: [
            "stun:stun.l.google.com:19302",
            "stun:global.stun.twilio.com:3478"
          ]
        }
      ],
      sdpSemantics: "unified-plan"
    };
    Peer.channelConfig = {};
    module2.exports = Peer;
  }
});

// node_modules/ipfs-utils/src/supports.js
var require_supports = __commonJS({
  "node_modules/ipfs-utils/src/supports.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {
      supportsFileReader: typeof self !== "undefined" && "FileReader" in self,
      supportsWebRTC: "RTCPeerConnection" in globalThis && (typeof navigator !== "undefined" && typeof navigator.mediaDevices !== "undefined" && "getUserMedia" in navigator.mediaDevices),
      supportsWebRTCDataChannels: "RTCPeerConnection" in globalThis
    };
  }
});

// node_modules/libp2p-webrtc-star/src/constants.js
var require_constants8 = __commonJS({
  "node_modules/libp2p-webrtc-star/src/constants.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.CODE_P2P = 421;
    exports2.CODE_CIRCUIT = 290;
    exports2.CLOSE_TIMEOUT = 2e3;
  }
});

// node_modules/parseuri/index.js
var require_parseuri = __commonJS({
  "node_modules/parseuri/index.js"(exports2, module2) {
    init_node_globals();
    var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    var parts = [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ];
    module2.exports = function parseuri(str) {
      var src2 = str, b = str.indexOf("["), e = str.indexOf("]");
      if (b != -1 && e != -1) {
        str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
      }
      var m = re.exec(str || ""), uri = {}, i = 14;
      while (i--) {
        uri[parts[i]] = m[i] || "";
      }
      if (b != -1 && e != -1) {
        uri.source = src2;
        uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
        uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
        uri.ipv6uri = true;
      }
      uri.pathNames = pathNames(uri, uri["path"]);
      uri.queryKey = queryKey(uri, uri["query"]);
      return uri;
    };
    function pathNames(obj, path) {
      var regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
      if (path.substr(0, 1) == "/" || path.length === 0) {
        names.splice(0, 1);
      }
      if (path.substr(path.length - 1, 1) == "/") {
        names.splice(names.length - 1, 1);
      }
      return names;
    }
    function queryKey(uri, query) {
      var data = {};
      query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
        if ($1) {
          data[$1] = $2;
        }
      });
      return data;
    }
  }
});

// node_modules/socket.io-client/build/cjs/url.js
var require_url = __commonJS({
  "node_modules/socket.io-client/build/cjs/url.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.url = void 0;
    var parseuri_1 = __importDefault(require_parseuri());
    var debug_1 = __importDefault(require_browser2());
    var debug17 = debug_1.default("socket.io-client:url");
    function url(uri, path = "", loc) {
      let obj = uri;
      loc = loc || typeof location !== "undefined" && location;
      if (uri == null)
        uri = loc.protocol + "//" + loc.host;
      if (typeof uri === "string") {
        if (uri.charAt(0) === "/") {
          if (uri.charAt(1) === "/") {
            uri = loc.protocol + uri;
          } else {
            uri = loc.host + uri;
          }
        }
        if (!/^(https?|wss?):\/\//.test(uri)) {
          debug17("protocol-less url %s", uri);
          if (typeof loc !== "undefined") {
            uri = loc.protocol + "//" + uri;
          } else {
            uri = "https://" + uri;
          }
        }
        debug17("parse %s", uri);
        obj = parseuri_1.default(uri);
      }
      if (!obj.port) {
        if (/^(http|ws)$/.test(obj.protocol)) {
          obj.port = "80";
        } else if (/^(http|ws)s$/.test(obj.protocol)) {
          obj.port = "443";
        }
      }
      obj.path = obj.path || "/";
      const ipv6 = obj.host.indexOf(":") !== -1;
      const host = ipv6 ? "[" + obj.host + "]" : obj.host;
      obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
      obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
      return obj;
    }
    exports2.url = url;
  }
});

// node_modules/has-cors/index.js
var require_has_cors = __commonJS({
  "node_modules/has-cors/index.js"(exports2, module2) {
    init_node_globals();
    try {
      module2.exports = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
    } catch (err) {
      module2.exports = false;
    }
  }
});

// node_modules/engine.io-client/build/cjs/globalThis.browser.js
var require_globalThis_browser = __commonJS({
  "node_modules/engine.io-client/build/cjs/globalThis.browser.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = (() => {
      if (typeof self !== "undefined") {
        return self;
      } else if (typeof window !== "undefined") {
        return window;
      } else {
        return Function("return this")();
      }
    })();
  }
});

// node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js
var require_xmlhttprequest_browser = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/xmlhttprequest.browser.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var has_cors_1 = __importDefault(require_has_cors());
    var globalThis_js_1 = __importDefault(require_globalThis_browser());
    function default_1(opts) {
      const xdomain = opts.xdomain;
      try {
        if (typeof XMLHttpRequest !== "undefined" && (!xdomain || has_cors_1.default)) {
          return new XMLHttpRequest();
        }
      } catch (e) {
      }
      if (!xdomain) {
        try {
          return new globalThis_js_1.default[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
        } catch (e) {
        }
      }
    }
    exports2.default = default_1;
  }
});

// node_modules/engine.io-client/build/cjs/util.js
var require_util6 = __commonJS({
  "node_modules/engine.io-client/build/cjs/util.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.installTimerFunctions = exports2.pick = void 0;
    var globalThis_js_1 = __importDefault(require_globalThis_browser());
    function pick(obj, ...attr) {
      return attr.reduce((acc, k) => {
        if (obj.hasOwnProperty(k)) {
          acc[k] = obj[k];
        }
        return acc;
      }, {});
    }
    exports2.pick = pick;
    var NATIVE_SET_TIMEOUT = setTimeout;
    var NATIVE_CLEAR_TIMEOUT = clearTimeout;
    function installTimerFunctions(obj, opts) {
      if (opts.useNativeTimers) {
        obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThis_js_1.default);
        obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThis_js_1.default);
      } else {
        obj.setTimeoutFn = setTimeout.bind(globalThis_js_1.default);
        obj.clearTimeoutFn = clearTimeout.bind(globalThis_js_1.default);
      }
    }
    exports2.installTimerFunctions = installTimerFunctions;
  }
});

// node_modules/@socket.io/component-emitter/index.js
var require_component_emitter = __commonJS({
  "node_modules/@socket.io/component-emitter/index.js"(exports2) {
    init_node_globals();
    exports2.Emitter = Emitter;
    function Emitter(obj) {
      if (obj)
        return mixin(obj);
    }
    function mixin(obj) {
      for (var key in Emitter.prototype) {
        obj[key] = Emitter.prototype[key];
      }
      return obj;
    }
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on() {
        this.off(event, on);
        fn.apply(this, arguments);
      }
      on.fn = fn;
      this.on(event, on);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (arguments.length == 0) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks)
        return this;
      if (arguments.length == 1) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.emitReserved = Emitter.prototype.emit;
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/engine.io-parser/build/cjs/commons.js
var require_commons = __commonJS({
  "node_modules/engine.io-parser/build/cjs/commons.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ERROR_PACKET = exports2.PACKET_TYPES_REVERSE = exports2.PACKET_TYPES = void 0;
    var PACKET_TYPES = Object.create(null);
    exports2.PACKET_TYPES = PACKET_TYPES;
    PACKET_TYPES["open"] = "0";
    PACKET_TYPES["close"] = "1";
    PACKET_TYPES["ping"] = "2";
    PACKET_TYPES["pong"] = "3";
    PACKET_TYPES["message"] = "4";
    PACKET_TYPES["upgrade"] = "5";
    PACKET_TYPES["noop"] = "6";
    var PACKET_TYPES_REVERSE = Object.create(null);
    exports2.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
    Object.keys(PACKET_TYPES).forEach((key) => {
      PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
    });
    var ERROR_PACKET = { type: "error", data: "parser error" };
    exports2.ERROR_PACKET = ERROR_PACKET;
  }
});

// node_modules/engine.io-parser/build/cjs/encodePacket.browser.js
var require_encodePacket_browser = __commonJS({
  "node_modules/engine.io-parser/build/cjs/encodePacket.browser.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commons_js_1 = require_commons();
    var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var isView = (obj) => {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
    };
    var encodePacket = ({ type, data }, supportsBinary, callback) => {
      if (withNativeBlob && data instanceof Blob) {
        if (supportsBinary) {
          return callback(data);
        } else {
          return encodeBlobAsBase64(data, callback);
        }
      } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
        if (supportsBinary) {
          return callback(data);
        } else {
          return encodeBlobAsBase64(new Blob([data]), callback);
        }
      }
      return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
    };
    var encodeBlobAsBase64 = (data, callback) => {
      const fileReader = new FileReader();
      fileReader.onload = function() {
        const content = fileReader.result.split(",")[1];
        callback("b" + content);
      };
      return fileReader.readAsDataURL(data);
    };
    exports2.default = encodePacket;
  }
});

// node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js
var base64_arraybuffer_es5_exports = {};
__export(base64_arraybuffer_es5_exports, {
  decode: () => decode11,
  encode: () => encode9
});
var chars, lookup, i, encode9, decode11;
var init_base64_arraybuffer_es5 = __esm({
  "node_modules/base64-arraybuffer/dist/base64-arraybuffer.es5.js"() {
    init_node_globals();
    chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
    for (i = 0; i < chars.length; i++) {
      lookup[chars.charCodeAt(i)] = i;
    }
    encode9 = function(arraybuffer) {
      var bytes3 = new Uint8Array(arraybuffer), i, len = bytes3.length, base642 = "";
      for (i = 0; i < len; i += 3) {
        base642 += chars[bytes3[i] >> 2];
        base642 += chars[(bytes3[i] & 3) << 4 | bytes3[i + 1] >> 4];
        base642 += chars[(bytes3[i + 1] & 15) << 2 | bytes3[i + 2] >> 6];
        base642 += chars[bytes3[i + 2] & 63];
      }
      if (len % 3 === 2) {
        base642 = base642.substring(0, base642.length - 1) + "=";
      } else if (len % 3 === 1) {
        base642 = base642.substring(0, base642.length - 2) + "==";
      }
      return base642;
    };
    decode11 = function(base642) {
      var bufferLength = base642.length * 0.75, len = base642.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base642[base642.length - 1] === "=") {
        bufferLength--;
        if (base642[base642.length - 2] === "=") {
          bufferLength--;
        }
      }
      var arraybuffer = new ArrayBuffer(bufferLength), bytes3 = new Uint8Array(arraybuffer);
      for (i = 0; i < len; i += 4) {
        encoded1 = lookup[base642.charCodeAt(i)];
        encoded2 = lookup[base642.charCodeAt(i + 1)];
        encoded3 = lookup[base642.charCodeAt(i + 2)];
        encoded4 = lookup[base642.charCodeAt(i + 3)];
        bytes3[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes3[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes3[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
  }
});

// node_modules/engine.io-parser/build/cjs/decodePacket.browser.js
var require_decodePacket_browser = __commonJS({
  "node_modules/engine.io-parser/build/cjs/decodePacket.browser.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var commons_js_1 = require_commons();
    var base64_arraybuffer_1 = (init_base64_arraybuffer_es5(), base64_arraybuffer_es5_exports);
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var decodePacket = (encodedPacket, binaryType) => {
      if (typeof encodedPacket !== "string") {
        return {
          type: "message",
          data: mapBinary(encodedPacket, binaryType)
        };
      }
      const type = encodedPacket.charAt(0);
      if (type === "b") {
        return {
          type: "message",
          data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
        };
      }
      const packetType = commons_js_1.PACKET_TYPES_REVERSE[type];
      if (!packetType) {
        return commons_js_1.ERROR_PACKET;
      }
      return encodedPacket.length > 1 ? {
        type: commons_js_1.PACKET_TYPES_REVERSE[type],
        data: encodedPacket.substring(1)
      } : {
        type: commons_js_1.PACKET_TYPES_REVERSE[type]
      };
    };
    var decodeBase64Packet = (data, binaryType) => {
      if (withNativeArrayBuffer) {
        const decoded = (0, base64_arraybuffer_1.decode)(data);
        return mapBinary(decoded, binaryType);
      } else {
        return { base64: true, data };
      }
    };
    var mapBinary = (data, binaryType) => {
      switch (binaryType) {
        case "blob":
          return data instanceof ArrayBuffer ? new Blob([data]) : data;
        case "arraybuffer":
        default:
          return data;
      }
    };
    exports2.default = decodePacket;
  }
});

// node_modules/engine.io-parser/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/engine.io-parser/build/cjs/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodePayload = exports2.decodePacket = exports2.encodePayload = exports2.encodePacket = exports2.protocol = void 0;
    var encodePacket_js_1 = require_encodePacket_browser();
    exports2.encodePacket = encodePacket_js_1.default;
    var decodePacket_js_1 = require_decodePacket_browser();
    exports2.decodePacket = decodePacket_js_1.default;
    var SEPARATOR = String.fromCharCode(30);
    var encodePayload = (packets, callback) => {
      const length4 = packets.length;
      const encodedPackets = new Array(length4);
      let count = 0;
      packets.forEach((packet, i) => {
        (0, encodePacket_js_1.default)(packet, false, (encodedPacket) => {
          encodedPackets[i] = encodedPacket;
          if (++count === length4) {
            callback(encodedPackets.join(SEPARATOR));
          }
        });
      });
    };
    exports2.encodePayload = encodePayload;
    var decodePayload = (encodedPayload, binaryType) => {
      const encodedPackets = encodedPayload.split(SEPARATOR);
      const packets = [];
      for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = (0, decodePacket_js_1.default)(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
          break;
        }
      }
      return packets;
    };
    exports2.decodePayload = decodePayload;
    exports2.protocol = 4;
  }
});

// node_modules/engine.io-client/build/cjs/transport.js
var require_transport = __commonJS({
  "node_modules/engine.io-client/build/cjs/transport.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Transport = void 0;
    var engine_io_parser_1 = require_cjs();
    var component_emitter_1 = require_component_emitter();
    var util_js_1 = require_util6();
    var debug_1 = __importDefault(require_browser2());
    var debug17 = (0, debug_1.default)("engine.io-client:transport");
    var Transport = class extends component_emitter_1.Emitter {
      constructor(opts) {
        super();
        this.writable = false;
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.readyState = "";
        this.socket = opts.socket;
      }
      onError(msg, desc) {
        const err = new Error(msg);
        err.type = "TransportError";
        err.description = desc;
        super.emit("error", err);
        return this;
      }
      open() {
        if (this.readyState === "closed" || this.readyState === "") {
          this.readyState = "opening";
          this.doOpen();
        }
        return this;
      }
      close() {
        if (this.readyState === "opening" || this.readyState === "open") {
          this.doClose();
          this.onClose();
        }
        return this;
      }
      send(packets) {
        if (this.readyState === "open") {
          this.write(packets);
        } else {
          debug17("transport is not open, discarding packets");
        }
      }
      onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emit("open");
      }
      onData(data) {
        const packet = (0, engine_io_parser_1.decodePacket)(data, this.socket.binaryType);
        this.onPacket(packet);
      }
      onPacket(packet) {
        super.emit("packet", packet);
      }
      onClose() {
        this.readyState = "closed";
        super.emit("close");
      }
    };
    exports2.Transport = Transport;
  }
});

// node_modules/yeast/index.js
var require_yeast = __commonJS({
  "node_modules/yeast/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
    var length4 = 64;
    var map8 = {};
    var seed = 0;
    var i = 0;
    var prev;
    function encode10(num) {
      var encoded = "";
      do {
        encoded = alphabet[num % length4] + encoded;
        num = Math.floor(num / length4);
      } while (num > 0);
      return encoded;
    }
    function decode12(str) {
      var decoded = 0;
      for (i = 0; i < str.length; i++) {
        decoded = decoded * length4 + map8[str.charAt(i)];
      }
      return decoded;
    }
    function yeast() {
      var now = encode10(+new Date());
      if (now !== prev)
        return seed = 0, prev = now;
      return now + "." + encode10(seed++);
    }
    for (; i < length4; i++)
      map8[alphabet[i]] = i;
    yeast.encode = encode10;
    yeast.decode = decode12;
    module2.exports = yeast;
  }
});

// node_modules/parseqs/index.js
var require_parseqs = __commonJS({
  "node_modules/parseqs/index.js"(exports2) {
    init_node_globals();
    exports2.encode = function(obj) {
      var str = "";
      for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
          if (str.length)
            str += "&";
          str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
        }
      }
      return str;
    };
    exports2.decode = function(qs) {
      var qry = {};
      var pairs = qs.split("&");
      for (var i = 0, l = pairs.length; i < l; i++) {
        var pair = pairs[i].split("=");
        qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
      }
      return qry;
    };
  }
});

// node_modules/engine.io-client/build/cjs/transports/polling.js
var require_polling = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/polling.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Polling = void 0;
    var transport_js_1 = require_transport();
    var debug_1 = __importDefault(require_browser2());
    var yeast_1 = __importDefault(require_yeast());
    var parseqs_1 = __importDefault(require_parseqs());
    var engine_io_parser_1 = require_cjs();
    var debug17 = (0, debug_1.default)("engine.io-client:polling");
    var Polling = class extends transport_js_1.Transport {
      constructor() {
        super(...arguments);
        this.polling = false;
      }
      get name() {
        return "polling";
      }
      doOpen() {
        this.poll();
      }
      pause(onPause) {
        this.readyState = "pausing";
        const pause = () => {
          debug17("paused");
          this.readyState = "paused";
          onPause();
        };
        if (this.polling || !this.writable) {
          let total = 0;
          if (this.polling) {
            debug17("we are currently polling - waiting to pause");
            total++;
            this.once("pollComplete", function() {
              debug17("pre-pause polling complete");
              --total || pause();
            });
          }
          if (!this.writable) {
            debug17("we are currently writing - waiting to pause");
            total++;
            this.once("drain", function() {
              debug17("pre-pause writing complete");
              --total || pause();
            });
          }
        } else {
          pause();
        }
      }
      poll() {
        debug17("polling");
        this.polling = true;
        this.doPoll();
        this.emit("poll");
      }
      onData(data) {
        debug17("polling got data %s", data);
        const callback = (packet) => {
          if (this.readyState === "opening" && packet.type === "open") {
            this.onOpen();
          }
          if (packet.type === "close") {
            this.onClose();
            return false;
          }
          this.onPacket(packet);
        };
        (0, engine_io_parser_1.decodePayload)(data, this.socket.binaryType).forEach(callback);
        if (this.readyState !== "closed") {
          this.polling = false;
          this.emit("pollComplete");
          if (this.readyState === "open") {
            this.poll();
          } else {
            debug17('ignoring poll - transport state "%s"', this.readyState);
          }
        }
      }
      doClose() {
        const close = () => {
          debug17("writing close packet");
          this.write([{ type: "close" }]);
        };
        if (this.readyState === "open") {
          debug17("transport open - closing");
          close();
        } else {
          debug17("transport not open - deferring close");
          this.once("open", close);
        }
      }
      write(packets) {
        this.writable = false;
        (0, engine_io_parser_1.encodePayload)(packets, (data) => {
          this.doWrite(data, () => {
            this.writable = true;
            this.emit("drain");
          });
        });
      }
      uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "https" : "http";
        let port = "";
        if (this.opts.timestampRequests !== false) {
          query[this.opts.timestampParam] = (0, yeast_1.default)();
        }
        if (!this.supportsBinary && !query.sid) {
          query.b64 = 1;
        }
        if (this.opts.port && (schema === "https" && Number(this.opts.port) !== 443 || schema === "http" && Number(this.opts.port) !== 80)) {
          port = ":" + this.opts.port;
        }
        const encodedQuery = parseqs_1.default.encode(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
      }
    };
    exports2.Polling = Polling;
  }
});

// node_modules/engine.io-client/build/cjs/transports/polling-xhr.js
var require_polling_xhr = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/polling-xhr.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Request = exports2.XHR = void 0;
    var xmlhttprequest_js_1 = __importDefault(require_xmlhttprequest_browser());
    var debug_1 = __importDefault(require_browser2());
    var globalThis_js_1 = __importDefault(require_globalThis_browser());
    var util_js_1 = require_util6();
    var component_emitter_1 = require_component_emitter();
    var polling_js_1 = require_polling();
    var debug17 = (0, debug_1.default)("engine.io-client:polling-xhr");
    function empty2() {
    }
    var hasXHR2 = function() {
      const xhr = new xmlhttprequest_js_1.default({
        xdomain: false
      });
      return xhr.responseType != null;
    }();
    var XHR = class extends polling_js_1.Polling {
      constructor(opts) {
        super(opts);
        if (typeof location !== "undefined") {
          const isSSL = location.protocol === "https:";
          let port = location.port;
          if (!port) {
            port = isSSL ? "443" : "80";
          }
          this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
          this.xs = opts.secure !== isSSL;
        }
        const forceBase64 = opts && opts.forceBase64;
        this.supportsBinary = hasXHR2 && !forceBase64;
      }
      request(opts = {}) {
        Object.assign(opts, { xd: this.xd, xs: this.xs }, this.opts);
        return new Request(this.uri(), opts);
      }
      doWrite(data, fn) {
        const req = this.request({
          method: "POST",
          data
        });
        req.on("success", fn);
        req.on("error", (err) => {
          this.onError("xhr post error", err);
        });
      }
      doPoll() {
        debug17("xhr poll");
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (err) => {
          this.onError("xhr poll error", err);
        });
        this.pollXhr = req;
      }
    };
    exports2.XHR = XHR;
    var Request = class extends component_emitter_1.Emitter {
      constructor(uri, opts) {
        super();
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.opts = opts;
        this.method = opts.method || "GET";
        this.uri = uri;
        this.async = opts.async !== false;
        this.data = opts.data !== void 0 ? opts.data : null;
        this.create();
      }
      create() {
        const opts = (0, util_js_1.pick)(this.opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this.opts.xd;
        opts.xscheme = !!this.opts.xs;
        const xhr = this.xhr = new xmlhttprequest_js_1.default(opts);
        try {
          debug17("xhr open %s: %s", this.method, this.uri);
          xhr.open(this.method, this.uri, this.async);
          try {
            if (this.opts.extraHeaders) {
              xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
              for (let i in this.opts.extraHeaders) {
                if (this.opts.extraHeaders.hasOwnProperty(i)) {
                  xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
                }
              }
            }
          } catch (e) {
          }
          if (this.method === "POST") {
            try {
              xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            } catch (e) {
            }
          }
          try {
            xhr.setRequestHeader("Accept", "*/*");
          } catch (e) {
          }
          if ("withCredentials" in xhr) {
            xhr.withCredentials = this.opts.withCredentials;
          }
          if (this.opts.requestTimeout) {
            xhr.timeout = this.opts.requestTimeout;
          }
          xhr.onreadystatechange = () => {
            if (xhr.readyState !== 4)
              return;
            if (xhr.status === 200 || xhr.status === 1223) {
              this.onLoad();
            } else {
              this.setTimeoutFn(() => {
                this.onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };
          debug17("xhr data %s", this.data);
          xhr.send(this.data);
        } catch (e) {
          this.setTimeoutFn(() => {
            this.onError(e);
          }, 0);
          return;
        }
        if (typeof document !== "undefined") {
          this.index = Request.requestsCount++;
          Request.requests[this.index] = this;
        }
      }
      onSuccess() {
        this.emit("success");
        this.cleanup();
      }
      onData(data) {
        this.emit("data", data);
        this.onSuccess();
      }
      onError(err) {
        this.emit("error", err);
        this.cleanup(true);
      }
      cleanup(fromError) {
        if (typeof this.xhr === "undefined" || this.xhr === null) {
          return;
        }
        this.xhr.onreadystatechange = empty2;
        if (fromError) {
          try {
            this.xhr.abort();
          } catch (e) {
          }
        }
        if (typeof document !== "undefined") {
          delete Request.requests[this.index];
        }
        this.xhr = null;
      }
      onLoad() {
        const data = this.xhr.responseText;
        if (data !== null) {
          this.onData(data);
        }
      }
      abort() {
        this.cleanup();
      }
    };
    exports2.Request = Request;
    Request.requestsCount = 0;
    Request.requests = {};
    if (typeof document !== "undefined") {
      if (typeof attachEvent === "function") {
        attachEvent("onunload", unloadHandler);
      } else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globalThis_js_1.default ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
      }
    }
    function unloadHandler() {
      for (let i in Request.requests) {
        if (Request.requests.hasOwnProperty(i)) {
          Request.requests[i].abort();
        }
      }
    }
  }
});

// node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js
var require_websocket_constructor_browser = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/websocket-constructor.browser.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.defaultBinaryType = exports2.usingBrowserWebSocket = exports2.WebSocket = exports2.nextTick = void 0;
    var globalThis_js_1 = __importDefault(require_globalThis_browser());
    exports2.nextTick = (() => {
      const isPromiseAvailable = typeof Promise === "function" && typeof Promise.resolve === "function";
      if (isPromiseAvailable) {
        return (cb) => Promise.resolve().then(cb);
      } else {
        return (cb, setTimeoutFn) => setTimeoutFn(cb, 0);
      }
    })();
    exports2.WebSocket = globalThis_js_1.default.WebSocket || globalThis_js_1.default.MozWebSocket;
    exports2.usingBrowserWebSocket = true;
    exports2.defaultBinaryType = "arraybuffer";
  }
});

// node_modules/engine.io-client/build/cjs/transports/websocket.js
var require_websocket = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/websocket.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WS = void 0;
    var transport_js_1 = require_transport();
    var parseqs_1 = __importDefault(require_parseqs());
    var yeast_1 = __importDefault(require_yeast());
    var util_js_1 = require_util6();
    var websocket_constructor_js_1 = require_websocket_constructor_browser();
    var debug_1 = __importDefault(require_browser2());
    var engine_io_parser_1 = require_cjs();
    var debug17 = (0, debug_1.default)("engine.io-client:websocket");
    var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
    var WS2 = class extends transport_js_1.Transport {
      constructor(opts) {
        super(opts);
        this.supportsBinary = !opts.forceBase64;
      }
      get name() {
        return "websocket";
      }
      doOpen() {
        if (!this.check()) {
          return;
        }
        const uri = this.uri();
        const protocols = this.opts.protocols;
        const opts = isReactNative ? {} : (0, util_js_1.pick)(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
          opts.headers = this.opts.extraHeaders;
        }
        try {
          this.ws = websocket_constructor_js_1.usingBrowserWebSocket && !isReactNative ? protocols ? new websocket_constructor_js_1.WebSocket(uri, protocols) : new websocket_constructor_js_1.WebSocket(uri) : new websocket_constructor_js_1.WebSocket(uri, protocols, opts);
        } catch (err) {
          return this.emit("error", err);
        }
        this.ws.binaryType = this.socket.binaryType || websocket_constructor_js_1.defaultBinaryType;
        this.addEventListeners();
      }
      addEventListeners() {
        this.ws.onopen = () => {
          if (this.opts.autoUnref) {
            this.ws._socket.unref();
          }
          this.onOpen();
        };
        this.ws.onclose = this.onClose.bind(this);
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e) => this.onError("websocket error", e);
      }
      write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
          const packet = packets[i];
          const lastPacket = i === packets.length - 1;
          (0, engine_io_parser_1.encodePacket)(packet, this.supportsBinary, (data) => {
            const opts = {};
            if (!websocket_constructor_js_1.usingBrowserWebSocket) {
              if (packet.options) {
                opts.compress = packet.options.compress;
              }
              if (this.opts.perMessageDeflate) {
                const len = typeof data === "string" ? Buffer.byteLength(data) : data.length;
                if (len < this.opts.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }
            try {
              if (websocket_constructor_js_1.usingBrowserWebSocket) {
                this.ws.send(data);
              } else {
                this.ws.send(data, opts);
              }
            } catch (e) {
              debug17("websocket closed before onclose event");
            }
            if (lastPacket) {
              (0, websocket_constructor_js_1.nextTick)(() => {
                this.writable = true;
                this.emit("drain");
              }, this.setTimeoutFn);
            }
          });
        }
      }
      doClose() {
        if (typeof this.ws !== "undefined") {
          this.ws.close();
          this.ws = null;
        }
      }
      uri() {
        let query = this.query || {};
        const schema = this.opts.secure ? "wss" : "ws";
        let port = "";
        if (this.opts.port && (schema === "wss" && Number(this.opts.port) !== 443 || schema === "ws" && Number(this.opts.port) !== 80)) {
          port = ":" + this.opts.port;
        }
        if (this.opts.timestampRequests) {
          query[this.opts.timestampParam] = (0, yeast_1.default)();
        }
        if (!this.supportsBinary) {
          query.b64 = 1;
        }
        const encodedQuery = parseqs_1.default.encode(query);
        const ipv6 = this.opts.hostname.indexOf(":") !== -1;
        return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + (encodedQuery.length ? "?" + encodedQuery : "");
      }
      check() {
        return !!websocket_constructor_js_1.WebSocket && !("__initialize" in websocket_constructor_js_1.WebSocket && this.name === WS2.prototype.name);
      }
    };
    exports2.WS = WS2;
  }
});

// node_modules/engine.io-client/build/cjs/transports/index.js
var require_transports = __commonJS({
  "node_modules/engine.io-client/build/cjs/transports/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.transports = void 0;
    var polling_xhr_js_1 = require_polling_xhr();
    var websocket_js_1 = require_websocket();
    exports2.transports = {
      websocket: websocket_js_1.WS,
      polling: polling_xhr_js_1.XHR
    };
  }
});

// node_modules/engine.io-client/build/cjs/socket.js
var require_socket = __commonJS({
  "node_modules/engine.io-client/build/cjs/socket.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Socket = void 0;
    var index_js_1 = require_transports();
    var util_js_1 = require_util6();
    var parseqs_1 = __importDefault(require_parseqs());
    var parseuri_1 = __importDefault(require_parseuri());
    var debug_1 = __importDefault(require_browser2());
    var component_emitter_1 = require_component_emitter();
    var engine_io_parser_1 = require_cjs();
    var debug17 = (0, debug_1.default)("engine.io-client:socket");
    var Socket = class extends component_emitter_1.Emitter {
      constructor(uri, opts = {}) {
        super();
        if (uri && typeof uri === "object") {
          opts = uri;
          uri = null;
        }
        if (uri) {
          uri = (0, parseuri_1.default)(uri);
          opts.hostname = uri.host;
          opts.secure = uri.protocol === "https" || uri.protocol === "wss";
          opts.port = uri.port;
          if (uri.query)
            opts.query = uri.query;
        } else if (opts.host) {
          opts.hostname = (0, parseuri_1.default)(opts.host).host;
        }
        (0, util_js_1.installTimerFunctions)(this, opts);
        this.secure = opts.secure != null ? opts.secure : typeof location !== "undefined" && location.protocol === "https:";
        if (opts.hostname && !opts.port) {
          opts.port = this.secure ? "443" : "80";
        }
        this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
        this.transports = opts.transports || ["polling", "websocket"];
        this.readyState = "";
        this.writeBuffer = [];
        this.prevBufferLen = 0;
        this.opts = Object.assign({
          path: "/engine.io",
          agent: false,
          withCredentials: false,
          upgrade: true,
          timestampParam: "t",
          rememberUpgrade: false,
          rejectUnauthorized: true,
          perMessageDeflate: {
            threshold: 1024
          },
          transportOptions: {},
          closeOnBeforeunload: true
        }, opts);
        this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
        if (typeof this.opts.query === "string") {
          this.opts.query = parseqs_1.default.decode(this.opts.query);
        }
        this.id = null;
        this.upgrades = null;
        this.pingInterval = null;
        this.pingTimeout = null;
        this.pingTimeoutTimer = null;
        if (typeof addEventListener === "function") {
          if (this.opts.closeOnBeforeunload) {
            addEventListener("beforeunload", () => {
              if (this.transport) {
                this.transport.removeAllListeners();
                this.transport.close();
              }
            }, false);
          }
          if (this.hostname !== "localhost") {
            this.offlineEventListener = () => {
              this.onClose("transport close");
            };
            addEventListener("offline", this.offlineEventListener, false);
          }
        }
        this.open();
      }
      createTransport(name5) {
        debug17('creating transport "%s"', name5);
        const query = clone(this.opts.query);
        query.EIO = engine_io_parser_1.protocol;
        query.transport = name5;
        if (this.id)
          query.sid = this.id;
        const opts = Object.assign({}, this.opts.transportOptions[name5], this.opts, {
          query,
          socket: this,
          hostname: this.hostname,
          secure: this.secure,
          port: this.port
        });
        debug17("options: %j", opts);
        return new index_js_1.transports[name5](opts);
      }
      open() {
        let transport;
        if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
          transport = "websocket";
        } else if (this.transports.length === 0) {
          this.setTimeoutFn(() => {
            this.emitReserved("error", "No transports available");
          }, 0);
          return;
        } else {
          transport = this.transports[0];
        }
        this.readyState = "opening";
        try {
          transport = this.createTransport(transport);
        } catch (e) {
          debug17("error while creating transport: %s", e);
          this.transports.shift();
          this.open();
          return;
        }
        transport.open();
        this.setTransport(transport);
      }
      setTransport(transport) {
        debug17("setting transport %s", transport.name);
        if (this.transport) {
          debug17("clearing existing transport %s", this.transport.name);
          this.transport.removeAllListeners();
        }
        this.transport = transport;
        transport.on("drain", this.onDrain.bind(this)).on("packet", this.onPacket.bind(this)).on("error", this.onError.bind(this)).on("close", () => {
          this.onClose("transport close");
        });
      }
      probe(name5) {
        debug17('probing transport "%s"', name5);
        let transport = this.createTransport(name5);
        let failed = false;
        Socket.priorWebsocketSuccess = false;
        const onTransportOpen = () => {
          if (failed)
            return;
          debug17('probe transport "%s" opened', name5);
          transport.send([{ type: "ping", data: "probe" }]);
          transport.once("packet", (msg) => {
            if (failed)
              return;
            if (msg.type === "pong" && msg.data === "probe") {
              debug17('probe transport "%s" pong', name5);
              this.upgrading = true;
              this.emitReserved("upgrading", transport);
              if (!transport)
                return;
              Socket.priorWebsocketSuccess = transport.name === "websocket";
              debug17('pausing current transport "%s"', this.transport.name);
              this.transport.pause(() => {
                if (failed)
                  return;
                if (this.readyState === "closed")
                  return;
                debug17("changing transport and sending upgrade packet");
                cleanup();
                this.setTransport(transport);
                transport.send([{ type: "upgrade" }]);
                this.emitReserved("upgrade", transport);
                transport = null;
                this.upgrading = false;
                this.flush();
              });
            } else {
              debug17('probe transport "%s" failed', name5);
              const err = new Error("probe error");
              err.transport = transport.name;
              this.emitReserved("upgradeError", err);
            }
          });
        };
        function freezeTransport() {
          if (failed)
            return;
          failed = true;
          cleanup();
          transport.close();
          transport = null;
        }
        const onerror = (err) => {
          const error = new Error("probe error: " + err);
          error.transport = transport.name;
          freezeTransport();
          debug17('probe transport "%s" failed because of error: %s', name5, err);
          this.emitReserved("upgradeError", error);
        };
        function onTransportClose() {
          onerror("transport closed");
        }
        function onclose() {
          onerror("socket closed");
        }
        function onupgrade(to) {
          if (transport && to.name !== transport.name) {
            debug17('"%s" works - aborting "%s"', to.name, transport.name);
            freezeTransport();
          }
        }
        const cleanup = () => {
          transport.removeListener("open", onTransportOpen);
          transport.removeListener("error", onerror);
          transport.removeListener("close", onTransportClose);
          this.off("close", onclose);
          this.off("upgrading", onupgrade);
        };
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        transport.open();
      }
      onOpen() {
        debug17("socket open");
        this.readyState = "open";
        Socket.priorWebsocketSuccess = this.transport.name === "websocket";
        this.emitReserved("open");
        this.flush();
        if (this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
          debug17("starting upgrade probes");
          let i = 0;
          const l = this.upgrades.length;
          for (; i < l; i++) {
            this.probe(this.upgrades[i]);
          }
        }
      }
      onPacket(packet) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
          debug17('socket receive: type "%s", data "%s"', packet.type, packet.data);
          this.emitReserved("packet", packet);
          this.emitReserved("heartbeat");
          switch (packet.type) {
            case "open":
              this.onHandshake(JSON.parse(packet.data));
              break;
            case "ping":
              this.resetPingTimeout();
              this.sendPacket("pong");
              this.emitReserved("ping");
              this.emitReserved("pong");
              break;
            case "error":
              const err = new Error("server error");
              err.code = packet.data;
              this.onError(err);
              break;
            case "message":
              this.emitReserved("data", packet.data);
              this.emitReserved("message", packet.data);
              break;
          }
        } else {
          debug17('packet received with socket readyState "%s"', this.readyState);
        }
      }
      onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this.upgrades = this.filterUpgrades(data.upgrades);
        this.pingInterval = data.pingInterval;
        this.pingTimeout = data.pingTimeout;
        this.onOpen();
        if (this.readyState === "closed")
          return;
        this.resetPingTimeout();
      }
      resetPingTimeout() {
        this.clearTimeoutFn(this.pingTimeoutTimer);
        this.pingTimeoutTimer = this.setTimeoutFn(() => {
          this.onClose("ping timeout");
        }, this.pingInterval + this.pingTimeout);
        if (this.opts.autoUnref) {
          this.pingTimeoutTimer.unref();
        }
      }
      onDrain() {
        this.writeBuffer.splice(0, this.prevBufferLen);
        this.prevBufferLen = 0;
        if (this.writeBuffer.length === 0) {
          this.emitReserved("drain");
        } else {
          this.flush();
        }
      }
      flush() {
        if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
          debug17("flushing %d packets in socket", this.writeBuffer.length);
          this.transport.send(this.writeBuffer);
          this.prevBufferLen = this.writeBuffer.length;
          this.emitReserved("flush");
        }
      }
      write(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }
      send(msg, options, fn) {
        this.sendPacket("message", msg, options, fn);
        return this;
      }
      sendPacket(type, data, options, fn) {
        if (typeof data === "function") {
          fn = data;
          data = void 0;
        }
        if (typeof options === "function") {
          fn = options;
          options = null;
        }
        if (this.readyState === "closing" || this.readyState === "closed") {
          return;
        }
        options = options || {};
        options.compress = options.compress !== false;
        const packet = {
          type,
          data,
          options
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn)
          this.once("flush", fn);
        this.flush();
      }
      close() {
        const close = () => {
          this.onClose("forced close");
          debug17("socket closing - telling transport to close");
          this.transport.close();
        };
        const cleanupAndClose = () => {
          this.off("upgrade", cleanupAndClose);
          this.off("upgradeError", cleanupAndClose);
          close();
        };
        const waitForUpgrade = () => {
          this.once("upgrade", cleanupAndClose);
          this.once("upgradeError", cleanupAndClose);
        };
        if (this.readyState === "opening" || this.readyState === "open") {
          this.readyState = "closing";
          if (this.writeBuffer.length) {
            this.once("drain", () => {
              if (this.upgrading) {
                waitForUpgrade();
              } else {
                close();
              }
            });
          } else if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        }
        return this;
      }
      onError(err) {
        debug17("socket error %j", err);
        Socket.priorWebsocketSuccess = false;
        this.emitReserved("error", err);
        this.onClose("transport error", err);
      }
      onClose(reason, desc) {
        if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
          debug17('socket close with reason: "%s"', reason);
          this.clearTimeoutFn(this.pingTimeoutTimer);
          this.transport.removeAllListeners("close");
          this.transport.close();
          this.transport.removeAllListeners();
          if (typeof removeEventListener === "function") {
            removeEventListener("offline", this.offlineEventListener, false);
          }
          this.readyState = "closed";
          this.id = null;
          this.emitReserved("close", reason, desc);
          this.writeBuffer = [];
          this.prevBufferLen = 0;
        }
      }
      filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        let i = 0;
        const j = upgrades.length;
        for (; i < j; i++) {
          if (~this.transports.indexOf(upgrades[i]))
            filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
      }
    };
    exports2.Socket = Socket;
    Socket.protocol = engine_io_parser_1.protocol;
    function clone(obj) {
      const o = {};
      for (let i in obj) {
        if (obj.hasOwnProperty(i)) {
          o[i] = obj[i];
        }
      }
      return o;
    }
  }
});

// node_modules/engine.io-client/build/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/engine.io-client/build/cjs/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.installTimerFunctions = exports2.transports = exports2.Transport = exports2.protocol = exports2.Socket = void 0;
    var socket_js_1 = require_socket();
    Object.defineProperty(exports2, "Socket", { enumerable: true, get: function() {
      return socket_js_1.Socket;
    } });
    exports2.protocol = socket_js_1.Socket.protocol;
    var transport_js_1 = require_transport();
    Object.defineProperty(exports2, "Transport", { enumerable: true, get: function() {
      return transport_js_1.Transport;
    } });
    var index_js_1 = require_transports();
    Object.defineProperty(exports2, "transports", { enumerable: true, get: function() {
      return index_js_1.transports;
    } });
    var util_js_1 = require_util6();
    Object.defineProperty(exports2, "installTimerFunctions", { enumerable: true, get: function() {
      return util_js_1.installTimerFunctions;
    } });
  }
});

// node_modules/socket.io-parser/build/cjs/is-binary.js
var require_is_binary = __commonJS({
  "node_modules/socket.io-parser/build/cjs/is-binary.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasBinary = exports2.isBinary = void 0;
    var withNativeArrayBuffer = typeof ArrayBuffer === "function";
    var isView = (obj) => {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
    };
    var toString4 = Object.prototype.toString;
    var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString4.call(Blob) === "[object BlobConstructor]";
    var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString4.call(File) === "[object FileConstructor]";
    function isBinary2(obj) {
      return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
    }
    exports2.isBinary = isBinary2;
    function hasBinary(obj, toJSON) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      if (Array.isArray(obj)) {
        for (let i = 0, l = obj.length; i < l; i++) {
          if (hasBinary(obj[i])) {
            return true;
          }
        }
        return false;
      }
      if (isBinary2(obj)) {
        return true;
      }
      if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
        return hasBinary(obj.toJSON(), true);
      }
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
          return true;
        }
      }
      return false;
    }
    exports2.hasBinary = hasBinary;
  }
});

// node_modules/socket.io-parser/build/cjs/binary.js
var require_binary = __commonJS({
  "node_modules/socket.io-parser/build/cjs/binary.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.reconstructPacket = exports2.deconstructPacket = void 0;
    var is_binary_js_1 = require_is_binary();
    function deconstructPacket(packet) {
      const buffers = [];
      const packetData = packet.data;
      const pack = packet;
      pack.data = _deconstructPacket(packetData, buffers);
      pack.attachments = buffers.length;
      return { packet: pack, buffers };
    }
    exports2.deconstructPacket = deconstructPacket;
    function _deconstructPacket(data, buffers) {
      if (!data)
        return data;
      if (is_binary_js_1.isBinary(data)) {
        const placeholder = { _placeholder: true, num: buffers.length };
        buffers.push(data);
        return placeholder;
      } else if (Array.isArray(data)) {
        const newData = new Array(data.length);
        for (let i = 0; i < data.length; i++) {
          newData[i] = _deconstructPacket(data[i], buffers);
        }
        return newData;
      } else if (typeof data === "object" && !(data instanceof Date)) {
        const newData = {};
        for (const key in data) {
          if (data.hasOwnProperty(key)) {
            newData[key] = _deconstructPacket(data[key], buffers);
          }
        }
        return newData;
      }
      return data;
    }
    function reconstructPacket(packet, buffers) {
      packet.data = _reconstructPacket(packet.data, buffers);
      packet.attachments = void 0;
      return packet;
    }
    exports2.reconstructPacket = reconstructPacket;
    function _reconstructPacket(data, buffers) {
      if (!data)
        return data;
      if (data && data._placeholder) {
        return buffers[data.num];
      } else if (Array.isArray(data)) {
        for (let i = 0; i < data.length; i++) {
          data[i] = _reconstructPacket(data[i], buffers);
        }
      } else if (typeof data === "object") {
        for (const key in data) {
          if (data.hasOwnProperty(key)) {
            data[key] = _reconstructPacket(data[key], buffers);
          }
        }
      }
      return data;
    }
  }
});

// node_modules/socket.io-parser/build/cjs/index.js
var require_cjs3 = __commonJS({
  "node_modules/socket.io-parser/build/cjs/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Decoder = exports2.Encoder = exports2.PacketType = exports2.protocol = void 0;
    var component_emitter_1 = require_component_emitter();
    var binary_js_1 = require_binary();
    var is_binary_js_1 = require_is_binary();
    var debug_1 = require_browser2();
    var debug17 = debug_1.default("socket.io-parser");
    exports2.protocol = 5;
    var PacketType;
    (function(PacketType2) {
      PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
      PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
      PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
      PacketType2[PacketType2["ACK"] = 3] = "ACK";
      PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
      PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
      PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
    })(PacketType = exports2.PacketType || (exports2.PacketType = {}));
    var Encoder2 = class {
      encode(obj) {
        debug17("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
          if (is_binary_js_1.hasBinary(obj)) {
            obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
            return this.encodeAsBinary(obj);
          }
        }
        return [this.encodeAsString(obj)];
      }
      encodeAsString(obj) {
        let str = "" + obj.type;
        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
          str += obj.attachments + "-";
        }
        if (obj.nsp && obj.nsp !== "/") {
          str += obj.nsp + ",";
        }
        if (obj.id != null) {
          str += obj.id;
        }
        if (obj.data != null) {
          str += JSON.stringify(obj.data);
        }
        debug17("encoded %j as %s", obj, str);
        return str;
      }
      encodeAsBinary(obj) {
        const deconstruction = binary_js_1.deconstructPacket(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack);
        return buffers;
      }
    };
    exports2.Encoder = Encoder2;
    var Decoder2 = class extends component_emitter_1.Emitter {
      constructor() {
        super();
      }
      add(obj) {
        let packet;
        if (typeof obj === "string") {
          packet = this.decodeString(obj);
          if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
            this.reconstructor = new BinaryReconstructor(packet);
            if (packet.attachments === 0) {
              super.emitReserved("decoded", packet);
            }
          } else {
            super.emitReserved("decoded", packet);
          }
        } else if (is_binary_js_1.isBinary(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error("got binary data when not reconstructing a packet");
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              this.reconstructor = null;
              super.emitReserved("decoded", packet);
            }
          }
        } else {
          throw new Error("Unknown type: " + obj);
        }
      }
      decodeString(str) {
        let i = 0;
        const p = {
          type: Number(str.charAt(0))
        };
        if (PacketType[p.type] === void 0) {
          throw new Error("unknown packet type " + p.type);
        }
        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
          const start = i + 1;
          while (str.charAt(++i) !== "-" && i != str.length) {
          }
          const buf2 = str.substring(start, i);
          if (buf2 != Number(buf2) || str.charAt(i) !== "-") {
            throw new Error("Illegal attachments");
          }
          p.attachments = Number(buf2);
        }
        if (str.charAt(i + 1) === "/") {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if (c === ",")
              break;
            if (i === str.length)
              break;
          }
          p.nsp = str.substring(start, i);
        } else {
          p.nsp = "/";
        }
        const next = str.charAt(i + 1);
        if (next !== "" && Number(next) == next) {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if (c == null || Number(c) != c) {
              --i;
              break;
            }
            if (i === str.length)
              break;
          }
          p.id = Number(str.substring(start, i + 1));
        }
        if (str.charAt(++i)) {
          const payload = tryParse(str.substr(i));
          if (Decoder2.isPayloadValid(p.type, payload)) {
            p.data = payload;
          } else {
            throw new Error("invalid payload");
          }
        }
        debug17("decoded %s as %j", str, p);
        return p;
      }
      static isPayloadValid(type, payload) {
        switch (type) {
          case PacketType.CONNECT:
            return typeof payload === "object";
          case PacketType.DISCONNECT:
            return payload === void 0;
          case PacketType.CONNECT_ERROR:
            return typeof payload === "string" || typeof payload === "object";
          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            return Array.isArray(payload) && payload.length > 0;
          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            return Array.isArray(payload);
        }
      }
      destroy() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
        }
      }
    };
    exports2.Decoder = Decoder2;
    function tryParse(str) {
      try {
        return JSON.parse(str);
      } catch (e) {
        return false;
      }
    }
    var BinaryReconstructor = class {
      constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
      }
      takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
          const packet = binary_js_1.reconstructPacket(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      }
      finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
      }
    };
  }
});

// node_modules/socket.io-client/build/cjs/on.js
var require_on = __commonJS({
  "node_modules/socket.io-client/build/cjs/on.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.on = void 0;
    function on(obj, ev, fn) {
      obj.on(ev, fn);
      return function subDestroy() {
        obj.off(ev, fn);
      };
    }
    exports2.on = on;
  }
});

// node_modules/socket.io-client/build/cjs/socket.js
var require_socket2 = __commonJS({
  "node_modules/socket.io-client/build/cjs/socket.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Socket = void 0;
    var socket_io_parser_1 = require_cjs3();
    var on_js_1 = require_on();
    var component_emitter_1 = require_component_emitter();
    var debug_1 = __importDefault(require_browser2());
    var debug17 = debug_1.default("socket.io-client:socket");
    var RESERVED_EVENTS = Object.freeze({
      connect: 1,
      connect_error: 1,
      disconnect: 1,
      disconnecting: 1,
      newListener: 1,
      removeListener: 1
    });
    var Socket = class extends component_emitter_1.Emitter {
      constructor(io, nsp, opts) {
        super();
        this.connected = false;
        this.disconnected = true;
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this.ids = 0;
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
          this.auth = opts.auth;
        }
        if (this.io._autoConnect)
          this.open();
      }
      subEvents() {
        if (this.subs)
          return;
        const io = this.io;
        this.subs = [
          on_js_1.on(io, "open", this.onopen.bind(this)),
          on_js_1.on(io, "packet", this.onpacket.bind(this)),
          on_js_1.on(io, "error", this.onerror.bind(this)),
          on_js_1.on(io, "close", this.onclose.bind(this))
        ];
      }
      get active() {
        return !!this.subs;
      }
      connect() {
        if (this.connected)
          return this;
        this.subEvents();
        if (!this.io["_reconnecting"])
          this.io.open();
        if (this.io._readyState === "open")
          this.onopen();
        return this;
      }
      open() {
        return this.connect();
      }
      send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
      }
      emit(ev, ...args) {
        if (RESERVED_EVENTS.hasOwnProperty(ev)) {
          throw new Error('"' + ev + '" is a reserved event name');
        }
        args.unshift(ev);
        const packet = {
          type: socket_io_parser_1.PacketType.EVENT,
          data: args
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        if (typeof args[args.length - 1] === "function") {
          debug17("emitting packet with ack id %d", this.ids);
          this.acks[this.ids] = args.pop();
          packet.id = this.ids++;
        }
        const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
        const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
        if (discardPacket) {
          debug17("discard packet as the transport is not currently writable");
        } else if (this.connected) {
          this.packet(packet);
        } else {
          this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
      }
      packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
      }
      onopen() {
        debug17("transport is open - connecting");
        if (typeof this.auth == "function") {
          this.auth((data) => {
            this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data });
          });
        } else {
          this.packet({ type: socket_io_parser_1.PacketType.CONNECT, data: this.auth });
        }
      }
      onerror(err) {
        if (!this.connected) {
          this.emitReserved("connect_error", err);
        }
      }
      onclose(reason) {
        debug17("close (%s)", reason);
        this.connected = false;
        this.disconnected = true;
        delete this.id;
        this.emitReserved("disconnect", reason);
      }
      onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace)
          return;
        switch (packet.type) {
          case socket_io_parser_1.PacketType.CONNECT:
            if (packet.data && packet.data.sid) {
              const id = packet.data.sid;
              this.onconnect(id);
            } else {
              this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
            }
            break;
          case socket_io_parser_1.PacketType.EVENT:
            this.onevent(packet);
            break;
          case socket_io_parser_1.PacketType.BINARY_EVENT:
            this.onevent(packet);
            break;
          case socket_io_parser_1.PacketType.ACK:
            this.onack(packet);
            break;
          case socket_io_parser_1.PacketType.BINARY_ACK:
            this.onack(packet);
            break;
          case socket_io_parser_1.PacketType.DISCONNECT:
            this.ondisconnect();
            break;
          case socket_io_parser_1.PacketType.CONNECT_ERROR:
            const err = new Error(packet.data.message);
            err.data = packet.data.data;
            this.emitReserved("connect_error", err);
            break;
        }
      }
      onevent(packet) {
        const args = packet.data || [];
        debug17("emitting event %j", args);
        if (packet.id != null) {
          debug17("attaching ack callback to event");
          args.push(this.ack(packet.id));
        }
        if (this.connected) {
          this.emitEvent(args);
        } else {
          this.receiveBuffer.push(Object.freeze(args));
        }
      }
      emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
          const listeners = this._anyListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, args);
          }
        }
        super.emit.apply(this, args);
      }
      ack(id) {
        const self2 = this;
        let sent = false;
        return function(...args) {
          if (sent)
            return;
          sent = true;
          debug17("sending ack %j", args);
          self2.packet({
            type: socket_io_parser_1.PacketType.ACK,
            id,
            data: args
          });
        };
      }
      onack(packet) {
        const ack = this.acks[packet.id];
        if (typeof ack === "function") {
          debug17("calling ack %s with %j", packet.id, packet.data);
          ack.apply(this, packet.data);
          delete this.acks[packet.id];
        } else {
          debug17("bad ack %s", packet.id);
        }
      }
      onconnect(id) {
        debug17("socket connected with id %s", id);
        this.id = id;
        this.connected = true;
        this.disconnected = false;
        this.emitBuffered();
        this.emitReserved("connect");
      }
      emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => this.packet(packet));
        this.sendBuffer = [];
      }
      ondisconnect() {
        debug17("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
      }
      destroy() {
        if (this.subs) {
          this.subs.forEach((subDestroy) => subDestroy());
          this.subs = void 0;
        }
        this.io["_destroy"](this);
      }
      disconnect() {
        if (this.connected) {
          debug17("performing disconnect (%s)", this.nsp);
          this.packet({ type: socket_io_parser_1.PacketType.DISCONNECT });
        }
        this.destroy();
        if (this.connected) {
          this.onclose("io client disconnect");
        }
        return this;
      }
      close() {
        return this.disconnect();
      }
      compress(compress) {
        this.flags.compress = compress;
        return this;
      }
      get volatile() {
        this.flags.volatile = true;
        return this;
      }
      onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
      }
      prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
      }
      offAny(listener) {
        if (!this._anyListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyListeners;
          for (let i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyListeners = [];
        }
        return this;
      }
      listenersAny() {
        return this._anyListeners || [];
      }
    };
    exports2.Socket = Socket;
  }
});

// node_modules/backo2/index.js
var require_backo2 = __commonJS({
  "node_modules/backo2/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = Backoff;
    function Backoff(opts) {
      opts = opts || {};
      this.ms = opts.min || 100;
      this.max = opts.max || 1e4;
      this.factor = opts.factor || 2;
      this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
      this.attempts = 0;
    }
    Backoff.prototype.duration = function() {
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };
    Backoff.prototype.reset = function() {
      this.attempts = 0;
    };
    Backoff.prototype.setMin = function(min) {
      this.ms = min;
    };
    Backoff.prototype.setMax = function(max) {
      this.max = max;
    };
    Backoff.prototype.setJitter = function(jitter) {
      this.jitter = jitter;
    };
  }
});

// node_modules/socket.io-client/build/cjs/manager.js
var require_manager = __commonJS({
  "node_modules/socket.io-client/build/cjs/manager.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Manager = void 0;
    var engine_io_client_1 = require_cjs2();
    var socket_js_1 = require_socket2();
    var parser = __importStar(require_cjs3());
    var on_js_1 = require_on();
    var backo2_1 = __importDefault(require_backo2());
    var component_emitter_1 = require_component_emitter();
    var debug_1 = __importDefault(require_browser2());
    var debug17 = debug_1.default("socket.io-client:manager");
    var Manager = class extends component_emitter_1.Emitter {
      constructor(uri, opts) {
        var _a;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && typeof uri === "object") {
          opts = uri;
          uri = void 0;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        engine_io_client_1.installTimerFunctions(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1e3);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
        this.randomizationFactor((_a = opts.randomizationFactor) !== null && _a !== void 0 ? _a : 0.5);
        this.backoff = new backo2_1.default({
          min: this.reconnectionDelay(),
          max: this.reconnectionDelayMax(),
          jitter: this.randomizationFactor()
        });
        this.timeout(opts.timeout == null ? 2e4 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || parser;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect)
          this.open();
      }
      reconnection(v) {
        if (!arguments.length)
          return this._reconnection;
        this._reconnection = !!v;
        return this;
      }
      reconnectionAttempts(v) {
        if (v === void 0)
          return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
      }
      reconnectionDelay(v) {
        var _a;
        if (v === void 0)
          return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
        return this;
      }
      randomizationFactor(v) {
        var _a;
        if (v === void 0)
          return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
        return this;
      }
      reconnectionDelayMax(v) {
        var _a;
        if (v === void 0)
          return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
        return this;
      }
      timeout(v) {
        if (!arguments.length)
          return this._timeout;
        this._timeout = v;
        return this;
      }
      maybeReconnectOnOpen() {
        if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
          this.reconnect();
        }
      }
      open(fn) {
        debug17("readyState %s", this._readyState);
        if (~this._readyState.indexOf("open"))
          return this;
        debug17("opening %s", this.uri);
        this.engine = new engine_io_client_1.Socket(this.uri, this.opts);
        const socket = this.engine;
        const self2 = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        const openSubDestroy = on_js_1.on(socket, "open", function() {
          self2.onopen();
          fn && fn();
        });
        const errorSub = on_js_1.on(socket, "error", (err) => {
          debug17("error");
          self2.cleanup();
          self2._readyState = "closed";
          this.emitReserved("error", err);
          if (fn) {
            fn(err);
          } else {
            self2.maybeReconnectOnOpen();
          }
        });
        if (this._timeout !== false) {
          const timeout = this._timeout;
          debug17("connect attempt will timeout after %d", timeout);
          if (timeout === 0) {
            openSubDestroy();
          }
          const timer = this.setTimeoutFn(() => {
            debug17("connect attempt timed out after %d", timeout);
            openSubDestroy();
            socket.close();
            socket.emit("error", new Error("timeout"));
          }, timeout);
          if (this.opts.autoUnref) {
            timer.unref();
          }
          this.subs.push(function subDestroy() {
            clearTimeout(timer);
          });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
      }
      connect(fn) {
        return this.open(fn);
      }
      onopen() {
        debug17("open");
        this.cleanup();
        this._readyState = "open";
        this.emitReserved("open");
        const socket = this.engine;
        this.subs.push(on_js_1.on(socket, "ping", this.onping.bind(this)), on_js_1.on(socket, "data", this.ondata.bind(this)), on_js_1.on(socket, "error", this.onerror.bind(this)), on_js_1.on(socket, "close", this.onclose.bind(this)), on_js_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
      }
      onping() {
        this.emitReserved("ping");
      }
      ondata(data) {
        this.decoder.add(data);
      }
      ondecoded(packet) {
        this.emitReserved("packet", packet);
      }
      onerror(err) {
        debug17("error", err);
        this.emitReserved("error", err);
      }
      socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
          socket = new socket_js_1.Socket(this, nsp, opts);
          this.nsps[nsp] = socket;
        }
        return socket;
      }
      _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
          const socket2 = this.nsps[nsp];
          if (socket2.active) {
            debug17("socket %s is still active, skipping close", nsp);
            return;
          }
        }
        this._close();
      }
      _packet(packet) {
        debug17("writing packet %j", packet);
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
          this.engine.write(encodedPackets[i], packet.options);
        }
      }
      cleanup() {
        debug17("cleanup");
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
      }
      _close() {
        debug17("disconnect");
        this.skipReconnect = true;
        this._reconnecting = false;
        if (this._readyState === "opening") {
          this.cleanup();
        }
        this.backoff.reset();
        this._readyState = "closed";
        if (this.engine)
          this.engine.close();
      }
      disconnect() {
        return this._close();
      }
      onclose(reason) {
        debug17("onclose");
        this.cleanup();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason);
        if (this._reconnection && !this.skipReconnect) {
          this.reconnect();
        }
      }
      reconnect() {
        if (this._reconnecting || this.skipReconnect)
          return this;
        const self2 = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
          debug17("reconnect failed");
          this.backoff.reset();
          this.emitReserved("reconnect_failed");
          this._reconnecting = false;
        } else {
          const delay = this.backoff.duration();
          debug17("will wait %dms before reconnect attempt", delay);
          this._reconnecting = true;
          const timer = this.setTimeoutFn(() => {
            if (self2.skipReconnect)
              return;
            debug17("attempting reconnect");
            this.emitReserved("reconnect_attempt", self2.backoff.attempts);
            if (self2.skipReconnect)
              return;
            self2.open((err) => {
              if (err) {
                debug17("reconnect attempt error");
                self2._reconnecting = false;
                self2.reconnect();
                this.emitReserved("reconnect_error", err);
              } else {
                debug17("reconnect success");
                self2.onreconnect();
              }
            });
          }, delay);
          if (this.opts.autoUnref) {
            timer.unref();
          }
          this.subs.push(function subDestroy() {
            clearTimeout(timer);
          });
        }
      }
      onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
      }
    };
    exports2.Manager = Manager;
  }
});

// node_modules/socket.io-client/build/cjs/index.js
var require_cjs4 = __commonJS({
  "node_modules/socket.io-client/build/cjs/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.connect = exports2.io = exports2.Socket = exports2.Manager = exports2.protocol = void 0;
    var url_js_1 = require_url();
    var manager_js_1 = require_manager();
    Object.defineProperty(exports2, "Manager", { enumerable: true, get: function() {
      return manager_js_1.Manager;
    } });
    var socket_js_1 = require_socket2();
    Object.defineProperty(exports2, "Socket", { enumerable: true, get: function() {
      return socket_js_1.Socket;
    } });
    var debug_1 = __importDefault(require_browser2());
    var debug17 = debug_1.default("socket.io-client");
    var cache2 = {};
    function lookup2(uri, opts) {
      if (typeof uri === "object") {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      const parsed = url_js_1.url(uri, opts.path || "/socket.io");
      const source = parsed.source;
      const id = parsed.id;
      const path = parsed.path;
      const sameNamespace = cache2[id] && path in cache2[id]["nsps"];
      const newConnection = opts.forceNew || opts["force new connection"] || opts.multiplex === false || sameNamespace;
      let io;
      if (newConnection) {
        debug17("ignoring socket cache for %s", source);
        io = new manager_js_1.Manager(source, opts);
      } else {
        if (!cache2[id]) {
          debug17("new io instance for %s", source);
          cache2[id] = new manager_js_1.Manager(source, opts);
        }
        io = cache2[id];
      }
      if (parsed.query && !opts.query) {
        opts.query = parsed.queryKey;
      }
      return io.socket(parsed.path, opts);
    }
    exports2.io = lookup2;
    exports2.connect = lookup2;
    var socket_io_parser_1 = require_cjs3();
    Object.defineProperty(exports2, "protocol", { enumerable: true, get: function() {
      return socket_io_parser_1.protocol;
    } });
  }
});

// node_modules/stream-to-it/sink.js
var require_sink2 = __commonJS({
  "node_modules/stream-to-it/sink.js"(exports2, module2) {
    init_node_globals();
    var getIterator = require_get_iterator();
    module2.exports = (writable) => async (source) => {
      source = getIterator(source);
      const maybeEndSource = (source2) => {
        if (typeof source2.return === "function")
          source2.return();
      };
      let error = null;
      let errCb = null;
      const errorHandler2 = (err) => {
        error = err;
        if (errCb)
          errCb(err);
        maybeEndSource(source);
      };
      let closeCb = null;
      let closed = false;
      const closeHandler = () => {
        closed = true;
        if (closeCb)
          closeCb();
      };
      let finishCb = null;
      let finished = false;
      const finishHandler = () => {
        finished = true;
        if (finishCb)
          finishCb();
      };
      let drainCb = null;
      const drainHandler = () => {
        if (drainCb)
          drainCb();
      };
      const waitForDrainOrClose = () => {
        return new Promise((resolve6, reject) => {
          closeCb = drainCb = resolve6;
          errCb = reject;
          writable.once("drain", drainHandler);
        });
      };
      const waitForDone = () => {
        maybeEndSource(source);
        return new Promise((resolve6, reject) => {
          if (closed || finished || error)
            return resolve6();
          finishCb = closeCb = resolve6;
          errCb = reject;
        });
      };
      const cleanup = () => {
        writable.removeListener("error", errorHandler2);
        writable.removeListener("close", closeHandler);
        writable.removeListener("finish", finishHandler);
        writable.removeListener("drain", drainHandler);
      };
      writable.once("error", errorHandler2);
      writable.once("close", closeHandler);
      writable.once("finish", finishHandler);
      try {
        for await (const value of source) {
          if (!writable.writable || writable.destroyed || error)
            break;
          if (writable.write(value) === false) {
            await waitForDrainOrClose();
          }
        }
      } catch (err) {
        if (!error) {
          writable.destroy();
        }
        error = err;
      }
      try {
        if (writable.writable) {
          writable.end();
        }
        await waitForDone();
        if (error)
          throw error;
      } finally {
        cleanup();
      }
    };
  }
});

// node_modules/stream-to-it/duplex.js
var require_duplex2 = __commonJS({
  "node_modules/stream-to-it/duplex.js"(exports2, module2) {
    init_node_globals();
    var toSink = require_sink2();
    var toSource = require_source();
    module2.exports = (duplex) => ({ sink: toSink(duplex), source: toSource(duplex) });
  }
});

// node_modules/stream-to-it/transform.js
var require_transform = __commonJS({
  "node_modules/stream-to-it/transform.js"(exports2, module2) {
    init_node_globals();
    var toDuplex = require_duplex2();
    module2.exports = (transform) => async function* (source) {
      const duplex = toDuplex(transform);
      let sinkError;
      duplex.sink(source).catch((err) => {
        sinkError = err;
      });
      yield* duplex.source;
      if (sinkError)
        throw sinkError;
    };
  }
});

// node_modules/stream-to-it/index.js
var require_stream_to_it = __commonJS({
  "node_modules/stream-to-it/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = require_source();
    module2.exports.source = require_source();
    module2.exports.sink = require_sink2();
    module2.exports.transform = require_transform();
    module2.exports.duplex = require_duplex2();
  }
});

// node_modules/libp2p-webrtc-star/src/socket-to-conn.js
var require_socket_to_conn2 = __commonJS({
  "node_modules/libp2p-webrtc-star/src/socket-to-conn.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var abortable = require_abortable_iterator();
    var toIterable2 = require_stream_to_it();
    var { CLOSE_TIMEOUT } = require_constants8();
    var toMultiaddr = require_ip_port_to_multiaddr();
    var debug17 = require_browser2();
    var log15 = debug17("libp2p:webrtc-star:socket");
    log15.error = debug17("libp2p:webrtc-star:socket:error");
    var toWebrtcMultiaddr = (address, port) => {
      if (!address || !port)
        return void 0;
      try {
        return toMultiaddr(address, port);
      } catch (err) {
        log15.error(err);
        return toMultiaddr("0.0.0.0", port);
      }
    };
    module2.exports = (socket, options = {}) => {
      const { sink, source } = toIterable2.duplex(socket);
      const remoteAddr = options.remoteAddr || toWebrtcMultiaddr(socket.remoteAddress, socket.remotePort);
      const localAddr = toWebrtcMultiaddr(socket.localAddress, socket.localPort);
      const maConn = {
        async sink(source2) {
          if (options.signal) {
            source2 = abortable(source2, options.signal);
          }
          try {
            await sink(async function* () {
              for await (const chunk of source2) {
                yield chunk instanceof Uint8Array ? chunk : chunk.slice();
              }
            }());
          } catch (err) {
            if (err.type !== "aborted") {
              log15.error(err);
            }
          }
        },
        source: options.signal ? abortable(source, options.signal) : source,
        conn: socket,
        localAddr,
        remoteAddr,
        timeline: { open: Date.now() },
        close() {
          if (socket.destroyed)
            return;
          return new Promise((resolve6, reject) => {
            const start = Date.now();
            const timeout = setTimeout(() => {
              if (maConn.remoteAddr) {
                const { host, port } = maConn.remoteAddr.toOptions();
                log15("timeout closing socket to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
              }
              if (!socket.destroyed) {
                socket.destroy();
              }
            }, CLOSE_TIMEOUT);
            socket.once("close", () => {
              resolve6();
            });
            socket.end((err) => {
              clearTimeout(timeout);
              maConn.timeline.close = Date.now();
              if (err)
                return reject(err);
            });
          });
        }
      };
      socket.once("close", () => {
        if (!maConn.timeline.close) {
          maConn.timeline.close = Date.now();
        }
      });
      return maConn;
    };
  }
});

// node_modules/libp2p-webrtc-star/src/utils.js
var require_utils13 = __commonJS({
  "node_modules/libp2p-webrtc-star/src/utils.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { Multiaddr: Multiaddr18 } = require_src();
    function cleanUrlSIO(ma) {
      const maStrSplit = ma.toString().split("/");
      const tcpProto = ma.protos()[1].name;
      const wsProto = ma.protos()[2].name;
      const tcpPort = ma.stringTuples()[1][1];
      if (tcpProto !== "tcp" || wsProto !== "ws" && wsProto !== "wss") {
        throw new Error("invalid multiaddr: " + ma.toString());
      }
      if (!Multiaddr18.isName(ma)) {
        return "http://" + maStrSplit[2] + ":" + maStrSplit[4];
      }
      if (wsProto === "ws") {
        return "http://" + maStrSplit[2] + (tcpPort === "80" ? "" : ":" + tcpPort);
      }
      if (wsProto === "wss") {
        return "https://" + maStrSplit[2] + (tcpPort === "443" ? "" : ":" + tcpPort);
      }
    }
    function cleanMultiaddr(maStr) {
      const legacy = "/libp2p-webrtc-star";
      if (maStr.indexOf(legacy) !== -1) {
        maStr = maStr.substring(legacy.length, maStr.length);
        let ma = new Multiaddr18(maStr);
        const tuppleIPFS = ma.stringTuples().filter((tupple) => {
          return tupple[0] === 421;
        })[0];
        ma = ma.decapsulate("p2p");
        ma = ma.encapsulate("/p2p-webrtc-star");
        ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`);
        maStr = ma.toString();
      }
      return maStr;
    }
    module2.exports = {
      cleanUrlSIO,
      cleanMultiaddr
    };
  }
});

// node_modules/libp2p-webrtc-star/src/listener.js
var require_listener = __commonJS({
  "node_modules/libp2p-webrtc-star/src/listener.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var EventEmitter4 = require_events();
    var debug17 = require_browser2();
    var log15 = debug17("libp2p:webrtc-star:listener");
    log15.error = debug17("libp2p:webrtc-star:listener:error");
    var errCode32 = require_err_code();
    var io = require_cjs4();
    var SimplePeer = require_libp2p_webrtc_peer();
    var pDefer = require_p_defer();
    var toConnection = require_socket_to_conn2();
    var { cleanUrlSIO } = require_utils13();
    var { CODE_P2P } = require_constants8();
    var sioOptions = {
      transports: ["websocket"],
      "force new connection": true,
      path: "/socket.io-next/"
    };
    module2.exports = ({ handler, upgrader }, WebRTCStar2, options = {}) => {
      const listener = new EventEmitter4();
      let listeningAddr;
      let signallingUrl;
      listener.__connections = [];
      listener.__spChannels = new Map();
      listener.__pendingIntents = new Map();
      listener.listen = (ma) => {
        if (listeningAddr) {
          throw errCode32(new Error("listener already in use"), "ERR_ALREADY_LISTENING");
        }
        const defer = pDefer();
        listeningAddr = ma;
        let signallingAddr;
        if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {
          signallingAddr = ma.encapsulate(`/p2p/${upgrader.localPeer.toB58String()}`);
        } else {
          signallingAddr = ma;
        }
        listener.on("error", () => defer.reject());
        signallingUrl = cleanUrlSIO(ma);
        log15("Dialing to Signalling Server on: " + signallingUrl);
        listener.io = io.connect(signallingUrl, sioOptions);
        const incomingDial = (offer) => {
          if (offer.answer || offer.err || !offer.intentId) {
            return;
          }
          const intentId = offer.intentId;
          let pendings = listener.__pendingIntents.get(intentId);
          if (!pendings) {
            pendings = [];
            listener.__pendingIntents.set(intentId, pendings);
          }
          let channel = listener.__spChannels.get(intentId);
          if (channel) {
            channel.signal(offer.signal);
            return;
          } else if (offer.signal.type !== "offer") {
            pendings.push(offer);
            return;
          }
          const spOptions = {
            trickle: false,
            ...options
          };
          if (WebRTCStar2.wrtc) {
            spOptions.wrtc = WebRTCStar2.wrtc;
          }
          channel = new SimplePeer(spOptions);
          const onError = (err) => {
            log15.error("incoming connection errored", err);
          };
          channel.on("error", onError);
          channel.once("close", (...args) => {
            channel.removeListener("error", onError);
          });
          channel.on("signal", (signal) => {
            offer.signal = signal;
            offer.answer = true;
            listener.io.emit("ss-handshake", offer);
          });
          channel.signal(offer.signal);
          for (const pendingOffer of pendings) {
            channel.signal(pendingOffer.signal);
          }
          listener.__pendingIntents.set(intentId, []);
          channel.once("connect", async () => {
            const maConn = toConnection(channel);
            log15("new inbound connection %s", maConn.remoteAddr);
            let conn;
            try {
              conn = await upgrader.upgradeInbound(maConn);
            } catch (err) {
              log15.error("inbound connection failed to upgrade", err);
              return maConn.close();
            }
            if (!conn.remoteAddr) {
              try {
                conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toB58String()}`);
              } catch (err) {
                log15.error("could not determine remote address", err);
              }
            }
            log15("inbound connection %s upgraded", maConn.remoteAddr);
            trackConn(listener, maConn, intentId);
            listener.emit("connection", conn);
            handler(conn);
          });
          listener.__spChannels.set(intentId, channel);
        };
        listener.io.once("connect_error", (err) => defer.reject(err));
        listener.io.once("error", (err) => {
          listener.emit("error", err);
          listener.emit("close");
        });
        listener.io.on("ws-handshake", incomingDial);
        listener.io.on("ws-peer", WebRTCStar2._peerDiscovered);
        listener.io.on("connect", () => {
          listener.io.emit("ss-join", signallingAddr.toString());
        });
        listener.io.once("connect", () => {
          listener.emit("listening");
          defer.resolve();
        });
        WebRTCStar2.sigReferences.set(signallingUrl, {
          listener,
          signallingAddr
        });
        return defer.promise;
      };
      listener.close = async () => {
        const ref = WebRTCStar2.sigReferences.get(signallingUrl);
        if (ref && ref.listener.io) {
          ref.listener.io.emit("ss-leave");
          ref.listener.io.close();
        }
        await Promise.all(listener.__connections.map((maConn) => maConn.close()));
        listener.emit("close");
        listener.removeAllListeners();
        listeningAddr = void 0;
        WebRTCStar2.sigReferences.delete(signallingUrl);
      };
      listener.getAddrs = () => {
        return [listeningAddr];
      };
      return listener;
    };
    function trackConn(listener, maConn, intentId) {
      listener.__connections.push(maConn);
      const untrackConn = () => {
        listener.__connections = listener.__connections.filter((c) => c !== maConn);
        listener.__spChannels.delete(intentId);
        listener.__pendingIntents.delete(intentId);
      };
      maConn.conn.once("close", untrackConn);
    }
  }
});

// node_modules/libp2p-webrtc-star/src/index.js
var require_src18 = __commonJS({
  "node_modules/libp2p-webrtc-star/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = debug17("libp2p:webrtc-star");
    log15.error = debug17("libp2p:webrtc-star:error");
    var { EventEmitter: EventEmitter4 } = require_events();
    var errcode7 = require_err_code();
    var withIs = require_class_is();
    var { AbortError } = require_abortable_iterator();
    var SimplePeer = require_libp2p_webrtc_peer();
    var { supportsWebRTCDataChannels: webrtcSupport } = require_supports();
    var { Multiaddr: Multiaddr18 } = require_src();
    var mafmt = require_src2();
    var PeerId2 = require_src6();
    var { CODE_CIRCUIT } = require_constants8();
    var createListener = require_listener();
    var toConnection = require_socket_to_conn2();
    var { cleanMultiaddr, cleanUrlSIO } = require_utils13();
    function noop2() {
    }
    var WebRTCStar2 = class {
      constructor(options = {}) {
        if (!options.upgrader) {
          throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");
        }
        this._upgrader = options.upgrader;
        this.sioOptions = {
          transports: ["websocket"],
          "force new connection": true
        };
        if (options.wrtc) {
          this.wrtc = options.wrtc;
        }
        this.sigReferences = new Map();
        this.discovery = new EventEmitter4();
        this.discovery.tag = "webRTCStar";
        this.discovery._isStarted = false;
        this.discovery.start = () => {
          this.discovery._isStarted = true;
        };
        this.discovery.stop = () => {
          this.discovery._isStarted = false;
        };
        this._peerDiscovered = this._peerDiscovered.bind(this);
      }
      async dial(ma, options = {}) {
        const rawConn = await this._connect(ma, options);
        const maConn = toConnection(rawConn, { remoteAddr: ma, signal: options.signal });
        log15("new outbound connection %s", maConn.remoteAddr);
        const conn = await this._upgrader.upgradeOutbound(maConn);
        log15("outbound connection %s upgraded", maConn.remoteAddr);
        return conn;
      }
      _connect(ma, options = {}) {
        if (options.signal && options.signal.aborted) {
          throw new AbortError();
        }
        const spOptions = {
          initiator: true,
          trickle: false,
          ...options.spOptions || {}
        };
        if (this.wrtc) {
          spOptions.wrtc = this.wrtc;
        }
        const cOpts = ma.toOptions();
        const intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now();
        return new Promise((resolve6, reject) => {
          const sio = this.sigReferences.get(cleanUrlSIO(ma));
          if (!sio || !sio.listener) {
            return reject(errcode7(new Error("unknown signal server to use"), "ERR_UNKNOWN_SIGNAL_SERVER"));
          }
          const sioClient = sio.listener.io;
          const start = Date.now();
          let connected;
          log15("dialing %s:%s", cOpts.host, cOpts.port);
          const channel = new SimplePeer(spOptions);
          const onError = (err) => {
            if (!connected) {
              const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err.message}`;
              log15.error(msg);
              done(err);
            }
          };
          const onTimeout = () => {
            log15("connnection timeout %s:%s", cOpts.host, cOpts.port);
            const err = errcode7(new Error(`connection timeout after ${Date.now() - start}ms`), "ERR_CONNECT_TIMEOUT");
            channel.emit("error", err);
          };
          const onConnect = () => {
            connected = true;
            log15("connection opened %s:%s", cOpts.host, cOpts.port);
            done(null);
          };
          const onAbort = () => {
            log15.error("connection aborted %s:%s", cOpts.host, cOpts.port);
            channel.destroy();
            done(new AbortError());
          };
          const done = (err) => {
            channel.removeListener("timeout", onTimeout);
            channel.removeListener("connect", onConnect);
            options.signal && options.signal.removeEventListener("abort", onAbort);
            err ? reject(err) : resolve6(channel);
          };
          channel.on("error", onError);
          channel.once("timeout", onTimeout);
          channel.once("connect", onConnect);
          channel.on("close", () => {
            channel.removeListener("error", onError);
          });
          options.signal && options.signal.addEventListener("abort", onAbort);
          channel.on("signal", (signal) => {
            sioClient.emit("ss-handshake", {
              intentId,
              srcMultiaddr: sio.signallingAddr.toString(),
              dstMultiaddr: ma.toString(),
              signal
            });
          });
          sioClient.on("ws-handshake", (offer) => {
            if (offer.intentId === intentId && offer.err) {
              channel.destroy();
              reject(errcode7(offer.err instanceof Error ? offer.err : new Error(offer.err), "ERR_SIGNALLING_FAILED"));
            }
            if (offer.intentId !== intentId || !offer.answer || channel.destroyed) {
              return;
            }
            channel.signal(offer.signal);
          });
        });
      }
      createListener(options = {}, handler) {
        if (!webrtcSupport && !this.wrtc) {
          throw errcode7(new Error("no WebRTC support"), "ERR_NO_WEBRTC_SUPPORT");
        }
        if (typeof options === "function") {
          handler = options;
          options = {};
        }
        handler = handler || noop2;
        return createListener({ handler, upgrader: this._upgrader }, this, options);
      }
      filter(multiaddrs) {
        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
        return multiaddrs.filter((ma) => {
          if (ma.protoCodes().includes(CODE_CIRCUIT)) {
            return false;
          }
          return mafmt.WebRTCStar.matches(ma);
        });
      }
      _peerDiscovered(maStr) {
        if (!this.discovery._isStarted)
          return;
        log15("Peer Discovered:", maStr);
        maStr = cleanMultiaddr(maStr);
        const ma = new Multiaddr18(maStr);
        const peerId = PeerId2.createFromB58String(ma.getPeerId());
        this.discovery.emit("peer", {
          id: peerId,
          multiaddrs: [ma]
        });
      }
    };
    module2.exports = withIs(WebRTCStar2, { className: "WebRTCStar", symbolName: "@libp2p/js-libp2p-webrtc-star/webrtcstar" });
  }
});

// node_modules/libp2p-mplex/src/coder/encode.browser.js
var require_encode_browser = __commonJS({
  "node_modules/libp2p-mplex/src/coder/encode.browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var varint7 = require_varint();
    var BufferList3 = require_BufferList();
    var POOL_SIZE = 10 * 1024;
    var Encoder2 = class {
      constructor() {
        this._pool = new Uint8Array(POOL_SIZE);
        this._poolOffset = 0;
      }
      write(msg) {
        const pool = this._pool;
        let offset = this._poolOffset;
        varint7.encode(msg.id << 3 | msg.type, pool, offset);
        offset += varint7.encode.bytes;
        varint7.encode(msg.data ? msg.data.length : 0, pool, offset);
        offset += varint7.encode.bytes;
        const header = pool.subarray(this._poolOffset, offset);
        if (POOL_SIZE - offset < 100) {
          this._pool = new Uint8Array(POOL_SIZE);
          this._poolOffset = 0;
        } else {
          this._poolOffset = offset;
        }
        if (!msg.data)
          return header;
        return [header, msg.data];
      }
    };
    var encoder = new Encoder2();
    module2.exports = (source) => async function* encode10() {
      for await (const msg of source) {
        if (Array.isArray(msg)) {
          yield new BufferList3(msg.map((m) => encoder.write(m)));
        } else {
          yield new BufferList3(encoder.write(msg));
        }
      }
    }();
  }
});

// node_modules/libp2p-mplex/src/coder/decode.js
var require_decode3 = __commonJS({
  "node_modules/libp2p-mplex/src/coder/decode.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var varint7 = require_varint();
    var BufferList3 = require_BufferList();
    module2.exports = (source) => async function* decode12() {
      const decoder = new Decoder2();
      for await (const chunk of source) {
        const msgs = decoder.write(chunk);
        if (msgs.length)
          yield msgs;
      }
    }();
    var Decoder2 = class {
      constructor() {
        this._buffer = new BufferList3();
        this._bufferProxy = new Proxy({}, {
          get: (_, prop) => prop[0] === "l" ? this._buffer[prop] : this._buffer.get(parseInt(prop))
        });
        this._headerInfo = null;
      }
      write(chunk) {
        if (!chunk || !chunk.length)
          return [];
        this._buffer.append(chunk);
        const msgs = [];
        while (true) {
          if (!this._headerInfo) {
            try {
              this._headerInfo = this._decodeHeader(this._bufferProxy);
            } catch (_) {
              break;
            }
          }
          const { id, type, length: length4, offset } = this._headerInfo;
          const bufferedDataLength = this._buffer.length - offset;
          if (bufferedDataLength < length4)
            break;
          msgs.push({ id, type, data: this._buffer.shallowSlice(offset, offset + length4) });
          this._buffer.consume(offset + length4);
          this._headerInfo = null;
        }
        return msgs;
      }
      _decodeHeader(data) {
        const h = varint7.decode(data);
        let offset = varint7.decode.bytes;
        const length4 = varint7.decode(data, offset);
        offset += varint7.decode.bytes;
        return { id: h >> 3, type: h & 7, offset, length: length4 };
      }
    };
  }
});

// node_modules/libp2p-mplex/src/coder/index.js
var require_coder = __commonJS({
  "node_modules/libp2p-mplex/src/coder/index.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.encode = require_encode_browser();
    exports2.decode = require_decode3();
  }
});

// node_modules/libp2p-mplex/src/restrict-size.js
var require_restrict_size = __commonJS({
  "node_modules/libp2p-mplex/src/restrict-size.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var MAX_MSG_SIZE = 1 << 20;
    module2.exports = (max) => {
      max = max || MAX_MSG_SIZE;
      const checkSize = (msg) => {
        if (msg.data && msg.data.length > max) {
          throw Object.assign(new Error("message size too large!"), { code: "ERR_MSG_TOO_BIG" });
        }
      };
      return (source) => {
        return async function* restrictSize() {
          for await (const msg of source) {
            if (Array.isArray(msg)) {
              msg.forEach(checkSize);
            } else {
              checkSize(msg);
            }
            yield msg;
          }
        }();
      };
    };
    module2.exports.MAX_MSG_SIZE = MAX_MSG_SIZE;
  }
});

// node_modules/libp2p-mplex/src/message-types.js
var require_message_types = __commonJS({
  "node_modules/libp2p-mplex/src/message-types.js"(exports2) {
    init_node_globals();
    "use strict";
    var MessageTypes = Object.freeze({
      NEW_STREAM: 0,
      MESSAGE_RECEIVER: 1,
      MESSAGE_INITIATOR: 2,
      CLOSE_RECEIVER: 3,
      CLOSE_INITIATOR: 4,
      RESET_RECEIVER: 5,
      RESET_INITIATOR: 6
    });
    exports2.MessageTypes = MessageTypes;
    exports2.InitiatorMessageTypes = Object.freeze({
      NEW_STREAM: MessageTypes.NEW_STREAM,
      MESSAGE: MessageTypes.MESSAGE_INITIATOR,
      CLOSE: MessageTypes.CLOSE_INITIATOR,
      RESET: MessageTypes.RESET_INITIATOR
    });
    exports2.ReceiverMessageTypes = Object.freeze({
      MESSAGE: MessageTypes.MESSAGE_RECEIVER,
      CLOSE: MessageTypes.CLOSE_RECEIVER,
      RESET: MessageTypes.RESET_RECEIVER
    });
    exports2.MessageTypeNames = Object.freeze(Object.entries(MessageTypes).reduce((obj, e) => {
      obj[e[1]] = e[0];
      return obj;
    }, {}));
  }
});

// node_modules/libp2p-mplex/src/stream.js
var require_stream = __commonJS({
  "node_modules/libp2p-mplex/src/stream.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var abortable = require_abortable_iterator();
    var AbortController13 = require_browser3();
    var log15 = require_browser2()("libp2p:mplex:stream");
    var pushable4 = require_it_pushable();
    var BufferList3 = require_BufferList();
    var errCode32 = require_err_code();
    var { MAX_MSG_SIZE } = require_restrict_size();
    var { InitiatorMessageTypes, ReceiverMessageTypes } = require_message_types();
    var ERR_MPLEX_STREAM_RESET = "ERR_MPLEX_STREAM_RESET";
    var ERR_MPLEX_STREAM_ABORT = "ERR_MPLEX_STREAM_ABORT";
    module2.exports = ({ id, name: name5, send, onEnd = () => {
    }, type = "initiator", maxMsgSize = MAX_MSG_SIZE }) => {
      const abortController = new AbortController13();
      const resetController = new AbortController13();
      const Types = type === "initiator" ? InitiatorMessageTypes : ReceiverMessageTypes;
      const externalId = type === "initiator" ? `i${id}` : `r${id}`;
      name5 = String(name5 == null ? id : name5);
      let sourceEnded = false;
      let sinkEnded = false;
      let endErr;
      const onSourceEnd = (err) => {
        if (sourceEnded)
          return;
        sourceEnded = true;
        log15("%s stream %s source end", type, name5, err);
        if (err && !endErr)
          endErr = err;
        if (sinkEnded) {
          stream.timeline.close = Date.now();
          onEnd(endErr);
        }
      };
      const onSinkEnd = (err) => {
        if (sinkEnded)
          return;
        sinkEnded = true;
        log15("%s stream %s sink end", type, name5, err);
        if (err && !endErr)
          endErr = err;
        if (sourceEnded) {
          stream.timeline.close = Date.now();
          onEnd(endErr);
        }
      };
      const stream = {
        close: () => stream.source.end(),
        abort: (err) => {
          log15("%s stream %s abort", type, name5, err);
          stream.source.end(err);
          abortController.abort();
          onSinkEnd(err);
        },
        reset: () => {
          const err = errCode32(new Error("stream reset"), ERR_MPLEX_STREAM_RESET);
          resetController.abort();
          stream.source.end(err);
          onSinkEnd(err);
        },
        sink: async (source) => {
          source = abortable(source, [
            { signal: abortController.signal, options: { abortMessage: "stream aborted", abortCode: ERR_MPLEX_STREAM_ABORT } },
            { signal: resetController.signal, options: { abortMessage: "stream reset", abortCode: ERR_MPLEX_STREAM_RESET } }
          ]);
          if (type === "initiator") {
            send({ id, type: Types.NEW_STREAM, data: name5 });
          }
          try {
            for await (let data of source) {
              while (data.length) {
                if (data.length <= maxMsgSize) {
                  send({ id, type: Types.MESSAGE, data });
                  break;
                }
                data = BufferList3.isBufferList(data) ? data : new BufferList3(data);
                send({ id, type: Types.MESSAGE, data: data.shallowSlice(0, maxMsgSize) });
                data.consume(maxMsgSize);
              }
            }
          } catch (err) {
            if (err.code === ERR_MPLEX_STREAM_RESET) {
              log15("%s stream %s reset", type, name5);
            } else {
              log15("%s stream %s error", type, name5, err);
              send({ id, type: Types.RESET });
            }
            stream.source.end(err);
            return onSinkEnd(err);
          }
          send({ id, type: Types.CLOSE });
          onSinkEnd();
        },
        source: pushable4(onSourceEnd),
        timeline: {
          open: Date.now(),
          close: null
        },
        id: externalId
      };
      return stream;
    };
  }
});

// node_modules/libp2p-mplex/src/mplex.js
var require_mplex = __commonJS({
  "node_modules/libp2p-mplex/src/mplex.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var pipe4 = require_it_pipe();
    var pushable4 = require_it_pushable();
    var log15 = require_browser2()("libp2p:mplex");
    var abortable = require_abortable_iterator();
    var Coder = require_coder();
    var restrictSize = require_restrict_size();
    var { MessageTypes, MessageTypeNames } = require_message_types();
    var createStream = require_stream();
    var Mplex = class {
      constructor(options) {
        options = options || {};
        options = typeof options === "function" ? { onStream: options } : options;
        this._streamId = 0;
        this._streams = {
          initiators: new Map(),
          receivers: new Map()
        };
        this._options = options;
        this.sink = this._createSink();
        this.source = this._createSource();
        this.onStream = options.onStream;
        this.onStreamEnd = options.onStreamEnd;
      }
      get streams() {
        const streams = [];
        this._streams.initiators.forEach((stream) => {
          streams.push(stream);
        });
        this._streams.receivers.forEach((stream) => {
          streams.push(stream);
        });
        return streams;
      }
      newStream(name5) {
        const id = this._streamId++;
        name5 = name5 == null ? id.toString() : String(name5);
        const registry = this._streams.initiators;
        return this._newStream({ id, name: name5, type: "initiator", registry });
      }
      _newReceiverStream({ id, name: name5 }) {
        const registry = this._streams.receivers;
        return this._newStream({ id, name: name5, type: "receiver", registry });
      }
      _newStream({ id, name: name5, type, registry }) {
        if (registry.has(id)) {
          throw new Error(`${type} stream ${id} already exists!`);
        }
        log15("new %s stream %s %s", type, id, name5);
        const send = (msg) => {
          if (log15.enabled) {
            log15("%s stream %s %s send", type, id, name5, { ...msg, type: MessageTypeNames[msg.type], data: msg.data && msg.data.slice() });
          }
          return this.source.push(msg);
        };
        const onEnd = () => {
          log15("%s stream %s %s ended", type, id, name5);
          registry.delete(id);
          this.onStreamEnd && this.onStreamEnd(stream);
        };
        const stream = createStream({ id, name: name5, send, type, onEnd, maxMsgSize: this._options.maxMsgSize });
        registry.set(id, stream);
        return stream;
      }
      _createSink() {
        return async (source) => {
          if (this._options.signal) {
            source = abortable(source, this._options.signal);
          }
          try {
            await pipe4(source, Coder.decode, restrictSize(this._options.maxMsgSize), async (source2) => {
              for await (const msgs of source2) {
                for (const msg of msgs) {
                  this._handleIncoming(msg);
                }
              }
            });
          } catch (err) {
            log15("error in sink", err);
            return this.source.end(err);
          }
          this.source.end();
        };
      }
      _createSource() {
        const onEnd = (err) => {
          const { initiators, receivers } = this._streams;
          for (const s of initiators.values())
            s.abort(err);
          for (const s of receivers.values())
            s.abort(err);
        };
        const source = pushable4({ onEnd, writev: true });
        return Object.assign(Coder.encode(source), {
          push: source.push,
          end: source.end,
          return: source.return
        });
      }
      _handleIncoming({ id, type, data }) {
        if (log15.enabled) {
          log15("incoming message", { id, type: MessageTypeNames[type], data: data.slice() });
        }
        if (type === MessageTypes.NEW_STREAM && this.onStream) {
          const stream2 = this._newReceiverStream({ id, name: data.toString() });
          return this.onStream(stream2);
        }
        const list = type & 1 ? this._streams.initiators : this._streams.receivers;
        const stream = list.get(id);
        if (!stream)
          return log15("missing stream %s", id);
        switch (type) {
          case MessageTypes.MESSAGE_INITIATOR:
          case MessageTypes.MESSAGE_RECEIVER:
            stream.source.push(data);
            break;
          case MessageTypes.CLOSE_INITIATOR:
          case MessageTypes.CLOSE_RECEIVER:
            stream.close();
            break;
          case MessageTypes.RESET_INITIATOR:
          case MessageTypes.RESET_RECEIVER:
            stream.reset();
            break;
          default:
            log15("unknown message type %s", type);
        }
      }
    };
    Mplex.multicodec = "/mplex/6.7.0";
    module2.exports = Mplex;
  }
});

// node_modules/libp2p-mplex/src/index.js
var require_src19 = __commonJS({
  "node_modules/libp2p-mplex/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = require_mplex();
  }
});

// node_modules/@stablelib/random/lib/source/browser.js
var require_browser10 = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var QUOTA = 65536;
    var BrowserRandomSource = function() {
      function BrowserRandomSource2() {
        this.isAvailable = false;
        this.isInstantiated = false;
        var browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      BrowserRandomSource2.prototype.randomBytes = function(length4) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        var out = new Uint8Array(length4);
        for (var i = 0; i < out.length; i += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i, i + Math.min(out.length - i, QUOTA)));
        }
        return out;
      };
      return BrowserRandomSource2;
    }();
    exports2.BrowserRandomSource = BrowserRandomSource;
  }
});

// node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function wipe(array2) {
      for (var i = 0; i < array2.length; i++) {
        array2[i] = 0;
      }
      return array2;
    }
    exports2.wipe = wipe;
  }
});

// node_modules/@stablelib/random/lib/source/node.js
var require_node2 = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var wipe_1 = require_wipe();
    var NodeRandomSource = function() {
      function NodeRandomSource2() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          var nodeCrypto = require_crypto();
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      NodeRandomSource2.prototype.randomBytes = function(length4) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        var buffer2 = this._crypto.randomBytes(length4);
        if (buffer2.length !== length4) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        var out = new Uint8Array(length4);
        for (var i = 0; i < out.length; i++) {
          out[i] = buffer2[i];
        }
        wipe_1.wipe(buffer2);
        return out;
      };
      return NodeRandomSource2;
    }();
    exports2.NodeRandomSource = NodeRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var browser_1 = require_browser10();
    var node_1 = require_node2();
    var SystemRandomSource = function() {
      function SystemRandomSource2() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      SystemRandomSource2.prototype.randomBytes = function(length4) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length4);
      };
      return SystemRandomSource2;
    }();
    exports2.SystemRandomSource = SystemRandomSource;
  }
});

// node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function imulShim(a, b) {
      var ah = a >>> 16 & 65535, al = a & 65535;
      var bh = b >>> 16 & 65535, bl = b & 65535;
      return al * bl + (ah * bl + al * bh << 16 >>> 0) | 0;
    }
    exports2.mul = Math.imul || imulShim;
    function add(a, b) {
      return a + b | 0;
    }
    exports2.add = add;
    function sub(a, b) {
      return a - b | 0;
    }
    exports2.sub = sub;
    function rotl(x, n) {
      return x << n | x >>> 32 - n;
    }
    exports2.rotl = rotl;
    function rotr(x, n) {
      return x << 32 - n | x >>> n;
    }
    exports2.rotr = rotr;
    function isIntegerShim(n) {
      return typeof n === "number" && isFinite(n) && Math.floor(n) === n;
    }
    exports2.isInteger = Number.isInteger || isIntegerShim;
    exports2.MAX_SAFE_INTEGER = 9007199254740991;
    exports2.isSafeInteger = function(n) {
      return exports2.isInteger(n) && (n >= -exports2.MAX_SAFE_INTEGER && n <= exports2.MAX_SAFE_INTEGER);
    };
  }
});

// node_modules/@stablelib/binary/lib/binary.js
var require_binary2 = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset + 0] << 8 | array2[offset + 1]) << 16 >> 16;
    }
    exports2.readInt16BE = readInt16BE;
    function readUint16BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset + 0] << 8 | array2[offset + 1]) >>> 0;
    }
    exports2.readUint16BE = readUint16BE;
    function readInt16LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset + 1] << 8 | array2[offset]) << 16 >> 16;
    }
    exports2.readInt16LE = readInt16LE;
    function readUint16LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset + 1] << 8 | array2[offset]) >>> 0;
    }
    exports2.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    exports2.writeUint16BE = writeUint16BE;
    exports2.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    exports2.writeUint16LE = writeUint16LE;
    exports2.writeInt16LE = writeUint16LE;
    function readInt32BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array2[offset] << 24 | array2[offset + 1] << 16 | array2[offset + 2] << 8 | array2[offset + 3];
    }
    exports2.readInt32BE = readInt32BE;
    function readUint32BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset] << 24 | array2[offset + 1] << 16 | array2[offset + 2] << 8 | array2[offset + 3]) >>> 0;
    }
    exports2.readUint32BE = readUint32BE;
    function readInt32LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array2[offset + 3] << 24 | array2[offset + 2] << 16 | array2[offset + 1] << 8 | array2[offset];
    }
    exports2.readInt32LE = readInt32LE;
    function readUint32LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array2[offset + 3] << 24 | array2[offset + 2] << 16 | array2[offset + 1] << 8 | array2[offset]) >>> 0;
    }
    exports2.readUint32LE = readUint32LE;
    function writeUint32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    exports2.writeUint32BE = writeUint32BE;
    exports2.writeInt32BE = writeUint32BE;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    exports2.writeUint32LE = writeUint32LE;
    exports2.writeInt32LE = writeUint32LE;
    function readInt64BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array2, offset);
      var lo = readInt32BE(array2, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64BE = readInt64BE;
    function readUint64BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array2, offset);
      var lo = readUint32BE(array2, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64BE = readUint64BE;
    function readInt64LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readInt32LE(array2, offset);
      var hi = readInt32LE(array2, offset + 4);
      return hi * 4294967296 + lo - (lo >> 31) * 4294967296;
    }
    exports2.readInt64LE = readInt64LE;
    function readUint64LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo = readUint32LE(array2, offset);
      var hi = readUint32LE(array2, offset + 4);
      return hi * 4294967296 + lo;
    }
    exports2.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value / 4294967296 >>> 0, out, offset);
      writeUint32BE(value >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64BE = writeUint64BE;
    exports2.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports2.writeUint64LE = writeUint64LE;
    exports2.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array2.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        result += array2[i] * mul;
        mul *= 256;
      }
      return result;
    }
    exports2.readUintBE = readUintBE;
    function readUintLE(bitLength, array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array2.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        result += array2[i] * mul;
        mul *= 256;
      }
      return result;
    }
    exports2.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i = bitLength / 8 + offset - 1; i >= offset; i--) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i = offset; i < offset + bitLength / 8; i++) {
        out[i] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports2.writeUintLE = writeUintLE;
    function readFloat32BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
      return view.getFloat32(offset);
    }
    exports2.readFloat32BE = readFloat32BE;
    function readFloat32LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
      return view.getFloat32(offset, true);
    }
    exports2.readFloat32LE = readFloat32LE;
    function readFloat64BE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
      return view.getFloat64(offset);
    }
    exports2.readFloat64BE = readFloat64BE;
    function readFloat64LE(array2, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array2.buffer, array2.byteOffset, array2.byteLength);
      return view.getFloat64(offset, true);
    }
    exports2.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    exports2.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    exports2.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    exports2.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    exports2.writeFloat64LE = writeFloat64LE;
  }
});

// node_modules/@stablelib/random/lib/random.js
var require_random2 = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var system_1 = require_system();
    var binary_1 = require_binary2();
    var wipe_1 = require_wipe();
    exports2.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes(length4, prng) {
      if (prng === void 0) {
        prng = exports2.defaultRandomSource;
      }
      return prng.randomBytes(length4);
    }
    exports2.randomBytes = randomBytes;
    function randomUint32(prng) {
      if (prng === void 0) {
        prng = exports2.defaultRandomSource;
      }
      var buf2 = randomBytes(4, prng);
      var result = binary_1.readUint32LE(buf2);
      wipe_1.wipe(buf2);
      return result;
    }
    exports2.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length4, charset, prng) {
      if (charset === void 0) {
        charset = ALPHANUMERIC;
      }
      if (prng === void 0) {
        prng = exports2.defaultRandomSource;
      }
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      var out = "";
      var charsLen = charset.length;
      var maxByte = 256 - 256 % charsLen;
      while (length4 > 0) {
        var buf2 = randomBytes(Math.ceil(length4 * 256 / maxByte), prng);
        for (var i = 0; i < buf2.length && length4 > 0; i++) {
          var randomByte = buf2[i];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length4--;
          }
        }
        wipe_1.wipe(buf2);
      }
      return out;
    }
    exports2.randomString = randomString;
    function randomStringForEntropy(bits, charset, prng) {
      if (charset === void 0) {
        charset = ALPHANUMERIC;
      }
      if (prng === void 0) {
        prng = exports2.defaultRandomSource;
      }
      var length4 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length4, charset, prng);
    }
    exports2.randomStringForEntropy = randomStringForEntropy;
  }
});

// node_modules/@stablelib/x25519/lib/x25519.js
var require_x25519 = __commonJS({
  "node_modules/@stablelib/x25519/lib/x25519.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var random_1 = require_random2();
    var wipe_1 = require_wipe();
    exports2.PUBLIC_KEY_LENGTH = 32;
    exports2.SECRET_KEY_LENGTH = 32;
    exports2.SHARED_KEY_LENGTH = 32;
    function gf(init) {
      var r = new Float64Array(16);
      if (init) {
        for (var i = 0; i < init.length; i++) {
          r[i] = init[i];
        }
      }
      return r;
    }
    var _9 = new Uint8Array(32);
    _9[0] = 9;
    var _121665 = gf([56129, 1]);
    function car25519(o) {
      var c = 1;
      for (var i = 0; i < 16; i++) {
        var v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function sel25519(p, q, b) {
      var c = ~(b - 1);
      for (var i = 0; i < 16; i++) {
        var t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    function pack25519(o, n) {
      var m = gf();
      var t = gf();
      for (var i = 0; i < 16; i++) {
        t[i] = n[i];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (var j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (var i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        var b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (var i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function unpack25519(o, n) {
      for (var i = 0; i < 16; i++) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }
      o[15] &= 32767;
    }
    function add(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] + b[i];
      }
    }
    function sub(o, a, b) {
      for (var i = 0; i < 16; i++) {
        o[i] = a[i] - b[i];
      }
    }
    function mul(o, a, b) {
      var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function square(o, a) {
      mul(o, a, a);
    }
    function inv25519(o, inp) {
      var c = gf();
      for (var i = 0; i < 16; i++) {
        c[i] = inp[i];
      }
      for (var i = 253; i >= 0; i--) {
        square(c, c);
        if (i !== 2 && i !== 4) {
          mul(c, c, inp);
        }
      }
      for (var i = 0; i < 16; i++) {
        o[i] = c[i];
      }
    }
    function scalarMult(n, p) {
      var z = new Uint8Array(32);
      var x = new Float64Array(80);
      var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
      for (var i = 0; i < 31; i++) {
        z[i] = n[i];
      }
      z[31] = n[31] & 127 | 64;
      z[0] &= 248;
      unpack25519(x, p);
      for (var i = 0; i < 16; i++) {
        b[i] = x[i];
      }
      a[0] = d[0] = 1;
      for (var i = 254; i >= 0; --i) {
        var r = z[i >>> 3] >>> (i & 7) & 1;
        sel25519(a, b, r);
        sel25519(c, d, r);
        add(e, a, c);
        sub(a, a, c);
        add(c, b, d);
        sub(b, b, d);
        square(d, e);
        square(f, a);
        mul(a, c, a);
        mul(c, b, e);
        add(e, a, c);
        sub(a, a, c);
        square(b, a);
        sub(c, d, f);
        mul(a, c, _121665);
        add(a, a, d);
        mul(c, c, a);
        mul(a, d, f);
        mul(d, b, x);
        square(b, e);
        sel25519(a, b, r);
        sel25519(c, d, r);
      }
      for (var i = 0; i < 16; i++) {
        x[i + 16] = a[i];
        x[i + 32] = c[i];
        x[i + 48] = b[i];
        x[i + 64] = d[i];
      }
      var x32 = x.subarray(32);
      var x16 = x.subarray(16);
      inv25519(x32, x32);
      mul(x16, x16, x32);
      var q = new Uint8Array(32);
      pack25519(q, x16);
      return q;
    }
    exports2.scalarMult = scalarMult;
    function scalarMultBase(n) {
      return scalarMult(n, _9);
    }
    exports2.scalarMultBase = scalarMultBase;
    function generateKeyPairFromSeed(seed) {
      if (seed.length !== exports2.SECRET_KEY_LENGTH) {
        throw new Error("x25519: seed must be " + exports2.SECRET_KEY_LENGTH + " bytes");
      }
      var secretKey = new Uint8Array(seed);
      var publicKey = scalarMultBase(secretKey);
      return {
        publicKey,
        secretKey
      };
    }
    exports2.generateKeyPairFromSeed = generateKeyPairFromSeed;
    function generateKeyPair(prng) {
      var seed = random_1.randomBytes(32, prng);
      var result = generateKeyPairFromSeed(seed);
      wipe_1.wipe(seed);
      return result;
    }
    exports2.generateKeyPair = generateKeyPair;
    function sharedKey(mySecretKey, theirPublicKey, rejectZero) {
      if (rejectZero === void 0) {
        rejectZero = false;
      }
      if (mySecretKey.length !== exports2.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect secret key length");
      }
      if (theirPublicKey.length !== exports2.PUBLIC_KEY_LENGTH) {
        throw new Error("X25519: incorrect public key length");
      }
      var result = scalarMult(mySecretKey, theirPublicKey);
      if (rejectZero) {
        var zeros = 0;
        for (var i = 0; i < result.length; i++) {
          zeros |= result[i];
        }
        if (zeros === 0) {
          throw new Error("X25519: invalid shared key");
        }
      }
      return result;
    }
    exports2.sharedKey = sharedKey;
  }
});

// node_modules/it-handshake/src/index.js
var require_src20 = __commonJS({
  "node_modules/it-handshake/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var Reader = require_it_reader();
    var Writer = require_it_pushable();
    var defer = require_p_defer();
    module2.exports = (stream) => {
      const writer = Writer();
      const reader = Reader(stream.source);
      const sourcePromise = defer();
      let sinkErr;
      const sinkPromise = stream.sink(async function* () {
        yield* writer;
        const source = await sourcePromise.promise;
        yield* source;
      }());
      sinkPromise.catch((err) => {
        sinkErr = err;
      });
      const rest = {
        sink: (source) => {
          if (sinkErr) {
            return Promise.reject(sinkErr);
          }
          sourcePromise.resolve(source);
          return sinkPromise;
        },
        source: reader
      };
      return {
        reader,
        writer,
        stream: rest,
        rest: () => writer.end(),
        write: writer.push,
        read: async () => {
          return (await reader.next()).value;
        }
      };
    };
  }
});

// node_modules/it-pb-rpc/src/index.js
var require_src21 = __commonJS({
  "node_modules/it-pb-rpc/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var isBuffer3 = require_is_buffer();
    var Shake = require_src20();
    var lp2 = require_src12();
    module2.exports = (duplex, opts = {}) => {
      const shake = Shake(duplex);
      const lpReader = lp2.decode.fromReader(shake.reader, opts);
      let isDone = false;
      const W = {
        read: async (bytes3) => {
          const { value, done } = await shake.reader.next(bytes3);
          if (done && value.length < bytes3) {
            throw new Error("Couldn't read enough bytes");
          }
          isDone = done;
          if (!value) {
            throw new Error("Value is null");
          }
          return value;
        },
        readLP: async () => {
          const { value, done } = await lpReader.next();
          isDone = done;
          if (!value) {
            throw new Error("Value is null");
          }
          return value;
        },
        readPB: async (proto) => {
          const value = await W.readLP();
          if (!value) {
            throw new Error("Value is null");
          }
          const buf2 = isBuffer3(value) ? value : value.slice();
          return proto.decode(buf2);
        },
        write: (data) => {
          shake.writer.push(data);
        },
        writeLP: (data) => {
          W.write(lp2.encode.single(data, opts));
        },
        writePB: (data, proto) => {
          W.writeLP(proto.encode(data));
        },
        pb: (proto) => {
          return {
            read: () => W.readPB(proto),
            write: (d) => W.writePB(d, proto)
          };
        },
        unwrap: () => {
          shake.rest();
          return shake.stream;
        }
      };
      return W;
    };
  }
});

// node_modules/it-pair/index.js
var require_it_pair = __commonJS({
  "node_modules/it-pair/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var getIterator = require_get_iterator();
    module2.exports = function pair() {
      let _source, onSource;
      const sink = async (source2) => {
        if (_source)
          throw new Error("already piped");
        _source = getIterator(source2);
        if (onSource)
          onSource(_source);
      };
      const source = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next() {
          if (_source)
            return _source.next();
          return new Promise((resolve6) => {
            onSource = (source2) => {
              onSource = null;
              resolve6(source2.next());
            };
          });
        }
      };
      return { sink, source };
    };
  }
});

// node_modules/it-pair/duplex.js
var require_duplex3 = __commonJS({
  "node_modules/it-pair/duplex.js"(exports2, module2) {
    init_node_globals();
    var Pair = require_it_pair();
    module2.exports = function() {
      var a = Pair();
      var b = Pair();
      return [
        {
          source: a.source,
          sink: b.sink
        },
        {
          source: b.source,
          sink: a.sink
        }
      ];
    };
  }
});

// node_modules/it-buffer/index.js
var require_it_buffer = __commonJS({
  "node_modules/it-buffer/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { Buffer: Buffer2 } = require_buffer();
    var BufferList3 = require_BufferList();
    module2.exports = async function* (source) {
      for await (const b of source) {
        if (Buffer2.isBuffer(b)) {
          yield b;
        } else if (BufferList3.isBufferList(b)) {
          yield b.slice();
        } else {
          yield Buffer2.from(b);
        }
      }
    };
    module2.exports.toBuffer = module2.exports;
    module2.exports.toList = async function* (source) {
      for await (const b of source) {
        if (Buffer2.isBuffer(b)) {
          yield new BufferList3().append(b);
        } else if (BufferList3.isBufferList(b)) {
          yield b;
        } else {
          yield new BufferList3().append(Buffer2.from(b));
        }
      }
    };
  }
});

// node_modules/@stablelib/hash/lib/hash.js
var require_hash2 = __commonJS({
  "node_modules/@stablelib/hash/lib/hash.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function isSerializableHash(h) {
      return typeof h.saveState !== "undefined" && typeof h.restoreState !== "undefined" && typeof h.cleanSavedState !== "undefined";
    }
    exports2.isSerializableHash = isSerializableHash;
  }
});

// node_modules/@stablelib/constant-time/lib/constant-time.js
var require_constant_time = __commonJS({
  "node_modules/@stablelib/constant-time/lib/constant-time.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function select(subject, resultIfOne, resultIfZero) {
      return ~(subject - 1) & resultIfOne | subject - 1 & resultIfZero;
    }
    exports2.select = select;
    function lessOrEqual(a, b) {
      return (a | 0) - (b | 0) - 1 >>> 31 & 1;
    }
    exports2.lessOrEqual = lessOrEqual;
    function compare3(a, b) {
      if (a.length !== b.length) {
        return 0;
      }
      var result = 0;
      for (var i = 0; i < a.length; i++) {
        result |= a[i] ^ b[i];
      }
      return 1 & result - 1 >>> 8;
    }
    exports2.compare = compare3;
    function equal(a, b) {
      if (a.length === 0 || b.length === 0) {
        return false;
      }
      return compare3(a, b) !== 0;
    }
    exports2.equal = equal;
  }
});

// node_modules/@stablelib/hmac/lib/hmac.js
var require_hmac3 = __commonJS({
  "node_modules/@stablelib/hmac/lib/hmac.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hash_1 = require_hash2();
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    var HMAC = function() {
      function HMAC2(hash2, key) {
        this._finished = false;
        this._inner = new hash2();
        this._outer = new hash2();
        this.blockSize = this._outer.blockSize;
        this.digestLength = this._outer.digestLength;
        var pad = new Uint8Array(this.blockSize);
        if (key.length > this.blockSize) {
          this._inner.update(key).finish(pad).clean();
        } else {
          pad.set(key);
        }
        for (var i = 0; i < pad.length; i++) {
          pad[i] ^= 54;
        }
        this._inner.update(pad);
        for (var i = 0; i < pad.length; i++) {
          pad[i] ^= 54 ^ 92;
        }
        this._outer.update(pad);
        if (hash_1.isSerializableHash(this._inner) && hash_1.isSerializableHash(this._outer)) {
          this._innerKeyedState = this._inner.saveState();
          this._outerKeyedState = this._outer.saveState();
        }
        wipe_1.wipe(pad);
      }
      HMAC2.prototype.reset = function() {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
          throw new Error("hmac: can't reset() because hash doesn't implement restoreState()");
        }
        this._inner.restoreState(this._innerKeyedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
      };
      HMAC2.prototype.clean = function() {
        if (hash_1.isSerializableHash(this._inner)) {
          this._inner.cleanSavedState(this._innerKeyedState);
        }
        if (hash_1.isSerializableHash(this._outer)) {
          this._outer.cleanSavedState(this._outerKeyedState);
        }
        this._inner.clean();
        this._outer.clean();
      };
      HMAC2.prototype.update = function(data) {
        this._inner.update(data);
        return this;
      };
      HMAC2.prototype.finish = function(out) {
        if (this._finished) {
          this._outer.finish(out);
          return this;
        }
        this._inner.finish(out);
        this._outer.update(out.subarray(0, this.digestLength)).finish(out);
        this._finished = true;
        return this;
      };
      HMAC2.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      HMAC2.prototype.saveState = function() {
        if (!hash_1.isSerializableHash(this._inner)) {
          throw new Error("hmac: can't saveState() because hash doesn't implement it");
        }
        return this._inner.saveState();
      };
      HMAC2.prototype.restoreState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner) || !hash_1.isSerializableHash(this._outer)) {
          throw new Error("hmac: can't restoreState() because hash doesn't implement it");
        }
        this._inner.restoreState(savedState);
        this._outer.restoreState(this._outerKeyedState);
        this._finished = false;
        return this;
      };
      HMAC2.prototype.cleanSavedState = function(savedState) {
        if (!hash_1.isSerializableHash(this._inner)) {
          throw new Error("hmac: can't cleanSavedState() because hash doesn't implement it");
        }
        this._inner.cleanSavedState(savedState);
      };
      return HMAC2;
    }();
    exports2.HMAC = HMAC;
    function hmac(hash2, key, data) {
      var h = new HMAC(hash2, key);
      h.update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }
    exports2.hmac = hmac;
    exports2.equal = constant_time_1.equal;
  }
});

// node_modules/@stablelib/hkdf/lib/hkdf.js
var require_hkdf = __commonJS({
  "node_modules/@stablelib/hkdf/lib/hkdf.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var hmac_1 = require_hmac3();
    var wipe_1 = require_wipe();
    var HKDF = function() {
      function HKDF2(hash2, key, salt, info) {
        if (salt === void 0) {
          salt = new Uint8Array(0);
        }
        this._counter = new Uint8Array(1);
        this._hash = hash2;
        this._info = info;
        var okm = hmac_1.hmac(this._hash, salt, key);
        this._hmac = new hmac_1.HMAC(hash2, okm);
        this._buffer = new Uint8Array(this._hmac.digestLength);
        this._bufpos = this._buffer.length;
      }
      HKDF2.prototype._fillBuffer = function() {
        this._counter[0]++;
        var ctr = this._counter[0];
        if (ctr === 0) {
          throw new Error("hkdf: cannot expand more");
        }
        this._hmac.reset();
        if (ctr > 1) {
          this._hmac.update(this._buffer);
        }
        if (this._info) {
          this._hmac.update(this._info);
        }
        this._hmac.update(this._counter);
        this._hmac.finish(this._buffer);
        this._bufpos = 0;
      };
      HKDF2.prototype.expand = function(length4) {
        var out = new Uint8Array(length4);
        for (var i = 0; i < out.length; i++) {
          if (this._bufpos === this._buffer.length) {
            this._fillBuffer();
          }
          out[i] = this._buffer[this._bufpos++];
        }
        return out;
      };
      HKDF2.prototype.clean = function() {
        this._hmac.clean();
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._counter);
        this._bufpos = 0;
      };
      return HKDF2;
    }();
    exports2.HKDF = HKDF;
  }
});

// node_modules/@stablelib/sha256/lib/sha256.js
var require_sha2562 = __commonJS({
  "node_modules/@stablelib/sha256/lib/sha256.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var binary_1 = require_binary2();
    var wipe_1 = require_wipe();
    exports2.DIGEST_LENGTH = 32;
    exports2.BLOCK_SIZE = 64;
    var SHA256 = function() {
      function SHA2562() {
        this.digestLength = exports2.DIGEST_LENGTH;
        this.blockSize = exports2.BLOCK_SIZE;
        this._state = new Int32Array(8);
        this._temp = new Int32Array(64);
        this._buffer = new Uint8Array(128);
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        this.reset();
      }
      SHA2562.prototype._initState = function() {
        this._state[0] = 1779033703;
        this._state[1] = 3144134277;
        this._state[2] = 1013904242;
        this._state[3] = 2773480762;
        this._state[4] = 1359893119;
        this._state[5] = 2600822924;
        this._state[6] = 528734635;
        this._state[7] = 1541459225;
      };
      SHA2562.prototype.reset = function() {
        this._initState();
        this._bufferLength = 0;
        this._bytesHashed = 0;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._temp);
        this.reset();
      };
      SHA2562.prototype.update = function(data, dataLength) {
        if (dataLength === void 0) {
          dataLength = data.length;
        }
        if (this._finished) {
          throw new Error("SHA256: can't update because hash was finished.");
        }
        var dataPos = 0;
        this._bytesHashed += dataLength;
        if (this._bufferLength > 0) {
          while (this._bufferLength < this.blockSize && dataLength > 0) {
            this._buffer[this._bufferLength++] = data[dataPos++];
            dataLength--;
          }
          if (this._bufferLength === this.blockSize) {
            hashBlocks(this._temp, this._state, this._buffer, 0, this.blockSize);
            this._bufferLength = 0;
          }
        }
        if (dataLength >= this.blockSize) {
          dataPos = hashBlocks(this._temp, this._state, data, dataPos, dataLength);
          dataLength %= this.blockSize;
        }
        while (dataLength > 0) {
          this._buffer[this._bufferLength++] = data[dataPos++];
          dataLength--;
        }
        return this;
      };
      SHA2562.prototype.finish = function(out) {
        if (!this._finished) {
          var bytesHashed = this._bytesHashed;
          var left = this._bufferLength;
          var bitLenHi = bytesHashed / 536870912 | 0;
          var bitLenLo = bytesHashed << 3;
          var padLength = bytesHashed % 64 < 56 ? 64 : 128;
          this._buffer[left] = 128;
          for (var i = left + 1; i < padLength - 8; i++) {
            this._buffer[i] = 0;
          }
          binary_1.writeUint32BE(bitLenHi, this._buffer, padLength - 8);
          binary_1.writeUint32BE(bitLenLo, this._buffer, padLength - 4);
          hashBlocks(this._temp, this._state, this._buffer, 0, padLength);
          this._finished = true;
        }
        for (var i = 0; i < this.digestLength / 4; i++) {
          binary_1.writeUint32BE(this._state[i], out, i * 4);
        }
        return this;
      };
      SHA2562.prototype.digest = function() {
        var out = new Uint8Array(this.digestLength);
        this.finish(out);
        return out;
      };
      SHA2562.prototype.saveState = function() {
        if (this._finished) {
          throw new Error("SHA256: cannot save finished state");
        }
        return {
          state: new Int32Array(this._state),
          buffer: this._bufferLength > 0 ? new Uint8Array(this._buffer) : void 0,
          bufferLength: this._bufferLength,
          bytesHashed: this._bytesHashed
        };
      };
      SHA2562.prototype.restoreState = function(savedState) {
        this._state.set(savedState.state);
        this._bufferLength = savedState.bufferLength;
        if (savedState.buffer) {
          this._buffer.set(savedState.buffer);
        }
        this._bytesHashed = savedState.bytesHashed;
        this._finished = false;
        return this;
      };
      SHA2562.prototype.cleanSavedState = function(savedState) {
        wipe_1.wipe(savedState.state);
        if (savedState.buffer) {
          wipe_1.wipe(savedState.buffer);
        }
        savedState.bufferLength = 0;
        savedState.bytesHashed = 0;
      };
      return SHA2562;
    }();
    exports2.SHA256 = SHA256;
    var K = new Int32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    function hashBlocks(w, v, p, pos, len) {
      while (len >= 64) {
        var a = v[0];
        var b = v[1];
        var c = v[2];
        var d = v[3];
        var e = v[4];
        var f = v[5];
        var g = v[6];
        var h = v[7];
        for (var i = 0; i < 16; i++) {
          var j = pos + i * 4;
          w[i] = binary_1.readUint32BE(p, j);
        }
        for (var i = 16; i < 64; i++) {
          var u = w[i - 2];
          var t1 = (u >>> 17 | u << 32 - 17) ^ (u >>> 19 | u << 32 - 19) ^ u >>> 10;
          u = w[i - 15];
          var t2 = (u >>> 7 | u << 32 - 7) ^ (u >>> 18 | u << 32 - 18) ^ u >>> 3;
          w[i] = (t1 + w[i - 7] | 0) + (t2 + w[i - 16] | 0);
        }
        for (var i = 0; i < 64; i++) {
          var t1 = (((e >>> 6 | e << 32 - 6) ^ (e >>> 11 | e << 32 - 11) ^ (e >>> 25 | e << 32 - 25)) + (e & f ^ ~e & g) | 0) + (h + (K[i] + w[i] | 0) | 0) | 0;
          var t2 = ((a >>> 2 | a << 32 - 2) ^ (a >>> 13 | a << 32 - 13) ^ (a >>> 22 | a << 32 - 22)) + (a & b ^ a & c ^ b & c) | 0;
          h = g;
          g = f;
          f = e;
          e = d + t1 | 0;
          d = c;
          c = b;
          b = a;
          a = t1 + t2 | 0;
        }
        v[0] += a;
        v[1] += b;
        v[2] += c;
        v[3] += d;
        v[4] += e;
        v[5] += f;
        v[6] += g;
        v[7] += h;
        pos += 64;
        len -= 64;
      }
      return pos;
    }
    function hash2(data) {
      var h = new SHA256();
      h.update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }
    exports2.hash = hash2;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js
var require_payload = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/proto/payload.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    (function(global2, factory) {
      if (typeof define === "function" && define.amd)
        define(["protobufjs/minimal"], factory);
      else if (typeof __require === "function" && typeof module2 === "object" && module2 && module2.exports)
        module2.exports = factory(require_minimal2());
    })(exports2, function($protobuf5) {
      "use strict";
      var $Reader5 = $protobuf5.Reader, $Writer5 = $protobuf5.Writer, $util5 = $protobuf5.util;
      var $root5 = $protobuf5.roots["libp2p-noise"] || ($protobuf5.roots["libp2p-noise"] = {});
      $root5.pb = function() {
        var pb = {};
        pb.NoiseHandshakePayload = function() {
          function NoiseHandshakePayload(properties) {
            if (properties) {
              for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                if (properties[keys[i]] != null)
                  this[keys[i]] = properties[keys[i]];
            }
          }
          NoiseHandshakePayload.prototype.identityKey = $util5.newBuffer([]);
          NoiseHandshakePayload.prototype.identitySig = $util5.newBuffer([]);
          NoiseHandshakePayload.prototype.data = $util5.newBuffer([]);
          NoiseHandshakePayload.create = function create7(properties) {
            return new NoiseHandshakePayload(properties);
          };
          NoiseHandshakePayload.encode = function encode10(message, writer) {
            if (!writer)
              writer = $Writer5.create();
            if (message.identityKey != null && Object.hasOwnProperty.call(message, "identityKey"))
              writer.uint32(10).bytes(message.identityKey);
            if (message.identitySig != null && Object.hasOwnProperty.call(message, "identitySig"))
              writer.uint32(18).bytes(message.identitySig);
            if (message.data != null && Object.hasOwnProperty.call(message, "data"))
              writer.uint32(26).bytes(message.data);
            return writer;
          };
          NoiseHandshakePayload.encodeDelimited = function encodeDelimited(message, writer) {
            return this.encode(message, writer).ldelim();
          };
          NoiseHandshakePayload.decode = function decode12(reader, length4) {
            if (!(reader instanceof $Reader5))
              reader = $Reader5.create(reader);
            var end = length4 === void 0 ? reader.len : reader.pos + length4, message = new $root5.pb.NoiseHandshakePayload();
            while (reader.pos < end) {
              var tag2 = reader.uint32();
              switch (tag2 >>> 3) {
                case 1:
                  message.identityKey = reader.bytes();
                  break;
                case 2:
                  message.identitySig = reader.bytes();
                  break;
                case 3:
                  message.data = reader.bytes();
                  break;
                default:
                  reader.skipType(tag2 & 7);
                  break;
              }
            }
            return message;
          };
          NoiseHandshakePayload.decodeDelimited = function decodeDelimited(reader) {
            if (!(reader instanceof $Reader5))
              reader = new $Reader5(reader);
            return this.decode(reader, reader.uint32());
          };
          NoiseHandshakePayload.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
              return "object expected";
            if (message.identityKey != null && message.hasOwnProperty("identityKey")) {
              if (!(message.identityKey && typeof message.identityKey.length === "number" || $util5.isString(message.identityKey)))
                return "identityKey: buffer expected";
            }
            if (message.identitySig != null && message.hasOwnProperty("identitySig")) {
              if (!(message.identitySig && typeof message.identitySig.length === "number" || $util5.isString(message.identitySig)))
                return "identitySig: buffer expected";
            }
            if (message.data != null && message.hasOwnProperty("data")) {
              if (!(message.data && typeof message.data.length === "number" || $util5.isString(message.data)))
                return "data: buffer expected";
            }
            return null;
          };
          NoiseHandshakePayload.fromObject = function fromObject(object) {
            if (object instanceof $root5.pb.NoiseHandshakePayload)
              return object;
            var message = new $root5.pb.NoiseHandshakePayload();
            if (object.identityKey != null) {
              if (typeof object.identityKey === "string")
                $util5.base64.decode(object.identityKey, message.identityKey = $util5.newBuffer($util5.base64.length(object.identityKey)), 0);
              else if (object.identityKey.length)
                message.identityKey = object.identityKey;
            }
            if (object.identitySig != null) {
              if (typeof object.identitySig === "string")
                $util5.base64.decode(object.identitySig, message.identitySig = $util5.newBuffer($util5.base64.length(object.identitySig)), 0);
              else if (object.identitySig.length)
                message.identitySig = object.identitySig;
            }
            if (object.data != null) {
              if (typeof object.data === "string")
                $util5.base64.decode(object.data, message.data = $util5.newBuffer($util5.base64.length(object.data)), 0);
              else if (object.data.length)
                message.data = object.data;
            }
            return message;
          };
          NoiseHandshakePayload.toObject = function toObject(message, options) {
            if (!options)
              options = {};
            var object = {};
            if (options.defaults) {
              if (options.bytes === String)
                object.identityKey = "";
              else {
                object.identityKey = [];
                if (options.bytes !== Array)
                  object.identityKey = $util5.newBuffer(object.identityKey);
              }
              if (options.bytes === String)
                object.identitySig = "";
              else {
                object.identitySig = [];
                if (options.bytes !== Array)
                  object.identitySig = $util5.newBuffer(object.identitySig);
              }
              if (options.bytes === String)
                object.data = "";
              else {
                object.data = [];
                if (options.bytes !== Array)
                  object.data = $util5.newBuffer(object.data);
              }
            }
            if (message.identityKey != null && message.hasOwnProperty("identityKey"))
              object.identityKey = options.bytes === String ? $util5.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
            if (message.identitySig != null && message.hasOwnProperty("identitySig"))
              object.identitySig = options.bytes === String ? $util5.base64.encode(message.identitySig, 0, message.identitySig.length) : options.bytes === Array ? Array.prototype.slice.call(message.identitySig) : message.identitySig;
            if (message.data != null && message.hasOwnProperty("data"))
              object.data = options.bytes === String ? $util5.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
            return object;
          };
          NoiseHandshakePayload.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
          };
          return NoiseHandshakePayload;
        }();
        return pb;
      }();
      return $root5;
    });
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/utils.js
var require_utils14 = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/utils.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isValidPublicKey = exports2.getHkdf = exports2.verifySignedPayload = exports2.getHandshakePayload = exports2.decodePayload = exports2.getPeerIdFromPayload = exports2.signPayload = exports2.createHandshakePayload = exports2.getPayload = exports2.generateKeypair = void 0;
    var hkdf_1 = require_hkdf();
    var sha256_1 = require_sha2562();
    var x25519 = __importStar(require_x25519());
    var buffer_1 = require_buffer();
    var peer_id_1 = __importDefault(require_src6());
    var libp2p_crypto_1 = require_src7();
    var payload_1 = require_payload();
    var equals_1 = (init_equals(), equals_exports);
    var NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;
    function generateKeypair() {
      const keypair = x25519.generateKeyPair();
      return {
        publicKey: buffer_1.Buffer.from(keypair.publicKey.buffer, keypair.publicKey.byteOffset, keypair.publicKey.length),
        privateKey: buffer_1.Buffer.from(keypair.secretKey.buffer, keypair.secretKey.byteOffset, keypair.secretKey.length)
      };
    }
    exports2.generateKeypair = generateKeypair;
    async function getPayload(localPeer, staticPublicKey, earlyData) {
      const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
      const earlyDataPayload = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);
      return createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);
    }
    exports2.getPayload = getPayload;
    function createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {
      const payloadInit = NoiseHandshakePayloadProto.create({
        identityKey: buffer_1.Buffer.from(libp2pPublicKey),
        identitySig: signedPayload,
        data: earlyData !== null && earlyData !== void 0 ? earlyData : null
      });
      return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());
    }
    exports2.createHandshakePayload = createHandshakePayload;
    async function signPayload(peerId, payload) {
      return buffer_1.Buffer.from(await peerId.privKey.sign(payload));
    }
    exports2.signPayload = signPayload;
    async function getPeerIdFromPayload(payload) {
      return await peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));
    }
    exports2.getPeerIdFromPayload = getPeerIdFromPayload;
    function decodePayload(payload) {
      return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));
    }
    exports2.decodePayload = decodePayload;
    function getHandshakePayload(publicKey) {
      return buffer_1.Buffer.concat([buffer_1.Buffer.from("noise-libp2p-static-key:"), publicKey]);
    }
    exports2.getHandshakePayload = getHandshakePayload;
    async function isValidPeerId(peerId, publicKeyProtobuf) {
      const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);
      return equals_1.equals(generatedPeerId.id, peerId);
    }
    async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
      const identityKey = buffer_1.Buffer.from(payload.identityKey);
      if (!await isValidPeerId(remotePeer.id, identityKey)) {
        throw new Error("Peer ID doesn't match libp2p public key.");
      }
      const generatedPayload = getHandshakePayload(noiseStaticKey);
      const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey);
      if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {
        throw new Error("Static key doesn't match to peer that signed payload!");
      }
      return await peer_id_1.default.createFromPubKey(identityKey);
    }
    exports2.verifySignedPayload = verifySignedPayload;
    function getHkdf(ck, ikm) {
      const hkdf = new hkdf_1.HKDF(sha256_1.SHA256, ikm, ck);
      const okmU8Array = hkdf.expand(96);
      const okm = buffer_1.Buffer.from(okmU8Array.buffer, okmU8Array.byteOffset, okmU8Array.length);
      const k1 = okm.slice(0, 32);
      const k2 = okm.slice(32, 64);
      const k3 = okm.slice(64, 96);
      return [k1, k2, k3];
    }
    exports2.getHkdf = getHkdf;
    function isValidPublicKey(pk) {
      if (!buffer_1.Buffer.isBuffer(pk)) {
        return false;
      }
      if (pk.length !== 32) {
        return false;
      }
      return true;
    }
    exports2.isValidPublicKey = isValidPublicKey;
  }
});

// node_modules/@stablelib/chacha/lib/chacha.js
var require_chacha = __commonJS({
  "node_modules/@stablelib/chacha/lib/chacha.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var binary_1 = require_binary2();
    var wipe_1 = require_wipe();
    var ROUNDS = 20;
    function core(out, input, key) {
      var j0 = 1634760805;
      var j1 = 857760878;
      var j2 = 2036477234;
      var j3 = 1797285236;
      var j4 = key[3] << 24 | key[2] << 16 | key[1] << 8 | key[0];
      var j5 = key[7] << 24 | key[6] << 16 | key[5] << 8 | key[4];
      var j6 = key[11] << 24 | key[10] << 16 | key[9] << 8 | key[8];
      var j7 = key[15] << 24 | key[14] << 16 | key[13] << 8 | key[12];
      var j8 = key[19] << 24 | key[18] << 16 | key[17] << 8 | key[16];
      var j9 = key[23] << 24 | key[22] << 16 | key[21] << 8 | key[20];
      var j10 = key[27] << 24 | key[26] << 16 | key[25] << 8 | key[24];
      var j11 = key[31] << 24 | key[30] << 16 | key[29] << 8 | key[28];
      var j12 = input[3] << 24 | input[2] << 16 | input[1] << 8 | input[0];
      var j13 = input[7] << 24 | input[6] << 16 | input[5] << 8 | input[4];
      var j14 = input[11] << 24 | input[10] << 16 | input[9] << 8 | input[8];
      var j15 = input[15] << 24 | input[14] << 16 | input[13] << 8 | input[12];
      var x0 = j0;
      var x1 = j1;
      var x2 = j2;
      var x3 = j3;
      var x4 = j4;
      var x5 = j5;
      var x6 = j6;
      var x7 = j7;
      var x8 = j8;
      var x9 = j9;
      var x10 = j10;
      var x11 = j11;
      var x12 = j12;
      var x13 = j13;
      var x14 = j14;
      var x15 = j15;
      for (var i = 0; i < ROUNDS; i += 2) {
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x2 = x2 + x6 | 0;
        x14 ^= x2;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x10 = x10 + x14 | 0;
        x6 ^= x10;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x3 = x3 + x7 | 0;
        x15 ^= x3;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x11 = x11 + x15 | 0;
        x7 ^= x11;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x1 = x1 + x5 | 0;
        x13 ^= x1;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x9 = x9 + x13 | 0;
        x5 ^= x9;
        x5 = x5 >>> 32 - 7 | x5 << 7;
        x0 = x0 + x4 | 0;
        x12 ^= x0;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x8 = x8 + x12 | 0;
        x4 ^= x8;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 16 | x15 << 16;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 12 | x5 << 12;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 16 | x12 << 16;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 12 | x6 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 16 | x13 << 16;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 12 | x7 << 12;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 16 | x14 << 16;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 12 | x4 << 12;
        x2 = x2 + x7 | 0;
        x13 ^= x2;
        x13 = x13 >>> 32 - 8 | x13 << 8;
        x8 = x8 + x13 | 0;
        x7 ^= x8;
        x7 = x7 >>> 32 - 7 | x7 << 7;
        x3 = x3 + x4 | 0;
        x14 ^= x3;
        x14 = x14 >>> 32 - 8 | x14 << 8;
        x9 = x9 + x14 | 0;
        x4 ^= x9;
        x4 = x4 >>> 32 - 7 | x4 << 7;
        x1 = x1 + x6 | 0;
        x12 ^= x1;
        x12 = x12 >>> 32 - 8 | x12 << 8;
        x11 = x11 + x12 | 0;
        x6 ^= x11;
        x6 = x6 >>> 32 - 7 | x6 << 7;
        x0 = x0 + x5 | 0;
        x15 ^= x0;
        x15 = x15 >>> 32 - 8 | x15 << 8;
        x10 = x10 + x15 | 0;
        x5 ^= x10;
        x5 = x5 >>> 32 - 7 | x5 << 7;
      }
      binary_1.writeUint32LE(x0 + j0 | 0, out, 0);
      binary_1.writeUint32LE(x1 + j1 | 0, out, 4);
      binary_1.writeUint32LE(x2 + j2 | 0, out, 8);
      binary_1.writeUint32LE(x3 + j3 | 0, out, 12);
      binary_1.writeUint32LE(x4 + j4 | 0, out, 16);
      binary_1.writeUint32LE(x5 + j5 | 0, out, 20);
      binary_1.writeUint32LE(x6 + j6 | 0, out, 24);
      binary_1.writeUint32LE(x7 + j7 | 0, out, 28);
      binary_1.writeUint32LE(x8 + j8 | 0, out, 32);
      binary_1.writeUint32LE(x9 + j9 | 0, out, 36);
      binary_1.writeUint32LE(x10 + j10 | 0, out, 40);
      binary_1.writeUint32LE(x11 + j11 | 0, out, 44);
      binary_1.writeUint32LE(x12 + j12 | 0, out, 48);
      binary_1.writeUint32LE(x13 + j13 | 0, out, 52);
      binary_1.writeUint32LE(x14 + j14 | 0, out, 56);
      binary_1.writeUint32LE(x15 + j15 | 0, out, 60);
    }
    function streamXOR(key, nonce, src2, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      if (key.length !== 32) {
        throw new Error("ChaCha: key size must be 32 bytes");
      }
      if (dst.length < src2.length) {
        throw new Error("ChaCha: destination is shorter than source");
      }
      var nc;
      var counterLength;
      if (nonceInplaceCounterLength === 0) {
        if (nonce.length !== 8 && nonce.length !== 12) {
          throw new Error("ChaCha nonce must be 8 or 12 bytes");
        }
        nc = new Uint8Array(16);
        counterLength = nc.length - nonce.length;
        nc.set(nonce, counterLength);
      } else {
        if (nonce.length !== 16) {
          throw new Error("ChaCha nonce with counter must be 16 bytes");
        }
        nc = nonce;
        counterLength = nonceInplaceCounterLength;
      }
      var block = new Uint8Array(64);
      for (var i = 0; i < src2.length; i += 64) {
        core(block, nc, key);
        for (var j = i; j < i + 64 && j < src2.length; j++) {
          dst[j] = src2[j] ^ block[j - i];
        }
        incrementCounter(nc, 0, counterLength);
      }
      wipe_1.wipe(block);
      if (nonceInplaceCounterLength === 0) {
        wipe_1.wipe(nc);
      }
      return dst;
    }
    exports2.streamXOR = streamXOR;
    function stream(key, nonce, dst, nonceInplaceCounterLength) {
      if (nonceInplaceCounterLength === void 0) {
        nonceInplaceCounterLength = 0;
      }
      wipe_1.wipe(dst);
      return streamXOR(key, nonce, dst, dst, nonceInplaceCounterLength);
    }
    exports2.stream = stream;
    function incrementCounter(counter, pos, len) {
      var carry = 1;
      while (len--) {
        carry = carry + (counter[pos] & 255) | 0;
        counter[pos] = carry & 255;
        carry >>>= 8;
        pos++;
      }
      if (carry > 0) {
        throw new Error("ChaCha: counter overflow");
      }
    }
  }
});

// node_modules/@stablelib/poly1305/lib/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/@stablelib/poly1305/lib/poly1305.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var constant_time_1 = require_constant_time();
    var wipe_1 = require_wipe();
    exports2.DIGEST_LENGTH = 16;
    var Poly1305 = function() {
      function Poly13052(key) {
        this.digestLength = exports2.DIGEST_LENGTH;
        this._buffer = new Uint8Array(16);
        this._r = new Uint16Array(10);
        this._h = new Uint16Array(10);
        this._pad = new Uint16Array(8);
        this._leftover = 0;
        this._fin = 0;
        this._finished = false;
        var t0 = key[0] | key[1] << 8;
        this._r[0] = t0 & 8191;
        var t1 = key[2] | key[3] << 8;
        this._r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        var t2 = key[4] | key[5] << 8;
        this._r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        var t3 = key[6] | key[7] << 8;
        this._r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        var t4 = key[8] | key[9] << 8;
        this._r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this._r[5] = t4 >>> 1 & 8190;
        var t5 = key[10] | key[11] << 8;
        this._r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        var t6 = key[12] | key[13] << 8;
        this._r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        var t7 = key[14] | key[15] << 8;
        this._r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this._r[9] = t7 >>> 5 & 127;
        this._pad[0] = key[16] | key[17] << 8;
        this._pad[1] = key[18] | key[19] << 8;
        this._pad[2] = key[20] | key[21] << 8;
        this._pad[3] = key[22] | key[23] << 8;
        this._pad[4] = key[24] | key[25] << 8;
        this._pad[5] = key[26] | key[27] << 8;
        this._pad[6] = key[28] | key[29] << 8;
        this._pad[7] = key[30] | key[31] << 8;
      }
      Poly13052.prototype._blocks = function(m, mpos, bytes3) {
        var hibit = this._fin ? 0 : 1 << 11;
        var h0 = this._h[0], h1 = this._h[1], h2 = this._h[2], h3 = this._h[3], h4 = this._h[4], h5 = this._h[5], h6 = this._h[6], h7 = this._h[7], h8 = this._h[8], h9 = this._h[9];
        var r0 = this._r[0], r1 = this._r[1], r2 = this._r[2], r3 = this._r[3], r4 = this._r[4], r5 = this._r[5], r6 = this._r[6], r7 = this._r[7], r8 = this._r[8], r9 = this._r[9];
        while (bytes3 >= 16) {
          var t0 = m[mpos + 0] | m[mpos + 1] << 8;
          h0 += t0 & 8191;
          var t1 = m[mpos + 2] | m[mpos + 3] << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          var t2 = m[mpos + 4] | m[mpos + 5] << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          var t3 = m[mpos + 6] | m[mpos + 7] << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          var t4 = m[mpos + 8] | m[mpos + 9] << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          var t5 = m[mpos + 10] | m[mpos + 11] << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          var t6 = m[mpos + 12] | m[mpos + 13] << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          var t7 = m[mpos + 14] | m[mpos + 15] << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          var c = 0;
          var d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          var d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          var d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          var d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          var d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          var d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          var d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          var d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          var d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          var d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes3 -= 16;
        }
        this._h[0] = h0;
        this._h[1] = h1;
        this._h[2] = h2;
        this._h[3] = h3;
        this._h[4] = h4;
        this._h[5] = h5;
        this._h[6] = h6;
        this._h[7] = h7;
        this._h[8] = h8;
        this._h[9] = h9;
      };
      Poly13052.prototype.finish = function(mac, macpos) {
        if (macpos === void 0) {
          macpos = 0;
        }
        var g = new Uint16Array(10);
        var c;
        var mask;
        var f;
        var i;
        if (this._leftover) {
          i = this._leftover;
          this._buffer[i++] = 1;
          for (; i < 16; i++) {
            this._buffer[i] = 0;
          }
          this._fin = 1;
          this._blocks(this._buffer, 0, 16);
        }
        c = this._h[1] >>> 13;
        this._h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this._h[i] += c;
          c = this._h[i] >>> 13;
          this._h[i] &= 8191;
        }
        this._h[0] += c * 5;
        c = this._h[0] >>> 13;
        this._h[0] &= 8191;
        this._h[1] += c;
        c = this._h[1] >>> 13;
        this._h[1] &= 8191;
        this._h[2] += c;
        g[0] = this._h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this._h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) {
          g[i] &= mask;
        }
        mask = ~mask;
        for (i = 0; i < 10; i++) {
          this._h[i] = this._h[i] & mask | g[i];
        }
        this._h[0] = (this._h[0] | this._h[1] << 13) & 65535;
        this._h[1] = (this._h[1] >>> 3 | this._h[2] << 10) & 65535;
        this._h[2] = (this._h[2] >>> 6 | this._h[3] << 7) & 65535;
        this._h[3] = (this._h[3] >>> 9 | this._h[4] << 4) & 65535;
        this._h[4] = (this._h[4] >>> 12 | this._h[5] << 1 | this._h[6] << 14) & 65535;
        this._h[5] = (this._h[6] >>> 2 | this._h[7] << 11) & 65535;
        this._h[6] = (this._h[7] >>> 5 | this._h[8] << 8) & 65535;
        this._h[7] = (this._h[8] >>> 8 | this._h[9] << 5) & 65535;
        f = this._h[0] + this._pad[0];
        this._h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this._h[i] + this._pad[i] | 0) + (f >>> 16) | 0;
          this._h[i] = f & 65535;
        }
        mac[macpos + 0] = this._h[0] >>> 0;
        mac[macpos + 1] = this._h[0] >>> 8;
        mac[macpos + 2] = this._h[1] >>> 0;
        mac[macpos + 3] = this._h[1] >>> 8;
        mac[macpos + 4] = this._h[2] >>> 0;
        mac[macpos + 5] = this._h[2] >>> 8;
        mac[macpos + 6] = this._h[3] >>> 0;
        mac[macpos + 7] = this._h[3] >>> 8;
        mac[macpos + 8] = this._h[4] >>> 0;
        mac[macpos + 9] = this._h[4] >>> 8;
        mac[macpos + 10] = this._h[5] >>> 0;
        mac[macpos + 11] = this._h[5] >>> 8;
        mac[macpos + 12] = this._h[6] >>> 0;
        mac[macpos + 13] = this._h[6] >>> 8;
        mac[macpos + 14] = this._h[7] >>> 0;
        mac[macpos + 15] = this._h[7] >>> 8;
        this._finished = true;
        return this;
      };
      Poly13052.prototype.update = function(m) {
        var mpos = 0;
        var bytes3 = m.length;
        var want;
        if (this._leftover) {
          want = 16 - this._leftover;
          if (want > bytes3) {
            want = bytes3;
          }
          for (var i = 0; i < want; i++) {
            this._buffer[this._leftover + i] = m[mpos + i];
          }
          bytes3 -= want;
          mpos += want;
          this._leftover += want;
          if (this._leftover < 16) {
            return this;
          }
          this._blocks(this._buffer, 0, 16);
          this._leftover = 0;
        }
        if (bytes3 >= 16) {
          want = bytes3 - bytes3 % 16;
          this._blocks(m, mpos, want);
          mpos += want;
          bytes3 -= want;
        }
        if (bytes3) {
          for (var i = 0; i < bytes3; i++) {
            this._buffer[this._leftover + i] = m[mpos + i];
          }
          this._leftover += bytes3;
        }
        return this;
      };
      Poly13052.prototype.digest = function() {
        if (this._finished) {
          throw new Error("Poly1305 was finished");
        }
        var mac = new Uint8Array(16);
        this.finish(mac);
        return mac;
      };
      Poly13052.prototype.clean = function() {
        wipe_1.wipe(this._buffer);
        wipe_1.wipe(this._r);
        wipe_1.wipe(this._h);
        wipe_1.wipe(this._pad);
        this._leftover = 0;
        this._fin = 0;
        this._finished = true;
        return this;
      };
      return Poly13052;
    }();
    exports2.Poly1305 = Poly1305;
    function oneTimeAuth(key, data) {
      var h = new Poly1305(key);
      h.update(data);
      var digest = h.digest();
      h.clean();
      return digest;
    }
    exports2.oneTimeAuth = oneTimeAuth;
    function equal(a, b) {
      if (a.length !== exports2.DIGEST_LENGTH || b.length !== exports2.DIGEST_LENGTH) {
        return false;
      }
      return constant_time_1.equal(a, b);
    }
    exports2.equal = equal;
  }
});

// node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js
var require_chacha20poly1305 = __commonJS({
  "node_modules/@stablelib/chacha20poly1305/lib/chacha20poly1305.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var chacha_1 = require_chacha();
    var poly1305_1 = require_poly1305();
    var wipe_1 = require_wipe();
    var binary_1 = require_binary2();
    var constant_time_1 = require_constant_time();
    exports2.KEY_LENGTH = 32;
    exports2.NONCE_LENGTH = 12;
    exports2.TAG_LENGTH = 16;
    var ZEROS = new Uint8Array(16);
    var ChaCha20Poly1305 = function() {
      function ChaCha20Poly13052(key) {
        this.nonceLength = exports2.NONCE_LENGTH;
        this.tagLength = exports2.TAG_LENGTH;
        if (key.length !== exports2.KEY_LENGTH) {
          throw new Error("ChaCha20Poly1305 needs 32-byte key");
        }
        this._key = new Uint8Array(key);
      }
      ChaCha20Poly13052.prototype.seal = function(nonce, plaintext, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var resultLength = plaintext.length + this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, plaintext, result, 4);
        this._authenticate(result.subarray(result.length - this.tagLength, result.length), authKey, result.subarray(0, result.length - this.tagLength), associatedData);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.open = function(nonce, sealed, associatedData, dst) {
        if (nonce.length > 16) {
          throw new Error("ChaCha20Poly1305: incorrect nonce length");
        }
        if (sealed.length < this.tagLength) {
          return null;
        }
        var counter = new Uint8Array(16);
        counter.set(nonce, counter.length - nonce.length);
        var authKey = new Uint8Array(32);
        chacha_1.stream(this._key, counter, authKey, 4);
        var calculatedTag = new Uint8Array(this.tagLength);
        this._authenticate(calculatedTag, authKey, sealed.subarray(0, sealed.length - this.tagLength), associatedData);
        if (!constant_time_1.equal(calculatedTag, sealed.subarray(sealed.length - this.tagLength, sealed.length))) {
          return null;
        }
        var resultLength = sealed.length - this.tagLength;
        var result;
        if (dst) {
          if (dst.length !== resultLength) {
            throw new Error("ChaCha20Poly1305: incorrect destination length");
          }
          result = dst;
        } else {
          result = new Uint8Array(resultLength);
        }
        chacha_1.streamXOR(this._key, counter, sealed.subarray(0, sealed.length - this.tagLength), result, 4);
        wipe_1.wipe(counter);
        return result;
      };
      ChaCha20Poly13052.prototype.clean = function() {
        wipe_1.wipe(this._key);
        return this;
      };
      ChaCha20Poly13052.prototype._authenticate = function(tagOut, authKey, ciphertext, associatedData) {
        var h = new poly1305_1.Poly1305(authKey);
        if (associatedData) {
          h.update(associatedData);
          if (associatedData.length % 16 > 0) {
            h.update(ZEROS.subarray(associatedData.length % 16));
          }
        }
        h.update(ciphertext);
        if (ciphertext.length % 16 > 0) {
          h.update(ZEROS.subarray(ciphertext.length % 16));
        }
        var length4 = new Uint8Array(8);
        if (associatedData) {
          binary_1.writeUint64LE(associatedData.length, length4);
        }
        h.update(length4);
        binary_1.writeUint64LE(ciphertext.length, length4);
        h.update(length4);
        var tag2 = h.digest();
        for (var i = 0; i < tag2.length; i++) {
          tagOut[i] = tag2[i];
        }
        h.clean();
        wipe_1.wipe(tag2);
        wipe_1.wipe(length4);
      };
      return ChaCha20Poly13052;
    }();
    exports2.ChaCha20Poly1305 = ChaCha20Poly1305;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/constants.js
var require_constants9 = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/constants.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DUMP_SESSION_KEYS = exports2.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = exports2.NOISE_MSG_MAX_LENGTH_BYTES = void 0;
    exports2.NOISE_MSG_MAX_LENGTH_BYTES = 65535;
    exports2.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = exports2.NOISE_MSG_MAX_LENGTH_BYTES - 16;
    exports2.DUMP_SESSION_KEYS = process.env.DUMP_SESSION_KEYS;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/logger.js
var require_logger = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/logger.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.logCipherState = exports2.logRemoteEphemeralKey = exports2.logRemoteStaticKey = exports2.logLocalEphemeralKeys = exports2.logLocalStaticKeys = exports2.logger = void 0;
    var debug_1 = __importDefault(require_browser2());
    var constants_1 = require_constants9();
    exports2.logger = debug_1.default("libp2p:noise");
    var keyLogger;
    if (constants_1.DUMP_SESSION_KEYS) {
      keyLogger = exports2.logger;
    } else {
      keyLogger = () => {
      };
    }
    function logLocalStaticKeys(s) {
      keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${s.publicKey.toString("hex")}`);
      keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${s.privateKey.toString("hex")}`);
    }
    exports2.logLocalStaticKeys = logLocalStaticKeys;
    function logLocalEphemeralKeys(e) {
      if (e) {
        keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${e.publicKey.toString("hex")}`);
        keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${e.privateKey.toString("hex")}`);
      } else {
        keyLogger("Missing local ephemeral keys.");
      }
    }
    exports2.logLocalEphemeralKeys = logLocalEphemeralKeys;
    function logRemoteStaticKey(rs) {
      keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${rs.toString("hex")}`);
    }
    exports2.logRemoteStaticKey = logRemoteStaticKey;
    function logRemoteEphemeralKey(re) {
      keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${re.toString("hex")}`);
    }
    exports2.logRemoteEphemeralKey = logRemoteEphemeralKey;
    function logCipherState(session) {
      if (session.cs1 && session.cs2) {
        keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${session.cs1.k.toString("hex")}`);
        keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${session.cs2.k.toString("hex")}`);
      } else {
        keyLogger("Missing cipher state.");
      }
    }
    exports2.logCipherState = logCipherState;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js
var require_abstract_handshake = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/abstract-handshake.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AbstractHandshake = exports2.MIN_NONCE = void 0;
    var buffer_1 = require_buffer();
    var x25519 = __importStar(require_x25519());
    var SHA256 = __importStar(require_sha2562());
    var chacha20poly1305_1 = require_chacha20poly1305();
    var utils_1 = require_utils14();
    var logger_1 = require_logger();
    exports2.MIN_NONCE = 0;
    var AbstractHandshake = class {
      encryptWithAd(cs, ad, plaintext) {
        const e = this.encrypt(cs.k, cs.n, ad, plaintext);
        this.setNonce(cs, this.incrementNonce(cs.n));
        return e;
      }
      decryptWithAd(cs, ad, ciphertext) {
        const { plaintext, valid } = this.decrypt(cs.k, cs.n, ad, ciphertext);
        this.setNonce(cs, this.incrementNonce(cs.n));
        return { plaintext, valid };
      }
      hasKey(cs) {
        return !this.isEmptyKey(cs.k);
      }
      setNonce(cs, nonce) {
        cs.n = nonce;
      }
      createEmptyKey() {
        return buffer_1.Buffer.alloc(32);
      }
      isEmptyKey(k) {
        const emptyKey = this.createEmptyKey();
        return emptyKey.equals(k);
      }
      incrementNonce(n) {
        return n + 1;
      }
      nonceToBytes(n) {
        const nonce = buffer_1.Buffer.alloc(12);
        nonce.writeUInt32LE(n, 4);
        return nonce;
      }
      encrypt(k, n, ad, plaintext) {
        const nonce = this.nonceToBytes(n);
        const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);
        const encryptedMessage = ctx.seal(nonce, plaintext, ad);
        return buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length);
      }
      encryptAndHash(ss, plaintext) {
        let ciphertext;
        if (this.hasKey(ss.cs)) {
          ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
        } else {
          ciphertext = plaintext;
        }
        this.mixHash(ss, ciphertext);
        return ciphertext;
      }
      decrypt(k, n, ad, ciphertext) {
        const nonce = this.nonceToBytes(n);
        const ctx = new chacha20poly1305_1.ChaCha20Poly1305(k);
        const encryptedMessage = ctx.open(nonce, ciphertext, ad);
        if (encryptedMessage) {
          return {
            plaintext: buffer_1.Buffer.from(encryptedMessage.buffer, encryptedMessage.byteOffset, encryptedMessage.length),
            valid: true
          };
        } else {
          return {
            plaintext: buffer_1.Buffer.from(""),
            valid: false
          };
        }
      }
      decryptAndHash(ss, ciphertext) {
        let plaintext;
        let valid = true;
        if (this.hasKey(ss.cs)) {
          ({ plaintext, valid } = this.decryptWithAd(ss.cs, ss.h, ciphertext));
        } else {
          plaintext = ciphertext;
        }
        this.mixHash(ss, ciphertext);
        return { plaintext, valid };
      }
      dh(privateKey, publicKey) {
        try {
          const derivedU8 = x25519.sharedKey(privateKey, publicKey);
          const derived = buffer_1.Buffer.from(derivedU8.buffer, derivedU8.byteOffset, derivedU8.length);
          const result = buffer_1.Buffer.alloc(32);
          derived.copy(result);
          return result;
        } catch (e) {
          logger_1.logger(e.message);
          return buffer_1.Buffer.alloc(32);
        }
      }
      mixHash(ss, data) {
        ss.h = this.getHash(ss.h, data);
      }
      getHash(a, b) {
        const hash2 = SHA256.hash(buffer_1.Buffer.from([...a, ...b]));
        return buffer_1.Buffer.from(hash2.buffer, hash2.byteOffset, hash2.length);
      }
      mixKey(ss, ikm) {
        const [ck, tempK] = utils_1.getHkdf(ss.ck, ikm);
        ss.cs = this.initializeKey(tempK);
        ss.ck = ck;
      }
      initializeKey(k) {
        const n = exports2.MIN_NONCE;
        return { k, n };
      }
      initializeSymmetric(protocolName) {
        const protocolNameBytes = buffer_1.Buffer.from(protocolName, "utf-8");
        const h = this.hashProtocolName(protocolNameBytes);
        const ck = h;
        const key = this.createEmptyKey();
        const cs = this.initializeKey(key);
        return { cs, ck, h };
      }
      hashProtocolName(protocolName) {
        if (protocolName.length <= 32) {
          const h = buffer_1.Buffer.alloc(32);
          protocolName.copy(h);
          return h;
        } else {
          return this.getHash(protocolName, buffer_1.Buffer.alloc(0));
        }
      }
      split(ss) {
        const [tempk1, tempk2] = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0));
        const cs1 = this.initializeKey(tempk1);
        const cs2 = this.initializeKey(tempk2);
        return { cs1, cs2 };
      }
      writeMessageRegular(cs, payload) {
        const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);
        const ne = this.createEmptyKey();
        const ns = buffer_1.Buffer.alloc(0);
        return { ne, ns, ciphertext };
      }
      readMessageRegular(cs, message) {
        return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);
      }
    };
    exports2.AbstractHandshake = AbstractHandshake;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/xx.js
var require_xx = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/xx.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XX = void 0;
    var buffer_1 = require_buffer();
    var utils_1 = require_utils14();
    var abstract_handshake_1 = require_abstract_handshake();
    var XX = class extends abstract_handshake_1.AbstractHandshake {
      initializeInitiator(prologue, s, rs, psk) {
        const name5 = "Noise_XX_25519_ChaChaPoly_SHA256";
        const ss = this.initializeSymmetric(name5);
        this.mixHash(ss, prologue);
        const re = buffer_1.Buffer.alloc(32);
        return { ss, s, rs, psk, re };
      }
      initializeResponder(prologue, s, rs, psk) {
        const name5 = "Noise_XX_25519_ChaChaPoly_SHA256";
        const ss = this.initializeSymmetric(name5);
        this.mixHash(ss, prologue);
        const re = buffer_1.Buffer.alloc(32);
        return { ss, s, rs, psk, re };
      }
      writeMessageA(hs, payload, e) {
        const ns = buffer_1.Buffer.alloc(0);
        if (e !== void 0) {
          hs.e = e;
        } else {
          hs.e = utils_1.generateKeypair();
        }
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        return { ne, ns, ciphertext };
      }
      writeMessageB(hs, payload) {
        hs.e = utils_1.generateKeypair();
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        const spk = buffer_1.Buffer.from(hs.s.publicKey);
        const ns = this.encryptAndHash(hs.ss, spk);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        return { ne, ns, ciphertext };
      }
      writeMessageC(hs, payload) {
        const spk = buffer_1.Buffer.from(hs.s.publicKey);
        const ns = this.encryptAndHash(hs.ss, spk);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        const ne = this.createEmptyKey();
        const messageBuffer = { ne, ns, ciphertext };
        const { cs1, cs2 } = this.split(hs.ss);
        return { h: hs.ss.h, messageBuffer, cs1, cs2 };
      }
      readMessageA(hs, message) {
        if (utils_1.isValidPublicKey(message.ne)) {
          hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        return this.decryptAndHash(hs.ss, message.ciphertext);
      }
      readMessageB(hs, message) {
        if (utils_1.isValidPublicKey(message.ne)) {
          hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        if (!hs.e) {
          throw new Error("Handshake state `e` param is missing.");
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
        if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
          hs.rs = ns;
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
        return { plaintext, valid: valid1 && valid2 };
      }
      readMessageC(hs, message) {
        const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
        if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
          hs.rs = ns;
        }
        if (!hs.e) {
          throw new Error("Handshake state `e` param is missing.");
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
        const { cs1, cs2 } = this.split(hs.ss);
        return { h: hs.ss.h, plaintext, valid: valid1 && valid2, cs1, cs2 };
      }
      initSession(initiator, prologue, s) {
        const psk = this.createEmptyKey();
        const rs = buffer_1.Buffer.alloc(32);
        let hs;
        if (initiator) {
          hs = this.initializeInitiator(prologue, s, rs, psk);
        } else {
          hs = this.initializeResponder(prologue, s, rs, psk);
        }
        return {
          hs,
          i: initiator,
          mc: 0
        };
      }
      sendMessage(session, message, ephemeral) {
        let messageBuffer;
        if (session.mc === 0) {
          messageBuffer = this.writeMessageA(session.hs, message, ephemeral);
        } else if (session.mc === 1) {
          messageBuffer = this.writeMessageB(session.hs, message);
        } else if (session.mc === 2) {
          const { h, messageBuffer: resultingBuffer, cs1, cs2 } = this.writeMessageC(session.hs, message);
          messageBuffer = resultingBuffer;
          session.h = h;
          session.cs1 = cs1;
          session.cs2 = cs2;
        } else if (session.mc > 2) {
          if (session.i) {
            if (!session.cs1) {
              throw new Error("CS1 (cipher state) is not defined");
            }
            messageBuffer = this.writeMessageRegular(session.cs1, message);
          } else {
            if (!session.cs2) {
              throw new Error("CS2 (cipher state) is not defined");
            }
            messageBuffer = this.writeMessageRegular(session.cs2, message);
          }
        } else {
          throw new Error("Session invalid.");
        }
        session.mc++;
        return messageBuffer;
      }
      recvMessage(session, message) {
        let plaintext = buffer_1.Buffer.alloc(0);
        let valid = false;
        if (session.mc === 0) {
          ({ plaintext, valid } = this.readMessageA(session.hs, message));
        } else if (session.mc === 1) {
          ({ plaintext, valid } = this.readMessageB(session.hs, message));
        } else if (session.mc === 2) {
          const { h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2 } = this.readMessageC(session.hs, message);
          plaintext = resultingPlaintext;
          valid = resultingValid;
          session.h = h;
          session.cs1 = cs1;
          session.cs2 = cs2;
        }
        session.mc++;
        return { plaintext, valid };
      }
    };
    exports2.XX = XX;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/encoder.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decode2 = exports2.decode1 = exports2.decode0 = exports2.encode2 = exports2.encode1 = exports2.encode0 = exports2.uint16BEDecode = exports2.uint16BEEncode = void 0;
    var buffer_1 = require_buffer();
    var uint16BEEncode = (value, target, offset) => {
      target = target || buffer_1.Buffer.allocUnsafe(2);
      target.writeUInt16BE(value, offset);
      return target;
    };
    exports2.uint16BEEncode = uint16BEEncode;
    exports2.uint16BEEncode.bytes = 2;
    var uint16BEDecode = (data) => {
      if (data.length < 2)
        throw RangeError("Could not decode int16BE");
      return data.readUInt16BE(0);
    };
    exports2.uint16BEDecode = uint16BEDecode;
    exports2.uint16BEDecode.bytes = 2;
    function encode0(message) {
      return buffer_1.Buffer.concat([message.ne, message.ciphertext]);
    }
    exports2.encode0 = encode0;
    function encode1(message) {
      return buffer_1.Buffer.concat([message.ne, message.ns, message.ciphertext]);
    }
    exports2.encode1 = encode1;
    function encode22(message) {
      return buffer_1.Buffer.concat([message.ns, message.ciphertext]);
    }
    exports2.encode2 = encode22;
    function decode0(input) {
      if (input.length < 32) {
        throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
      }
      return {
        ne: input.slice(0, 32),
        ciphertext: input.slice(32, input.length),
        ns: buffer_1.Buffer.alloc(0)
      };
    }
    exports2.decode0 = decode0;
    function decode1(input) {
      if (input.length < 80) {
        throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
      }
      return {
        ne: input.slice(0, 32),
        ns: input.slice(32, 80),
        ciphertext: input.slice(80, input.length)
      };
    }
    exports2.decode1 = decode1;
    function decode22(input) {
      if (input.length < 48) {
        throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
      }
      return {
        ne: buffer_1.Buffer.alloc(0),
        ns: input.slice(0, 48),
        ciphertext: input.slice(48, input.length)
      };
    }
    exports2.decode2 = decode22;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx.js
var require_handshake_xx = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XXHandshake = void 0;
    var buffer_1 = require_buffer();
    var xx_1 = require_xx();
    var utils_1 = require_utils14();
    var logger_1 = require_logger();
    var encoder_1 = require_encoder();
    var XXHandshake = class {
      constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {
        this.isInitiator = isInitiator;
        this.payload = payload;
        this.prologue = prologue;
        this.staticKeypair = staticKeypair;
        this.connection = connection;
        if (remotePeer) {
          this.remotePeer = remotePeer;
        }
        this.xx = handshake !== null && handshake !== void 0 ? handshake : new xx_1.XX();
        this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
        this.remoteEarlyData = buffer_1.Buffer.alloc(0);
      }
      async propose() {
        logger_1.logLocalStaticKeys(this.session.hs.s);
        if (this.isInitiator) {
          logger_1.logger("Stage 0 - Initiator starting to send first message.");
          const messageBuffer = this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0));
          this.connection.writeLP(encoder_1.encode0(messageBuffer));
          logger_1.logger("Stage 0 - Initiator finished sending first message.");
          logger_1.logLocalEphemeralKeys(this.session.hs.e);
        } else {
          logger_1.logger("Stage 0 - Responder waiting to receive first message...");
          const receivedMessageBuffer = encoder_1.decode0((await this.connection.readLP()).slice());
          const { valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
          if (!valid) {
            throw new Error("xx handshake stage 0 validation fail");
          }
          logger_1.logger("Stage 0 - Responder received first message.");
          logger_1.logRemoteEphemeralKey(this.session.hs.re);
        }
      }
      async exchange() {
        if (this.isInitiator) {
          logger_1.logger("Stage 1 - Initiator waiting to receive first message from responder...");
          const receivedMessageBuffer = encoder_1.decode1((await this.connection.readLP()).slice());
          const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
          if (!valid) {
            throw new Error("xx handshake stage 1 validation fail");
          }
          logger_1.logger("Stage 1 - Initiator received the message.");
          logger_1.logRemoteEphemeralKey(this.session.hs.re);
          logger_1.logRemoteStaticKey(this.session.hs.rs);
          logger_1.logger("Initiator going to check remote's signature...");
          try {
            const decodedPayload = await utils_1.decodePayload(plaintext);
            this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
            this.remotePeer = await utils_1.verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);
            this.setRemoteEarlyData(decodedPayload.data);
          } catch (e) {
            const err = e;
            throw new Error(`Error occurred while verifying signed payload: ${err.message}`);
          }
          logger_1.logger("All good with the signature!");
        } else {
          logger_1.logger("Stage 1 - Responder sending out first message with signed payload and static key.");
          const messageBuffer = this.xx.sendMessage(this.session, this.payload);
          this.connection.writeLP(encoder_1.encode1(messageBuffer));
          logger_1.logger("Stage 1 - Responder sent the second handshake message with signed payload.");
          logger_1.logLocalEphemeralKeys(this.session.hs.e);
        }
      }
      async finish() {
        if (this.isInitiator) {
          logger_1.logger("Stage 2 - Initiator sending third handshake message.");
          const messageBuffer = this.xx.sendMessage(this.session, this.payload);
          this.connection.writeLP(encoder_1.encode2(messageBuffer));
          logger_1.logger("Stage 2 - Initiator sent message with signed payload.");
        } else {
          logger_1.logger("Stage 2 - Responder waiting for third handshake message...");
          const receivedMessageBuffer = encoder_1.decode2((await this.connection.readLP()).slice());
          const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
          if (!valid) {
            throw new Error("xx handshake stage 2 validation fail");
          }
          logger_1.logger("Stage 2 - Responder received the message, finished handshake.");
          try {
            const decodedPayload = await utils_1.decodePayload(plaintext);
            this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
            await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
            this.setRemoteEarlyData(decodedPayload.data);
          } catch (e) {
            const err = e;
            throw new Error(`Error occurred while verifying signed payload: ${err.message}`);
          }
        }
        logger_1.logCipherState(this.session);
      }
      encrypt(plaintext, session) {
        const cs = this.getCS(session);
        return this.xx.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);
      }
      decrypt(ciphertext, session) {
        const cs = this.getCS(session, false);
        return this.xx.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);
      }
      getRemoteStaticKey() {
        return this.session.hs.rs;
      }
      getCS(session, encryption = true) {
        if (!session.cs1 || !session.cs2) {
          throw new Error("Handshake not completed properly, cipher state does not exist.");
        }
        if (this.isInitiator) {
          return encryption ? session.cs1 : session.cs2;
        } else {
          return encryption ? session.cs2 : session.cs1;
        }
      }
      setRemoteEarlyData(data) {
        if (data) {
          this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);
        }
      }
    };
    exports2.XXHandshake = XXHandshake;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/ik.js
var require_ik = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshakes/ik.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IK = void 0;
    var buffer_1 = require_buffer();
    var utils_1 = require_utils14();
    var abstract_handshake_1 = require_abstract_handshake();
    var IK = class extends abstract_handshake_1.AbstractHandshake {
      initSession(initiator, prologue, s, rs) {
        const psk = this.createEmptyKey();
        let hs;
        if (initiator) {
          hs = this.initializeInitiator(prologue, s, rs, psk);
        } else {
          hs = this.initializeResponder(prologue, s, rs, psk);
        }
        return {
          hs,
          i: initiator,
          mc: 0
        };
      }
      sendMessage(session, message) {
        let messageBuffer;
        if (session.mc === 0) {
          messageBuffer = this.writeMessageA(session.hs, message);
        } else if (session.mc === 1) {
          const { messageBuffer: mb, h, cs1, cs2 } = this.writeMessageB(session.hs, message);
          messageBuffer = mb;
          session.h = h;
          session.cs1 = cs1;
          session.cs2 = cs2;
        } else if (session.mc > 1) {
          if (session.i) {
            if (!session.cs1) {
              throw new Error("CS1 (cipher state) is not defined");
            }
            messageBuffer = this.writeMessageRegular(session.cs1, message);
          } else {
            if (!session.cs2) {
              throw new Error("CS2 (cipher state) is not defined");
            }
            messageBuffer = this.writeMessageRegular(session.cs2, message);
          }
        } else {
          throw new Error("Session invalid.");
        }
        session.mc++;
        return messageBuffer;
      }
      recvMessage(session, message) {
        let plaintext = buffer_1.Buffer.alloc(0);
        let valid = false;
        if (session.mc === 0) {
          ({ plaintext, valid } = this.readMessageA(session.hs, message));
        }
        if (session.mc === 1) {
          const { plaintext: pt, valid: v, h, cs1, cs2 } = this.readMessageB(session.hs, message);
          plaintext = pt;
          valid = v;
          session.h = h;
          session.cs1 = cs1;
          session.cs2 = cs2;
        }
        session.mc++;
        return { plaintext, valid };
      }
      writeMessageA(hs, payload) {
        hs.e = utils_1.generateKeypair();
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const spk = buffer_1.Buffer.from(hs.s.publicKey);
        const ns = this.encryptAndHash(hs.ss, spk);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        return { ne, ns, ciphertext };
      }
      writeMessageB(hs, payload) {
        hs.e = utils_1.generateKeypair();
        const ne = hs.e.publicKey;
        this.mixHash(hs.ss, ne);
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
        const ciphertext = this.encryptAndHash(hs.ss, payload);
        const ns = this.createEmptyKey();
        const messageBuffer = { ne, ns, ciphertext };
        const { cs1, cs2 } = this.split(hs.ss);
        return { messageBuffer, cs1, cs2, h: hs.ss.h };
      }
      readMessageA(hs, message) {
        if (utils_1.isValidPublicKey(message.ne)) {
          hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const { plaintext: ns, valid: valid1 } = this.decryptAndHash(hs.ss, message.ns);
        if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
          hs.rs = ns;
        }
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));
        const { plaintext, valid: valid2 } = this.decryptAndHash(hs.ss, message.ciphertext);
        return { plaintext, valid: valid1 && valid2 };
      }
      readMessageB(hs, message) {
        if (utils_1.isValidPublicKey(message.ne)) {
          hs.re = message.ne;
        }
        this.mixHash(hs.ss, hs.re);
        if (!hs.e) {
          throw new Error("Handshake state should contain ephemeral key by now.");
        }
        this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
        this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
        const { plaintext, valid } = this.decryptAndHash(hs.ss, message.ciphertext);
        const { cs1, cs2 } = this.split(hs.ss);
        return { h: hs.ss.h, valid, plaintext, cs1, cs2 };
      }
      initializeInitiator(prologue, s, rs, psk) {
        const name5 = "Noise_IK_25519_ChaChaPoly_SHA256";
        const ss = this.initializeSymmetric(name5);
        this.mixHash(ss, prologue);
        this.mixHash(ss, rs);
        const re = buffer_1.Buffer.alloc(32);
        return { ss, s, rs, re, psk };
      }
      initializeResponder(prologue, s, rs, psk) {
        const name5 = "Noise_IK_25519_ChaChaPoly_SHA256";
        const ss = this.initializeSymmetric(name5);
        this.mixHash(ss, prologue);
        this.mixHash(ss, s.publicKey);
        const re = buffer_1.Buffer.alloc(32);
        return { ss, s, rs, re, psk };
      }
    };
    exports2.IK = IK;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/errors.js
var require_errors5 = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/errors.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FailedIKError = void 0;
    var FailedIKError = class extends Error {
      constructor(initialMsg, message) {
        super(message);
        this.initialMsg = initialMsg;
        this.name = "FailedIKhandshake";
      }
    };
    exports2.FailedIKError = FailedIKError;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshake-ik.js
var require_handshake_ik = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshake-ik.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.IKHandshake = void 0;
    var ik_1 = require_ik();
    var buffer_1 = require_buffer();
    var encoder_1 = require_encoder();
    var utils_1 = require_utils14();
    var errors_1 = require_errors5();
    var logger_1 = require_logger();
    var IKHandshake = class {
      constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {
        this.isInitiator = isInitiator;
        this.payload = buffer_1.Buffer.from(payload);
        this.prologue = prologue;
        this.staticKeypair = staticKeypair;
        this.connection = connection;
        if (remotePeer) {
          this.remotePeer = remotePeer;
        }
        this.ik = handshake !== null && handshake !== void 0 ? handshake : new ik_1.IK();
        this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);
        this.remoteEarlyData = buffer_1.Buffer.alloc(0);
      }
      async stage0() {
        logger_1.logLocalStaticKeys(this.session.hs.s);
        logger_1.logRemoteStaticKey(this.session.hs.rs);
        if (this.isInitiator) {
          logger_1.logger("IK Stage 0 - Initiator sending message...");
          const messageBuffer = this.ik.sendMessage(this.session, this.payload);
          this.connection.writeLP(encoder_1.encode1(messageBuffer));
          logger_1.logger("IK Stage 0 - Initiator sent message.");
          logger_1.logLocalEphemeralKeys(this.session.hs.e);
        } else {
          logger_1.logger("IK Stage 0 - Responder receiving message...");
          const receivedMsg = await this.connection.readLP();
          try {
            const receivedMessageBuffer = encoder_1.decode1(receivedMsg.slice());
            const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);
            if (!valid) {
              throw new Error("ik handshake stage 0 decryption validation fail");
            }
            logger_1.logger("IK Stage 0 - Responder got message, going to verify payload.");
            const decodedPayload = await utils_1.decodePayload(plaintext);
            this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
            await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
            this.setRemoteEarlyData(decodedPayload.data);
            logger_1.logger("IK Stage 0 - Responder successfully verified payload!");
            logger_1.logRemoteEphemeralKey(this.session.hs.re);
          } catch (e) {
            const err = e;
            logger_1.logger("Responder breaking up with IK handshake in stage 0.");
            throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${err.message}`);
          }
        }
      }
      async stage1() {
        if (this.isInitiator) {
          logger_1.logger("IK Stage 1 - Initiator receiving message...");
          const receivedMsg = (await this.connection.readLP()).slice();
          const receivedMessageBuffer = encoder_1.decode0(buffer_1.Buffer.from(receivedMsg));
          const { plaintext, valid } = this.ik.recvMessage(this.session, receivedMessageBuffer);
          logger_1.logger("IK Stage 1 - Initiator got message, going to verify payload.");
          try {
            if (!valid) {
              throw new Error("ik stage 1 decryption validation fail");
            }
            const decodedPayload = await utils_1.decodePayload(plaintext);
            this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
            await utils_1.verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);
            this.setRemoteEarlyData(decodedPayload.data);
            logger_1.logger("IK Stage 1 - Initiator successfully verified payload!");
            logger_1.logRemoteEphemeralKey(this.session.hs.re);
          } catch (e) {
            const err = e;
            logger_1.logger("Initiator breaking up with IK handshake in stage 1.");
            throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${err.message}`);
          }
        } else {
          logger_1.logger("IK Stage 1 - Responder sending message...");
          const messageBuffer = this.ik.sendMessage(this.session, this.payload);
          this.connection.writeLP(encoder_1.encode0(messageBuffer));
          logger_1.logger("IK Stage 1 - Responder sent message...");
          logger_1.logLocalEphemeralKeys(this.session.hs.e);
        }
        logger_1.logCipherState(this.session);
      }
      decrypt(ciphertext, session) {
        const cs = this.getCS(session, false);
        return this.ik.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);
      }
      encrypt(plaintext, session) {
        const cs = this.getCS(session);
        return this.ik.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);
      }
      getLocalEphemeralKeys() {
        if (!this.session.hs.e) {
          throw new Error("Ephemeral keys do not exist.");
        }
        return this.session.hs.e;
      }
      getCS(session, encryption = true) {
        if (!session.cs1 || !session.cs2) {
          throw new Error("Handshake not completed properly, cipher state does not exist.");
        }
        if (this.isInitiator) {
          return encryption ? session.cs1 : session.cs2;
        } else {
          return encryption ? session.cs2 : session.cs1;
        }
      }
      setRemoteEarlyData(data) {
        if (data) {
          this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);
        }
      }
    };
    exports2.IKHandshake = IKHandshake;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx-fallback.js
var require_handshake_xx_fallback = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/handshake-xx-fallback.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.XXFallbackHandshake = void 0;
    var buffer_1 = require_buffer();
    var handshake_xx_1 = require_handshake_xx();
    var utils_1 = require_utils14();
    var logger_1 = require_logger();
    var encoder_1 = require_encoder();
    var XXFallbackHandshake = class extends handshake_xx_1.XXHandshake {
      constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {
        super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);
        if (ephemeralKeys) {
          this.ephemeralKeys = ephemeralKeys;
        }
        this.initialMsg = initialMsg;
      }
      async propose() {
        if (this.isInitiator) {
          this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0), this.ephemeralKeys);
          logger_1.logger("XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.");
          logger_1.logLocalEphemeralKeys(this.session.hs.e);
        } else {
          logger_1.logger("XX Fallback Stage 0 - Responder decoding initial msg from IK.");
          const receivedMessageBuffer = encoder_1.decode0(this.initialMsg);
          const { valid } = this.xx.recvMessage(this.session, {
            ne: receivedMessageBuffer.ne,
            ns: buffer_1.Buffer.alloc(0),
            ciphertext: buffer_1.Buffer.alloc(0)
          });
          if (!valid) {
            throw new Error("xx fallback stage 0 decryption validation fail");
          }
          logger_1.logger("XX Fallback Stage 0 - Responder used received message from IK.");
          logger_1.logRemoteEphemeralKey(this.session.hs.re);
        }
      }
      async exchange() {
        if (this.isInitiator) {
          const receivedMessageBuffer = encoder_1.decode1(this.initialMsg);
          const { plaintext, valid } = this.xx.recvMessage(this.session, receivedMessageBuffer);
          if (!valid) {
            throw new Error("xx fallback stage 1 decryption validation fail");
          }
          logger_1.logger("XX Fallback Stage 1 - Initiator used received message from IK.");
          logger_1.logRemoteEphemeralKey(this.session.hs.re);
          logger_1.logRemoteStaticKey(this.session.hs.rs);
          logger_1.logger("Initiator going to check remote's signature...");
          try {
            const decodedPayload = await utils_1.decodePayload(plaintext);
            this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
            await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
            this.setRemoteEarlyData(decodedPayload.data);
          } catch (e) {
            const err = e;
            throw new Error(`Error occurred while verifying signed payload from responder: ${err.message}`);
          }
          logger_1.logger("All good with the signature!");
        } else {
          logger_1.logger("XX Fallback Stage 1 - Responder start");
          await super.exchange();
          logger_1.logger("XX Fallback Stage 1 - Responder end");
        }
      }
    };
    exports2.XXFallbackHandshake = XXFallbackHandshake;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js
var require_crypto2 = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/crypto.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decryptStream = exports2.encryptStream = void 0;
    var buffer_1 = require_buffer();
    var constants_1 = require_constants9();
    function encryptStream(handshake) {
      return async function* (source) {
        for await (const chunk of source) {
          const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);
          for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
            let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
            if (end > chunkBuffer.length) {
              end = chunkBuffer.length;
            }
            const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);
            yield data;
          }
        }
      };
    }
    exports2.encryptStream = encryptStream;
    function decryptStream(handshake) {
      return async function* (source) {
        for await (const chunk of source) {
          const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);
          for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {
            let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;
            if (end > chunkBuffer.length) {
              end = chunkBuffer.length;
            }
            const chunk2 = chunkBuffer.slice(i, end);
            const { plaintext: decrypted, valid } = await handshake.decrypt(chunk2, handshake.session);
            if (!valid) {
              throw new Error("Failed to validate decrypted chunk");
            }
            yield decrypted;
          }
        }
      };
    }
    exports2.decryptStream = decryptStream;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/keycache.js
var require_keycache = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/keycache.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.KeyCache = void 0;
    var Keycache = class {
      constructor() {
        this.storage = new Map();
      }
      store(peerId, key) {
        this.storage.set(peerId.id, key);
      }
      load(peerId) {
        var _a;
        if (!peerId) {
          return null;
        }
        return (_a = this.storage.get(peerId.id)) !== null && _a !== void 0 ? _a : null;
      }
      resetStorage() {
        this.storage.clear();
      }
    };
    var KeyCache = new Keycache();
    exports2.KeyCache = KeyCache;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/noise.js
var require_noise = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/noise.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule)
        return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k in mod2)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod2, k))
            __createBinding(result, mod2, k);
      }
      __setModuleDefault(result, mod2);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Noise = void 0;
    var x25519 = __importStar(require_x25519());
    var buffer_1 = require_buffer();
    var it_pb_rpc_1 = __importDefault(require_src21());
    var duplex_1 = __importDefault(require_duplex3());
    var it_buffer_1 = __importDefault(require_it_buffer());
    var it_pipe_1 = __importDefault(require_it_pipe());
    var it_length_prefixed_1 = require_src12();
    var handshake_xx_1 = require_handshake_xx();
    var handshake_ik_1 = require_handshake_ik();
    var handshake_xx_fallback_1 = require_handshake_xx_fallback();
    var utils_1 = require_utils14();
    var encoder_1 = require_encoder();
    var crypto_1 = require_crypto2();
    var keycache_1 = require_keycache();
    var logger_1 = require_logger();
    var constants_1 = require_constants9();
    var Noise = class {
      constructor(staticNoiseKey, earlyData) {
        this.protocol = "/noise";
        this.prologue = buffer_1.Buffer.alloc(0);
        this.earlyData = earlyData !== null && earlyData !== void 0 ? earlyData : buffer_1.Buffer.alloc(0);
        this.useNoisePipes = false;
        if (staticNoiseKey) {
          const keyPair = x25519.generateKeyPairFromSeed(staticNoiseKey);
          this.staticKeys = {
            privateKey: buffer_1.Buffer.from(keyPair.secretKey.buffer, keyPair.secretKey.byteOffset, keyPair.secretKey.length),
            publicKey: buffer_1.Buffer.from(keyPair.publicKey.buffer, keyPair.publicKey.byteOffset, keyPair.publicKey.length)
          };
        } else {
          this.staticKeys = utils_1.generateKeypair();
        }
      }
      async secureOutbound(localPeer, connection, remotePeer) {
        const wrappedConnection = it_pb_rpc_1.default(connection, {
          lengthEncoder: encoder_1.uint16BEEncode,
          lengthDecoder: encoder_1.uint16BEDecode,
          maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES
        });
        const handshake = await this.performHandshake({
          connection: wrappedConnection,
          isInitiator: true,
          localPeer,
          remotePeer
        });
        const conn = await this.createSecureConnection(wrappedConnection, handshake);
        return {
          conn,
          remoteEarlyData: handshake.remoteEarlyData,
          remotePeer: handshake.remotePeer
        };
      }
      async secureInbound(localPeer, connection, remotePeer) {
        const wrappedConnection = it_pb_rpc_1.default(connection, {
          lengthEncoder: encoder_1.uint16BEEncode,
          lengthDecoder: encoder_1.uint16BEDecode,
          maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES
        });
        const handshake = await this.performHandshake({
          connection: wrappedConnection,
          isInitiator: false,
          localPeer,
          remotePeer
        });
        const conn = await this.createSecureConnection(wrappedConnection, handshake);
        return {
          conn,
          remoteEarlyData: handshake.remoteEarlyData,
          remotePeer: handshake.remotePeer
        };
      }
      async performHandshake(params) {
        var _a;
        const payload = await utils_1.getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);
        let tryIK = this.useNoisePipes;
        if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {
          tryIK = false;
        }
        if (tryIK) {
          const { remotePeer, connection, isInitiator } = params;
          const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, (_a = keycache_1.KeyCache.load(params.remotePeer)) !== null && _a !== void 0 ? _a : buffer_1.Buffer.alloc(32), remotePeer);
          try {
            return await this.performIKHandshake(ikHandshake);
          } catch (e) {
            let ephemeralKeys;
            if (params.isInitiator) {
              ephemeralKeys = ikHandshake.getLocalEphemeralKeys();
            }
            return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);
          }
        } else {
          return await this.performXXHandshake(params, payload);
        }
      }
      async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {
        const { isInitiator, remotePeer, connection } = params;
        const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);
        try {
          await handshake.propose();
          await handshake.exchange();
          await handshake.finish();
        } catch (e) {
          logger_1.logger(e);
          const err = e;
          throw new Error(`Error occurred during XX Fallback handshake: ${err.message}`);
        }
        return handshake;
      }
      async performXXHandshake(params, payload) {
        const { isInitiator, remotePeer, connection } = params;
        const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);
        try {
          await handshake.propose();
          await handshake.exchange();
          await handshake.finish();
          if (this.useNoisePipes && handshake.remotePeer) {
            keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());
          }
        } catch (e) {
          const err = e;
          throw new Error(`Error occurred during XX handshake: ${err.message}`);
        }
        return handshake;
      }
      async performIKHandshake(handshake) {
        await handshake.stage0();
        await handshake.stage1();
        return handshake;
      }
      async createSecureConnection(connection, handshake) {
        const [secure, user] = duplex_1.default();
        const network = connection.unwrap();
        await it_pipe_1.default(secure, it_buffer_1.default, crypto_1.encryptStream(handshake), it_length_prefixed_1.encode({ lengthEncoder: encoder_1.uint16BEEncode }), network, it_length_prefixed_1.decode({ lengthDecoder: encoder_1.uint16BEDecode }), it_buffer_1.default, crypto_1.decryptStream(handshake), secure);
        return user;
      }
    };
    exports2.Noise = Noise;
  }
});

// node_modules/@chainsafe/libp2p-noise/dist/src/index.js
var require_src22 = __commonJS({
  "node_modules/@chainsafe/libp2p-noise/dist/src/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m)
        if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
          __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NOISE = void 0;
    var noise_1 = require_noise();
    __exportStar(require_noise(), exports2);
    exports2.NOISE = new noise_1.Noise();
  }
});

// node_modules/k-bucket/index.js
var require_k_bucket = __commonJS({
  "node_modules/k-bucket/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var randomBytes = require_browser9();
    var { EventEmitter: EventEmitter4 } = require_events();
    function arrayEquals(array1, array2) {
      if (array1 === array2) {
        return true;
      }
      if (array1.length !== array2.length) {
        return false;
      }
      for (let i = 0, length4 = array1.length; i < length4; ++i) {
        if (array1[i] !== array2[i]) {
          return false;
        }
      }
      return true;
    }
    function createNode2() {
      return { contacts: [], dontSplit: false, left: null, right: null };
    }
    function ensureInt8(name5, val) {
      if (!(val instanceof Uint8Array)) {
        throw new TypeError(name5 + " is not a Uint8Array");
      }
    }
    var KBucket = class extends EventEmitter4 {
      constructor(options = {}) {
        super();
        this.localNodeId = options.localNodeId || randomBytes(20);
        this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20;
        this.numberOfNodesToPing = options.numberOfNodesToPing || 3;
        this.distance = options.distance || KBucket.distance;
        this.arbiter = options.arbiter || KBucket.arbiter;
        this.metadata = Object.assign({}, options.metadata);
        ensureInt8("option.localNodeId as parameter 1", this.localNodeId);
        this.root = createNode2();
      }
      static arbiter(incumbent, candidate) {
        return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate;
      }
      static distance(firstId, secondId) {
        let distance = 0;
        let i = 0;
        const min = Math.min(firstId.length, secondId.length);
        const max = Math.max(firstId.length, secondId.length);
        for (; i < min; ++i) {
          distance = distance * 256 + (firstId[i] ^ secondId[i]);
        }
        for (; i < max; ++i)
          distance = distance * 256 + 255;
        return distance;
      }
      add(contact) {
        ensureInt8("contact.id", (contact || {}).id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, contact.id, bitIndex++);
        }
        const index = this._indexOf(node, contact.id);
        if (index >= 0) {
          this._update(node, index, contact);
          return this;
        }
        if (node.contacts.length < this.numberOfNodesPerKBucket) {
          node.contacts.push(contact);
          this.emit("added", contact);
          return this;
        }
        if (node.dontSplit) {
          this.emit("ping", node.contacts.slice(0, this.numberOfNodesToPing), contact);
          return this;
        }
        this._split(node, bitIndex);
        return this.add(contact);
      }
      closest(id, n = Infinity) {
        ensureInt8("id", id);
        if (!Number.isInteger(n) && n !== Infinity || n <= 0) {
          throw new TypeError("n is not positive number");
        }
        let contacts = [];
        for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            const detNode = this._determineNode(node, id, bitIndex++);
            nodes.push(node.left === detNode ? node.right : node.left);
            nodes.push(detNode);
          } else {
            contacts = contacts.concat(node.contacts);
          }
        }
        return contacts.map((a) => [this.distance(a.id, id), a]).sort((a, b) => a[0] - b[0]).slice(0, n).map((a) => a[1]);
      }
      count() {
        let count = 0;
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            count += node.contacts.length;
        }
        return count;
      }
      _determineNode(node, id, bitIndex) {
        const bytesDescribedByBitIndex = bitIndex >> 3;
        const bitIndexWithinByte = bitIndex % 8;
        if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {
          return node.left;
        }
        const byteUnderConsideration = id[bytesDescribedByBitIndex];
        if (byteUnderConsideration & 1 << 7 - bitIndexWithinByte) {
          return node.right;
        }
        return node.left;
      }
      get(id) {
        ensureInt8("id", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        return index >= 0 ? node.contacts[index] : null;
      }
      _indexOf(node, id) {
        for (let i = 0; i < node.contacts.length; ++i) {
          if (arrayEquals(node.contacts[i].id, id))
            return i;
        }
        return -1;
      }
      remove(id) {
        ensureInt8("the id as parameter 1", id);
        let bitIndex = 0;
        let node = this.root;
        while (node.contacts === null) {
          node = this._determineNode(node, id, bitIndex++);
        }
        const index = this._indexOf(node, id);
        if (index >= 0) {
          const contact = node.contacts.splice(index, 1)[0];
          this.emit("removed", contact);
        }
        return this;
      }
      _split(node, bitIndex) {
        node.left = createNode2();
        node.right = createNode2();
        for (const contact of node.contacts) {
          this._determineNode(node, contact.id, bitIndex).contacts.push(contact);
        }
        node.contacts = null;
        const detNode = this._determineNode(node, this.localNodeId, bitIndex);
        const otherNode = node.left === detNode ? node.right : node.left;
        otherNode.dontSplit = true;
      }
      toArray() {
        let result = [];
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null)
            nodes.push(node.right, node.left);
          else
            result = result.concat(node.contacts);
        }
        return result;
      }
      *toIterable() {
        for (const nodes = [this.root]; nodes.length > 0; ) {
          const node = nodes.pop();
          if (node.contacts === null) {
            nodes.push(node.right, node.left);
          } else {
            yield* node.contacts;
          }
        }
      }
      _update(node, index, contact) {
        if (!arrayEquals(node.contacts[index].id, contact.id)) {
          throw new Error("wrong index for _update");
        }
        const incumbent = node.contacts[index];
        const selection = this.arbiter(incumbent, contact);
        if (selection === incumbent && incumbent !== contact)
          return;
        node.contacts.splice(index, 1);
        node.contacts.push(selection);
        this.emit("updated", incumbent, selection);
      }
    };
    module2.exports = KBucket;
  }
});

// node_modules/uint8arrays/esm/src/xor.js
var xor_exports = {};
__export(xor_exports, {
  xor: () => xor
});
function xor(a, b) {
  if (a.length !== b.length) {
    throw new Error("Inputs should have the same length");
  }
  const result = new Uint8Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = a[i] ^ b[i];
  }
  return result;
}
var init_xor = __esm({
  "node_modules/uint8arrays/esm/src/xor.js"() {
    init_node_globals();
  }
});

// node_modules/libp2p-kad-dht/src/routing-table/generated-prefix-list-browser.json
var require_generated_prefix_list_browser = __commonJS({
  "node_modules/libp2p-kad-dht/src/routing-table/generated-prefix-list-browser.json"(exports2, module2) {
    module2.exports = [
      77591,
      22417,
      43971,
      28421,
      740,
      29829,
      71467,
      228973,
      196661,
      78537,
      27689,
      36431,
      44415,
      14362,
      19456,
      106025,
      96308,
      2882,
      49509,
      21149,
      87173,
      131409,
      75844,
      23676,
      121838,
      30291,
      17492,
      2953,
      7564,
      110620,
      129477,
      127283,
      53113,
      72417,
      165166,
      109690,
      21200,
      102125,
      24049,
      71504,
      90342,
      25307,
      72039,
      26812,
      26715,
      32264,
      133800,
      71161,
      88956,
      171987,
      51779,
      24425,
      16671,
      30251,
      186294,
      247761,
      14202,
      2121,
      8465,
      35024,
      4876,
      85917,
      169730,
      3638,
      256836,
      96184,
      943,
      18678,
      6583,
      52907,
      35807,
      112254,
      214097,
      18796,
      11595,
      9243,
      23554,
      887,
      268203,
      382004,
      24590,
      111335,
      11625,
      16619,
      29039,
      102425,
      69006,
      97976,
      92362,
      32552,
      63717,
      41433,
      128974,
      137630,
      59943,
      10019,
      13986,
      35430,
      33665,
      108037,
      43799,
      43280,
      38195,
      29078,
      58629,
      18265,
      14425,
      46832,
      235538,
      40830,
      77881,
      110717,
      58937,
      3463,
      325358,
      51300,
      47623,
      117252,
      19007,
      10170,
      20540,
      91237,
      294813,
      4951,
      79841,
      56232,
      36270,
      128547,
      69209,
      66275,
      100156,
      32063,
      73531,
      34439,
      80937,
      28892,
      44466,
      88595,
      216307,
      32583,
      49620,
      16605,
      82127,
      45807,
      21630,
      78726,
      20235,
      40163,
      111007,
      96926,
      5567,
      72083,
      21665,
      58844,
      39419,
      179767,
      48328,
      42662,
      51550,
      5251,
      37811,
      49608,
      81056,
      50854,
      55513,
      20922,
      18891,
      197409,
      164656,
      32593,
      71449,
      220474,
      58919,
      85682,
      67854,
      13758,
      35066,
      3565,
      61905,
      214793,
      119572,
      141419,
      21504,
      10302,
      27354,
      67003,
      46131,
      32668,
      15165,
      64871,
      34450,
      17821,
      2757,
      11452,
      34189,
      5160,
      12257,
      85523,
      560,
      53385,
      65887,
      119549,
      135620,
      312353,
      115979,
      122356,
      10867,
      193231,
      124537,
      54783,
      90675,
      120791,
      4715,
      142253,
      50943,
      17271,
      43358,
      25331,
      4917,
      120566,
      34580,
      12878,
      33786,
      160528,
      32523,
      4869,
      301307,
      104817,
      81491,
      23276,
      8832,
      97911,
      31265,
      52065,
      7998,
      49622,
      9715,
      43998,
      34091,
      84587,
      20664,
      69041,
      29419,
      53205,
      10838,
      58288,
      116145,
      6185,
      5154,
      141795,
      35924,
      21307,
      144738,
      43730,
      12085,
      8279,
      10002,
      119,
      133779,
      199668,
      72938,
      31768,
      39176,
      67875,
      38453,
      9700,
      44144,
      4121,
      116048,
      41733,
      12868,
      82669,
      92308,
      128,
      34262,
      11332,
      7712,
      90764,
      36141,
      13553,
      71312,
      77470,
      117314,
      96549,
      49135,
      23602,
      54468,
      28605,
      6327,
      62308,
      17171,
      67531,
      21319,
      14105,
      894,
      107722,
      46157,
      8503,
      51069,
      100472,
      45138,
      15246,
      14577,
      35609,
      191464,
      1757,
      13364,
      161349,
      32067,
      91705,
      81144,
      52339,
      5408,
      91066,
      21983,
      14157,
      100545,
      4372,
      26630,
      129112,
      1423,
      29676,
      213626,
      4397,
      88436,
      99190,
      6877,
      49958,
      26122,
      114348,
      60661,
      29818,
      293118,
      50042,
      179738,
      16400,
      163423,
      89627,
      31040,
      43973,
      36638,
      45952,
      5153,
      1894,
      109322,
      1898,
      134021,
      12402,
      112077,
      68309,
      190269,
      69866,
      31938,
      107383,
      11522,
      105232,
      11248,
      14868,
      39852,
      71707,
      186525,
      16530,
      38162,
      106212,
      11700,
      5130,
      16608,
      26998,
      59586,
      108399,
      230033,
      43683,
      48135,
      82179,
      2073,
      5015,
      196684,
      189293,
      16378,
      23452,
      8301,
      35640,
      11632,
      214551,
      29240,
      57644,
      33137,
      91949,
      55157,
      52384,
      117313,
      5090,
      17717,
      89668,
      49363,
      82238,
      241035,
      66216,
      29066,
      184088,
      97206,
      62820,
      26595,
      4241,
      135635,
      173672,
      8202,
      459,
      71355,
      146294,
      29587,
      3008,
      135385,
      141203,
      14803,
      6634,
      45094,
      69362,
      50925,
      546,
      51884,
      62011,
      83296,
      234584,
      44515,
      56050,
      89476,
      87751,
      19373,
      12691,
      149923,
      19794,
      13833,
      35846,
      87557,
      58339,
      2884,
      19145,
      25647,
      12224,
      11024,
      77338,
      64608,
      122297,
      53025,
      7205,
      36189,
      36294,
      170779,
      21750,
      7739,
      173883,
      75192,
      35664,
      224240,
      113121,
      30181,
      26267,
      27036,
      117827,
      92015,
      106516,
      55628,
      203549,
      67949,
      60462,
      60844,
      35911,
      20457,
      1820,
      920,
      19773,
      8738,
      73173,
      181993,
      38521,
      98254,
      76257,
      46008,
      92796,
      5384,
      26868,
      151566,
      22124,
      2411,
      15919,
      186872,
      180021,
      28099,
      152961,
      78811,
      80237,
      62352,
      102653,
      74259,
      184890,
      16792,
      123702,
      224945,
      29940,
      19512,
      75283,
      14059,
      112691,
      92811,
      233329,
      20411,
      138569,
      53341,
      109802,
      50600,
      134528,
      66747,
      5529,
      166531,
      31578,
      64732,
      67189,
      1596,
      126357,
      967,
      167999,
      206598,
      109752,
      119431,
      207825,
      78791,
      91938,
      10301,
      27311,
      24233,
      252343,
      28831,
      32812,
      66002,
      112267,
      90895,
      8786,
      8095,
      16824,
      22866,
      21813,
      60507,
      174833,
      19549,
      130985,
      117051,
      52110,
      6938,
      81923,
      123864,
      38061,
      919,
      18680,
      53534,
      46739,
      112893,
      161529,
      85429,
      26761,
      11900,
      81121,
      91968,
      15390,
      217947,
      56524,
      1713,
      6654,
      37089,
      85630,
      138866,
      61850,
      16491,
      75577,
      16884,
      98296,
      73523,
      6140,
      44645,
      6062,
      36366,
      29844,
      57946,
      37932,
      42472,
      5266,
      20834,
      19309,
      33753,
      127182,
      134259,
      35810,
      41805,
      45878,
      312001,
      14881,
      47757,
      49251,
      120050,
      44252,
      3708,
      25856,
      107864,
      120347,
      1228,
      36550,
      41682,
      34496,
      47025,
      8393,
      173365,
      246526,
      12894,
      161607,
      35670,
      90785,
      126572,
      2095,
      124731,
      157033,
      58694,
      554,
      12786,
      9642,
      4817,
      16136,
      47864,
      174698,
      66992,
      4639,
      69284,
      10625,
      40710,
      27763,
      51738,
      30404,
      264105,
      137904,
      109882,
      52487,
      42824,
      57514,
      2740,
      10479,
      146799,
      107390,
      16586,
      88038,
      174951,
      9410,
      16185,
      44158,
      5568,
      40658,
      46108,
      12763,
      97385,
      26175,
      108859,
      664,
      230732,
      67470,
      46663,
      14395,
      50750,
      141320,
      93140,
      15361,
      47997,
      55784,
      6791,
      307840,
      118569,
      107326,
      18056,
      58281,
      260415,
      54691,
      8790,
      73332,
      45633,
      7511,
      45674,
      143373,
      14031,
      11799,
      94491,
      35646,
      96544,
      14560,
      26049,
      32983,
      25791,
      83814,
      42094,
      231370,
      63955,
      139212,
      2359,
      169908,
      3108,
      183486,
      105867,
      28197,
      32941,
      124968,
      26402,
      88267,
      149768,
      23053,
      3078,
      19091,
      52924,
      25383,
      19209,
      111548,
      97361,
      3959,
      24880,
      235061,
      9099,
      24921,
      161254,
      151405,
      20508,
      7159,
      34381,
      20133,
      11434,
      74036,
      19974,
      34769,
      36585,
      1076,
      22454,
      17354,
      38727,
      235160,
      111547,
      96454,
      117448,
      156940,
      91330,
      37299,
      7310,
      26915,
      117060,
      51369,
      22620,
      61861,
      322264,
      106850,
      111694,
      15091,
      2624,
      40345,
      300446,
      177064,
      1707,
      27389,
      54792,
      327783,
      132669,
      183543,
      59003,
      17744,
      20603,
      151134,
      106923,
      53084,
      71803,
      279424,
      319816,
      11579,
      21946,
      16728,
      38274,
      72711,
      5085,
      83391,
      88646,
      40159,
      25027,
      34680,
      10752,
      12988,
      54126,
      30365,
      18338,
      100445,
      230674,
      44874,
      84974,
      143877,
      123253,
      139372,
      28082,
      91477,
      144002,
      13096,
      219729,
      46016,
      50029,
      42377,
      14601,
      6660,
      58244,
      58978,
      23918,
      88206,
      113611,
      64452,
      17541,
      41032,
      10942,
      12021,
      49189,
      10978,
      40175,
      37156,
      10947,
      71709,
      106894,
      112538,
      57007,
      137486,
      150608,
      152719,
      40615,
      7746,
      279716,
      13101,
      19524,
      28708,
      40578,
      72320,
      1096,
      182051,
      94527,
      51275,
      22833,
      45164,
      81917,
      77519,
      48508,
      5421,
      140302,
      37845,
      149830,
      5587,
      27579,
      5357,
      428725,
      248187,
      6326,
      206760,
      39814,
      32585,
      89923,
      44341,
      288753,
      284443,
      96368,
      31201,
      94189,
      119504,
      20359,
      52073,
      103216,
      179,
      27934,
      32801,
      96035,
      34111,
      34309,
      101326,
      18198,
      20704,
      210266,
      37643,
      27880,
      141873,
      106e3,
      19414,
      56614,
      167714,
      66483,
      107885,
      86602,
      4379,
      20796,
      75467,
      4987,
      5017,
      118857,
      26003,
      34308,
      114428,
      29198,
      6686,
      29697,
      73632,
      3739,
      69795,
      16798,
      41504,
      7207,
      30722,
      21436,
      36735,
      28067,
      28545,
      3239,
      11221,
      36031,
      41889,
      100010,
      19247,
      317673,
      29495,
      174554,
      6424,
      129725,
      53845,
      94986,
      7955,
      59676,
      2604,
      191497,
      19735,
      102214,
      62954,
      23844,
      11872,
      179525,
      261436,
      34492,
      428,
      78404,
      142035,
      16747,
      17246,
      27578,
      37021,
      33672,
      57944,
      26056,
      135760,
      2369,
      61674,
      122066,
      31327,
      19374,
      157065,
      40553,
      130982,
      69619,
      71290,
      38855,
      72100,
      92903,
      95940,
      51422,
      165999,
      65713,
      57873,
      50726,
      7288,
      20272,
      2081,
      42326,
      22624,
      81120,
      57914,
      79352,
      19447,
      1684,
      72302,
      11774,
      302559,
      161481,
      96396,
      13692,
      414988,
      3721,
      79066,
      56627,
      46883,
      21150,
      11747,
      12184,
      5856,
      113458,
      176117,
      84416,
      52079,
      27933,
      3354,
      59765,
      141359,
      2212,
      216309,
      2555,
      23458,
      196722,
      142463,
      45701,
      44548,
      28798,
      19418,
      215,
      29916,
      9396,
      10574,
      114226,
      84475,
      13520,
      18694,
      34056,
      4524,
      90302,
      62930,
      13539,
      19407,
      77209,
      7728,
      38088,
      9535,
      2263,
      23875,
      183945,
      17750,
      26274,
      67172,
      10585,
      28042,
      22199,
      7478,
      51331,
      66030,
      26774,
      192929,
      31434,
      25850,
      50197,
      52926,
      178158,
      4679,
      181256,
      70184,
      229600,
      9959,
      105594,
      72158,
      73974,
      2726,
      35085,
      78087,
      23284,
      35568,
      51713,
      155676,
      5401,
      27254,
      11966,
      17569,
      223253,
      71993,
      103357,
      111477,
      55722,
      30504,
      26034,
      46774,
      35392,
      36285,
      214814,
      41143,
      163465,
      1051,
      16094,
      81044,
      6636,
      76489,
      179102,
      20712,
      39178,
      35683,
      125177,
      54219,
      30617,
      52994,
      25324,
      50123,
      2543,
      87529,
      58995,
      10688,
      125199,
      12388,
      60158,
      125481,
      131646,
      7642,
      133350,
      65874,
      3438,
      97277,
      101450,
      10075,
      56344,
      116821,
      50778,
      60547,
      98016,
      106135,
      13859,
      14255,
      16300,
      77373,
      173521,
      8285,
      45932,
      37426,
      4054,
      114295,
      55947,
      7703,
      39114,
      52,
      51119,
      128135,
      19714,
      60715,
      9554,
      50492,
      88180,
      2823,
      118271,
      52993,
      122625,
      97919,
      23859,
      37895,
      25040,
      33614,
      32102,
      20431,
      3577,
      9275,
      15686,
      43031,
      157741,
      110358,
      1884,
      40291,
      125391,
      13736,
      5008,
      64881,
      87336,
      77381,
      70711,
      43032,
      49155,
      118587,
      70494,
      4318,
      10168,
      30126,
      12580,
      10524,
      280104,
      104001,
      145413,
      2862,
      84140,
      6603,
      106005,
      13566,
      12780,
      11251,
      42830,
      571,
      179910,
      82443,
      13146,
      469,
      42714,
      32591,
      265217,
      424024,
      92553,
      54721,
      134100,
      6007,
      15242,
      114681,
      59030,
      16718,
      85465,
      200214,
      85982,
      55174,
      165013,
      23493,
      56964,
      82529,
      109150,
      32706,
      27568,
      82442,
      5350,
      14976,
      13165,
      44890,
      60021,
      21343,
      33978,
      17264,
      4655,
      22328,
      27819,
      75730,
      16567,
      55483,
      14510,
      17926,
      45827,
      150609,
      3704,
      7385,
      272531,
      161543,
      76904,
      122163,
      52405,
      2039,
      19165,
      41623,
      14423,
      228354,
      3369,
      176360,
      85491,
      7122,
      35789,
      303724,
      4465,
      13628,
      2233,
      55311,
      118771,
      20713,
      10006,
      221519,
      45115,
      71021,
      35650,
      29775,
      7337,
      10864,
      20665,
      21142,
      1746,
      15080,
      1624,
      32449,
      10905,
      105743,
      229797,
      7701,
      3940,
      22997,
      178467,
      57208,
      389057,
      39683,
      59403,
      63344,
      63125,
      54847,
      69691,
      18336,
      56448,
      3362,
      37202,
      18282,
      29648,
      138224,
      35867,
      10495,
      5911,
      28814,
      26653,
      31514,
      176702,
      26550,
      45621,
      11734,
      4525,
      40543,
      73944,
      121080,
      27858,
      155561,
      14887,
      44670,
      30742,
      8796,
      107455,
      113472,
      56369,
      75581,
      183777,
      240095,
      133699,
      153299,
      8768,
      160464,
      26058,
      49078,
      103971,
      21875,
      71486,
      44888,
      17156,
      9678,
      89541,
      123019,
      102337,
      3972,
      83930,
      21245,
      87852,
      109660,
      287918,
      183019,
      686,
      10100,
      39177,
      283941,
      11274,
      24736,
      26793,
      26214,
      25995,
      77011,
      141580,
      4070,
      23742,
      46285,
      46632,
      30700,
      26669,
      19056,
      35951,
      115575,
      174034,
      56097,
      35463,
      87425,
      24575,
      44245,
      38701,
      82317,
      85922,
      281616,
      100333,
      147697,
      61503,
      7730,
      84330,
      8530,
      59917,
      61597,
      17173,
      9092,
      32658,
      90288,
      193136,
      39023,
      20381,
      56654,
      31132,
      7779,
      1919,
      1375,
      117128,
      30819,
      11169,
      40938,
      23935,
      115201,
      101155,
      151034,
      4835,
      11231,
      74550,
      89388,
      59951,
      91704,
      107312,
      167882,
      115062,
      12732,
      72738,
      88703,
      464019,
      158267,
      57995,
      60496,
      737,
      14371,
      123867,
      4174,
      243339,
      159946,
      7568,
      16025,
      134556,
      110916,
      38103,
      191,
      80226,
      88794,
      29688,
      27230,
      10454,
      76308,
      57647,
      77409,
      113483,
      66864,
      14745,
      19808,
      12023,
      46583,
      84805,
      16015,
      17102,
      2231,
      20611,
      3547,
      95740,
      250131,
      34559,
      108894,
      8498,
      15853,
      159169,
      148920,
      20942,
      2813,
      93160,
      45188,
      210613,
      45531,
      52587,
      149062,
      39782,
      28194,
      57849,
      60965,
      84954,
      89766,
      84453,
      100927,
      16501,
      27658,
      165311,
      103841,
      54192,
      207341,
      19558,
      20084,
      319622,
      5672,
      205467,
      98462,
      61849,
      36279,
      13609,
      147177,
      24726,
      165015,
      209489,
      59591,
      31157,
      6551,
      117580,
      75060,
      141146,
      277310,
      21072,
      22023,
      106474,
      63041,
      137443,
      122965,
      68371,
      5383,
      42146,
      98961,
      113467,
      30863,
      23794,
      4843,
      99630,
      30392,
      82679,
      13699,
      241612,
      33601,
      93146,
      24319,
      18643,
      32155,
      95669,
      40440,
      15333,
      34089,
      67799,
      142144,
      58245,
      38633,
      114531,
      117400,
      77861,
      188726,
      5507,
      2568,
      8853,
      10987,
      107222,
      2663,
      2421,
      11530,
      13345,
      30075,
      41785,
      118661,
      104786,
      17459,
      12490,
      16281,
      71936,
      193555,
      17431,
      5944,
      71758,
      26485,
      77317,
      20803,
      367167,
      158,
      7362,
      93430,
      11735,
      172445,
      46002,
      11532,
      54482,
      930,
      62911,
      2235,
      23004,
      179236,
      4764,
      101859,
      208113,
      22477,
      55163,
      95579,
      14098,
      67320,
      162556,
      90709,
      156949,
      3826,
      57492,
      4025,
      34092,
      87442,
      104565,
      6718,
      186015,
      28214,
      14209,
      10039,
      107186,
      233912,
      58877,
      81637,
      55265,
      39828,
      6194,
      145813,
      50831,
      105849,
      4974,
      88319,
      122296,
      10272,
      197216,
      95714,
      51540,
      72418,
      23324,
      91555,
      8743,
      140452,
      250249,
      51666,
      34124,
      7229,
      38592,
      129641,
      78169,
      174242,
      22464,
      149964,
      51450,
      14034,
      10026,
      95376,
      26190,
      120062,
      14401,
      8700,
      265,
      31386,
      143573,
      7203,
      229889,
      61567,
      4227,
      140981,
      2466,
      72052,
      10787,
      10062,
      30958,
      6099,
      38471,
      30103,
      23202,
      208101,
      70847,
      467,
      58934,
      32271,
      32984,
      36637,
      24107,
      30771,
      17109,
      73353,
      13650,
      2098,
      157040,
      67366,
      66904,
      106018,
      265380,
      107238,
      18535,
      44025,
      32681,
      144983,
      62505,
      91295,
      56120,
      3082,
      77508,
      10322,
      63023,
      36700,
      81885,
      224127,
      16721,
      45023,
      239261,
      111272,
      13852,
      7866,
      149243,
      204199,
      32309,
      22084,
      42029,
      38316,
      126644,
      104973,
      14406,
      43454,
      67322,
      61310,
      15789,
      40285,
      24026,
      181047,
      6301,
      70927,
      23319,
      115823,
      27248,
      66693,
      115875,
      278566,
      63007,
      146844,
      56841,
      59007,
      87368,
      180001,
      22370,
      42114,
      80605,
      12022,
      10374,
      308,
      25079,
      14689,
      12618,
      63368,
      7936,
      264973,
      212291,
      136713,
      95999,
      105801,
      18965,
      32075,
      48700,
      52230,
      35119,
      96912,
      32992,
      8586,
      16606,
      101333,
      101812,
      14969,
      39930,
      759,
      193090,
      27387,
      42914,
      12937,
      5058,
      62646,
      64528,
      38624,
      25743,
      37502,
      3716,
      4435,
      30352,
      178687,
      26461,
      132611,
      42002,
      138442,
      35833,
      59582,
      16345,
      8048,
      60319,
      49349,
      309,
      47800,
      49739,
      90482,
      26405,
      34470,
      63786,
      32479,
      85028,
      39866,
      47846,
      11649,
      23934,
      29466,
      2816,
      42864,
      31828,
      7410,
      74885,
      49632,
      47629,
      111801,
      90749,
      19536,
      18767,
      105764,
      59606,
      21223,
      10746,
      76298,
      22220,
      39408,
      7190,
      79654,
      64856,
      11602,
      82156,
      272765,
      17079,
      70089,
      245473,
      51813,
      184407,
      384678,
      1576,
      122249,
      5064,
      27481,
      6188,
      25790,
      74361,
      27541,
      318284,
      45430,
      31488,
      620,
      93579,
      45723,
      192118,
      22670,
      51913,
      4162,
      70244,
      35966,
      26397,
      16199,
      50899,
      209613,
      121702,
      287507,
      2993,
      36101,
      132229,
      67345,
      33062,
      76295,
      118628,
      78705,
      52316,
      34375,
      107083,
      107454,
      44863,
      127561,
      33964,
      3073,
      154010,
      190914,
      55967,
      39074,
      6272,
      31047,
      5550,
      41123,
      26154,
      98638,
      47110,
      19998,
      148091,
      50229,
      31329,
      59900,
      195442,
      19106,
      61347,
      73497,
      70015,
      682,
      45850,
      25776,
      38022,
      148951,
      6288,
      37411,
      232526,
      109277,
      27286,
      32342,
      9262,
      5220,
      16651,
      23175,
      46740,
      129438,
      78614,
      121925,
      66914,
      88710,
      127952,
      5563,
      21500,
      34521,
      10739,
      14863,
      191006,
      62956,
      17359,
      16749,
      67027,
      56284,
      69134,
      43301,
      35039,
      58883,
      54466,
      60823,
      404451,
      75743,
      59856,
      86979,
      7923,
      34273,
      83785,
      32142,
      7693,
      268986,
      197428,
      282681,
      17049,
      22346,
      22990,
      92245,
      107180,
      3357,
      37104,
      96724,
      49153,
      7683,
      31197,
      43267,
      82231,
      164276,
      23696,
      20848,
      188364,
      22309,
      24821,
      158707,
      1018,
      22514,
      70922,
      27792,
      45589,
      59709,
      10765,
      736,
      35218,
      63479,
      51987,
      24275,
      63588,
      55361,
      92929,
      81964,
      4658,
      20122,
      12330,
      44058,
      13065,
      311456,
      72224,
      8337,
      211229,
      38979,
      22590,
      138478,
      52757,
      32595,
      133600,
      8838,
      31549,
      94412,
      43391,
      90056,
      1585,
      94802,
      127271,
      6223,
      31889,
      137038,
      132910,
      2165,
      57616,
      230152,
      6080,
      10748,
      36737,
      74579,
      134062,
      50525,
      180532,
      119270,
      34556,
      76155,
      82394,
      52595,
      29258,
      31435,
      87820,
      67996,
      26943,
      183878,
      38007,
      2410,
      13526,
      180297,
      69856,
      3503,
      187396,
      167700,
      7838,
      16701,
      9199,
      56267,
      3661,
      37407,
      65994,
      23767,
      5708,
      62508,
      221700,
      67088,
      86978,
      46776,
      84434,
      32088,
      5612,
      9149,
      88244,
      21685,
      95151,
      46750,
      189612,
      2979,
      506311,
      2594,
      3628,
      40074,
      105039,
      78243,
      28523,
      6651,
      38058,
      71999,
      30992,
      12764,
      68261,
      108991,
      6165,
      26450,
      61961,
      13400,
      22426,
      7490,
      60890,
      109623,
      2070,
      12958,
      50355,
      67979,
      257096,
      7213,
      42578,
      52121,
      35716,
      65461,
      7516,
      124758,
      39268,
      302,
      64712,
      14977,
      1467,
      219452,
      2840,
      34229,
      11121,
      21602,
      19270,
      63574,
      8024,
      1532,
      17331,
      79839,
      78885,
      52029,
      180767,
      57957,
      6069,
      91265,
      61380,
      55767,
      8927,
      32881,
      287603,
      22149,
      35029,
      68876,
      6428,
      199567,
      46926,
      13412,
      104132,
      21434,
      366616,
      45060,
      110046,
      81924,
      128910,
      45886,
      52821,
      130416,
      29416,
      77342,
      21762,
      67329,
      121432,
      79924,
      11724,
      38625,
      81006,
      102033,
      28338,
      13326,
      3250,
      82056,
      82526,
      38212,
      21112,
      12382,
      111495,
      3263,
      7414,
      86274,
      93490,
      40844,
      30224,
      45212,
      24019,
      48411,
      71367,
      24941,
      76729,
      57776,
      3769,
      38114,
      202019,
      197745,
      31953,
      237533,
      33270,
      201580,
      255648,
      100798,
      44741,
      32241,
      98468,
      106931,
      10085,
      15090,
      170358,
      33154,
      66787,
      18819,
      69760,
      25061,
      234005,
      82660,
      6295,
      131975,
      16874,
      9076,
      4094,
      25005,
      17740,
      40908,
      19533,
      220019,
      44330,
      99792,
      50040,
      19619,
      13950,
      55228,
      24423,
      31253,
      95308,
      103177,
      184795,
      28590,
      82285,
      5059,
      3210,
      75525,
      49894,
      70007,
      56178,
      10580,
      36051,
      139681,
      21617,
      98736,
      3555,
      106306,
      164189,
      37352,
      63915,
      47824,
      24883,
      145530,
      61904,
      28444,
      11483,
      19837,
      145446,
      30420,
      112972,
      85939,
      11835,
      191233,
      2262,
      20705,
      58630,
      1753,
      148334,
      1197,
      144714,
      6887,
      11223,
      107667,
      60879,
      77914,
      4151,
      57417,
      81594,
      96681,
      169430,
      1784,
      20444,
      95138,
      254041,
      27038,
      596,
      7117,
      72808,
      13759,
      3353,
      126776,
      21074,
      55322,
      27081,
      36942,
      39547,
      139830,
      179275,
      4453,
      713,
      8722,
      71399,
      19204,
      25785,
      22794,
      23923,
      104114,
      11291,
      25458,
      102309,
      88396,
      75288,
      230440,
      206396,
      104551,
      58447,
      130857,
      37247,
      94734,
      31548,
      176529,
      226077,
      65159,
      20104,
      10096,
      66881,
      94191,
      237909,
      27109,
      37404,
      1520,
      27421,
      25220,
      113003,
      23423,
      24884,
      50585,
      6286,
      231877,
      150800,
      11789,
      3226,
      90004,
      60642,
      5053,
      202400,
      61442,
      132531,
      175329,
      57138,
      30116,
      103847,
      9973,
      75367,
      16452,
      32360,
      59119,
      21246,
      10191,
      164804,
      23305,
      61051,
      37348,
      154530,
      13214,
      5468,
      50403,
      66754,
      130976,
      50559,
      80515,
      14436,
      155492,
      84017,
      5472,
      43107,
      41240,
      2890,
      90431,
      70188,
      382,
      76234,
      48040,
      50211,
      281038,
      237007,
      32115,
      142178,
      1536,
      22761,
      96429,
      1811,
      31243,
      1679,
      49143,
      55209,
      17402,
      235054,
      61494,
      7462,
      77030,
      34925,
      87609,
      78002,
      9499,
      9027,
      73289,
      201078,
      101379,
      63544,
      27666,
      5469,
      10642,
      30029,
      49816,
      132979,
      95620,
      58086,
      351930,
      116300,
      2110,
      2043,
      30845,
      6154,
      11279,
      16727,
      4122,
      2277,
      27281,
      4971,
      3650,
      39060,
      61970,
      65951,
      39674,
      75686,
      38151,
      11370,
      130809,
      177895,
      32665,
      63725,
      122267,
      7857,
      39618,
      118483,
      44792,
      157755,
      178624,
      136994,
      24260,
      41308,
      22471,
      12404,
      21707,
      12486,
      30473,
      52781,
      50246,
      20247,
      39065,
      909,
      56825,
      103158,
      128603,
      31542,
      1089,
      41935,
      32744,
      12428,
      37963,
      84420,
      33134,
      72921,
      208449,
      42622,
      168151,
      127335,
      147107,
      46699,
      38216,
      12591,
      94342,
      85814,
      31423,
      24944,
      2605,
      87542,
      67473,
      192551,
      4496,
      56321,
      91819,
      17630,
      6300,
      256183,
      114569,
      202090,
      33209,
      35289,
      34897,
      24967,
      40520,
      43470,
      5344,
      10199,
      34810,
      14283,
      10381,
      10017,
      62923,
      49924,
      23233,
      64539,
      13051,
      35686,
      19698,
      11570,
      135555,
      120868,
      44924,
      87065,
      52318,
      52335,
      47586,
      140906,
      245885,
      109834,
      78668,
      9065,
      46990,
      25258,
      72022,
      61243,
      40838,
      4545,
      146387,
      10537,
      11557,
      17470,
      36930,
      68104,
      46711,
      24264,
      79401,
      81043,
      18225,
      120488,
      24746,
      84338,
      81652,
      28266,
      13776,
      21878,
      46973,
      1047,
      230465,
      73357,
      95777,
      24973,
      210160,
      62210,
      58404,
      110633,
      169651,
      6937,
      41870,
      9909,
      26822,
      191062,
      76553,
      27519,
      96256,
      239070,
      2478,
      205678,
      67955,
      58532,
      20601,
      50120,
      19148,
      78501,
      195724,
      110740,
      8249,
      109665,
      27446,
      30568,
      57631,
      31425,
      49752,
      32820,
      65504,
      50079,
      3663,
      102256,
      219898,
      23849,
      211315,
      14645,
      4359,
      91767,
      9528,
      12449,
      49366,
      7941,
      49763,
      107848,
      8930,
      27086,
      50686,
      9744,
      10447,
      81935,
      39513,
      46514,
      1670,
      29229,
      6172,
      22312,
      137280,
      97759,
      9806,
      14445,
      22976,
      56458,
      73391,
      34983,
      93760,
      174219,
      52573,
      33149,
      59747,
      2429,
      136277,
      75123,
      165263,
      91040,
      7446,
      57632,
      48633,
      97140,
      246081,
      84766,
      151684,
      79918,
      93268,
      120346,
      54059,
      54875,
      77858,
      32996,
      103590,
      45276,
      11968,
      19600,
      25849,
      17159,
      132907,
      42828,
      16817,
      4913,
      99462,
      103303,
      27395,
      5737,
      74184,
      20749,
      21160,
      14377,
      77062,
      131403,
      158735,
      10999,
      27799,
      77785,
      9320,
      34366,
      51593,
      61070,
      33746,
      47048,
      29268,
      36675,
      30262,
      53297,
      9832,
      82e3,
      20188,
      122292,
      39917,
      7331,
      18160,
      68301,
      185935,
      134830,
      15031,
      4935,
      10004,
      165845,
      185534,
      46923,
      30109,
      44134,
      122631,
      18874,
      22903,
      112790,
      26561,
      18549,
      348902,
      82871,
      140345,
      255565,
      135390,
      63556,
      103747,
      145055,
      179600,
      145662,
      296111,
      61661,
      211987,
      23952,
      52342,
      126343,
      48450,
      32919,
      44277,
      82185,
      9591,
      62139,
      205363,
      376969,
      394874,
      108461,
      18040,
      120885,
      14798,
      39863,
      16571,
      16794,
      58271,
      81025,
      55206,
      14640,
      118656,
      6361,
      44092,
      85970,
      6262,
      153863,
      108244,
      180200,
      72264,
      79947,
      38044,
      10050,
      5735,
      61221,
      80712,
      5471,
      115689,
      11391,
      11661,
      184257,
      20010,
      60116,
      30320,
      19327,
      134598,
      45455,
      27542,
      18004,
      125092,
      452272,
      1549,
      91523,
      46567,
      180063,
      156026,
      2608,
      11174,
      58848,
      37788,
      65907,
      80194,
      30490,
      5786,
      40775,
      119519,
      106241,
      11323,
      156297,
      8425,
      61495,
      2617,
      29675,
      2425,
      59886,
      112582,
      49142,
      59618,
      4863,
      50597,
      86710,
      50650,
      168632,
      27693,
      85641,
      83643,
      18993,
      25768,
      84284,
      28090,
      93592,
      36627,
      312804,
      43381,
      9887,
      9402,
      100931,
      97165,
      3311,
      173330,
      66805,
      28935,
      4963,
      184460,
      3201,
      78102,
      19126,
      21607,
      37496,
      24938,
      22615,
      16153,
      32862,
      134792,
      153318,
      61120,
      6067,
      2812,
      12826,
      12792,
      23825,
      37559,
      64662,
      202250,
      102694,
      155488,
      85881,
      149193,
      46233,
      65383,
      15521,
      106982,
      11358,
      176786,
      25752,
      39717,
      34208,
      24510,
      32464,
      77742,
      39371,
      72028,
      138229,
      60688,
      71386,
      102834,
      132477,
      2208,
      11548,
      63670,
      271279,
      28351,
      30338,
      38620,
      32491,
      99845,
      143885,
      152266,
      13252,
      2825,
      178663,
      108097,
      1775,
      78201,
      14897,
      113573,
      163346,
      62292,
      171129,
      22183,
      96598,
      38733,
      64971,
      166776,
      117445,
      9968,
      146393,
      44677,
      74867,
      20908,
      97328,
      12761,
      25656,
      26785,
      9148,
      112344,
      26115,
      99176,
      110121,
      22437,
      49547,
      6180,
      79320,
      5835,
      31392,
      43328,
      33377,
      75870,
      119860,
      69497,
      80273,
      7325,
      155219,
      43167,
      111173,
      28347,
      20222,
      3763,
      71752,
      55041,
      47252,
      14618,
      28088,
      15012,
      97805,
      194698,
      54636,
      2036,
      41349,
      6173,
      96604,
      61530,
      51859,
      43782,
      13361,
      24334,
      22668,
      24792,
      7070,
      23441,
      16789,
      3209,
      36211,
      208475,
      26242,
      32880,
      122181,
      182407,
      21444,
      31060,
      88459,
      29929,
      77907,
      12716,
      10934,
      97005,
      20599,
      31690,
      8403,
      58445,
      30303,
      22700,
      10336,
      86731,
      103115,
      337709,
      72556,
      46788,
      112566,
      47684,
      67089,
      53548,
      36874,
      56487,
      41387,
      125985,
      26893,
      40071,
      106683,
      73712,
      18787,
      40105,
      72992,
      67246,
      137276,
      50802,
      36790,
      70328,
      138827,
      22466,
      39263,
      183295,
      29858,
      50975,
      9322,
      57397,
      10654,
      24364,
      30383,
      55799,
      41600,
      23584,
      127295,
      296610,
      129078,
      143558,
      244131,
      86397,
      36049,
      1085,
      80677,
      3820,
      108139,
      5476,
      34767,
      24683,
      7758,
      13060,
      7239,
      131671,
      250593,
      59556,
      103392,
      29810,
      4188,
      252323,
      39404,
      116877,
      7651,
      43600,
      40338,
      13554,
      157253,
      39196,
      25978,
      144387,
      61211,
      234,
      50104,
      6129,
      10449,
      93777,
      9240,
      356378,
      274148,
      4439,
      72970,
      3724,
      147770,
      78680,
      62570,
      115877,
      40027,
      40547,
      36817,
      224392,
      64609,
      34795,
      165027,
      67440,
      2477,
      37206,
      23431,
      50754,
      164797,
      46018,
      94995,
      170982,
      27051,
      7957,
      22767,
      3674,
      27900,
      56419,
      18930,
      60701,
      41302,
      2692,
      84749,
      339721,
      61996,
      111094,
      80221,
      50129,
      1045,
      8153,
      62945,
      19202,
      8250,
      37208,
      37418,
      32560,
      79477,
      41106,
      88569,
      33963,
      36693,
      5892,
      30570,
      1581,
      66471,
      49647,
      11922,
      160717,
      29442,
      5643,
      114865,
      82962,
      95982,
      132098,
      22633,
      22838,
      94726,
      54556,
      28566,
      205039,
      162340,
      33216,
      16849,
      35847,
      221339,
      94851,
      26533,
      71469,
      1805,
      3804,
      12935,
      45483,
      71020,
      36310,
      65381,
      192960,
      34240,
      35165,
      59773,
      1248,
      46954,
      155332,
      96864,
      4246,
      388800,
      16129,
      57133,
      74592,
      44807,
      442014,
      38203,
      42574,
      80818,
      91592,
      26377,
      36424,
      65760,
      977,
      77387,
      22628,
      147610,
      28018,
      30561,
      98454,
      6969,
      119628,
      63648,
      18170,
      36854,
      26601,
      64018,
      22027,
      37279,
      51395,
      152934,
      21153,
      9430,
      58760,
      194742,
      5330,
      55115,
      34158,
      28917,
      174111,
      13171,
      122326,
      1526,
      43896,
      66094,
      25325,
      4234,
      148354,
      11450,
      275,
      18999,
      112191,
      44365,
      22723,
      68409,
      8733,
      57746,
      96565,
      75007,
      14196,
      108844,
      29475,
      88599,
      177563,
      100792,
      106156,
      86323,
      93726,
      14248,
      135341,
      194131,
      40126,
      47099,
      14779,
      8272,
      39597,
      95983,
      171398,
      65882,
      28052,
      10393,
      47213,
      40689,
      22120,
      72212,
      106829,
      34964,
      109146,
      753,
      648,
      21660,
      30047,
      17527,
      181025,
      5619,
      145357,
      4085,
      216883,
      9359,
      186951,
      24779,
      53931,
      24545,
      36197,
      223296,
      62628,
      168101,
      4243,
      107313,
      30321,
      26642,
      13049,
      51059,
      31027,
      107912,
      807,
      73550,
      26551,
      84369,
      122422,
      165872,
      49754,
      74213,
      234264,
      33151,
      52014,
      33100,
      87183,
      22365,
      52500,
      40013,
      23302,
      5652,
      72723,
      21404,
      26107,
      48434,
      587,
      94049,
      168493,
      96418,
      32871,
      70860,
      31709,
      25128,
      443,
      71597,
      166253,
      15670,
      70994,
      26341,
      133675,
      28280,
      75491,
      54756,
      47955,
      56028,
      26182,
      11952,
      113272,
      472197,
      64640,
      110753,
      17919,
      337,
      50642,
      22576,
      142,
      87371,
      53391,
      93210,
      126694,
      15285,
      19642,
      85667,
      14148,
      1506,
      42092,
      52962,
      33243,
      11970,
      20734,
      135843,
      57044,
      58880,
      13002,
      219134,
      22876,
      64754,
      232519,
      4257,
      43120,
      321573,
      24799,
      64526,
      124728,
      52579,
      81472,
      70831,
      276848,
      17403,
      74359,
      23021,
      182101,
      74597,
      23744,
      148267,
      12055,
      7976,
      5349,
      11772,
      67540,
      167347,
      65318,
      18720,
      127832,
      108238,
      22828,
      90233,
      9987,
      259080,
      118185,
      73209,
      79270,
      13775,
      90100,
      137742,
      90799,
      70569,
      15699,
      19961,
      9087,
      67475,
      57872,
      39731,
      8810,
      134897,
      131868,
      146849,
      19898,
      3334,
      2281,
      167061,
      91073,
      60356,
      467742,
      74712,
      188,
      53179,
      137679,
      92769,
      29241,
      9537,
      132595,
      80119,
      1041,
      88962,
      5976,
      40171,
      44911,
      102859,
      139059,
      104558,
      98987,
      47761,
      19272,
      71472,
      113864,
      175377,
      73338,
      10857,
      23402,
      23758,
      1591,
      139864,
      5644,
      4076,
      118760,
      16427,
      134198,
      18853,
      20291,
      100849,
      37423,
      22038,
      36677,
      19071,
      195521,
      57445,
      11069,
      31869,
      55718,
      66882,
      148490,
      44,
      41296,
      75242,
      49704,
      166810,
      9906,
      20943,
      122258,
      49112,
      105667,
      15969,
      10344,
      6408,
      187694,
      21399,
      72742,
      58970,
      14867,
      14376,
      81889,
      41856,
      23225,
      15042,
      56993,
      16074,
      131389,
      74276,
      72407,
      53875,
      383108,
      53597,
      37363,
      68993,
      44854,
      122548,
      430927,
      198279,
      38430,
      80409,
      12245,
      2981,
      628,
      2818,
      17760,
      37437,
      238229,
      7968,
      46892,
      2200,
      3730,
      34190,
      65983,
      37959,
      112291,
      87850,
      70827,
      6522,
      20750,
      73913,
      111621,
      41652,
      19587,
      2780,
      58668,
      25916,
      85259,
      18200,
      168962,
      95781,
      42445,
      102050,
      7776,
      57662,
      103313,
      47742,
      96358,
      41964,
      66174,
      100396,
      29069,
      204735,
      19679,
      27978,
      7479,
      40264,
      22534,
      61183,
      36081,
      107436,
      58223,
      14680,
      23002,
      101311,
      24716,
      124108,
      12908,
      5646,
      31750,
      40380,
      14215,
      232799,
      102772,
      14122,
      96775,
      61398,
      50917,
      12096,
      149880,
      67833,
      598749,
      124194,
      155871,
      49216,
      790,
      14677,
      65319,
      56917,
      7440,
      145744,
      95701,
      12206,
      49405,
      129269,
      76199,
      45732,
      9767,
      11058,
      9047,
      210885,
      11051,
      7392,
      26307,
      2130,
      8132,
      147526,
      20802,
      232698,
      115660,
      50060,
      59789,
      57344,
      107623,
      80343,
      112676,
      23291,
      9866,
      160971,
      34032,
      118291,
      15719,
      59730,
      164911,
      28975,
      2659,
      58046,
      78480,
      21854,
      66209,
      53863,
      109085,
      116045,
      29021,
      46481,
      107552,
      22130,
      18764,
      70254,
      31272,
      11300,
      52460,
      43933,
      84738,
      20721,
      53869,
      190840,
      79673,
      105300,
      7561,
      321817,
      66924,
      13940,
      33281,
      101046,
      183181,
      32176,
      71878,
      5678,
      62924,
      79535,
      56646,
      40303,
      19559,
      27703,
      93042,
      73368,
      42187,
      3670,
      37376,
      46440,
      7023,
      36816,
      109628,
      20680,
      5940,
      276440,
      275233,
      170848,
      112093,
      136996,
      14984,
      20226,
      111441,
      77693,
      112960,
      48577,
      39370,
      55707,
      50314,
      123404,
      26570,
      54281,
      61372,
      123391,
      4857,
      35928,
      246740,
      132507,
      106646,
      44241,
      7196,
      92258,
      9825,
      37688,
      51197,
      303141,
      5590,
      15476,
      132986,
      10955,
      85782,
      34486,
      26696,
      7991,
      28813,
      18858,
      39546,
      11703,
      11365,
      38185,
      5716,
      93555,
      11925,
      40121,
      60002,
      6985,
      10976,
      171384,
      3887,
      43394,
      13337,
      56346,
      6381,
      252336,
      39573,
      75042,
      53711,
      1028,
      31781,
      44295,
      95925,
      131713,
      7214,
      68125,
      43571,
      70954,
      213234,
      1628,
      8760,
      13391,
      65485,
      17320,
      56038,
      1710,
      25248,
      60803,
      57399,
      19839,
      3870,
      326,
      281556,
      50945,
      72400,
      21460,
      316244,
      75619,
      56246,
      98775,
      481,
      13513,
      55765,
      50427,
      7388,
      123519,
      32929,
      57908,
      27124,
      61316,
      101097,
      57467,
      30228,
      48792,
      10788,
      20402,
      37318,
      50526,
      155730,
      34456,
      158065,
      145305,
      17832,
      43733,
      64052,
      4506,
      35072,
      205355,
      177028,
      184004,
      187081,
      68616,
      35938,
      83703,
      10367,
      36892,
      93186,
      260137,
      51934,
      89970,
      4985,
      23445,
      26755,
      21558,
      7948,
      78741,
      23376,
      124405,
      85594,
      68596,
      57536,
      49351,
      12619,
      56593,
      132668,
      99924,
      109728,
      71844,
      71935,
      196018,
      65464,
      17617,
      14987,
      89701,
      143773,
      33997,
      8687,
      22701,
      33258,
      2914,
      4436,
      72108,
      85610,
      9671,
      49067,
      2327,
      82988,
      1361,
      1672,
      44033,
      35777,
      30269,
      24057,
      10605,
      82236,
      616,
      15793,
      13919,
      47249,
      112086,
      116698,
      9484,
      80207,
      90574,
      33304,
      68624,
      93127,
      56101,
      42210,
      160929,
      4827,
      38995,
      38095,
      4701,
      125119,
      5027,
      33680,
      9236,
      231236,
      14135,
      87837,
      23318,
      70261,
      78893,
      30151,
      81482,
      14332,
      1084,
      74256,
      27532,
      46644,
      79185,
      3148,
      62615,
      6981,
      55672,
      31668,
      36825,
      1849,
      14536,
      37446,
      14738,
      23779,
      43058,
      162749,
      72199,
      1168,
      21346,
      5592,
      85932,
      85302,
      9668,
      18351,
      57135,
      150360,
      2080,
      228015,
      77953,
      34670,
      119302,
      151751,
      31009,
      106725,
      84265,
      45214,
      59289,
      74178,
      113071,
      263206,
      111009,
      4021,
      44449,
      188119,
      192629,
      123592,
      392506,
      292847,
      114487,
      12831,
      205858,
      9852,
      20780,
      79648,
      75767,
      357014,
      97721,
      18166,
      21005,
      67950,
      33226,
      204009,
      16536,
      2987,
      11335,
      66717,
      144910,
      47950,
      17262,
      55060,
      15063,
      2934,
      51038,
      26775,
      178497,
      66008,
      3427,
      49433,
      128592,
      20036,
      157553,
      63861,
      3089,
      23015,
      51210,
      28696,
      35933,
      49942,
      71135,
      231518,
      99620,
      17248,
      21835,
      176536,
      20676,
      16944,
      38700,
      165831,
      233253,
      295625,
      36723,
      13023,
      52745,
      10907,
      19423,
      67972,
      125868,
      95473,
      82875,
      1183,
      108455,
      52685,
      33417,
      64095,
      21433,
      52438,
      33191,
      127809,
      44505,
      211823,
      7810,
      2752,
      95548,
      162031,
      7185,
      91196,
      47563,
      61721,
      33359,
      17897,
      23682,
      42806,
      178101,
      22874,
      49707,
      199897,
      75419,
      82456,
      8618,
      11171,
      79712,
      116847,
      18783,
      44190,
      46564,
      5346,
      59046,
      95032,
      7893,
      14916,
      3214,
      26800,
      24172,
      121453,
      34362,
      10250,
      17408,
      18888,
      4840,
      68696,
      22831,
      13162,
      36005,
      32512,
      14800,
      62357,
      41723,
      45046,
      27247,
      37486,
      5372,
      2564,
      34261,
      298500,
      66509,
      133920,
      89138,
      31305,
      117697,
      19097,
      108304,
      81386,
      84106,
      23802,
      46411,
      63304,
      946,
      51417,
      41777,
      41041,
      19501,
      115864,
      60743,
      294354,
      37955,
      94165,
      18116,
      1156,
      17937,
      20645,
      57114,
      90804,
      58042,
      48643,
      92288,
      9861,
      2557,
      88546,
      61333,
      101008,
      12853,
      5148,
      87856,
      4152,
      144503,
      73841,
      18718,
      9789,
      147565,
      10846,
      42085,
      12789,
      30223,
      8993,
      56352,
      67203,
      2448,
      28215,
      6052,
      23540,
      126319,
      75933,
      36689,
      80235,
      23231,
      23561,
      21383,
      38800,
      77548,
      102798,
      21234,
      31468,
      158608,
      46188,
      63960,
      191679,
      8051,
      67014,
      11185,
      170078,
      42186,
      28827,
      34777,
      41930,
      212079,
      12421,
      34750,
      24111,
      110344,
      73918,
      45171,
      70826,
      141949,
      40063,
      23979,
      24254,
      37309,
      26724,
      27179,
      24718,
      83648,
      54938,
      14591,
      17425,
      29525,
      102675,
      48975,
      48654,
      12316,
      8929,
      60640,
      41709,
      50168,
      63264,
      89812,
      50716,
      48632,
      38755,
      138583,
      160123,
      55579,
      71829,
      24230,
      233277,
      46322,
      39650,
      166388,
      34718,
      24108,
      98252,
      7031,
      106695,
      62498,
      18258,
      35062,
      217827,
      78731,
      34824,
      33354,
      19520,
      60852,
      2432,
      60224,
      8587,
      2836,
      62955,
      702,
      20227,
      42285,
      40560,
      95592,
      62486,
      11094,
      53035,
      143291,
      18842,
      46177,
      77994,
      1770,
      9657,
      107422,
      172915,
      32655,
      128716,
      25886,
      25164,
      156740,
      119928,
      165875,
      85817,
      11007,
      89110,
      33956,
      12652,
      65156,
      180266,
      8494,
      36889,
      19958,
      20955,
      96,
      1264,
      118288,
      135769,
      44754,
      86671,
      5632,
      19026,
      168220,
      289120,
      33569,
      93821,
      66144,
      70635,
      7687,
      5642,
      2714,
      55445,
      56636,
      71545,
      184182,
      93133,
      7332,
      37389,
      12643,
      52315,
      22729,
      11014,
      158742,
      17050,
      152889,
      50178,
      34601,
      41945,
      52136,
      9948,
      26914,
      63548,
      95721,
      115951,
      40759,
      8960,
      158258,
      38938,
      49232,
      48325,
      42234,
      81523,
      253019,
      66128,
      40978,
      20048,
      238048,
      38760,
      62928,
      122560,
      118532,
      43687,
      137472,
      163689,
      26680,
      9878,
      17448,
      51035,
      16211,
      60834,
      36749,
      29178,
      14241,
      59868,
      150086,
      2305,
      26477,
      42422,
      34342,
      165341,
      83279,
      33894,
      14257,
      29928,
      12743,
      13957,
      125571,
      89134,
      66712,
      10952,
      16507,
      147839,
      30146,
      7249,
      16565,
      45399,
      39874,
      114565,
      215780,
      31990,
      230881,
      171477,
      102,
      196546,
      44538,
      10880,
      84948,
      281705,
      86651,
      10617,
      31395,
      2342,
      453658,
      43569,
      60561,
      132901,
      21845,
      17727,
      58556,
      258242,
      22262,
      58728,
      4008,
      77997,
      11806,
      37431,
      30599,
      81375,
      109137,
      185787,
      114085,
      217292,
      97453,
      169085,
      30593,
      60212,
      11544,
      102056,
      65580,
      2384,
      91655,
      4855,
      95725,
      7295,
      157994,
      16228,
      20669,
      53276,
      141590,
      105246,
      17334,
      25440,
      76067,
      17967,
      39321,
      38911,
      11362,
      28559,
      63807,
      21627,
      26468,
      85816,
      40120,
      1025,
      15234,
      58319,
      69516,
      66512,
      124548,
      75845,
      78873,
      22137,
      46681,
      51242,
      85683,
      32909,
      76747,
      35555,
      43396,
      101465,
      1765,
      73094,
      1077,
      2962,
      39028,
      66777,
      57831,
      42048,
      15828,
      13962,
      36041,
      63657,
      52412,
      5242,
      58846,
      2141,
      5506,
      219012,
      134451,
      3936,
      182230,
      17558,
      17153,
      152237,
      22621,
      49377,
      170216,
      35257,
      68233,
      65374,
      6510,
      11126,
      212151,
      7184,
      2480,
      22517,
      3437,
      33073,
      30156,
      16557,
      3768,
      55067,
      86829,
      91e3,
      12350,
      148650,
      66017,
      79424,
      70885,
      49066,
      28250,
      21369,
      51213,
      34533,
      11510,
      3258,
      18176,
      18465,
      84413,
      6315,
      36411,
      163765,
      4346,
      356,
      107618,
      598,
      13727,
      285026,
      162695,
      8749,
      14583,
      7132,
      63521,
      184253,
      32378,
      25991,
      5604,
      30961,
      53675,
      4874,
      84693,
      5086,
      34811,
      26978,
      56564,
      7904,
      33519,
      51221,
      113942,
      69253,
      6664,
      125563,
      22055,
      220680,
      102008,
      742,
      51930,
      19494,
      176108,
      44424,
      35123,
      13025,
      75685,
      11759,
      74335,
      22250,
      181453,
      131147,
      16984,
      132115,
      154311,
      11991,
      76452,
      52609,
      85351,
      196,
      30969,
      9198,
      74919,
      2529,
      56838,
      71779,
      29187,
      116304,
      3504,
      62330,
      41190,
      86153,
      28393,
      254926,
      104228,
      105189,
      13264,
      84359,
      3574,
      12415,
      8534,
      57147,
      10175,
      188174,
      59504,
      60932,
      66318,
      16407,
      107921,
      17638,
      99103,
      49278,
      28403,
      39786,
      145865,
      8462,
      3558,
      43406,
      142271,
      29139,
      21989,
      36552,
      93955,
      72365,
      7176,
      13556,
      106185,
      37957,
      321774,
      17782,
      129017,
      51154,
      27938,
      24952,
      1935,
      39366,
      2791,
      33489,
      41582,
      56078,
      24558,
      9311,
      5449,
      218786,
      27808,
      190429,
      68013,
      36020,
      86003,
      29735,
      3404,
      87348,
      119357,
      115714,
      2324,
      86796,
      81973,
      40992,
      43376,
      93621,
      28784,
      16808,
      36367,
      2517,
      2909,
      191926,
      24978,
      55303,
      53308,
      205724,
      60068,
      3098,
      21375,
      64784,
      23949,
      26579,
      63121,
      12319,
      80145,
      39967,
      97861,
      6757,
      70143,
      67642,
      37082,
      34698,
      69140,
      122883,
      46151,
      62187,
      80934,
      429,
      19437,
      135071,
      137885,
      222647,
      13331,
      154065,
      327,
      61778,
      74257,
      40116,
      37493,
      14855,
      85079,
      237641,
      42342,
      102164,
      199965,
      71204,
      4662,
      29368,
      5042,
      113914,
      122214,
      8955,
      13149,
      102503,
      43173,
      5659,
      163787,
      69003,
      307084,
      63392,
      171080,
      21390,
      81918,
      86666,
      36622,
      24126,
      28887,
      5736,
      28054,
      207170,
      163428,
      79891,
      346467,
      95363,
      38980,
      111806,
      80828,
      9200,
      19288,
      294896,
      114468,
      87405,
      111715,
      141705,
      7015,
      72754,
      68463,
      48738,
      243147,
      33397,
      101210,
      37051,
      98801,
      82847,
      20397,
      4940,
      185559,
      18716,
      54718,
      83491,
      11725,
      40803,
      1128,
      12128,
      23060,
      5174,
      7745,
      67007,
      46701,
      1571,
      27807,
      180186,
      256996,
      18975,
      16837,
      7877,
      212758,
      250379,
      15440,
      87954,
      57755,
      24719,
      124057,
      83461,
      258,
      50864,
      8874,
      29038,
      71289,
      31627,
      15429,
      9005,
      4061,
      113851,
      107716,
      82819,
      13651,
      79656,
      117851,
      17539,
      111446,
      12938,
      39724,
      190787,
      4352,
      15402,
      21070,
      62708,
      8539,
      23777,
      73853,
      13552,
      38810,
      86117,
      16285,
      56400,
      1718,
      75342,
      142863,
      29033,
      378,
      110113,
      180321,
      32586,
      23606,
      26393,
      160984,
      207987,
      23783,
      8406,
      16904,
      24596,
      47274,
      11693,
      46539,
      60524,
      78595,
      48423,
      31718,
      20170,
      9009,
      146268,
      15183,
      191060,
      172765,
      1349,
      138436,
      37365,
      10970,
      40509,
      225817,
      20021,
      70394,
      152138,
      21541,
      66559,
      66544,
      89352,
      2725,
      17258,
      91345,
      7313,
      3815,
      115868,
      8660,
      40362,
      4071,
      103524,
      39388,
      118275,
      21950,
      6549,
      38226,
      32754,
      209574,
      29201,
      43495,
      18028,
      20296,
      40597,
      18370,
      47520,
      202450,
      24134,
      2219,
      8195,
      69545,
      38041,
      136934,
      46374,
      19041,
      159811,
      84865,
      58620,
      846,
      98749,
      13569,
      30714,
      97246,
      32186,
      4479,
      27355,
      92973,
      35214,
      151491,
      75963,
      37631,
      1561,
      27200,
      238083,
      23182,
      60756,
      12291,
      25766,
      39355,
      102333,
      87362,
      65741,
      59906,
      19538,
      201575,
      48772,
      102938,
      24438,
      292580,
      39964,
      66366,
      9004,
      61379,
      50548,
      37622,
      38732,
      28379,
      68180,
      76622,
      17488,
      69849,
      5963,
      7219,
      48143,
      43413,
      55358,
      540,
      58691,
      29506,
      19245,
      52193,
      48621,
      5518,
      13048,
      118625,
      44755,
      191081,
      42061,
      89197,
      2259,
      60665,
      66994,
      71210,
      51232,
      3585,
      142096,
      55024,
      7892,
      8345,
      58653,
      463307,
      65658,
      64319,
      137941,
      136323,
      53499,
      12746,
      43492,
      6978,
      95163,
      29925,
      60175,
      5128,
      7352,
      41463,
      184756,
      121146,
      20473,
      18426,
      4598,
      5309,
      54580,
      14277,
      121151,
      10691,
      56711,
      43880,
      63409,
      76682,
      11830,
      172218,
      264898,
      32632,
      66536,
      81062,
      31649,
      25788,
      92774,
      60222,
      11100,
      63159,
      9432,
      224657,
      25240,
      53613,
      152,
      138620,
      163829,
      2397,
      85345,
      12501,
      37507,
      64932,
      38575,
      43522,
      65789,
      80198,
      78796,
      35226,
      3851,
      108891,
      73311,
      3060,
      28391,
      93671,
      39663,
      46142,
      30982,
      66041,
      37281,
      68157,
      26553,
      71872,
      81142,
      211527,
      39747,
      118119,
      22695,
      2859,
      11066,
      20232,
      168911,
      7933,
      197005,
      17066,
      111071,
      44434,
      133994,
      120798,
      12766,
      227798,
      45756,
      132852,
      29917,
      36076,
      55352,
      65281,
      129800,
      41958,
      18944,
      84678,
      18580,
      168093,
      132621,
      39997,
      54092,
      27740,
      32354,
      3770,
      114118,
      103242,
      43918,
      15899,
      18574,
      145944,
      3190,
      123469,
      219903,
      24169,
      100571,
      62403,
      16776,
      92779,
      14535,
      17168,
      16475,
      14304,
      37231,
      1712,
      28218,
      242754,
      61688,
      28980,
      1318,
      51359,
      222657,
      99200,
      67989,
      31772,
      23932,
      35351,
      201251,
      49041,
      27306,
      19128,
      40135,
      3986,
      77333,
      19649,
      120683,
      151927,
      21081,
      7076,
      78375,
      77501,
      101599,
      8011,
      89585,
      96715,
      58179,
      5378,
      102138,
      106793,
      26051,
      217276,
      4197,
      16297,
      27014,
      46721,
      13322,
      22806,
      5278,
      29629,
      70632,
      9647,
      71519,
      58818,
      40603,
      128530,
      8903,
      36770,
      56900,
      31483,
      26935,
      43845,
      34265,
      34920,
      87658,
      6114,
      84767,
      64250,
      47318,
      50720,
      19264,
      162514,
      33357,
      13117,
      6705,
      46696,
      75032,
      71054,
      87004,
      42035,
      69138,
      11903,
      99854,
      102328,
      19611,
      34525,
      69312,
      6431,
      49842,
      101600,
      133178,
      108751,
      41829,
      89939,
      225664,
      48916,
      99556,
      9195,
      130387,
      5960,
      36857,
      116724,
      53518,
      94002,
      39077,
      53996,
      6945,
      22261,
      64291,
      8314,
      152785,
      57588,
      16522,
      9091,
      5048,
      87671,
      35441,
      39509,
      1945,
      12423,
      158923,
      178413,
      37549,
      14095,
      1475,
      73188,
      62878,
      4819,
      24012,
      68534,
      42606,
      4010,
      120809,
      57497,
      59564,
      101758,
      103718,
      32701,
      80116,
      12345,
      95834,
      46918,
      21468,
      53213,
      15665,
      31200,
      3867,
      5140,
      96013,
      250744,
      21016,
      10069,
      13968,
      35449,
      180829,
      27683,
      39704,
      59956,
      22893,
      3115,
      26293,
      32785,
      75934,
      62445,
      141162,
      62720,
      2018,
      83638,
      19949,
      114012,
      95006,
      3330,
      99829,
      130935,
      309272,
      9565,
      55874,
      121727,
      37017,
      23586,
      319858,
      40970,
      27602,
      8625,
      112329,
      61060,
      100088,
      118525,
      25922,
      16232,
      1907,
      60671,
      51583,
      44553,
      80993,
      5262,
      94679,
      8676,
      940,
      20736,
      11823,
      3020,
      16476,
      12340,
      152600,
      97416,
      3703,
      25744,
      66826,
      16245,
      16876,
      46446,
      84798,
      74227,
      176020,
      45192,
      61955,
      75496,
      23946,
      23626,
      40372,
      26036,
      6149,
      11822,
      30582,
      16541,
      41914,
      82385,
      232823,
      40921,
      80773,
      14930,
      3631,
      7517,
      39619,
      4348,
      36180,
      126106,
      138939,
      62611,
      1477,
      113512,
      47321,
      25052,
      14546,
      118881,
      29060,
      23589,
      128322,
      36795,
      18401,
      137921,
      104699,
      267929,
      36194,
      172791,
      18113,
      4766,
      188215,
      30083,
      332586,
      94089,
      5805,
      77909,
      22194,
      68234,
      154976,
      43220,
      40660,
      70001,
      184893,
      138095,
      11128,
      103010,
      22663,
      5108,
      212615,
      8485,
      5565,
      49222,
      54614,
      26530,
      42639,
      16319,
      55062,
      152662,
      105595,
      21114,
      22216,
      10294,
      68158,
      10436,
      86950,
      7206,
      62115,
      3977,
      3657,
      59874,
      456,
      118617,
      18156,
      106663,
      112229,
      80992,
      17442,
      8217,
      55551,
      5133,
      34344,
      251927,
      51153,
      39364,
      201321,
      7816,
      66803,
      23057,
      156724,
      145664,
      14276,
      95705,
      979,
      2796,
      6875,
      13429,
      212525,
      50602,
      26276,
      28284,
      3424,
      19465,
      52397,
      46963,
      31420,
      51399,
      206476,
      92317,
      48851,
      637,
      100820,
      83349,
      10317,
      60227,
      21972,
      6908,
      282439,
      32857,
      224767,
      95629,
      83882,
      42106,
      87338,
      69757,
      29840,
      68709,
      37665,
      45244,
      114577,
      49188,
      175943,
      54009,
      186746,
      106158,
      70168,
      3358,
      234002,
      50555,
      9221,
      129338,
      9562,
      20118,
      32923,
      78479,
      118280,
      65752,
      4977,
      10474,
      102174,
      60947,
      129006,
      10570,
      83451,
      8598,
      8078,
      159367,
      123785,
      80438,
      16742,
      5905,
      5281,
      181513,
      42402,
      6977,
      163136,
      93179,
      42191,
      14968,
      50421,
      112401,
      105440,
      33456,
      57347,
      121611,
      4221,
      94954,
      36517,
      24046,
      27796,
      6255,
      33394,
      72990,
      135408,
      116627,
      1233,
      57874,
      25654,
      95419,
      68156,
      401399,
      313338,
      55208,
      45573,
      93124,
      119251,
      47200,
      38196,
      11909,
      130667,
      45391,
      73904,
      64964,
      167846,
      4137,
      115606,
      52036,
      62214,
      7969,
      160925,
      7187,
      1132,
      134835,
      40309,
      73195,
      64494,
      80472,
      444841,
      61111,
      26500,
      45323,
      40743,
      53625,
      52797,
      22659,
      15631,
      29739,
      36706,
      28841,
      39147,
      102836,
      26794,
      10536,
      14845,
      87305,
      45874,
      12241,
      127587,
      83833,
      57183,
      79722,
      30844,
      41304,
      84655,
      20825,
      92500,
      3722,
      25655,
      27811,
      10157,
      81634,
      31362,
      34088,
      92487,
      70123,
      22190,
      185100,
      72658,
      139035,
      192523,
      88241,
      2078,
      230490,
      44528,
      85638,
      100198,
      22088,
      29982,
      291233,
      241062,
      13865,
      4445,
      137791,
      37835,
      107218,
      31726,
      19718,
      38234,
      72528,
      23046,
      19177,
      66695,
      5109,
      17251,
      28077,
      5617,
      21554,
      47839,
      72425,
      133825,
      1486,
      73065,
      181275,
      141508,
      21768,
      62971,
      63082,
      2512,
      34200,
      9904,
      120309,
      6392,
      91243,
      68416,
      268253,
      41199,
      116757,
      138551,
      185526,
      41246,
      28986,
      4093,
      19057,
      17295,
      4148,
      245766,
      122360,
      35356,
      112075,
      20301,
      75441,
      10998,
      7977,
      19769,
      62922,
      937,
      63547,
      100196,
      26427,
      157820,
      20983,
      236696,
      22935,
      8140,
      90315,
      156004,
      47204,
      140973,
      7726,
      45097,
      52725,
      22636,
      23436,
      257282,
      105247,
      522,
      88389,
      216031,
      202204,
      46812,
      211666,
      19693,
      68828,
      81691,
      45925,
      11256,
      30292,
      372,
      5236,
      167826,
      88328,
      232776,
      151611,
      5360,
      82104,
      18841,
      80393,
      25465,
      18285,
      20320,
      72377,
      31730,
      33160,
      45803,
      38715,
      27705,
      37379,
      24163,
      18360,
      103586,
      4015,
      32305,
      269494,
      91252,
      20080,
      36567,
      54650,
      7797,
      57073,
      12650,
      31164,
      42209,
      6375,
      261663,
      105528,
      81661,
      106002,
      2800,
      5375,
      17247,
      43151,
      4442,
      15727,
      194619,
      100855,
      144898,
      62320,
      78465,
      39929,
      16454,
      1967,
      28311,
      61363,
      17219,
      9395,
      8745,
      121445,
      76939,
      80385,
      162380,
      22009,
      54191,
      44248,
      16299,
      122830,
      48151,
      74429,
      78291,
      64755,
      14238,
      44966,
      2511,
      17712,
      67954,
      93583,
      829,
      105899,
      49935,
      84750,
      11591,
      33185,
      85447,
      42717,
      27409,
      208542,
      28965,
      62052,
      52525,
      5597,
      25694,
      65594,
      16343,
      63224,
      276188,
      12475,
      9331,
      127507,
      38522,
      57287,
      24128,
      133161,
      79723,
      105548,
      133695,
      48917,
      27558,
      43278,
      46520,
      13778,
      141954,
      110785,
      83366,
      17715,
      46317,
      105763,
      66298,
      147013,
      41086,
      94180,
      16478,
      220447,
      44611,
      730,
      19722,
      78975,
      117889,
      125643,
      26254,
      16574,
      18480,
      65006,
      15806,
      38549,
      246418,
      46052,
      36056,
      8440,
      34984,
      30170,
      3163,
      59800,
      4458,
      115442,
      4283,
      41970,
      33507,
      104078,
      1653,
      22,
      121158,
      276486,
      3655,
      6338,
      24048,
      133421,
      23641,
      2161,
      24422,
      36006,
      8086,
      10675,
      181474,
      12307,
      29514,
      59143,
      14729,
      52509,
      87128,
      122470,
      19446,
      80852,
      33314,
      24573,
      119864,
      14237,
      9652,
      57779,
      6612,
      51851,
      15284,
      98871,
      90581,
      124466,
      156831,
      21190,
      22015,
      71380,
      161906,
      87247,
      69201,
      18392,
      17908,
      108470,
      72962,
      40719,
      14338,
      17911,
      95260,
      43339,
      20610,
      78916,
      20710,
      72451,
      11315,
      31448,
      17263,
      58853,
      178878,
      48111,
      116002,
      45497,
      80506,
      82605,
      85880,
      36300,
      121755,
      25215,
      36118,
      301929,
      88728,
      405223,
      276136,
      553,
      34704,
      212438,
      49970,
      78329,
      922,
      20711,
      25036,
      257130,
      38295,
      145369,
      18128,
      15385,
      30829,
      55656,
      48345,
      8012,
      3561,
      28004,
      122041,
      192900,
      58338,
      112508,
      41085,
      29976,
      87040,
      47117,
      23905,
      4336,
      92061,
      138880,
      97407,
      42083,
      172121,
      6256,
      25192,
      172671,
      5,
      93568,
      1420,
      12677,
      31605,
      56743,
      40620,
      6015,
      78415,
      231077,
      31298,
      80026,
      13902,
      19048,
      24924,
      170586,
      32955,
      176119,
      87859,
      36731,
      6773,
      27711,
      24658,
      26475,
      115216,
      133207,
      93250,
      95820,
      88522,
      8317,
      5714,
      124047,
      55219,
      86860,
      19677,
      23961,
      22928,
      162209,
      8904,
      225992,
      359835,
      56084,
      96201,
      29392,
      96558,
      86071,
      93643,
      55114,
      13347,
      8183,
      95129,
      82012,
      2017,
      123336,
      34219,
      115554,
      157159,
      47747,
      101684,
      41008,
      18735,
      193781,
      104151,
      226906,
      7552,
      179874,
      124113,
      31159,
      21162,
      44010,
      14771,
      51268,
      166128,
      31382,
      73124,
      77438,
      92830,
      205709,
      12113,
      1292,
      38937,
      13114,
      1334,
      2118,
      15597,
      69581,
      14449,
      21934,
      76618,
      48728,
      67038,
      14967,
      51495,
      24243,
      87736,
      147249,
      26720,
      11119,
      46063,
      43749,
      5843,
      44147,
      152629,
      133428,
      65703,
      14269,
      45604,
      57982,
      28672,
      55616,
      45957,
      8438,
      95433,
      37698,
      220862,
      132034,
      39456,
      61870,
      4161,
      26501,
      73560,
      56418,
      9845,
      4654,
      20916,
      10456,
      88920,
      119358,
      9015,
      65931,
      96507,
      48029,
      38534,
      21676,
      109081,
      43078,
      34943,
      25089,
      6131,
      28766,
      23665,
      5477,
      10255,
      16695,
      67,
      45778,
      42443,
      42770,
      29534,
      23733,
      100513,
      62617,
      42630,
      48746,
      14191,
      43753,
      50295,
      26007,
      8792,
      57243,
      43119,
      54725,
      164253,
      58250,
      112304,
      131796,
      25165,
      4651,
      3188,
      24831,
      47748,
      3705,
      19540,
      13211,
      102095,
      5593,
      18699,
      23666,
      32005,
      117571,
      33541,
      60584,
      74573,
      86311,
      99443,
      25172,
      27222,
      168938,
      7143,
      11853,
      53560,
      18834,
      19960,
      86522,
      28217,
      53266,
      117700,
      72989,
      34323,
      18721,
      66450,
      34346,
      74056,
      47217,
      202002,
      46269,
      9429,
      68582,
      75458,
      37823,
      82843,
      96652,
      32549,
      145144,
      27958,
      19820,
      158086,
      31955,
      201406,
      135379,
      31207,
      192545,
      12950,
      51704,
      9094,
      248263,
      76147,
      64028,
      110009,
      79407,
      89345,
      99284,
      223492,
      47966,
      26848,
      15359,
      201137,
      2861,
      110507,
      71231,
      72297,
      31851,
      118777,
      71039,
      151051,
      240855,
      16333,
      50766,
      14727,
      7939,
      4149,
      80908,
      418780,
      88378,
      59276,
      1327,
      7284,
      38576,
      79814,
      65820,
      42199,
      84860,
      49574,
      62596,
      12396,
      70598,
      40117,
      8648,
      7994,
      16836,
      7630,
      14047,
      359699,
      106878,
      525,
      29037,
      28064,
      13380,
      11675,
      50669,
      74216,
      103539,
      180314,
      27449,
      56299,
      172344,
      19274,
      7301,
      246099,
      32043,
      19422,
      36506,
      129317,
      6806,
      30140,
      4614,
      46639,
      66926,
      932,
      86600,
      6322,
      27847,
      233103,
      10541,
      39025,
      34887,
      3517,
      12972,
      26220,
      2031,
      66561,
      115015,
      48658,
      47596,
      12714,
      33845,
      3893,
      16165,
      35237,
      89983,
      14769,
      11962,
      147224,
      47018,
      29977,
      27979,
      5552,
      82338,
      86023,
      131368,
      1218,
      24853,
      237840,
      132193,
      15455,
      40873,
      3668,
      65351,
      53388,
      15229,
      59889,
      272245,
      47934,
      11858,
      34347,
      18038,
      90853,
      86981,
      300602,
      19343,
      114181,
      29362,
      84921,
      6095,
      106059,
      79472,
      38015,
      1206,
      48741,
      6208,
      8e4,
      21916,
      17423,
      6002,
      108083,
      24479,
      34931,
      56661,
      9511,
      26995,
      100694,
      163853,
      35997,
      81254,
      58321,
      18919,
      171890,
      86877,
      91341,
      74503,
      70477,
      53412,
      7027,
      59281,
      39892,
      131302,
      5864,
      15947,
      61301,
      67466,
      162369,
      47956,
      27874,
      35624,
      282324,
      21270,
      111847,
      102548,
      41482,
      30955,
      116737,
      28264,
      8592,
      55458,
      22301,
      75090,
      29821,
      30697,
      51709,
      3041,
      19208,
      8038,
      24634,
      30467,
      87509,
      126428,
      19389,
      18814,
      152686,
      20701,
      83474,
      45832,
      80891,
      105808,
      11378,
      153223,
      120770,
      98186,
      150633,
      49838,
      9141,
      12755,
      30962,
      5260,
      74490,
      21256,
      31678,
      65062,
      33326,
      289838,
      187831,
      20595,
      89768,
      2805,
      58535,
      10844,
      70085,
      12090,
      2451,
      138068,
      98544,
      24461,
      4511,
      6754,
      41684,
      28203,
      3383,
      65355,
      82833,
      30161,
      83924,
      234361,
      128424,
      28921,
      222594,
      33975,
      125491,
      34069,
      11508,
      67464,
      144226,
      41850,
      98703,
      34371,
      7901,
      21254,
      38398,
      65651,
      23549,
      53883,
      213340,
      123269,
      12028,
      71764,
      177701,
      28758,
      2623,
      68395,
      11549,
      15232,
      68603,
      9660,
      63116,
      36079,
      57093,
      31198,
      20475,
      48467,
      89984,
      35619,
      186847,
      107469,
      31389,
      43631,
      73867,
      41949,
      68841,
      114250,
      1605,
      30564,
      63403,
      17588,
      27680,
      99533,
      12641,
      70325,
      50428,
      73426,
      78379,
      11855,
      91651,
      72081,
      91720,
      60198,
      15743,
      12065,
      83398,
      140046,
      6761,
      46598,
      45900,
      5068,
      886,
      62448,
      148968,
      37347,
      19405,
      9680,
      15819,
      43496,
      63370,
      75667,
      163700,
      37639,
      3633,
      22774,
      34341,
      183131,
      134335,
      37200,
      23915,
      7054,
      14194,
      12970,
      26438,
      13350,
      285521,
      25594,
      8219,
      104410,
      91039,
      168804,
      138480,
      149734,
      15907,
      33818,
      61132,
      60082,
      4622,
      110187,
      56736,
      13551,
      73571,
      3945,
      73463,
      65498,
      17758,
      263266,
      17593,
      2710,
      27585,
      54469,
      38200,
      45367,
      63754,
      28881,
      3473,
      12791,
      98287,
      31895,
      65787,
      4463,
      94536,
      24951,
      36332,
      59901,
      28803,
      52130,
      86403,
      7668,
      181822,
      74831,
      18977,
      9850,
      177206,
      145485,
      109798,
      7292,
      31421,
      26280,
      77211,
      58511,
      12507,
      127004,
      11113,
      147,
      8729,
      56208,
      43066,
      79926,
      129937,
      31345,
      83947,
      39915,
      46146,
      98763,
      42566,
      1337,
      13192,
      18323,
      105163,
      80570,
      117753,
      16555,
      72883,
      11077,
      159438,
      40764,
      70933,
      83329,
      26066,
      12276,
      72059,
      21655,
      173836,
      126713,
      69454,
      153482,
      91585,
      70644,
      102558,
      110483,
      6764,
      127864,
      190133,
      3961,
      101798,
      20945,
      71138,
      82402,
      90884,
      69669,
      44753,
      923,
      16939,
      59700,
      164258,
      25969,
      27082,
      31399,
      43846,
      6306,
      246093,
      51342,
      6153,
      151581,
      202801,
      182731,
      56475,
      162188,
      89426,
      141356,
      14355,
      121815,
      27536,
      28023,
      65257,
      77523,
      106668,
      127314,
      24947,
      12790,
      38796,
      169698,
      23555,
      10725,
      44573,
      183083,
      42088,
      62716,
      43265,
      105958,
      32050,
      44067,
      50118,
      1668,
      3874,
      6243,
      318411,
      16599,
      1691,
      94999,
      52378,
      28671,
      216728,
      123258,
      2059,
      34969,
      69225,
      5913,
      136280,
      171443,
      141515,
      91662,
      22175,
      135282,
      80020,
      92270,
      1663,
      4808,
      4482,
      3495,
      34691,
      5226,
      109830,
      108512,
      17342,
      107488,
      11606,
      123190,
      100247,
      29666,
      146527,
      113014,
      15794,
      30894,
      13224,
      39585,
      243192,
      22351,
      9903,
      7836,
      47699,
      11078,
      25468,
      122291,
      48821,
      26780,
      122679,
      75521,
      81450,
      630,
      4895,
      92900,
      55074,
      74293,
      17441,
      3563,
      111657,
      103102,
      51613,
      12318,
      52370,
      36191,
      68245,
      34269,
      40445,
      41354,
      122901,
      168604,
      182500,
      62012,
      42557,
      11259,
      24428,
      115113,
      86345,
      12362,
      3909,
      78430,
      86852,
      134602,
      20459,
      47853,
      93879,
      22577,
      7659,
      3688,
      38555,
      13349,
      17381,
      56715,
      91639,
      12493,
      10895,
      92438,
      3142,
      37057,
      28928,
      2004,
      36427,
      32268,
      34222,
      209974,
      10432,
      67436,
      41989,
      173518,
      107930,
      27079,
      62729,
      30908,
      55558,
      5828,
      45031,
      14902,
      53546,
      8204,
      144263,
      60255,
      14520,
      88212,
      86582,
      109589,
      69356,
      8064,
      47449,
      8505,
      66558,
      16886,
      4844,
      52817,
      111260,
      215129,
      12941,
      91118,
      650,
      20770,
      6273,
      73089,
      40618,
      62790,
      2873,
      35002,
      14023,
      97208,
      19386,
      102646,
      36993,
      143736,
      135457,
      35385,
      113601,
      17893,
      32627,
      84439,
      100619,
      56016,
      6581,
      57264,
      172160,
      45452,
      111710,
      203627,
      70131,
      24100,
      322787,
      1996,
      35665,
      70078,
      22358,
      90922,
      83658,
      4097,
      63200,
      58499,
      14542,
      99153,
      52159,
      6615,
      12414,
      63415,
      31986,
      16823,
      1579,
      65405,
      137809,
      8841,
      16898,
      48082,
      259,
      33014,
      42375,
      12260,
      179850,
      73667,
      91389,
      98882,
      29532,
      17311,
      326251,
      41092,
      5928,
      20742,
      44964,
      48019,
      43505,
      9317,
      49265,
      6643,
      192712,
      48424,
      163487,
      19861,
      20113,
      70848,
      31928,
      105333,
      23685,
      78563,
      14638,
      54755,
      7158,
      24142,
      44018,
      20774,
      125255,
      20331,
      24280,
      10163,
      1285,
      2336,
      39851,
      4299,
      117269,
      46714,
      63816,
      87779,
      159624,
      11731,
      9971,
      990,
      137317,
      108831,
      50994,
      74554,
      162680,
      23640,
      131597,
      146962,
      170620,
      34829,
      91205,
      21184,
      1913,
      63616,
      18427,
      93136,
      156592,
      17519,
      67565,
      115882,
      138220,
      78622,
      88535,
      18115,
      2711,
      33554,
      109492,
      54298,
      971,
      24914,
      25863,
      36363,
      45715,
      27099,
      194995,
      14299,
      178181,
      111488,
      72395,
      322385,
      157719,
      130787,
      11897,
      81843,
      83999,
      11369,
      49280,
      118604,
      40922,
      61332,
      110343,
      53407,
      75639,
      40582,
      300440,
      54722,
      25637,
      13694,
      48248,
      48278,
      194521,
      56203,
      52779,
      48783,
      72627,
      10953,
      376,
      16733,
      280238,
      26351,
      230789,
      15132,
      25168,
      137270,
      3588,
      63704,
      73376,
      94031,
      74284,
      19443,
      159557,
      9697,
      39901,
      13351,
      119050,
      15406,
      146455,
      3460,
      29556,
      75195,
      37673,
      102524,
      92329,
      47289,
      98413,
      15311,
      100684,
      56345,
      7116,
      95480,
      11590,
      7200,
      167,
      23610,
      58426,
      17730,
      136656,
      27944,
      53151,
      2701,
      8824,
      103124,
      3017,
      90744,
      113588,
      53216,
      79736,
      65940,
      26931,
      498,
      29568,
      80540,
      143543,
      21292,
      1740,
      59268,
      16561,
      180816,
      42323,
      50174,
      40890,
      52866,
      10703,
      57169,
      4700,
      17191,
      4424,
      93511,
      49698,
      166650,
      26972,
      48631,
      165169,
      82879,
      69326,
      202970,
      4007,
      2376,
      231325,
      139592,
      22119,
      62851,
      37504,
      68816,
      58345,
      67398,
      186643,
      43331,
      277416,
      53749,
      15746,
      23102,
      17432,
      4793,
      151138,
      48822,
      54265,
      48203,
      198688,
      14305,
      54287,
      2291,
      18018,
      113378,
      123260,
      7180,
      97549,
      87027,
      120085,
      2920,
      76080,
      8190,
      102005,
      5641,
      64580,
      14955,
      59802,
      54028,
      58884,
      19367,
      81779,
      412567,
      85957,
      97053,
      103637,
      78871,
      29364,
      27637,
      141728,
      4767,
      30686,
      112738,
      130146,
      42745,
      12730,
      105040,
      14844,
      232,
      210944,
      36581,
      152317,
      135543,
      29744,
      3129,
      55647,
      58149,
      46319,
      27265,
      17499,
      28005,
      59948,
      7170,
      34138,
      5702,
      293047,
      110892,
      408,
      91760,
      218674,
      18469,
      46095,
      81403,
      14389,
      4610,
      35672,
      73060,
      11006,
      74848,
      104820,
      118143,
      190357,
      20043,
      105358,
      141735,
      5115,
      27093,
      45924,
      123073,
      52599,
      29433,
      9616,
      238350,
      78610,
      24851,
      58858,
      26769,
      31969,
      24613,
      18294,
      4982,
      32735,
      39639,
      143563,
      112073,
      202205,
      12567,
      4873,
      88601,
      44897,
      81503,
      101648,
      81362,
      34662,
      85277,
      17574,
      48173,
      21435,
      221188,
      40215,
      39576,
      80786,
      26544,
      64668,
      81841,
      10731,
      37733,
      247986,
      149188,
      127703,
      495,
      18382,
      54388,
      72446,
      43071,
      30974,
      198723,
      89608,
      41360,
      190,
      33045,
      8386,
      31658,
      19992,
      237838,
      119015,
      137622,
      50890,
      100913,
      6460,
      116233,
      267230,
      26621,
      104129,
      65114,
      14190,
      41542,
      14888,
      85962,
      23342,
      23041,
      26453,
      43725,
      71809,
      45186,
      4770,
      46452,
      53894,
      56616,
      221286,
      18973,
      9038,
      109299,
      55365,
      19366,
      26863,
      18808,
      60909,
      69353,
      41738,
      83463,
      12100,
      68561,
      72860,
      3980,
      13796,
      49340,
      12332,
      31311,
      27418,
      4255,
      53430,
      18976,
      45523,
      510,
      14224,
      30477,
      26581,
      4530,
      3651,
      101663,
      139840,
      22709,
      150861,
      31996,
      63923,
      120623,
      262522,
      3076,
      10528,
      2929,
      14672,
      130238,
      18087,
      9816,
      121894,
      100308,
      25085,
      55111,
      14565,
      18952,
      53293,
      2042,
      369988,
      23674,
      61789,
      133529,
      28783,
      108293,
      35477,
      47119,
      36448,
      71049,
      40015,
      33055,
      78598,
      198442,
      1833,
      159937,
      40654,
      77444,
      189245,
      113153,
      8621,
      18599,
      38553,
      35223,
      166072,
      2375,
      11659,
      21786,
      89523,
      6032,
      12116,
      63046,
      159398,
      18454,
      3678,
      32521,
      47626,
      11411,
      103527,
      38896,
      42946,
      15696,
      26370,
      10185,
      8413,
      37080,
      165583,
      4331,
      63555,
      14907,
      72220,
      50056,
      6623,
      62236,
      36565,
      49783,
      10049,
      17503,
      100581,
      55951,
      146244,
      24724,
      9626,
      17969,
      25524,
      109300,
      173965,
      99994,
      101056,
      46459,
      43647,
      53737,
      277968,
      8347,
      123521,
      74858,
      33829,
      44762,
      77574,
      877,
      81377,
      222525,
      123532,
      30602,
      43881,
      53145,
      2973,
      16284,
      81940,
      61281,
      127044,
      63620,
      9875,
      14756,
      114829,
      19032,
      9202,
      52759,
      119141,
      23928,
      120551,
      19607,
      3599,
      33401,
      76821,
      73233,
      117430,
      39968,
      36539,
      7071,
      5446,
      121735,
      194059,
      15206,
      45283,
      6706,
      15603,
      65615,
      1207,
      165723,
      92275,
      34773,
      104447,
      8396,
      32353,
      205240,
      164323,
      13600,
      60555,
      79205,
      25532,
      22907,
      33410,
      57480,
      107111,
      69630,
      32137,
      47832,
      70913,
      33161,
      20321,
      2371,
      117348,
      10714,
      86246,
      1625,
      11763,
      17900,
      268,
      78457,
      99175,
      97940,
      101092,
      86660,
      32221,
      14041,
      128504,
      125080,
      53744,
      124263,
      31017,
      13897,
      403,
      31859,
      21964,
      5633,
      111630,
      5547,
      77329,
      17961,
      18241,
      84995,
      25984,
      12983,
      67491,
      62168,
      47262,
      5241,
      297,
      51191,
      7351,
      8967,
      147212,
      82060,
      16821,
      782,
      11033,
      82431,
      62957,
      5026,
      43459,
      77963,
      203477,
      53528,
      6247,
      191852,
      87774,
      74164,
      215654,
      13467,
      1522,
      219964,
      28589,
      244104,
      16242,
      117821,
      67725,
      72570,
      156792,
      17186,
      15979,
      26990,
      44128,
      193014,
      35276,
      57125,
      16212,
      166451,
      68017,
      6905,
      77608,
      16364,
      53777,
      75921,
      76426,
      37975,
      26203,
      269296,
      64099,
      84122,
      12077,
      38533,
      830,
      4407,
      20139,
      963,
      43028,
      38902,
      42911,
      37503,
      83343,
      85045,
      16979,
      1165,
      60835,
      137387,
      58380,
      86990,
      110066,
      134540,
      56331,
      193845,
      81238,
      17922,
      163093,
      38744,
      110641,
      12502,
      56404,
      34862,
      26865,
      125964,
      12965,
      111648,
      25547,
      7771,
      27196,
      136980,
      9555,
      29551,
      107158,
      57885,
      18831,
      37705,
      35505,
      101742,
      13970,
      102109,
      62548,
      124657,
      23328,
      11124,
      89592,
      146376,
      248050,
      6241,
      22033,
      18337,
      80685,
      29898,
      11908,
      216623,
      67721,
      106162,
      146610,
      21377,
      15085,
      91552,
      42041,
      62560,
      122532,
      125336,
      102365,
      121537,
      142559,
      29693,
      223919,
      11515,
      110495,
      18776,
      22494,
      5895,
      185059,
      103592,
      229351,
      51220,
      100102,
      37027,
      257855,
      29359,
      54123,
      36066,
      106493,
      12244,
      79258,
      32002,
      432,
      56205,
      94836,
      90182,
      6726,
      14762,
      29391,
      48938,
      26864,
      38083,
      60364,
      3310,
      60192,
      14766,
      205567,
      57504,
      110760,
      22649,
      24666,
      46333,
      21517,
      3430,
      13135,
      28873,
      27052,
      158809,
      11597,
      20529,
      6695,
      23138,
      22960,
      37137,
      45574,
      6545,
      305877,
      43423,
      26153,
      24769,
      59844,
      14501,
      10430,
      134352,
      56169,
      13213,
      103432,
      49523,
      35181,
      13435,
      12408,
      129475,
      64620,
      230854,
      77390,
      51990,
      15653,
      83248,
      33466,
      44571,
      117828,
      51481,
      2187,
      10559,
      68019,
      18021,
      54895,
      48247,
      18354,
      33737,
      4554,
      108595,
      37288,
      39767,
      116707,
      9175,
      3726,
      108877,
      21616,
      83684,
      49862,
      1938,
      8543,
      276466,
      20134,
      108498,
      48770,
      102254,
      31914,
      131520,
      185291,
      100559,
      51890,
      209,
      19526,
      76471,
      50544,
      71814,
      99351,
      8172,
      198526,
      28816,
      20419,
      9109,
      98389,
      136777,
      76479,
      75596,
      30635,
      165417,
      48216,
      120220,
      25955,
      211071,
      39314,
      24308,
      32164,
      2559,
      146280,
      43403,
      9233,
      17947,
      90585,
      1786,
      86920,
      125662,
      2457,
      64741,
      32152,
      32918,
      122882,
      78538,
      44001,
      31723,
      56426,
      23375,
      103172,
      88177,
      145697,
      52506,
      49319,
      68016,
      31664,
      41488,
      18486,
      110400,
      7030,
      28241,
      986,
      109199,
      19900,
      42147,
      56864,
      65287,
      49183,
      7858,
      24e3,
      30453,
      840,
      16673,
      25907,
      68916,
      89927,
      6309,
      158335,
      36407,
      199737,
      130464,
      13137,
      59603,
      201778,
      195292,
      21015,
      42466,
      179062,
      172561,
      89492,
      11075,
      180407,
      31868,
      72493,
      20998,
      60217,
      9865,
      19530,
      39274,
      130266,
      54539,
      21623,
      12535,
      13505,
      40641,
      73375,
      4087,
      85633,
      2153,
      3117,
      70680,
      55788,
      92096,
      47509,
      98493,
      37490,
      271936,
      151475,
      3032,
      16171,
      96642,
      34106,
      78425,
      125761,
      19591,
      3366,
      19316,
      54508,
      24183,
      50786,
      194248,
      91528,
      33253,
      34622,
      108355,
      41741,
      705,
      3814,
      3883,
      108929,
      13203,
      67831,
      10142,
      59754,
      68208,
      29128,
      84820,
      56880,
      38794,
      24972,
      48571,
      40821,
      40476,
      18137,
      164254,
      24064,
      236309,
      79181,
      11282,
      395,
      39169,
      2013,
      51587,
      28551,
      9645,
      701,
      109513,
      115899,
      113566,
      12762,
      62045,
      58322,
      103726,
      41343,
      40866,
      244102,
      143816,
      2490,
      70346,
      40973,
      52618,
      15412,
      30720,
      104315,
      38917,
      42027,
      93676,
      17513,
      107418,
      20706,
      123890,
      13399,
      97727,
      24044,
      87962,
      65606,
      44250,
      98044,
      65276,
      74790,
      101473,
      19350,
      91570,
      1326,
      87790,
      172042,
      7577,
      100813,
      86896,
      85891,
      41512,
      108130,
      27794,
      14875,
      71431,
      12835,
      156250,
      58135,
      3759,
      22476,
      42176,
      115873,
      34686,
      56523,
      73643,
      108505,
      51491,
      20838,
      12721,
      32863,
      45700,
      29496,
      13700,
      34294,
      55360,
      29206,
      155942,
      123812,
      7706,
      163234,
      203,
      132720,
      49358,
      144431,
      8130,
      175788,
      35818,
      3270,
      76832,
      25710,
      54095,
      97274,
      28779,
      94621,
      74396,
      19092,
      128242,
      58067,
      20885,
      14670,
      93255,
      15107,
      63291,
      23654,
      126900,
      129421,
      59294,
      262659,
      9798,
      3251,
      67344,
      28600,
      44629,
      50672,
      29072,
      26999,
      31526,
      23183,
      49175,
      165843,
      175455,
      17282,
      175411,
      32022,
      45989,
      30298,
      90690,
      78118,
      83156,
      23749,
      35636,
      31317,
      7069,
      80381,
      94561,
      133756,
      14960,
      97404,
      6138,
      41065,
      78041,
      32843,
      16601,
      34123,
      9559,
      146529,
      123377,
      96395,
      54441,
      42012,
      84257,
      123541,
      10745,
      22139,
      106459,
      11720,
      150883,
      172651,
      154996,
      110538,
      4728,
      53447,
      25704,
      2009,
      71152,
      119354,
      21166,
      66604,
      1429,
      216162,
      8637,
      122250,
      63520,
      27180,
      29172,
      36124,
      276428,
      107787,
      77184,
      4680,
      14952,
      104903,
      24418,
      14793,
      51561,
      52931,
      8371,
      26342,
      48526,
      7118,
      92066,
      67280,
      40653,
      8847,
      34597,
      105438,
      14198,
      50163,
      61188,
      146286,
      50315,
      41205,
      170829,
      161496,
      585,
      197359,
      95056,
      1687,
      365794,
      91349,
      48507,
      5804,
      49263,
      5146,
      104902,
      96365,
      117343,
      132222,
      46084,
      96919,
      16875,
      8073,
      262381,
      79982,
      52663,
      13928,
      16056,
      153908,
      15145,
      109256,
      132308,
      18763,
      24904,
      167644,
      13618,
      40750,
      18686,
      147124,
      114709,
      150038,
      52849,
      2938,
      12568,
      48617,
      8778,
      5459,
      44202,
      44591,
      74914,
      17183,
      248689,
      13878,
      7822,
      80060,
      23116,
      194037,
      18487,
      2067,
      7798,
      43077,
      33678,
      244028,
      31320,
      74273,
      2794,
      19466,
      8218,
      36280,
      183997,
      48124,
      19416,
      29656,
      19280,
      98734,
      7715,
      18311,
      30701,
      133602,
      150307,
      126956,
      7378,
      2933,
      79903,
      13178,
      12593,
      86571,
      26604,
      92446,
      13574,
      44205,
      65699,
      427599,
      21118,
      8245,
      14407,
      27877,
      47936,
      33542,
      7916,
      26460,
      117762,
      21596,
      37818,
      2249,
      127359,
      209394,
      60044,
      47677,
      308089,
      36791,
      154971,
      31417,
      6998,
      150042,
      174360,
      12255,
      43009,
      29335,
      48739,
      3912,
      101398,
      53340,
      2580,
      146939,
      151295,
      45360,
      125275,
      15273,
      45383,
      27456,
      48761,
      23314,
      8750,
      60801,
      85823,
      104759,
      27894,
      123685,
      66968,
      39480,
      26917,
      55290,
      83305,
      2696,
      98390,
      57569,
      145853,
      340733,
      4919,
      20024,
      52268,
      30884,
      7413,
      203685,
      70989,
      112855,
      4129,
      50536,
      349518,
      68205,
      332641,
      159581,
      135361,
      236026,
      37563,
      176404,
      64899,
      6578,
      122033,
      63871,
      1850,
      85234,
      82089,
      66124,
      74145,
      121098,
      107351,
      12687,
      36881,
      117334,
      13136,
      14698,
      85933,
      93866,
      18047,
      32620,
      310,
      15094,
      46e3,
      88451,
      23632,
      36645,
      27940,
      87618,
      80520,
      58892,
      20976,
      27702,
      140090,
      96075,
      67841,
      103292,
      238964,
      87778,
      107338,
      17019,
      83427,
      67522,
      7302,
      8261,
      47570,
      116787,
      8730,
      80484,
      61772,
      174422,
      56005,
      131193,
      52875,
      14588,
      28471,
      59817,
      9586,
      15720,
      158155,
      51307,
      109734,
      15196,
      11025,
      59331,
      3884,
      52626,
      102602,
      84797,
      25158,
      27314,
      4437,
      20488,
      76214,
      189248,
      35023,
      114952,
      157376,
      2827,
      62439,
      102878,
      129749,
      36405,
      10329,
      109339,
      108633,
      36662,
      1254,
      13267,
      5470,
      87105,
      58004,
      15397,
      10434,
      159667,
      21864,
      52022,
      179464,
      3013,
      32147,
      31496,
      116832,
      18494,
      105502,
      129227,
      107267,
      50033,
      13481,
      9954,
      24267,
      22141,
      16257,
      116154,
      36185,
      950,
      115685,
      11305,
      176708,
      2048,
      178671,
      112573,
      287867,
      162328,
      497663,
      95170,
      50979,
      193861,
      50987,
      30368,
      136257,
      31830,
      46549,
      15119,
      169876,
      23788,
      17462,
      249887,
      57377,
      1949,
      35448,
      14791,
      43769,
      210091,
      3783,
      34612,
      282103,
      88380,
      245190,
      5457,
      20491,
      98908,
      11402,
      86899,
      117916,
      16028,
      162584,
      60644,
      320177,
      156096,
      31065,
      55876,
      22e3,
      77655,
      9992,
      23397,
      13757,
      317623,
      63978,
      215255,
      2443,
      17648,
      93231,
      27388,
      104529,
      93807,
      55505,
      140477,
      12046,
      112040,
      70887,
      40152,
      94365,
      112353,
      25063,
      114679,
      266061,
      71248,
      119555,
      15589,
      2244,
      617,
      14129,
      211431,
      70110,
      100652,
      7777,
      4383,
      85911,
      89221,
      21010,
      120615,
      58357,
      86405,
      37554,
      41647,
      18,
      15143,
      69662,
      60491,
      14714,
      186134,
      148344,
      42347,
      5410,
      168175,
      44535,
      42449,
      343894,
      129417,
      99682,
      20659,
      27272,
      140483,
      63455,
      222159,
      17536,
      13722,
      42637,
      62324,
      11976,
      114691,
      148109,
      2283,
      32057,
      182393,
      4295,
      147364,
      33705,
      2075,
      44303,
      30274,
      28331,
      63740,
      69740,
      29148,
      10346,
      44862,
      33716,
      73937,
      153333,
      12930,
      38784,
      247159,
      2515,
      41053,
      20256,
      83368,
      256189,
      54639,
      115240,
      5096,
      24661,
      175419,
      153552,
      26516,
      141,
      138176,
      63885,
      34115,
      47222,
      55709,
      2765,
      28479,
      38875,
      236608,
      12229,
      22921,
      77291,
      54426,
      45388,
      2860,
      57787,
      114579,
      295139,
      105782,
      17826,
      71066,
      19119,
      54364,
      69385,
      16568,
      12323,
      28057,
      33346,
      34919,
      124763,
      155533,
      101386,
      31644,
      8627,
      49001,
      303600,
      29868,
      63213,
      9103,
      77280,
      71333,
      9696,
      138789,
      37059,
      24823,
      5057,
      21352,
      32368,
      114208,
      56803,
      19424,
      10445,
      58514,
      8661,
      209508,
      26187,
      171838,
      10460,
      63454,
      14016,
      122504,
      41328,
      21329,
      46618,
      32493,
      38225,
      7855,
      31763,
      7945,
      29876,
      8734,
      6438,
      24205,
      97490,
      139977,
      130740,
      47323,
      33195,
      85390,
      57194,
      13813,
      60600,
      21313,
      96251,
      7699,
      27584,
      170521,
      139271,
      1363,
      4402,
      336738,
      129223,
      84983,
      69150,
      13147,
      3590,
      163929,
      207225,
      155260,
      55916,
      20288,
      4503,
      8398,
      98490,
      11773,
      27512,
      37113,
      84976,
      86558,
      28365,
      11756,
      116005,
      182148,
      13733,
      115313,
      47644,
      67208,
      85069,
      9347,
      14995,
      226141,
      14704,
      101835,
      41159,
      35314,
      13113,
      63526,
      214039,
      29978,
      50446,
      83339,
      17440,
      129441,
      72522,
      118641,
      97816,
      24907,
      73844,
      15717,
      118884,
      167255,
      96509,
      162793,
      30847,
      36849,
      51297,
      78974,
      77793,
      10427,
      1873,
      2972,
      9999,
      35074,
      28190,
      64297,
      146836,
      46298,
      60038,
      163007,
      108919,
      61219,
      2403,
      75022,
      127339,
      4233,
      110389,
      69022,
      9833,
      128097,
      88016,
      79390,
      222936,
      22570,
      94657,
      28462,
      56956,
      38803,
      81536,
      30474,
      152794,
      19566,
      16481,
      147408,
      74574,
      81895,
      20731,
      1918,
      1366,
      76367,
      187321,
      54494,
      24366,
      21690,
      61696,
      33283,
      107477,
      77499,
      31112,
      414383,
      74362,
      18463,
      218441,
      120929,
      59848,
      258629,
      201924,
      69269,
      454,
      19989,
      13054,
      59894,
      3623,
      58908,
      20681,
      35723,
      78523,
      102680,
      38988,
      184112,
      108087,
      50944,
      132704,
      52966,
      21699,
      18860,
      96349,
      201411,
      82697,
      85395,
      95658,
      5093,
      6427,
      177894,
      44191,
      32755,
      26961,
      155739,
      6249,
      31310,
      81030,
      26574,
      84311,
      120155,
      86730,
      113535,
      7424,
      48888,
      13516,
      45747,
      98098,
      20077,
      183995,
      81945,
      43210,
      26704,
      40420,
      75831,
      45648,
      11180,
      6855,
      57927,
      65528,
      124096,
      34851,
      2598,
      156633,
      107572,
      127352,
      38169,
      123845,
      60142,
      62722,
      105584,
      232364,
      23211,
      68120,
      1601,
      22169,
      89299,
      747,
      258039,
      80572,
      7258,
      152249,
      11862,
      101204,
      8834,
      121434,
      33761,
      19175,
      133142,
      46343,
      40178,
      48723,
      3589,
      41977,
      30210,
      38868,
      62257,
      10087,
      82658,
      87827,
      90646,
      16415,
      47552,
      351723,
      28298,
      72225,
      91146,
      272760,
      1701,
      11295,
      1652,
      109651,
      300747,
      51863,
      198800,
      29446,
      11794,
      32345,
      37538,
      22356,
      33102,
      37590,
      113544,
      37970,
      11478,
      179743,
      25454,
      103417,
      59905,
      221970,
      105196,
      145604,
      7817,
      164809,
      102360,
      16974,
      75840,
      255333,
      56902,
      6659,
      1954,
      645,
      59400,
      67769,
      7689,
      18675,
      5215,
      13793,
      20536,
      27852,
      3387,
      29523,
      259718,
      16860,
      94625,
      43143,
      29245,
      15848,
      233581,
      22685,
      63631,
      78557,
      22836,
      133302,
      84513,
      1348,
      51826,
      47129,
      98836,
      58284,
      1830,
      1749,
      94642,
      10933,
      6145,
      12506,
      10975,
      13879,
      103781,
      144434,
      10268,
      28409,
      32346,
      52968,
      121567,
      107374,
      77268,
      23686,
      35097,
      10501,
      155275,
      15303,
      47136,
      21102,
      168741,
      55332,
      90385,
      15996,
      84817,
      681,
      137803,
      25054,
      142275,
      6163,
      38175,
      8056,
      124296,
      240642,
      65621,
      4934,
      178205,
      16101,
      62803,
      60964,
      18230,
      100622,
      76465,
      44689,
      14545,
      9543,
      47514,
      16852,
      93380,
      28048,
      12047,
      107106,
      37575,
      101485,
      77047,
      57326,
      34819,
      96137,
      76916,
      6469,
      46264,
      115983,
      75768,
      87668,
      69942,
      13027,
      165,
      8373,
      114231,
      26434,
      52844,
      42799,
      182044,
      23580,
      146254,
      38081,
      43236,
      33883,
      146220,
      382894,
      14606,
      46035,
      36481,
      166621,
      35417,
      95382,
      2957,
      59384,
      60428,
      36358,
      66343,
      75378,
      22267,
      22950,
      83528,
      17577,
      56474,
      25285,
      4619,
      179691,
      75355,
      95836,
      53295,
      34588,
      171410,
      4487,
      14679,
      84208,
      44015,
      18562,
      109133,
      54101,
      11531,
      86052,
      174479,
      303157,
      28095,
      9953,
      35642,
      14564,
      39802,
      16145,
      77606,
      117406,
      53038,
      121117,
      53624,
      22062,
      1212,
      7632,
      127157,
      237292,
      189087,
      10478,
      127345,
      102515,
      181997,
      86752,
      87623,
      10966,
      121602,
      68783,
      68681,
      83042,
      114380,
      138349,
      191305,
      67176,
      50085,
      39016,
      1427,
      42384,
      1412,
      67118,
      122616,
      72389,
      25260,
      2237,
      13576,
      137346,
      19938,
      20304,
      2191,
      68759,
      5373,
      61364,
      238507,
      75814,
      23931,
      69565,
      38993,
      131741,
      38364,
      12528,
      87762,
      5679,
      129853,
      5310,
      186831,
      32653,
      90338,
      260176,
      389531,
      108118,
      26843,
      43985,
      50175,
      30563,
      25106,
      56965,
      18130,
      140428,
      4542,
      165503,
      117991,
      24219,
      229605,
      1819,
      129663,
      1240,
      3797,
      76093,
      18398,
      71339,
      51919,
      93043,
      27175,
      47060,
      216257,
      6483,
      35051,
      1217,
      16512,
      80798,
      129064,
      13225,
      69339,
      8548,
      237079,
      72298,
      2575,
      34280,
      51379,
      117910,
      55671,
      53345,
      247552,
      29486,
      39328,
      140821,
      34681,
      57045,
      60177,
      5004,
      90269,
      78522,
      2479,
      322607,
      48474,
      61296,
      13057,
      31558,
      4678,
      59271,
      6699,
      27044,
      31988,
      35944,
      12503,
      83480,
      4389,
      136508,
      3781,
      114121,
      70279,
      4488,
      155829,
      42214,
      2898,
      68191,
      75695,
      305850,
      45041,
      74344,
      106509,
      30087,
      17429,
      93292,
      12477,
      290,
      23080,
      114802,
      35714,
      18751,
      26554,
      105424,
      17775,
      2144,
      2412,
      100610,
      65192,
      113975,
      52975,
      180272,
      135050,
      129815,
      76238,
      106483,
      21440,
      63186,
      4260,
      46189,
      9711,
      28249,
      4169,
      23429,
      23390,
      8324,
      141585,
      63809,
      67668,
      38457,
      38063,
      39226,
      59972,
      1189,
      203916,
      62368,
      14403,
      16949,
      61767,
      85801,
      1739,
      40147,
      35049,
      76757,
      33124,
      62102,
      15780,
      103593,
      103009,
      53484,
      22952,
      67973,
      114645,
      6566,
      5245,
      50462,
      7601,
      8288,
      3513,
      194571,
      80276,
      1908,
      54592,
      5124,
      58571,
      2513,
      6800,
      273997,
      193904,
      1119,
      17991,
      117245,
      2508,
      129156,
      82366,
      26278,
      71465,
      63341,
      56943,
      39662,
      106116,
      94966,
      156875,
      9736,
      2204,
      122308,
      94418,
      27134,
      1280,
      24539,
      49022,
      45314,
      3764,
      50904,
      46424,
      30699,
      28087,
      293839,
      9400,
      33646,
      40165,
      822,
      147499,
      50263,
      116179,
      29085,
      11863,
      31314,
      5578,
      17797,
      5104,
      12454,
      1604,
      15342,
      219206,
      10232,
      67800,
      94261,
      25872,
      13565,
      90339,
      78971,
      75377,
      26649,
      41184,
      47695,
      11514,
      35369,
      20767,
      14227,
      41953,
      309396,
      148270,
      147938,
      33074,
      14453,
      27499,
      109019,
      39018,
      25738,
      240196,
      158931,
      52820,
      8612,
      95853,
      21524,
      137010,
      84901,
      70869,
      70021,
      116794,
      48404,
      38771,
      6732,
      1070,
      70990,
      187297,
      49140,
      5238,
      576,
      3564,
      253975,
      16027,
      16483,
      2811,
      37775,
      19034,
      25259,
      4053,
      2e3,
      70083,
      95774,
      19713,
      33431,
      92703,
      91314,
      42381,
      288770,
      48194,
      95985,
      3991,
      77418,
      13406,
      241328,
      245086,
      56533,
      35275,
      62725,
      9246,
      51924,
      70181,
      95331,
      16163,
      31410,
      79016,
      39312,
      120878,
      119371,
      275987,
      80124,
      27712,
      9186,
      220,
      23598,
      146167,
      85209,
      68238,
      282190,
      57048,
      31273,
      30555,
      80913,
      17594,
      75779,
      59160,
      135002,
      101219,
      189377,
      29225,
      96735,
      60126,
      62522,
      104e3,
      27620,
      86814,
      17240,
      147533,
      11001,
      5425,
      43682,
      410,
      49460,
      87270,
      69480,
      46315,
      59448,
      1816,
      76201,
      9431,
      11788,
      87960,
      29063,
      65539,
      47347,
      11678,
      33846,
      7008,
      196704,
      9895,
      6753,
      8633,
      120892,
      59970,
      572824,
      115934,
      6646,
      202559,
      892,
      48351,
      37611,
      251282,
      57823,
      67263,
      57750,
      26527,
      34485,
      90747,
      7685,
      88370,
      6144,
      64182,
      1709,
      41969,
      21458,
      62327,
      181657,
      49247,
      225330,
      122600,
      114574,
      107124,
      85361,
      111833,
      63243,
      71420,
      15655,
      191178,
      72430,
      18063,
      51425,
      54002,
      12364,
      53225,
      86557,
      18193,
      97580,
      41232,
      138398,
      67821,
      128724,
      8944,
      233212,
      101353,
      52099,
      42127,
      14006,
      120107,
      32789,
      32132,
      3498,
      18123,
      33758,
      56058,
      5779,
      128760,
      59888,
      98869,
      18445,
      84702,
      51911,
      13234,
      218379,
      20093,
      39031,
      8074,
      70195,
      20708,
      23462,
      24355,
      131384,
      60189,
      26390,
      10403,
      41060,
      7140,
      10781,
      49410,
      42261,
      87202,
      82566,
      41663,
      43105,
      60276,
      2768,
      5733,
      74176,
      28329,
      2297,
      145430,
      131632,
      83615,
      122915,
      105441,
      655,
      224102,
      5284,
      136426,
      67763,
      16294,
      188511,
      32538,
      61049,
      27893,
      3394,
      13951,
      159099,
      28542,
      17930,
      145360,
      9492,
      190122,
      32285,
      78855,
      26440,
      13570,
      58648,
      73908,
      4239,
      124561,
      2444,
      74172,
      53131,
      11468,
      10794,
      73566,
      11623,
      35343,
      64710,
      30481,
      4163,
      10328,
      38309,
      29901,
      10538,
      154377,
      76132,
      92405,
      24839,
      11679,
      3465,
      13449,
      11637,
      7824,
      2337,
      57754,
      1260,
      14458,
      41118,
      19878,
      38661,
      13416,
      159180,
      37074,
      163164,
      54137,
      28627,
      52134,
      184900,
      8520,
      40385,
      29546,
      30502,
      22386,
      66527,
      107458,
      6850,
      24022,
      47983,
      30603,
      35083,
      8934,
      304066,
      39500,
      9,
      28261,
      33026,
      77251,
      9374,
      44833,
      116312,
      34990,
      29236,
      63563,
      125639,
      135405,
      165398,
      159055,
      55690,
      88141,
      69643,
      236964,
      31983,
      25572,
      20436,
      36746,
      60896,
      31850,
      16179,
      11828,
      5888,
      3043,
      66368,
      9750,
      31167,
      7915,
      53111,
      36430,
      1333,
      64344,
      93659,
      20061,
      60596,
      180191,
      51630,
      6792,
      30244,
      43509,
      101058,
      22409,
      420,
      44210,
      109783,
      43223,
      27030,
      72477,
      72831,
      32679,
      29235,
      7675,
      47556,
      12258,
      39907,
      149412,
      84926,
      118247,
      24692,
      71717,
      105038,
      86009,
      45941,
      41189,
      89453,
      29856,
      52543,
      30627,
      226798,
      67303,
      59230,
      67415,
      34408,
      1367,
      99685,
      16867,
      128419,
      52147,
      4111,
      125381,
      117881,
      16173,
      44093,
      102224,
      31575,
      23234,
      24870,
      83790,
      127407,
      239098,
      3200,
      994,
      1255,
      100903,
      242275,
      117266,
      55116,
      38205,
      16140,
      29662,
      11307,
      40414,
      208793,
      123355,
      56470,
      4862,
      75600,
      30119,
      58218,
      70828,
      24075,
      26974,
      7802,
      192353,
      4851,
      5475,
      78720,
      66596,
      3409,
      28573,
      64396,
      30381,
      30690,
      59859,
      88256,
      5406,
      99945,
      103064,
      34463,
      37727,
      24238,
      86643,
      60088,
      4057,
      23741,
      5967,
      162904,
      38240,
      28356,
      93858,
      25510,
      122879,
      6897,
      3278,
      7057,
      11971,
      4400,
      35461,
      211413,
      21395,
      59615,
      39471,
      87233,
      55795,
      128426,
      3051,
      22470,
      41950,
      14705,
      3974,
      180108,
      80476,
      78442,
      204996,
      91987,
      15634,
      67610,
      139015,
      142373,
      35611,
      51134,
      10387,
      4353,
      153456,
      57749,
      181039,
      14183,
      68447,
      151532,
      21107,
      36452,
      20551,
      3186,
      46247,
      46383,
      129666,
      88736,
      140662,
      146243,
      2066,
      8360,
      7978,
      64818,
      106963,
      17896,
      47801,
      10723,
      114821,
      223295,
      74192,
      3293,
      3393,
      16987,
      74064,
      11277,
      91622,
      4270,
      29828,
      27951,
      387869,
      103235,
      1374,
      61988,
      120083,
      477,
      145892,
      128378,
      11779,
      211263,
      61354,
      18221,
      17869,
      46530,
      83061,
      108538,
      157981,
      90608,
      67199,
      95080,
      49064,
      195814,
      12302,
      66307,
      10348,
      231346,
      160732,
      112859,
      63633,
      146558,
      21271,
      31037,
      198802,
      47622,
      12862,
      95710,
      3910,
      77850,
      73961,
      85585,
      34752,
      61e3,
      4082,
      24595,
      103679,
      71107,
      8208,
      79568,
      150019,
      16615,
      24961,
      139857,
      32664,
      197366,
      4559,
      54735,
      32696,
      4126,
      162019,
      75698,
      13916,
      70108,
      159638,
      19834,
      9349,
      24675,
      175560,
      49643,
      18206,
      52459,
      27992,
      10809,
      88865,
      401975,
      133172,
      29e3,
      34558,
      30915,
      3658,
      25834,
      42430,
      36562,
      125265,
      18182,
      10155,
      40149,
      97082,
      208980,
      19575,
      60853,
      90529,
      66545,
      9600,
      789,
      46420,
      2317,
      88593,
      55595,
      98980,
      115302,
      5742,
      169155,
      1073,
      177901,
      3472,
      11189,
      63711,
      78643,
      65472,
      50459,
      127979,
      93,
      42202,
      67053,
      21720,
      157650,
      11145,
      141378,
      42033,
      22824,
      85705,
      79114,
      35584,
      15974,
      1510,
      54172,
      28562,
      12451,
      104226,
      19190,
      97151,
      73024,
      20948,
      5151,
      81741,
      21499,
      29006,
      84183,
      198074,
      54003,
      45120,
      170125,
      26240,
      35177,
      28389,
      64863,
      79974,
      60778,
      176915,
      232183,
      45342,
      2038,
      80253,
      41564,
      40703,
      32689,
      5430,
      100689,
      5366,
      23007,
      134279,
      14266,
      26712,
      73993,
      24934,
      64242,
      52113,
      102887,
      61801,
      46415,
      201049,
      54251,
      62133,
      122757,
      164883,
      30815,
      139966,
      2319,
      30842,
      766,
      13362,
      10287,
      134518,
      86111,
      81665,
      82440,
      28333,
      43019,
      18963,
      8804,
      161944,
      23439,
      102144,
      101145,
      80029,
      39052,
      248708,
      30350,
      117340,
      11878,
      128467,
      974,
      138625,
      63961,
      5237,
      74778,
      61834,
      67040,
      43814,
      13690,
      65947,
      33809,
      232476,
      115258,
      181745,
      28824,
      94013,
      9510,
      10246,
      93722,
      81976,
      7217,
      114383,
      3493,
      16014,
      69045,
      72692,
      12145,
      80981,
      9507,
      6692,
      1620,
      60820,
      330444,
      35474,
      33962,
      4797,
      7053,
      295463,
      46445,
      27026,
      12491,
      77988,
      49524,
      35675,
      90947,
      29114,
      166705,
      101385,
      133782,
      32704,
      6186,
      84595,
      176031,
      185623,
      45966,
      151302,
      63069,
      1699,
      107491,
      947,
      15458,
      74452,
      196212,
      6046,
      10498,
      12163,
      10239,
      35191,
      243951,
      9277,
      9090,
      29539,
      54460,
      22820,
      26514,
      112549,
      60372,
      51753,
      48756,
      21812,
      70861,
      260326,
      41,
      44222,
      10441,
      16961,
      48148,
      138771,
      216194,
      5914,
      52153,
      53400,
      212036,
      56519,
      26245,
      10117,
      45888,
      15294,
      138019,
      90913,
      26368,
      43842,
      42111,
      23348,
      6082,
      194845,
      161089,
      156206,
      51546,
      11647,
      30759,
      302912,
      262094,
      8635,
      78876,
      26535,
      35283,
      54183,
      31183,
      85484,
      147873,
      12989,
      5197,
      6356,
      72894,
      65347,
      20150,
      27370,
      73787,
      1493,
      45918,
      12366,
      190217,
      20724,
      13858,
      10981,
      67449,
      81213,
      7553,
      14115,
      72242,
      271517,
      11842,
      48310,
      88743,
      143726,
      22177,
      3290,
      243231,
      58452,
      62937,
      12592,
      1654,
      40066,
      33477,
      13751,
      9921,
      128442,
      15868,
      7106,
      75236,
      83773,
      10775,
      36938,
      10482,
      170465,
      17368,
      17469,
      161508,
      32752,
      98340,
      800,
      19824,
      264456,
      3901,
      87319,
      2867,
      26782,
      9630,
      113102,
      185815,
      24197,
      44584,
      86366,
      40224,
      3636,
      140916,
      31731,
      267731,
      9567,
      53678,
      72984,
      29389,
      27963,
      17106,
      50282,
      284911,
      60170,
      8322,
      12608,
      23374,
      89652,
      5268,
      39044,
      229766,
      8869,
      151350,
      31436,
      177342,
      12269,
      183212,
      120418,
      116270,
      2843,
      78888,
      69192,
      7865,
      184099,
      1086,
      129897,
      18383,
      70508,
      20242,
      18508,
      229924,
      124569,
      35749,
      50589,
      55626,
      9884,
      83115,
      40971,
      30671,
      18135,
      14452,
      38861,
      17844,
      201826,
      5549,
      26413,
      17189,
      13561,
      38539,
      10679,
      143331,
      3314,
      36785,
      171194,
      49685,
      187713,
      67506,
      4618,
      104039,
      17060,
      195080,
      50648,
      33159,
      19238,
      67559,
      134840,
      28599,
      157523,
      17130,
      38064,
      117398,
      94355,
      31918,
      13575,
      34538,
      40326,
      13997,
      3494,
      348283,
      62481,
      26862,
      3603,
      104426,
      244363,
      153709,
      112487,
      304612,
      199674,
      41239,
      35545,
      54869,
      293005,
      28223,
      26277,
      26899,
      4533,
      18518,
      15492,
      38587,
      80488,
      70485,
      160395,
      263,
      60162,
      11382,
      222152,
      4696,
      250751,
      51921,
      182609,
      10707,
      48463,
      46243,
      1227,
      49111,
      111564,
      46502,
      33342,
      56846,
      68541,
      63559,
      858,
      139927,
      16654,
      229375,
      76759,
      26478,
      33205,
      95828,
      23399,
      92945,
      2637,
      35630,
      28470,
      143992,
      50214,
      14174,
      21456,
      166191,
      65665,
      1711,
      21594,
      78019,
      97599,
      111701,
      36,
      147151,
      110246,
      189022,
      43021,
      30397,
      40757,
      131935,
      42065,
      73335,
      48039,
      26596,
      28984,
      15102,
      2361,
      7421,
      202167,
      69744,
      43766,
      52826,
      3642,
      83304,
      33873,
      75140,
      63169,
      192389,
      36551,
      92748,
      13039,
      123959,
      233220,
      21738,
      84447,
      77230,
      20228,
      187852,
      19095,
      25799,
      92136,
      108774,
      29237,
      53947,
      2299,
      118106,
      2687,
      8830,
      42331,
      202924,
      33667,
      2023,
      73763,
      30704,
      19363,
      19779,
      16737,
      35629,
      48081,
      24068,
      101013,
      162338,
      291912,
      13749,
      24745,
      328289,
      167679,
      70086,
      48299,
      23306,
      16732,
      17801,
      43322,
      54589,
      3586,
      63653,
      43624,
      53474,
      925,
      109177,
      251316,
      43805,
      13082,
      19511,
      86565,
      142182,
      92461,
      17117,
      101033,
      103319,
      64589,
      4022,
      4351,
      235897,
      5352,
      82705,
      107142,
      46391,
      156084,
      5860,
      61365,
      10558,
      13045,
      7717,
      18357,
      33922,
      12590,
      33065,
      6928,
      46993,
      783,
      46937,
      67846,
      8952,
      26295,
      6107,
      119656,
      18799,
      17458,
      50747,
      4229,
      179559,
      112727,
      118080,
      20683,
      41464,
      125468,
      51560,
      49749,
      44231,
      7359,
      35339,
      62988,
      136487,
      67015,
      5208,
      29150,
      24956,
      105186,
      48858,
      6143,
      18097,
      6972,
      16404,
      73489,
      58742,
      97196,
      36357,
      164616,
      5834,
      32267,
      13746,
      147733,
      15113,
      132091,
      34127,
      106298,
      39729,
      106426,
      22294,
      9780,
      15602,
      36213,
      71502,
      42808,
      66802,
      599,
      60755,
      5851,
      39120,
      67363,
      108623,
      126368,
      72770,
      91263,
      32486,
      30596,
      151717,
      7951,
      52002,
      43103,
      11768,
      68942,
      40901,
      39344,
      24037,
      127500,
      116890,
      48403,
      16926,
      86750,
      17745,
      48648,
      159545,
      34460,
      58419,
      5634,
      114317,
      67865,
      31462,
      23352,
      24010,
      98185,
      125708,
      69686,
      68337,
      13610,
      26271,
      70691,
      2980,
      4768,
      27225,
      102402,
      75453,
      28106,
      8104,
      6931,
      1176,
      6274,
      6475,
      112635,
      22498,
      6176,
      238686,
      26832,
      28893,
      90319,
      14441,
      15682,
      15087,
      39517,
      45270,
      109134,
      104440,
      45965,
      47645,
      81772,
      7876,
      52683,
      87720,
      12898,
      4505,
      185665,
      2769,
      113401,
      15664,
      57592,
      105229,
      137381,
      97059,
      119268,
      6876,
      43309,
      33886,
      128363,
      35476,
      144249,
      67013,
      143587,
      83367,
      25703,
      91436,
      59347,
      53236,
      2289,
      16519,
      19844,
      46309,
      58558,
      99834,
      23313,
      218816,
      231303,
      36388,
      51333,
      183535,
      109792,
      139277,
      54306,
      90139,
      18235,
      8275,
      32710,
      37677,
      82464,
      86025,
      92204,
      88842,
      117723,
      37570,
      128723,
      234242,
      76350,
      73795,
      34896,
      148247,
      58424,
      11105,
      11744,
      45746,
      63372,
      17118,
      49772,
      199520,
      81902,
      38004,
      22911,
      33752,
      3125,
      1995,
      53792,
      4689,
      26909,
      108150,
      146062,
      69674,
      41811,
      161444,
      84855,
      8999,
      28561,
      16731,
      93937,
      3189,
      21967,
      24890,
      22943,
      1356,
      145300,
      51569,
      28802,
      517,
      118679,
      31703,
      40607,
      48098,
      108854,
      25003,
      10233,
      73969,
      177495,
      5248,
      24516,
      215347,
      146192,
      48712,
      60626,
      69188,
      40735,
      5866,
      586,
      101541,
      6509,
      47590,
      52129,
      5969,
      222045,
      110933,
      25733,
      24223,
      65339,
      62812,
      2414,
      155418,
      35819,
      16022,
      78423,
      43138,
      20995,
      128255,
      240673,
      46745,
      236093,
      72176,
      57085,
      97841,
      61248,
      107,
      36068,
      193177,
      105427,
      55726,
      215229,
      20446,
      47228,
      100420,
      87091,
      14429,
      121708,
      23605,
      21157,
      187721,
      21880,
      2997,
      203976,
      99166,
      95068,
      25877,
      7724,
      98925,
      83401,
      4829,
      13182,
      18229,
      13718,
      239662,
      38653,
      116505,
      153497,
      30589,
      89029,
      38962,
      181302,
      43853,
      78872,
      180301,
      4786,
      248240,
      7401,
      106136,
      112590,
      77745,
      19731,
      60880,
      77789,
      125748,
      135487,
      5975,
      48627,
      34084,
      12419,
      215770,
      47557,
      254582,
      10364,
      106495,
      21856,
      67539,
      88981,
      38805,
      21428,
      48732,
      42316,
      12149,
      16078,
      52808,
      25327,
      51322,
      33850,
      51147,
      12253,
      122354,
      46077,
      56483,
      254553,
      115417,
      81834,
      150991,
      94662,
      86668,
      7381,
      12841,
      100650,
      18218,
      15741,
      22372,
      68294,
      50705,
      15535,
      84660,
      61887,
      22553,
      72299,
      31361,
      24824,
      17743,
      46820,
      64288,
      31582,
      77006,
      111674,
      116384,
      30760,
      80920,
      86149,
      77192,
      51979,
      79691,
      60342,
      122805,
      103800,
      240873,
      160744,
      233114,
      78962,
      54920,
      8608,
      3484,
      316104,
      72548,
      24337,
      5088,
      230040,
      21926,
      10172,
      36838,
      26,
      86221,
      83458,
      102176,
      12062,
      17571,
      41929,
      41170,
      28428,
      68239,
      41750,
      103930,
      2634,
      18313,
      53019,
      34825,
      97837,
      63115,
      24606,
      73157,
      152474,
      14715,
      91439,
      37033,
      109806,
      140259,
      30668,
      174760,
      380,
      135597,
      95673,
      136073,
      65073,
      134249,
      13829,
      17279,
      122305,
      4420,
      46444,
      10237,
      64848,
      203623,
      70728,
      10349,
      182885,
      65075,
      24519,
      25783,
      40318,
      34139,
      22222,
      63394,
      55266,
      102764,
      41422,
      20126,
      65100,
      90408,
      53640,
      35128,
      48932,
      11192,
      38935,
      96839,
      34782,
      39492,
      19396,
      41332,
      6250,
      5511,
      19492,
      51304,
      25936,
      104466,
      54099,
      73771,
      86115,
      5080,
      7669,
      30891,
      111700,
      13931,
      25276,
      72289,
      135447,
      14820,
      258641,
      25265,
      31005,
      281179,
      75286,
      393,
      95359,
      14623,
      13584,
      6680,
      101227,
      80173,
      44933,
      76666,
      54542,
      13244,
      39348,
      458,
      25379,
      109451,
      134348,
      81143,
      6959,
      65554,
      12027,
      51311,
      8716,
      57589,
      140731,
      28467,
      23316,
      17272,
      30458,
      25980,
      55229,
      77197,
      83798,
      28302,
      114784,
      7428,
      34548,
      26241,
      14712,
      39336,
      103304,
      18928,
      54080,
      12870,
      334,
      87722,
      15208,
      16895,
      142098,
      114262,
      39820,
      83913,
      57817,
      28682,
      7721,
      14900,
      108672,
      11250,
      62246,
      42849,
      415188,
      1724,
      26555,
      24549,
      25505,
      26443,
      107450,
      145899,
      61035,
      43528,
      6901,
      60726,
      65906,
      267741,
      21338,
      147590,
      42079,
      18924,
      73017,
      135236,
      15393,
      5206,
      4026,
      84185,
      1531,
      5988,
      113890,
      82647,
      303391,
      7386,
      69844,
      71611,
      189865,
      76523,
      31877,
      13315,
      19314,
      198575,
      32821,
      1928,
      67641,
      25913,
      104475,
      103489,
      3297,
      70391,
      18406,
      15446,
      113347,
      19295,
      93790,
      27856,
      1792,
      167471,
      116449,
      8541,
      4408,
      41757,
      63233,
      25765,
      86680,
      64501,
      27034,
      24816,
      34975,
      6079,
      4486,
      49693,
      36229,
      16917,
      21581,
      62426,
      27862,
      11612,
      54284,
      35702,
      194034,
      355,
      24277,
      48262,
      87411,
      70504,
      310164,
      118018,
      12516,
      47559,
      43502,
      57433,
      107139,
      9290,
      66533,
      80863,
      14634,
      34312,
      91725,
      28606,
      21342,
      67241,
      72355,
      43244,
      375789,
      37402,
      174015,
      105070,
      8342,
      44167,
      67494,
      1890,
      16365,
      11723,
      271002,
      1865,
      47918,
      8350,
      45564,
      27742,
      25110,
      125803,
      8553,
      49504,
      81925,
      62211,
      4534,
      15491,
      19011,
      80373,
      206920,
      667,
      102405,
      128623,
      245524,
      5553,
      113309,
      192739,
      65766,
      19567,
      22832,
      261958,
      29679,
      21293,
      71134,
      20962,
      105123,
      24721,
      860,
      21752,
      33448,
      18372,
      157167,
      94822,
      35770,
      173224,
      232737,
      75729,
      28937,
      46828,
      28062,
      25453,
      5207,
      140366,
      36665,
      30652,
      6169,
      67920,
      150458,
      92040,
      23186,
      184604,
      92330,
      20891,
      176492,
      49427,
      27828,
      38305,
      42495,
      143982,
      49560,
      25503,
      90043,
      29747,
      65328,
      47830,
      12932,
      11068,
      77721,
      9003,
      25213,
      94205,
      140426,
      46090,
      89945,
      138173,
      192691,
      33329,
      112232,
      129905,
      35709,
      27514,
      1841,
      19957,
      31411,
      127476,
      53572,
      17497,
      173549,
      55063,
      175135,
      19841,
      69314,
      5192,
      237921,
      117660,
      150697,
      4060,
      273045,
      50414,
      98940,
      65348,
      153665,
      164423,
      58804,
      156695,
      48994,
      213928,
      86036,
      28608,
      8355,
      39574,
      34540,
      16927,
      135680,
      18374,
      151587,
      10830,
      53805,
      16878,
      16623,
      4282,
      48030,
      8537,
      14986,
      46102,
      13062,
      72897,
      72,
      33050,
      108227,
      39451,
      45935,
      651,
      113320,
      40535,
      95176,
      57450,
      48843,
      5003,
      19019,
      10407,
      211163,
      3848,
      1068,
      4988,
      32091,
      30095,
      41692,
      15099,
      43602,
      107434,
      50744,
      7627,
      171349,
      16313,
      150832,
      352665,
      207750,
      33937,
      38256,
      51091,
      156e3,
      87889,
      90663,
      84175,
      24908,
      114900,
      50365,
      31494,
      83829,
      5398,
      169342,
      47521,
      54818,
      18935,
      8356,
      43094,
      41212,
      174536,
      10082,
      92550,
      6678,
      60614,
      23355,
      69721,
      14796,
      34149,
      128830,
      58187,
      3179,
      208,
      40325,
      28399,
      225029,
      401412,
      51150,
      31580,
      207268,
      6657,
      10993,
      69818,
      64282,
      289845,
      23308,
      12961,
      38447,
      6681,
      52944,
      31855,
      2572,
      47646,
      120728,
      179148,
      37240,
      45196,
      218274,
      4816,
      3695,
      21961,
      50084,
      35209,
      18073,
      51452,
      27004,
      6100,
      33941,
      1377,
      84831,
      171214,
      85,
      141510,
      9078,
      99227,
      32610,
      6417,
      11718,
      49868,
      65579,
      87902,
      73018,
      49062,
      46280,
      61742,
      21512,
      40862,
      107733,
      15941,
      29168,
      157765,
      144919,
      14487,
      5767,
      158014,
      140070,
      7241,
      573,
      71584,
      16921,
      223566,
      40331,
      179473,
      35081,
      47926,
      140885,
      41508,
      52104,
      59180,
      42310,
      32811,
      29048,
      123517,
      102413,
      80208,
      10104,
      14746,
      12649,
      153641,
      126022,
      37965,
      113017,
      4171,
      83,
      142592,
      2809,
      6362,
      50416,
      71323,
      116894,
      260776,
      16204,
      1524,
      5760,
      30351,
      12658,
      20703,
      54403,
      36083,
      45408,
      74772,
      4946,
      14485,
      50759,
      111222,
      10890,
      2195,
      167147,
      92962,
      130534,
      16283,
      177256,
      35016,
      15472,
      210156,
      151187,
      73922,
      117691,
      43250,
      52051,
      37392,
      24811,
      24358,
      30830,
      5775,
      818,
      21969,
      1476,
      127322,
      151783,
      58392,
      31021,
      106913,
      65215,
      89407,
      90802,
      28531,
      11690,
      20234,
      95249,
      44602,
      37256,
      18707,
      11928,
      5161,
      4410,
      26571,
      51903,
      49768,
      22008,
      25252,
      65780,
      209499,
      68769,
      203726,
      13249,
      137363,
      48845,
      86823,
      6658,
      5674,
      31881,
      1083,
      1823,
      108676,
      34518,
      166752,
      13791,
      14287,
      91576,
      91429,
      8665,
      11529,
      26401,
      16191,
      91972,
      30964,
      5254,
      28486,
      54697,
      79613,
      66520,
      18447,
      22870,
      45203,
      194466,
      22822,
      51703,
      12278,
      76716,
      44595,
      73455,
      33546,
      12235,
      144843,
      36154,
      51247,
      11116,
      33040,
      3180,
      225753,
      60864,
      1972,
      28469,
      12891,
      28879,
      10338,
      144157,
      56294,
      353058,
      38302,
      41447,
      87532,
      110616,
      27065,
      168438,
      6557,
      1213,
      50804,
      144643,
      24817,
      2390,
      136531,
      38174,
      247513,
      16190,
      4059,
      122791,
      131994,
      137430,
      39506,
      57650,
      16305,
      5188,
      54309,
      106128,
      20628,
      88071,
      67394,
      395446,
      250285,
      66176,
      91254,
      1399,
      114196,
      43915,
      60230,
      44853,
      27206,
      106353,
      43013,
      18733,
      345105,
      226453,
      51202,
      16607,
      57106,
      117175,
      35492,
      10476,
      89598,
      127439,
      15187,
      39624,
      13688,
      61570,
      10615,
      31111,
      59370,
      6238,
      175252,
      32143,
      224492,
      41388,
      95408,
      34384,
      148238,
      78307,
      38959,
      9340,
      160091,
      61443,
      15737,
      11216,
      41244,
      170,
      38299,
      102443,
      113097,
      26382,
      14027,
      33707,
      3957,
      76300,
      66160,
      19431,
      18900,
      6952,
      1717,
      108656,
      82206,
      188021,
      257335,
      27295,
      43999,
      41210,
      31777,
      46956,
      57457,
      12657,
      11489,
      15697,
      48060,
      204748,
      53583,
      82422,
      284790,
      30503,
      137341,
      8120,
      19615,
      220311,
      15991,
      10217,
      63424,
      9808,
      67431,
      70976,
      98221,
      4491,
      15177,
      28535,
      144789,
      751,
      13230,
      2394,
      1504,
      33977,
      132104,
      30316,
      22230,
      931,
      97193,
      185240,
      24826,
      22687,
      174322,
      15307,
      22988,
      1390,
      188745,
      180325,
      29580,
      59068,
      74903,
      18994,
      29195,
      79,
      15436,
      7622,
      38462,
      11566,
      138710,
      44828,
      45774,
      37768,
      99236,
      68137,
      84083,
      19282,
      22698,
      17134,
      74807,
      126662,
      173497,
      46248,
      16938,
      119735,
      3212,
      28292,
      213652,
      49013,
      9975,
      32180,
      45660,
      86250,
      4801,
      68788,
      95490,
      77482,
      113751,
      11994,
      44624,
      94452,
      46839,
      128497,
      100316,
      5798,
      58588,
      73184,
      202987,
      65417,
      37790,
      88524,
      1606,
      43156,
      97964,
      105717,
      34947,
      11203,
      100060,
      37742,
      130074,
      93653,
      107799,
      94311,
      196106,
      41347,
      8035,
      10780,
      16390,
      27883,
      118236,
      167395,
      1979,
      25006,
      19375,
      31628,
      18916,
      144723,
      78502,
      114047,
      103107,
      86492,
      107686,
      5844,
      20934,
      206963,
      23556,
      22591,
      16562,
      146333,
      20167,
      10471,
      117434,
      33085,
      2863,
      9740,
      36669,
      41849,
      37271,
      22790,
      18209,
      28979,
      8231,
      12952,
      54408,
      21731,
      25130,
      45208,
      55748,
      138120,
      75826,
      414,
      29593,
      9925,
      292865,
      25999,
      683,
      123149,
      7036,
      92159,
      86055,
      61827,
      103680,
      23176,
      54918,
      58466,
      57578,
      13305,
      5709,
      86479,
      16697,
      31064,
      17660,
      200919,
      10770,
      49793,
      33423,
      32370,
      52047,
      16488,
      62555,
      6459,
      8426,
      83493,
      7763,
      59725,
      82812,
      18628,
      67760,
      79405,
      68557,
      9612,
      7673,
      28102,
      56517,
      69620,
      171797,
      32458,
      29541,
      15870,
      81109,
      32080,
      207644,
      71495,
      21202,
      11039,
      91036,
      61230,
      2810,
      130800,
      32260,
      4613,
      60590,
      37112,
      75214,
      33979,
      126402,
      155062,
      30642,
      63875,
      12810,
      194463,
      82799,
      47664,
      16725,
      36685,
      43367,
      61099,
      449,
      172150,
      102867,
      21691,
      301838,
      36745,
      7130,
      18671,
      57316,
      34852,
      38034,
      54182,
      35578,
      65900,
      99486,
      19771,
      3456,
      2658,
      16914,
      99866,
      28390,
      28109,
      8262,
      21147,
      34353,
      20006,
      4228,
      137085,
      1675,
      203023,
      283196,
      198286,
      214375,
      163329,
      290603,
      152574,
      40471,
      83506,
      30068,
      14730,
      23177,
      131539,
      34759,
      27668,
      32178,
      71896,
      104799,
      116305,
      85430,
      119262,
      42860,
      25160,
      8911,
      23428,
      49437,
      105322,
      6519,
      16203,
      6349,
      74711,
      1230,
      38045,
      8540,
      75165,
      44736,
      25909,
      51026,
      317034,
      4984,
      32281,
      91312,
      27060,
      44431,
      17817,
      45363,
      155937,
      239085,
      35697,
      59784,
      91993,
      29531,
      126740,
      213757,
      76560,
      167776,
      285273,
      24262,
      8237,
      65030,
      41160,
      74437,
      48804,
      118916,
      13159,
      37842,
      1031,
      75349,
      1478,
      11655,
      108777,
      23435,
      277425,
      101734,
      67469,
      70231,
      124711,
      43532,
      28514,
      65526,
      54956,
      1e3,
      21882,
      17728,
      25302,
      40952,
      52214,
      149632,
      1999,
      2111,
      3259,
      63362,
      89961,
      220561,
      39777,
      26335,
      9063,
      10572,
      12416,
      34551,
      34623,
      38604,
      24723,
      5947,
      15588,
      69927,
      66252,
      119177,
      69173,
      46629,
      28714,
      70715,
      212408,
      20521,
      406913,
      74380,
      11716,
      50659,
      50862,
      37009,
      88460,
      130101,
      7210,
      53853,
      538,
      65120,
      151950,
      55806,
      163748,
      52837,
      13153,
      21100,
      16674,
      64536,
      6091,
      138201,
      44837,
      58547,
      3723,
      163,
      2177,
      32288,
      85454,
      34033,
      8497,
      14282,
      25742,
      10535,
      10741,
      79559,
      117493,
      243787,
      49337,
      100718,
      79495,
      40139,
      42956,
      7551,
      55433,
      15421,
      31509,
      23034,
      45081,
      547,
      61176,
      53434,
      328001,
      8470,
      36263,
      30145,
      4519,
      74173,
      53935,
      11845,
      73774,
      60211,
      78025,
      3,
      4102,
      73782,
      109293,
      315332,
      48412,
      26683,
      13714,
      6865,
      20128,
      18490,
      104141,
      325,
      39470,
      171970,
      115860,
      15707,
      7268,
      73301,
      74336,
      31370,
      2368,
      111827,
      107757,
      136231,
      142844,
      97138,
      96638,
      84053,
      38691,
      23801,
      1588,
      10573,
      122098,
      77039,
      240,
      186135,
      146101,
      11996,
      18143,
      112963,
      46171,
      155836,
      348769,
      47795,
      121213,
      116266,
      132515,
      3344,
      144804,
      31286,
      99187,
      255838,
      129694,
      35894,
      48779,
      55235,
      148582,
      71967,
      65282,
      15174,
      13920,
      47080,
      6147,
      108242,
      157593,
      125025,
      7136,
      1286,
      28957,
      127956,
      28402,
      98813,
      20805,
      7532,
      109417,
      40610,
      5041,
      32958,
      15142,
      18408,
      108596,
      33543,
      50517,
      27748,
      80114,
      233434,
      91447,
      487,
      37094,
      100048,
      30541,
      43477,
      10639,
      89862,
      155868,
      37667,
      8726,
      60684,
      237903,
      73408,
      99589,
      12190,
      38739,
      97348,
      3914,
      13594,
      2680,
      149016,
      13907,
      30171,
      28343,
      23530,
      115225,
      61104,
      35821,
      147679,
      14337,
      4297,
      244282,
      24085,
      326976,
      56428,
      7851,
      21303,
      131620,
      71446,
      83253,
      68692,
      111870,
      5224,
      15813,
      38197,
      49026,
      45057,
      13660,
      3306,
      76345,
      40671,
      27905,
      91072,
      996,
      68527,
      62085,
      91351,
      122634,
      55109,
      168209,
      2024,
      27560,
      112707,
      17352,
      8306,
      167115,
      169921,
      166958,
      5031,
      46020,
      11844,
      67284,
      19130,
      76185,
      6920,
      32849,
      5450,
      14610,
      22451,
      21002,
      17392,
      31872,
      66682,
      84796,
      13709,
      40210,
      59898,
      12029,
      8719,
      53564,
      21462,
      91884,
      21647,
      88379,
      194428,
      12754,
      37797,
      132826,
      160016,
      22567,
      54383,
      53186,
      77611,
      31107,
      8339,
      4694,
      19185,
      90355,
      23597,
      17222,
      140675,
      28442,
      23668,
      55977,
      9128,
      61555,
      28774,
      155229,
      17658,
      9390,
      24379,
      69357,
      15752,
      127381,
      239631,
      62460,
      93181,
      55913,
      45133,
      140155,
      18676,
      25249,
      33164,
      29581,
      82837,
      67223,
      22362,
      29975,
      7317,
      52813,
      1943,
      29613,
      20012,
      207130,
      49617,
      49651,
      5636,
      15334,
      36313,
      29226,
      28084,
      95247,
      72072,
      19e3,
      224932,
      15811,
      114,
      32127,
      38097,
      37508,
      88507,
      37225,
      27359,
      91626,
      12193,
      69279,
      20608,
      11055,
      88156,
      92808,
      2152,
      57259,
      55275,
      72789,
      24475,
      104414,
      1708,
      9882,
      3818,
      48661,
      66897,
      1631,
      34806,
      227930,
      85815,
      87753,
      18321,
      250664,
      72733,
      25107,
      206797,
      50891,
      8082,
      196411,
      92596,
      96764,
      152823,
      65514,
      22819,
      387277,
      62176,
      51225,
      40329,
      15563,
      189,
      3659,
      73670,
      64357,
      51793,
      275136,
      33482,
      86653,
      74615,
      67058,
      11318,
      125720,
      15388,
      22388,
      8267,
      1730,
      102663,
      170910,
      40784,
      7144,
      85373,
      13040,
      7088,
      94309,
      583,
      44224,
      140424,
      77439,
      18496,
      164026,
      36578,
      4722,
      9151,
      5824,
      63365,
      26510,
      35199,
      40500,
      79277,
      32495,
      44614,
      35233,
      9566,
      203293,
      152144,
      7097,
      2330,
      183480,
      98629,
      13423,
      330887,
      44130,
      68600,
      30939,
      97829,
      31012,
      345465,
      56747,
      94879,
      4939,
      160027,
      149761,
      99423,
      46099,
      32251,
      15332,
      8761,
      96094,
      128555,
      5763,
      235318,
      222223,
      55729,
      30241,
      55420,
      201746,
      3987,
      81382,
      8259,
      49325,
      23287,
      7719,
      24633,
      251100,
      92311,
      18591,
      110533,
      64759,
      170260,
      393860,
      7175,
      21144,
      132887,
      3593,
      75346,
      101277,
      91109,
      16387,
      259187,
      11627,
      57459,
      173829,
      44694,
      55780,
      49797,
      89192,
      120443,
      62622,
      3904,
      14814,
      23887,
      1027,
      112258,
      64955,
      99800,
      11132,
      66353,
      36202,
      48624,
      18158,
      88481,
      96882,
      43059,
      11040,
      2455,
      7077,
      21651,
      181159,
      99126,
      100434,
      61388,
      68186,
      19161,
      110468,
      120052,
      8819,
      55324,
      41494,
      7014,
      37689,
      3618,
      87729,
      92615,
      207943,
      9823,
      128657,
      12587,
      15857,
      6379,
      67628,
      51216,
      71775,
      157617,
      63244,
      1503,
      3864,
      218754,
      110864,
      5769,
      21492,
      7243,
      1192,
      87921,
      85529,
      31512,
      18537,
      42698,
      35350,
      73510,
      84474,
      34301,
      8991,
      21013,
      35034,
      566,
      38832,
      19838,
      35586,
      37216,
      39413,
      55006,
      12178,
      59742,
      856,
      84563,
      6900,
      25632,
      17437,
      49786,
      30723,
      13847,
      70845,
      4044,
      7843,
      23944,
      235976,
      55530,
      48942,
      6518,
      20939,
      73769,
      192653,
      52936,
      95207,
      23895,
      132542,
      142982,
      22632,
      87452,
      48042,
      54018,
      178468,
      10728,
      26230,
      23559,
      363,
      81269,
      142012,
      5718,
      346258,
      31456,
      84333,
      246476,
      51018,
      66692,
      101804,
      120570,
      39962,
      30373,
      70593,
      2864,
      60541,
      19425,
      54209,
      104092,
      7201,
      31545,
      48018,
      25865,
      15442,
      46257,
      40443,
      8328,
      6451,
      111782,
      47527,
      97754,
      33046,
      470,
      245116,
      31095,
      39,
      91934,
      87208,
      73470,
      36708,
      36521,
      12801,
      70624,
      36272,
      8892,
      79768,
      12427,
      55454,
      103756,
      5908,
      52390,
      62962,
      22720,
      141138,
      94634,
      41689,
      128402,
      126390,
      6628,
      106394,
      35527,
      134394,
      82727,
      254651,
      194502,
      148064,
      89549,
      3202,
      28359,
      957,
      21954,
      27906,
      49840,
      142747,
      8307,
      24206,
      48978,
      1186,
      71728,
      133038,
      71474,
      91306,
      6333,
      110959,
      74600,
      70387,
      18983,
      62609,
      56057,
      22970,
      1147,
      135850,
      1321,
      28834,
      3578,
      59715,
      102227,
      32827,
      81415,
      99952,
      55636,
      257598,
      390,
      22702,
      35701,
      85872,
      402916,
      39216,
      189795,
      14929,
      19467,
      10112,
      144422,
      61514,
      5279,
      63421,
      134686,
      41436,
      8424,
      51925,
      10598,
      132295,
      124416,
      4604,
      194739,
      210929,
      57866,
      31829,
      51626,
      50007,
      9976,
      91878,
      61906,
      56168,
      81906,
      60918,
      61859,
      40017,
      23059,
      16887,
      40927,
      62064,
      12785,
      32893,
      32913,
      21782,
      93965,
      20169,
      44387,
      79084,
      38463,
      11457,
      93950,
      27127,
      157050,
      2697,
      337088,
      5116,
      54128,
      48255,
      33279,
      8821,
      27352,
      25515,
      124022,
      65710,
      28906,
      38557,
      33390,
      1722,
      104435,
      72215,
      38551,
      12094,
      30978,
      25113,
      6671,
      37355,
      175109,
      42862,
      98024,
      65406,
      221276,
      59624,
      118012,
      64637,
      78760,
      86697,
      21426,
      1639,
      40350,
      12584,
      67193,
      84144,
      31396,
      7863,
      143011,
      69629,
      63112,
      9454,
      28666,
      65798,
      46372,
      134721,
      6314,
      51402,
      30837,
      151922,
      2847,
      38676,
      38008,
      92823,
      136245,
      17540,
      5504,
      109295,
      205242,
      37606,
      5211,
      214892,
      1586,
      20670,
      208711,
      137743,
      19328,
      40652,
      16995,
      20023,
      14657,
      154919,
      34422,
      12996,
      13918,
      38221,
      47690,
      16398,
      2959,
      37680,
      89122,
      6721,
      198469,
      91876,
      172043,
      83898,
      101992,
      26084,
      94570,
      3635,
      76958,
      22853,
      76497,
      38266,
      176590,
      168403,
      44464,
      142840,
      79180,
      184594,
      1984,
      41806,
      83147,
      11985,
      6546,
      366068,
      59732,
      24533,
      271505,
      8736,
      39084,
      222992,
      93429,
      28962,
      58985,
      86665,
      8432,
      30028,
      14548,
      32439,
      54424,
      165029,
      55175,
      27458,
      69046,
      121277,
      46168,
      33732,
      20661,
      24581,
      135574,
      123110,
      37556,
      79260,
      72611,
      16957,
      12939,
      46162,
      58238,
      44907,
      72936,
      253758,
      41324,
      32518,
      96480,
      11949,
      124438,
      65280,
      43256,
      34107,
      53533,
      43531,
      37037,
      28366,
      45970,
      32741,
      173438,
      6121,
      194202,
      62969,
      26355,
      30314,
      58370,
      28455,
      1848,
      50519,
      82830,
      90393,
      21761,
      295490,
      10936,
      256940,
      133568,
      44050,
      20269,
      4089,
      27457,
      21610,
      219460,
      36743,
      14821,
      101388,
      52005,
      13124,
      30979,
      140816,
      167362,
      26054,
      18458,
      60789,
      34917,
      40447,
      26606,
      33422,
      9066,
      3452,
      83614,
      5761,
      20263,
      137238,
      25038,
      91310,
      101,
      52322,
      74548,
      42572,
      38084,
      214054,
      186568,
      31802,
      17665,
      30620,
      141936,
      37730,
      14420,
      4265,
      187218,
      49640,
      188208,
      51441,
      55388,
      96452,
      66659,
      40869,
      42039,
      60967,
      221027,
      19234,
      178581,
      29105,
      96050,
      9165,
      196118,
      157335,
      3738,
      40354,
      117436,
      2965,
      34136,
      59659,
      15570,
      50843,
      230035,
      31444,
      71260,
      43886,
      18316,
      5387,
      38500,
      168508,
      17406,
      32174,
      8828,
      103373,
      143806,
      90367,
      3560,
      18719,
      122310,
      16508,
      26719,
      2541,
      105429,
      6645,
      37998,
      73190,
      10591,
      235916,
      49737,
      87112,
      233941,
      53188,
      32193,
      79154,
      4544,
      52905,
      126477,
      7580,
      63501,
      57314,
      3216,
      31337,
      6541,
      103083,
      60846,
      49,
      9756,
      15481,
      1355,
      43840,
      14319,
      13743,
      27486,
      10222,
      73114,
      230718,
      418644,
      16706,
      6674,
      279748,
      23058,
      45273,
      295831,
      86306,
      2743,
      5535,
      88773,
      21829,
      35253,
      120938,
      31153,
      3169,
      16839,
      42847,
      8751,
      80974,
      33942,
      36867,
      35514,
      16485,
      26474,
      77775,
      56877,
      5391,
      48346,
      3882,
      108713,
      31403,
      27804,
      55248,
      26235,
      43821,
      136104,
      40118,
      175507,
      28034,
      203908,
      18732,
      1788,
      34030,
      106427,
      36958,
      54359,
      7251,
      44936,
      15356,
      69139,
      455,
      157915,
      22173,
      140291,
      50348,
      43275,
      82066,
      49621,
      54952,
      15216,
      36226,
      96695,
      66855,
      6936,
      1987,
      8227,
      196087,
      4631,
      68827,
      99004,
      47541,
      110265,
      17953,
      147605,
      110242,
      58520,
      31312,
      38724,
      329975,
      642,
      3155,
      34497,
      75937,
      6207,
      73843,
      6120,
      17249,
      51429,
      117746,
      3218,
      910,
      68961,
      319671,
      14938,
      29555,
      34700,
      1649,
      66673,
      72268,
      9655,
      76800,
      153087,
      6941,
      210168,
      27130,
      35398,
      1780,
      73242,
      3135,
      56689,
      19556,
      165307,
      8765,
      35967,
      121458,
      13333,
      70453,
      17350,
      117253,
      22265,
      13340,
      44265,
      39869,
      441,
      3742,
      135025,
      23581,
      33309,
      16543,
      17731,
      13291,
      157637,
      283005,
      21408,
      101360,
      63887,
      52312,
      83873,
      5338,
      233779,
      23759,
      186949,
      34531,
      177320,
      38069,
      156465,
      91004,
      19353,
      59852,
      68160,
      14891,
      1338,
      1072,
      29823,
      1950,
      28901,
      81407,
      313445,
      73038,
      84807,
      162348,
      240257,
      37162,
      138934,
      16111,
      58013,
      41253,
      102951,
      16457,
      96056,
      19541,
      56402,
      67217,
      41638,
      94381,
      89674,
      29481,
      37456,
      80815,
      151579,
      13937,
      13683,
      132537,
      19699,
      134545,
      67020,
      29816,
      222341,
      141235,
      427578,
      48868,
      129557,
      233342,
      23077,
      87871,
      16213,
      18728,
      16184,
      9469,
      37913,
      19680,
      2798,
      171356,
      178328,
      13216,
      50049,
      72690,
      71904,
      124644,
      55455,
      7504,
      29052,
      41036,
      266546,
      19899,
      30391,
      188755,
      8659,
      59469,
      16,
      104298,
      112943,
      53865,
      76203,
      138226,
      68857,
      139953,
      14125,
      107625,
      119795,
      173133,
      4398,
      50273,
      48808,
      54390,
      16466,
      122086,
      31835,
      67035,
      50971,
      48859,
      7508,
      46427,
      66477,
      73021,
      84615,
      39985,
      83076,
      46779,
      201569,
      53336,
      36443,
      60865,
      168164,
      143810,
      51393,
      25548,
      169307,
      32896,
      24485,
      38424,
      21837,
      29087,
      275813,
      51674,
      6714,
      64883,
      46169,
      187369,
      55186,
      76192,
      12852,
      12018,
      62134,
      31067,
      118303,
      16542,
      12125,
      10579,
      4928,
      26291,
      43854,
      7091,
      10946,
      253716,
      109062,
      39283,
      17261,
      113012,
      258512,
      47764,
      125126,
      32646,
      55892,
      80279,
      201623,
      149872,
      3192,
      385,
      1208,
      48750,
      5376,
      58738,
      22335,
      5427,
      82416,
      47811,
      32435,
      143086,
      38930,
      94128,
      59975,
      156037,
      37977,
      38224,
      62485,
      7698,
      50405,
      71027,
      16462,
      21559,
      136153,
      34131,
      107506,
      162069,
      63703,
      3101,
      215029,
      40407,
      4178,
      3774,
      9187,
      80019,
      17880,
      97926,
      67579,
      2600,
      18405,
      8351,
      47924,
      86638,
      70820,
      92206,
      86453,
      29610,
      42241,
      119200,
      3198,
      15466,
      67813,
      57863,
      35454,
      4779,
      99518,
      4649,
      104641,
      144269,
      33730,
      38073,
      65864,
      6838,
      109456,
      193298,
      154007,
      5623,
      45741,
      30846,
      182578,
      25573,
      157224,
      1543,
      58575,
      138703,
      146140,
      44971,
      49356,
      18275,
      59064,
      20300,
      13122,
      11848,
      24453,
      11973,
      9797,
      86843,
      2919,
      25530,
      49210,
      1130,
      161220,
      76788,
      75373,
      85604,
      34926,
      36014,
      17777,
      17255,
      51533,
      11676,
      92226,
      51845,
      119859,
      21525,
      5936,
      18507,
      28050,
      1140,
      31418,
      14857,
      34207,
      47859,
      10750,
      36382,
      32079,
      106909,
      59426,
      87757,
      38393,
      110042,
      15965,
      97104,
      33757,
      35344,
      97993,
      53979,
      33651,
      45407,
      41884,
      82515,
      173089,
      7177,
      58371,
      35365,
      47543,
      51927,
      35587,
      10670,
      23544,
      29306,
      84233,
      39976,
      76076,
      62097,
      9007,
      8668,
      28119,
      78281,
      120790,
      19835,
      143020,
      54968,
      18670,
      64959,
      20649,
      34469,
      42570,
      33001,
      136570,
      87796,
      120044,
      1106,
      58700,
      63951,
      127623,
      12805,
      83057,
      40212,
      31773,
      49850,
      7361,
      54336,
      347524,
      101314,
      23751,
      19569,
      48791,
      29174,
      49369,
      20467,
      7465,
      75842,
      38281,
      623,
      112457,
      60210,
      28849,
      51003,
      94720,
      6426,
      90047,
      85560,
      43761,
      3579,
      85105,
      34607,
      90410,
      118528,
      7224,
      42907,
      111163,
      18168,
      6960,
      161135,
      191298,
      5247,
      100584,
      127552,
      171568,
      20121,
      91173,
      12636,
      54615,
      20199,
      63730,
      98105,
      2396,
      40387,
      14438,
      125012,
      4765,
      33235,
      12865,
      45299,
      37728,
      82098,
      77872,
      114037,
      59253,
      19675,
      24838,
      398016,
      102561,
      11446,
      17069,
      57508,
      178277,
      65836,
      99941,
      26114,
      2585,
      271882,
      136866,
      50126,
      11027,
      155648,
      118367,
      14585,
      8910,
      123015,
      335383,
      40434,
      41016,
      53021,
      14439,
      87098,
      176860,
      201543,
      121888,
      2358,
      9286,
      5739,
      22666,
      54270,
      37884,
      169381,
      33984,
      93859,
      16124,
      89364,
      72207,
      51639,
      76366,
      99029,
      65812,
      2198,
      12147,
      174891,
      194289,
      6986,
      30252,
      88822,
      21284,
      11445,
      288337,
      160821,
      33034,
      100869,
      43852,
      25761,
      52882,
      1144,
      103809,
      1924,
      84458,
      86079,
      43411,
      13542,
      139276,
      18141,
      34978,
      41298,
      7276,
      26481,
      173800,
      33210,
      17951,
      142652,
      33616,
      33677,
      2210,
      19941,
      98568,
      2486,
      192414,
      80136,
      12058,
      235883,
      50963,
      249638,
      29572,
      27221,
      47034,
      6124,
      72107,
      63346,
      97620,
      158513,
      299699,
      40388,
      23235,
      37176,
      224244,
      198386,
      121323,
      67992,
      23827,
      63170,
      17838,
      106622,
      158590,
      26807,
      5345,
      23489,
      91891,
      55474,
      74834,
      37981,
      13058,
      5977,
      72552,
      34706,
      26828,
      145172,
      19904,
      21367,
      34043,
      960,
      77092,
      91381,
      4733,
      47446,
      7680,
      41697,
      5170,
      16960,
      14741,
      46101,
      13656,
      473,
      51842,
      37433,
      11103,
      11551,
      121951,
      13191,
      97536,
      165932,
      50397,
      51628,
      129028,
      9069,
      44885,
      6590,
      59195,
      47045,
      32940,
      225472,
      90345,
      21833,
      13303,
      29407,
      96615,
      141951,
      5198,
      6028,
      18395,
      7181,
      3861,
      14966,
      156358,
      167182,
      36529,
      55253,
      25942,
      173153,
      30959,
      27261,
      50691,
      150176,
      162201,
      38467,
      48462,
      80602,
      42163,
      118482,
      168,
      108756,
      26011,
      17166,
      54149,
      456538,
      22512,
      91374,
      13816,
      90358,
      131615,
      18132,
      226707,
      1824,
      28139,
      26860,
      42253,
      93877,
      77351,
      65575,
      8980,
      80574,
      22020,
      27948,
      40422,
      91324,
      76376,
      13528,
      39281,
      91685,
      82215,
      122541,
      144066,
      1983,
      193851,
      17283,
      26320,
      2739,
      194978,
      4790,
      26845,
      42627,
      61300,
      65815,
      174612,
      55133,
      4200,
      191130,
      79771,
      158321,
      52280,
      166796,
      221620,
      62461,
      11278,
      4067,
      88152,
      83409,
      31717,
      121367,
      13522,
      47325,
      37945,
      10406,
      174348,
      249321,
      154101,
      64912,
      29938,
      51775,
      17220,
      15776,
      166138,
      78890,
      84425,
      54121,
      42861,
      16368,
      24572,
      291647,
      10197,
      32073,
      22651,
      11677,
      97509,
      26952,
      35787,
      18424,
      41910,
      71614,
      94977,
      72318,
      41594,
      70024,
      275419,
      37702,
      60199,
      7335,
      39107,
      61315,
      18271,
      18394,
      33768,
      87884,
      104277,
      123724,
      7277,
      56288,
      71981,
      189803,
      49320,
      3352,
      6798,
      14240,
      8954,
      69220,
      94433,
      57372,
      28620,
      68863,
      193727,
      85575,
      42309,
      41667,
      67689,
      42081,
      22543,
      44824,
      12719,
      28540,
      114236,
      101553,
      27638,
      27296,
      4300,
      5353,
      4663,
      19379,
      94098,
      3758,
      95888,
      95144,
      80344,
      87320,
      28447,
      259518,
      12718,
      71391,
      152731,
      37063,
      24132,
      31911,
      104896,
      15672,
      103782,
      1521,
      4945,
      72541,
      23717,
      122632,
      15619,
      87175,
      206120,
      29428,
      189780,
      61416,
      28350,
      44457,
      972,
      1175,
      47233,
      198738,
      95789,
      41907,
      21953,
      97034,
      59341,
      22864,
      53713,
      16873,
      32971,
      20693,
      20954,
      31336,
      21477,
      16169,
      38370,
      16412,
      9019,
      3841,
      24599,
      21938,
      17085,
      6484,
      81198,
      76413,
      5849,
      72514,
      12320,
      65247,
      276175,
      37234,
      59796,
      52642,
      16312,
      57349,
      198507,
      94148,
      46134,
      18958,
      125552,
      1747,
      18725,
      151873,
      14901,
      5490,
      68287,
      29470,
      3689,
      64794,
      40814,
      26018,
      25692,
      54450,
      2703,
      88278,
      124886,
      173087,
      174e3,
      24159,
      179477,
      24276,
      46004,
      201876,
      209202,
      445,
      52876,
      31948,
      30206,
      157610,
      39180,
      18439,
      44124,
      50469,
      5774,
      96278,
      222758,
      200216,
      50290,
      45486,
      20435,
      46986,
      46276,
      140133,
      142326,
      15569,
      13363,
      47522,
      92583,
      2182,
      7135,
      16853,
      22998,
      30272,
      4952,
      63263,
      35623,
      39096,
      53789,
      44864,
      20053,
      110392,
      124213,
      4630,
      16087,
      28221,
      127787,
      25839,
      77481,
      44693,
      13464,
      113146,
      6983,
      27069,
      55717,
      50102,
      4760,
      7107,
      26186,
      66507,
      59145,
      36032,
      104182,
      71328,
      29425,
      64317,
      50781,
      47465,
      94298,
      69706,
      74899,
      22754,
      120756,
      25108,
      93077,
      56834,
      73286,
      39928,
      16218,
      41699,
      176763,
      7555,
      70819,
      50083,
      26895,
      23315,
      26014,
      16773,
      123079,
      41712,
      5719,
      31516,
      90427,
      158540,
      85051,
      183128,
      40864,
      27505,
      55392,
      9058,
      45224,
      96857,
      30901,
      136622,
      96557,
      56304,
      120061,
      11501,
      151448,
      5773,
      89743,
      7769,
      86069,
      2935,
      18471,
      41628,
      10114,
      33660,
      110170,
      49479,
      26745,
      92846,
      33221,
      26731,
      18795,
      87076,
      8550,
      2100,
      29972,
      120289,
      3077,
      72490,
      33784,
      2630,
      208722,
      50861,
      63483,
      79029,
      6419,
      39467,
      14302,
      45286,
      64207,
      9686,
      67513,
      44170,
      1050,
      77246,
      59266,
      17055,
      53801,
      7150,
      11111,
      42432,
      4278,
      94579,
      362117,
      36175,
      42902,
      41933,
      39002,
      98489,
      22913,
      74161,
      84773,
      57036,
      17556,
      162288,
      74485,
      178760,
      93867,
      73635,
      128860,
      50362,
      261,
      67455,
      80001,
      46080,
      35662,
      4368,
      25247,
      19230,
      74393,
      22588,
      1822,
      27682,
      235324,
      13798,
      85998,
      13194,
      235067,
      23514,
      71669,
      147632,
      23191,
      134748,
      214683,
      105101,
      1518,
      25489,
      247114,
      7380,
      54842,
      26922,
      3971,
      26361,
      20844,
      68642,
      170517,
      77339,
      123255,
      8963,
      77818,
      150998,
      48466,
      36806,
      2732,
      23261,
      11741,
      236162,
      18243,
      126216,
      28690,
      50546,
      16385,
      92760,
      197383,
      246558,
      201295,
      88255,
      67588,
      71687,
      176076,
      172653,
      169058,
      33906,
      63747,
      24835,
      157621,
      43338,
      30050,
      46152,
      132741,
      2770,
      51371,
      94835,
      6614,
      15112,
      11749,
      56936,
      1250,
      19027,
      399017,
      58036,
      100215,
      23388,
      55815,
      308768,
      124152,
      94803,
      9521,
      64186,
      8971,
      28,
      30427,
      62163,
      7616,
      103838,
      35079,
      29203,
      131235,
      7743,
      17389,
      10882,
      37420,
      61460,
      228512,
      85363,
      41581,
      131077,
      62822,
      119647,
      10130,
      54445,
      26925,
      19968,
      29016,
      24446,
      74028,
      24176,
      61448,
      67185,
      9254,
      8563,
      119129,
      9771,
      99184,
      37716,
      39514,
      10532,
      221512,
      258753,
      218630,
      55980,
      23394,
      32141,
      61924,
      66749,
      32411,
      3741,
      36475,
      26678,
      77010,
      44946,
      91203,
      128749,
      116953,
      20476,
      49625,
      53116,
      13735,
      102335,
      29376,
      51946,
      83407,
      67892,
      59212,
      34685,
      21083,
      1546,
      112982,
      32972,
      74397,
      1078,
      190545,
      16082,
      86140,
      58591,
      89611,
      101531,
      10061,
      105104,
      76319,
      20035,
      17551,
      52611,
      169061,
      190842,
      100780,
      23907,
      90413,
      115619,
      9675,
      34710,
      193435,
      49443,
      129734,
      11183,
      258877,
      16318,
      136182,
      126808,
      44635,
      27304,
      192375,
      2599,
      125648,
      47051,
      12091,
      23814,
      721,
      58800,
      40137,
      66726,
      97930,
      60877,
      74487,
      7942,
      54326,
      9841,
      41428,
      13762,
      8211,
      85383,
      6950,
      99177,
      79806,
      201786,
      296464,
      124087,
      13144,
      29741,
      41721,
      47634,
      55088,
      254286,
      106408,
      17041,
      99064,
      12942,
      64086,
      45233,
      14005,
      2612,
      55827,
      255,
      7984,
      13980,
      38574,
      12776,
      46654,
      73499,
      249951,
      2101,
      26676,
      25996,
      132326,
      116415,
      119062,
      50449,
      31033,
      23038,
      11589,
      179252,
      20007,
      14860,
      129270,
      21143,
      17796,
      144715,
      60106,
      70758,
      69842,
      34674,
      282133,
      44014,
      16774,
      57268,
      38528,
      24053,
      46373,
      201667,
      28327,
      471023,
      51889,
      102667,
      21193,
      114909,
      84132,
      69317,
      96723,
      67969,
      16134,
      68145,
      15058,
      28765,
      32035,
      2524,
      101089,
      98664,
      25045,
      76571,
      14957,
      86040,
      118506,
      262428,
      154764,
      81573,
      39681,
      283900,
      73287,
      127825,
      544,
      80448,
      52347,
      38512,
      175971,
      15180,
      45467,
      33086,
      46552,
      48894,
      81107,
      43213,
      36672,
      54025,
      76703,
      8053,
      7608,
      13299,
      56619,
      20752,
      238099,
      54164,
      105133,
      1444,
      32942,
      953,
      37564,
      8e3,
      66316,
      119463,
      106817,
      404,
      13667,
      149108,
      128597,
      31267,
      10269,
      49836,
      106150,
      1484,
      52330,
      76965,
      160486,
      171648,
      38456,
      31263,
      22424,
      37738,
      66245,
      67467,
      143369,
      60471,
      75610,
      20895,
      115528,
      86070,
      60854,
      40796,
      49347,
      18989,
      15030,
      11371,
      37578,
      15779,
      79867,
      10187,
      86462,
      46402,
      155626,
      93200,
      40229,
      7090,
      57547,
      108053,
      99598,
      11088,
      47505,
      41218,
      206017,
      2173,
      20988,
      30219,
      22919,
      80563,
      57566,
      42369,
      93141,
      41675,
      2407,
      182519,
      120495,
      27154,
      16702,
      29456,
      14349,
      7958,
      16688,
      117177,
      140375,
      42467,
      261919,
      74916,
      153569,
      10836,
      34742,
      49526,
      7621,
      105997,
      12212,
      2270,
      392377,
      7755,
      17959,
      25086,
      232152,
      138791,
      33847,
      13860,
      35316,
      5811,
      1344,
      71259,
      50452,
      207539,
      92635,
      50359,
      5821,
      33674,
      30255,
      2086,
      2587,
      96264,
      17543,
      42,
      6029,
      9580,
      43007,
      139248,
      82831,
      12917,
      29607,
      25786,
      51467,
      42137,
      85161,
      100698,
      31561,
      88989,
      121990,
      278500,
      3602,
      109344,
      37982,
      15279,
      116442,
      28936,
      30880,
      87894,
      58079,
      128661,
      126731,
      67392,
      28051,
      146885,
      4861,
      16216,
      97344,
      42827,
      147561,
      153948,
      22684,
      21335,
      47685,
      1853,
      43349,
      15185,
      59642,
      10229,
      25520,
      187921,
      108972,
      5579,
      98037,
      24945,
      6697,
      19193,
      63734,
      137934,
      75056,
      89740,
      19767,
      224268,
      56138,
      63643,
      151661,
      39313,
      70618,
      84031,
      89723,
      84074,
      13703,
      85626,
      35460,
      8867,
      64845,
      3439,
      57906,
      99776,
      63968,
      49270,
      81130,
      34356,
      16210,
      23547,
      36446,
      34090,
      140028,
      72439,
      2221,
      22163,
      57058,
      363492,
      113754,
      18913,
      95451,
      48663,
      54464,
      54037,
      176097,
      68425,
      3023,
      34906,
      29482,
      117389,
      341780,
      80431,
      58330,
      16753,
      92616,
      60907,
      94846,
      147486,
      4498,
      48646,
      7773,
      46801,
      7778,
      18946,
      464978,
      47558,
      33223,
      177444,
      7328,
      15626,
      63337,
      94700,
      11743,
      9351,
      255024,
      39098,
      16447,
      42647,
      96230,
      39769,
      58840,
      10068,
      63439,
      35800,
      65843,
      58823,
      413844,
      9156,
      51258,
      7434,
      61791,
      85018,
      6872,
      3692,
      28096,
      7121,
      33024,
      6009,
      75532,
      31997,
      192535,
      9661,
      3304,
      9547,
      14753,
      31987,
      25314,
      55689,
      15896,
      20430,
      39472,
      31340,
      99744,
      25398,
      115569,
      54883,
      28719,
      205423,
      23071,
      57855,
      64638,
      149867,
      25671,
      82403,
      37616,
      20668,
      39989,
      77996,
      74948,
      140555,
      175248,
      64810,
      36515,
      46595,
      4958,
      248773,
      24045,
      28728,
      136673,
      168704,
      20804,
      114833,
      100325,
      27135,
      21205,
      96151,
      153134,
      45992,
      7093,
      13992,
      76047,
      1980,
      19432,
      145001,
      75159,
      87462,
      17710,
      1013,
      45556,
      34297,
      144882,
      20648,
      26061,
      11319,
      129567,
      108555,
      18872,
      464580,
      33386,
      22717,
      65948,
      167189,
      5603,
      135042,
      79542,
      8801,
      202632,
      18114,
      91882,
      5973,
      5239,
      67315,
      4431,
      60916,
      47819,
      71693,
      32597,
      32606,
      18183,
      45072,
      80329,
      76385,
      24749,
      51305,
      40314,
      156514,
      14693,
      130345,
      13168,
      66214,
      18029,
      12858,
      34801,
      27628,
      14544,
      10823,
      40522,
      40185,
      33739,
      148694,
      23548,
      9923,
      61012,
      28859,
      17933,
      19442,
      34364,
      99849,
      164107,
      141167,
      30629,
      21054,
      6744,
      36491,
      8096,
      42474,
      41706,
      155060,
      30650,
      10600,
      163442,
      1143,
      96655,
      61390,
      52359,
      7559,
      51568,
      64256,
      203854,
      4467,
      22453,
      14504,
      436398,
      7878,
      6980,
      8293,
      63610,
      293747,
      16167,
      35763,
      19627,
      147603,
      15419,
      18032,
      110744,
      51346,
      33681,
      54571,
      40472,
      48615,
      39073,
      21604,
      13754,
      173027,
      92560,
      11083,
      47299,
      63062,
      11813,
      52007,
      29883,
      9734,
      139722,
      15953,
      1550,
      20651,
      13616,
      49306,
      16113,
      90089,
      92326,
      7584,
      30712,
      72424,
      164858,
      6831,
      152871,
      55746,
      197721,
      34167,
      196442,
      6022,
      112107,
      55215,
      7538,
      123381,
      4920,
      43539,
      77165,
      8939,
      50392,
      34192,
      20225,
      79762,
      22505,
      58667,
      40770,
      29788,
      97180,
      82835,
      4568,
      8579,
      13273,
      363569,
      35898,
      49983,
      436,
      36598,
      3237,
      131691,
      62418,
      35591,
      8101,
      4073,
      379438,
      65218,
      76072,
      33887,
      2968,
      27573,
      212619,
      288680,
      68278,
      72851,
      150504,
      217896,
      6913,
      121339,
      22017,
      35340,
      51072,
      43616,
      75043,
      31437,
      10833,
      81487,
      4364,
      22968,
      41454,
      106687,
      85446,
      19863,
      109625,
      149241,
      524,
      141850,
      214404,
      54376,
      657,
      237023,
      9401,
      108137,
      53800,
      32474,
      49712,
      53334,
      126876,
      27337,
      45552,
      177696,
      8269,
      15036,
      12097,
      42240,
      2328,
      125374,
      119295,
      99715,
      2500,
      19624,
      39441,
      27220,
      102691,
      60957,
      94543,
      39101,
      18566,
      67362,
      13975,
      78230,
      25017,
      34017,
      239007,
      90027,
      39351,
      41681,
      35354,
      43822,
      1043,
      916,
      58587,
      141983,
      94818,
      38799,
      75459,
      41114,
      67432,
      16195,
      36606,
      59568,
      22272,
      126769,
      31424,
      68659,
      12287,
      134302,
      257977,
      5756,
      207285,
      95637,
      47248,
      117689,
      19583,
      77451,
      22373,
      12200,
      54993,
      117118,
      34244,
      29386,
      34562,
      53819,
      71267,
      64172,
      77665,
      49368,
      7716,
      59301,
      25749,
      45426,
      194789,
      17297,
      2650,
      1766,
      32501,
      45198,
      20403,
      20984,
      6600,
      14171,
      94604,
      19037,
      5402,
      29896,
      9938,
      59935,
      109708,
      88081,
      145182,
      44844,
      39167,
      352626,
      164173,
      35374,
      45982,
      6122,
      154,
      73419,
      220487,
      53834,
      53601,
      17992,
      8609,
      229321,
      5610,
      68098,
      66815,
      71012,
      95069,
      140968,
      27396,
      8957,
      134489,
      24656,
      86659,
      56598,
      134852,
      17316,
      123838,
      255436,
      6613,
      41610,
      138033,
      81452,
      32023,
      32396,
      123687,
      63398,
      8693,
      29712,
      30407,
      19296,
      121188,
      3551,
      36099,
      20032,
      111948,
      56624,
      16547,
      27453,
      35916,
      15378,
      52039,
      56849,
      13489,
      22214,
      73177,
      53097,
      277349,
      2157,
      14029,
      187886,
      10260,
      141743,
      246460,
      91880,
      50869,
      3788,
      49486,
      133566,
      54950,
      33120,
      129337,
      53768,
      18333,
      9525,
      26902,
      312251,
      10297,
      9020,
      70759,
      16647,
      112432,
      59260,
      84609,
      9818,
      82766,
      73569,
      468,
      46001,
      75780,
      55028,
      52106,
      11498,
      43645,
      108069,
      17150,
      17753,
      29417,
      16705,
      31799,
      9606,
      289,
      122254,
      115975,
      8620,
      6133,
      255357,
      56908,
      14456,
      133464,
      43554,
      79224,
      11247,
      29630,
      160,
      12756,
      25464,
      65960,
      350428,
      62521,
      321796,
      100359,
      67358,
      35169,
      46172,
      113128,
      48988,
      88868,
      31094,
      33266,
      6847,
      60887,
      98188,
      49659,
      69117,
      92977,
      220228,
      13947,
      80181,
      35103,
      62170,
      97351,
      13475,
      2440,
      199768,
      19498,
      36597,
      46971,
      25234,
      67806,
      62881,
      84717,
      73648,
      181966,
      10488,
      94149,
      21550,
      26655,
      63436,
      48375,
      14405,
      165650,
      9621,
      24439,
      28043,
      42735,
      4490,
      29963,
      56674,
      45373,
      1934,
      262446,
      50855,
      67098,
      26898,
      5261,
      52696,
      40644,
      33900,
      9440,
      180286,
      87162,
      22940,
      19704,
      26936,
      69769,
      10254,
      101759,
      27406,
      12243,
      48e3,
      73926,
      113215,
      54935,
      5726,
      192787,
      4312,
      106216,
      9366,
      11550,
      52949,
      23457,
      212271,
      277152,
      133895,
      108374,
      6191,
      96477,
      29980,
      218916,
      58024,
      54696,
      40853,
      91124,
      65894,
      91170,
      65908,
      252552,
      6793,
      29212,
      15389,
      44516,
      122515,
      52617,
      35058,
      9017,
      103536,
      39510,
      49136,
      19242,
      130652,
      662077,
      74699,
      47024,
      31422,
      8517,
      73351,
      24399,
      13867,
      128360,
      4810,
      4434,
      61779,
      111983,
      61036,
      17798,
      110240,
      59722,
      102960,
      39688,
      10001,
      23803,
      23039,
      176498,
      56659,
      44814,
      134295,
      17188,
      77577,
      74466,
      226175,
      102472,
      154333,
      63900,
      111747,
      18062,
      41171,
      79669,
      32773,
      408933,
      42562,
      28931,
      30907,
      107388,
      43487,
      2946,
      240310,
      23938,
      24354,
      319,
      184983,
      7927,
      6488,
      1422,
      10790,
      68809,
      68209,
      64775,
      4361,
      202,
      17123,
      59634,
      51200,
      44391,
      18188,
      17843,
      2619,
      74278,
      3230,
      9540,
      47187,
      21702,
      36274,
      56894,
      43907,
      16310,
      34790,
      16866,
      6150,
      5561,
      13587,
      107545,
      108873,
      126867,
      86986,
      28640,
      33427,
      19017,
      5762,
      80637,
      17430,
      46903,
      2047,
      131055,
      25958,
      13558,
      5444,
      47152,
      13900,
      44563,
      122857,
      45348,
      70863,
      39593,
      54332,
      38068,
      33637,
      318,
      40310,
      143467,
      18502,
      24520,
      11377,
      62013,
      28942,
      27246,
      28269,
      83545,
      17999,
      59015,
      90707,
      30065,
      15161,
      34720,
      1263,
      37008,
      2012,
      6060,
      98575,
      92933,
      5721,
      299,
      199555,
      24578,
      29223,
      2985,
      743,
      115825,
      109523,
      136657,
      47454,
      26378,
      53586,
      3733,
      174945,
      93340,
      244456,
      5693,
      37386,
      28782,
      89767,
      27545,
      23573,
      18798,
      136425,
      34320,
      84778,
      20041,
      48453,
      38215,
      7477,
      71958,
      40621,
      8773,
      5874,
      187927,
      105965,
      51100,
      43533,
      18083,
      8443,
      10180,
      43597,
      2003,
      183999,
      69689,
      12216,
      129696,
      146188,
      62389,
      34044,
      68410,
      12765,
      43273,
      26949,
      266807,
      3345,
      34477,
      79197,
      5688,
      47539,
      213110,
      21634,
      22257,
      50092,
      32222,
      42346,
      39530,
      63668,
      98,
      134978,
      74022,
      5152,
      59088,
      174145,
      37220,
      9934,
      9545,
      118937,
      5724,
      87240,
      19875,
      15784,
      40143,
      23263,
      87513,
      181654,
      285152,
      37881,
      263241,
      4966,
      43934,
      10433,
      186657,
      6470,
      74416,
      225854,
      25908,
      142677,
      246262,
      32280,
      6192,
      75890,
      45546,
      143264,
      135305,
      29742,
      47013,
      77787,
      11732,
      126658,
      8763,
      37950,
      21806,
      57557,
      113464,
      89465,
      108995,
      164574,
      23894,
      22996,
      23169,
      15369,
      23117,
      17642,
      130607,
      40503,
      36239,
      280990,
      44666,
      9981,
      40427,
      147487,
      26869,
      168452,
      32886,
      32991,
      46798,
      240839,
      15111,
      70502,
      65697,
      88548,
      44145,
      28701,
      48767,
      31139,
      206777,
      35659,
      181164,
      166262,
      14554,
      171445,
      31786,
      66523,
      76607,
      17956,
      6507,
      31279,
      90476,
      116611,
      167918,
      6560,
      1243,
      115324,
      80128,
      41867,
      55897,
      187323,
      37069,
      32596,
      189444,
      145931,
      13390,
      105530,
      65709,
      26805,
      6999,
      55714,
      41300,
      22915,
      68951,
      22138,
      21120,
      22264,
      10058,
      19945,
      33635,
      56123,
      99085,
      10032,
      5818,
      6016,
      46649,
      57476,
      35264,
      94413,
      112522,
      262288,
      93686,
      83038,
      14341,
      23204,
      28807,
      66084,
      77987,
      6101,
      126673,
      7133,
      38126,
      5923,
      122091,
      170240,
      97772,
      46874,
      215746,
      43948,
      41622,
      3272,
      55596,
      8332,
      146411,
      251315,
      13533,
      8561,
      81521,
      115449,
      48616,
      175175,
      2063,
      186556,
      3036,
      134537,
      75772,
      29728,
      82360,
      22973,
      186559,
      86348,
      89100,
      38388,
      82297,
      45610,
      2613,
      87082,
      9986,
      177812,
      57884,
      23591,
      47485,
      42543,
      33582,
      44713,
      74439,
      257444,
      252451,
      31825,
      35631,
      38540,
      33066,
      5147,
      13973,
      4343,
      51830,
      70378,
      22827,
      26448,
      95560,
      36896,
      241741,
      48067,
      203953,
      298860,
      61620,
      20450,
      3220,
      67272,
      6586,
      107662,
      100160,
      108684,
      6929,
      57226,
      4762,
      7457,
      1320,
      40404,
      77204,
      99309,
      62750,
      208653,
      59977,
      44e3,
      74315,
      34332,
      5819,
      172217,
      64904,
      114077,
      18147,
      84012,
      1791,
      98456,
      90930,
      21446,
      116669,
      103938,
      7422,
      85140,
      59713,
      5768,
      326211,
      16239,
      75411,
      13229,
      29398,
      10758,
      236107,
      1539,
      112472,
      95979,
      152154,
      151294,
      306,
      21196,
      38146,
      10700,
      6891,
      84282,
      109646,
      56492,
      40539,
      6589,
      119491,
      51354,
      30685,
      140209,
      136906,
      29622,
      73617,
      49553,
      70525,
      51671,
      166869,
      139616,
      74395,
      37439,
      49595,
      45678,
      11959,
      33211,
      86560,
      52434,
      9282,
      62690,
      112155,
      130810,
      5243,
      108261,
      99970,
      265613,
      72551,
      80049,
      6391,
      33365,
      90721,
      66737,
      69872,
      87011,
      1860,
      9032,
      112544,
      60905,
      37371,
      89015,
      140351,
      19076,
      850,
      373531,
      2802,
      36725,
      218795,
      72062,
      28990,
      16550,
      24614,
      7815,
      6187,
      26336,
      33373,
      32162,
      42791,
      73555,
      32062,
      23386,
      10244,
      56392,
      49442,
      27076,
      136262,
      12412,
      14883,
      1134,
      33675,
      97153,
      199281,
      15608,
      100152,
      74072,
      47942,
      254301,
      36451,
      16026,
      10687,
      65067,
      56708,
      254030,
      30290,
      50490,
      13864,
      57941,
      259331,
      35588,
      23485,
      43486,
      24869,
      21620,
      92971,
      22072,
      88645,
      1048,
      182050,
      13343,
      32452,
      14825,
      19509,
      3325,
      216938,
      45740,
      99716,
      189082,
      53740,
      78245,
      25609,
      24311,
      176777,
      47340,
      308354,
      40669,
      66085,
      14102,
      125339,
      9225,
      128709,
      97207,
      1271,
      200933,
      78439,
      113451,
      88975,
      18324,
      46521,
      11819,
      18570,
      141756,
      72512,
      170020,
      52754,
      63550,
      118515,
      103073,
      93330,
      32736,
      50499,
      14722,
      31600,
      68452,
      398867,
      29316,
      172786,
      18417,
      104924,
      2606,
      5670,
      84818,
      16288,
      67106,
      59580,
      82929,
      607401,
      291,
      85829,
      359,
      15897,
      35830,
      50696,
      65630,
      52672,
      22115,
      356968,
      29895,
      40837,
      231192,
      34024,
      38957,
      26722,
      406,
      23335,
      124952,
      72068,
      68804,
      13268,
      147101,
      164740,
      276569,
      162596,
      66943,
      11569,
      26654,
      66358,
      4777,
      23229,
      102127,
      5848,
      978,
      2921,
      59666,
      5371,
      28212,
      90108,
      42938,
      39320,
      2499,
      4271,
      108792,
      33510,
      125072,
      71653,
      65239,
      38250,
      66357,
      38577,
      13964,
      86251,
      35708,
      50755,
      36010,
      29448,
      12209,
      3844,
      38222,
      206337,
      100876,
      67827,
      137088,
      14167,
      252225,
      84163,
      195270,
      1306,
      5703,
      54198,
      779,
      46802,
      22028,
      51124,
      86759,
      70560,
      113164,
      35685,
      162145,
      45471,
      34561,
      422,
      2611,
      6464,
      47486,
      19223,
      38246,
      9191,
      18331,
      89942,
      243642,
      212364,
      15893,
      17518,
      22617,
      6409,
      30046,
      126182,
      59716,
      36560,
      104428,
      18846,
      26592,
      19458,
      50793,
      147333,
      30826,
      1388,
      27647,
      10922,
      14495,
      33545,
      19269,
      135828,
      39727,
      41601,
      46931,
      233379,
      49169,
      131130,
      182112,
      16276,
      82381,
      118209,
      142445,
      128310,
      19672,
      28740,
      82907,
      33436,
      3118,
      102206,
      28723,
      24819,
      41937,
      38854,
      5157,
      3881,
      111491,
      1142,
      9776,
      421673,
      152241,
      29309,
      14961,
      87854,
      6054,
      15424,
      3796,
      82656,
      54996,
      2108,
      55367,
      239450,
      154525,
      9643,
      118103,
      106041,
      64601,
      68549,
      48707,
      30266,
      25772,
      18740,
      9462,
      229669,
      91798,
      112152,
      191327,
      14493,
      72828,
      8175,
      66636,
      236474,
      25817,
      87351,
      129027,
      76653,
      20422,
      22983,
      71240,
      27846,
      44661,
      12399,
      46158,
      77704,
      53101,
      35032,
      11072,
      17300,
      109294,
      33638,
      24408,
      1895,
      11241,
      760,
      17584,
      82479,
      125877,
      63150,
      141075,
      34259,
      23274,
      81698,
      15732,
      43577,
      48340,
      91584,
      14688,
      16379,
      24481,
      150280,
      96420,
      262050,
      48635,
      43727,
      61819,
      56268,
      72003,
      88178,
      17281,
      79912,
      13218,
      122519,
      125295,
      166396,
      11811,
      2171,
      118930,
      67746,
      17636,
      178278,
      174656,
      95661,
      173039,
      83845,
      79689,
      17473,
      98555,
      127696,
      203415,
      54730,
      22925,
      232239,
      9309,
      12136,
      175026,
      20740,
      180188,
      10747,
      39816,
      314017,
      266131,
      10040,
      175732,
      112550,
      220651,
      31974,
      37393,
      888,
      23008,
      86799,
      4303,
      64905,
      148467,
      75337,
      251,
      3284,
      370102,
      50264,
      9835,
      5438,
      23655,
      4481,
      29851,
      329,
      12855,
      7162,
      64931,
      78141,
      12804,
      42372,
      296771,
      83547,
      18624,
      34874,
      86271,
      3360,
      48665,
      77735,
      88767,
      11463,
      63527,
      28889,
      22258,
      29140,
      194315,
      113924,
      25499,
      6406,
      31334,
      1845,
      4802,
      49184,
      43455,
      35469,
      127594,
      92970,
      61038,
      115005,
      38840,
      87761,
      106838,
      8811,
      20572,
      55637,
      11162,
      96721,
      132425,
      108925,
      2948,
      125457,
      36356,
      3502,
      75270,
      27622,
      127192,
      2561,
      123095,
      49394,
      61155,
      16897,
      110064,
      9699,
      89448,
      53356,
      19628,
      220310,
      21622,
      83036,
      9885,
      112214,
      6087,
      26713,
      17901,
      161912,
      91492,
      3440,
      68594,
      9266,
      92238,
      8087,
      6866,
      150194,
      72175,
      80701,
      13459,
      31836,
      43243,
      239700,
      95846,
      44749,
      50647,
      21945,
      230538,
      120612,
      132371,
      244604,
      5193,
      105637,
      34661,
      41341,
      68775,
      85393,
      1874,
      8771,
      33718,
      49672,
      77403,
      595452,
      99507,
      6490,
      58895,
      128742,
      7704,
      39239,
      73217,
      43816,
      62824,
      37804,
      199976,
      22361,
      80005,
      87514,
      94832,
      14089,
      4574,
      139975,
      59142,
      75523,
      100268,
      43906,
      53442,
      15152,
      2547,
      186002,
      17011,
      19513,
      204282,
      3343,
      60568,
      128318,
      119250,
      4298,
      51871,
      41336,
      71759,
      21921,
      45074,
      98169,
      145889,
      99427,
      11350,
      1237,
      5520,
      28799,
      7803,
      53702,
      21026,
      136352,
      38293,
      128690,
      12158,
      90132,
      44600,
      10184,
      26957,
      39459,
      126025,
      78904,
      82999,
      59373,
      39301,
      150198,
      120529,
      153042,
      20177,
      50089,
      14764,
      271571,
      30530,
      123161,
      38975,
      101562,
      22941,
      5648,
      124654,
      109243,
      69817,
      71675,
      49162,
      106884,
      21241,
      107795,
      30258,
      16572,
      188262,
      141456,
      7688,
      60718,
      8271,
      11044,
      32440,
      104608,
      103419,
      236109,
      93156,
      43293,
      128929,
      42107,
      67180,
      25201,
      115254,
      185488,
      130954,
      72813,
      167547,
      20537,
      39969,
      38432,
      22582,
      184022,
      1139,
      27199,
      5655,
      17767,
      97412,
      122606,
      209377,
      27070,
      35871,
      326617,
      188954,
      42680,
      73512,
      80911,
      22629,
      3011,
      95021,
      315242,
      157737,
      383,
      41821,
      41808,
      19335,
      27950,
      15674,
      25677,
      110950,
      35375,
      76835,
      59108,
      57370,
      35262,
      16569,
      160415,
      37706,
      78086,
      32041,
      49691,
      137143,
      9782,
      172080,
      50148,
      77917,
      6323,
      10110,
      69172,
      17711,
      21795,
      59511,
      76184,
      135114,
      31046,
      132319,
      59105,
      157578,
      20549,
      80778,
      57649,
      158421,
      65143,
      4575,
      72235,
      21899,
      10797,
      92745,
      34035,
      106079,
      80159,
      4508,
      78304,
      25350,
      75457,
      46458,
      32937,
      25623,
      47,
      8531,
      104751,
      84953,
      8138,
      36508,
      187199,
      66310,
      115274,
      13253,
      32461,
      38536,
      1916,
      42007,
      187160,
      35055,
      26325,
      84394,
      35963,
      94216,
      45590,
      97782
    ];
  }
});

// node_modules/indent-string/index.js
var require_indent_string = __commonJS({
  "node_modules/indent-string/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = (string3, count = 1, options) => {
      options = {
        indent: " ",
        includeEmptyLines: false,
        ...options
      };
      if (typeof string3 !== "string") {
        throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string3}\``);
      }
      if (typeof count !== "number") {
        throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
      }
      if (typeof options.indent !== "string") {
        throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
      }
      if (count === 0) {
        return string3;
      }
      const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
      return string3.replace(regex, options.indent.repeat(count));
    };
  }
});

// (disabled):os
var require_os = __commonJS({
  "(disabled):os"() {
    init_node_globals();
  }
});

// node_modules/clean-stack/index.js
var require_clean_stack = __commonJS({
  "node_modules/clean-stack/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var os = require_os();
    var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
    var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
    var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
    module2.exports = (stack, options) => {
      options = Object.assign({ pretty: false }, options);
      return stack.replace(/\\/g, "/").split("\n").filter((line) => {
        const pathMatches = line.match(extractPathRegex);
        if (pathMatches === null || !pathMatches[1]) {
          return true;
        }
        const match = pathMatches[1];
        if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
          return false;
        }
        return !pathRegex.test(match);
      }).filter((line) => line.trim() !== "").map((line) => {
        if (options.pretty) {
          return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
        }
        return line;
      }).join("\n");
    };
  }
});

// node_modules/aggregate-error/index.js
var require_aggregate_error = __commonJS({
  "node_modules/aggregate-error/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var indentString = require_indent_string();
    var cleanStack = require_clean_stack();
    var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
    var AggregateError2 = class extends Error {
      constructor(errors2) {
        if (!Array.isArray(errors2)) {
          throw new TypeError(`Expected input to be an Array, got ${typeof errors2}`);
        }
        errors2 = [...errors2].map((error) => {
          if (error instanceof Error) {
            return error;
          }
          if (error !== null && typeof error === "object") {
            return Object.assign(new Error(error.message), error);
          }
          return new Error(error);
        });
        let message = errors2.map((error) => {
          return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
        }).join("\n");
        message = "\n" + indentString(message, 4);
        super(message);
        this.name = "AggregateError";
        Object.defineProperty(this, "_errors", { value: errors2 });
      }
      *[Symbol.iterator]() {
        for (const error of this._errors) {
          yield error;
        }
      }
    };
    module2.exports = AggregateError2;
  }
});

// node_modules/p-map/index.js
var require_p_map = __commonJS({
  "node_modules/p-map/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var AggregateError2 = require_aggregate_error();
    module2.exports = async (iterable, mapper, {
      concurrency = Infinity,
      stopOnError = true
    } = {}) => {
      return new Promise((resolve6, reject) => {
        if (typeof mapper !== "function") {
          throw new TypeError("Mapper function is required");
        }
        if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
          throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
        }
        const result = [];
        const errors2 = [];
        const iterator = iterable[Symbol.iterator]();
        let isRejected = false;
        let isIterableDone = false;
        let resolvingCount = 0;
        let currentIndex = 0;
        const next = () => {
          if (isRejected) {
            return;
          }
          const nextItem = iterator.next();
          const index = currentIndex;
          currentIndex++;
          if (nextItem.done) {
            isIterableDone = true;
            if (resolvingCount === 0) {
              if (!stopOnError && errors2.length !== 0) {
                reject(new AggregateError2(errors2));
              } else {
                resolve6(result);
              }
            }
            return;
          }
          resolvingCount++;
          (async () => {
            try {
              const element = await nextItem.value;
              result[index] = await mapper(element, index);
              resolvingCount--;
              next();
            } catch (error) {
              if (stopOnError) {
                isRejected = true;
                reject(error);
              } else {
                errors2.push(error);
                resolvingCount--;
                next();
              }
            }
          })();
        };
        for (let i = 0; i < concurrency; i++) {
          next();
          if (isIterableDone) {
            break;
          }
        }
      });
    };
  }
});

// node_modules/libp2p-kad-dht/src/utils.js
var require_utils15 = __commonJS({
  "node_modules/libp2p-kad-dht/src/utils.js"(exports2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
    var { base58btc: base58btc2 } = (init_base58(), base58_exports);
    var { Key: Key2 } = (init_key(), key_exports);
    var { xor: uint8ArrayXor } = (init_xor(), xor_exports);
    var { compare: uint8ArrayCompare } = (init_compare(), compare_exports);
    var pMap = require_p_map();
    var { Record } = require_src8();
    var PeerId2 = require_src6();
    var errcode7 = require_err_code();
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { concat: uint8ArrayConcat } = (init_concat(), concat_exports);
    var pTimeout = require_p_timeout2();
    exports2.convertBuffer = async (buf2) => {
      return (await sha2562.digest(buf2)).digest;
    };
    exports2.convertPeerId = async (peer) => {
      return (await sha2562.digest(peer.id)).digest;
    };
    exports2.bufferToKey = (buf2) => {
      return new Key2("/" + exports2.encodeBase32(buf2), false);
    };
    exports2.keyForPublicKey = (peer) => {
      return uint8ArrayConcat([
        uint8ArrayFromString("/pk/"),
        peer.id
      ]);
    };
    exports2.isPublicKeyKey = (key) => {
      return uint8ArrayToString(key.slice(0, 4)) === "/pk/";
    };
    exports2.fromPublicKeyKey = (key) => {
      return new PeerId2(key.slice(4));
    };
    exports2.now = () => {
      return Date.now();
    };
    exports2.encodeBase32 = (buf2) => {
      return uint8ArrayToString(buf2, "base32");
    };
    exports2.decodeBase32 = (raw7) => {
      return uint8ArrayFromString(raw7, "base32");
    };
    exports2.sortClosestPeers = async (peers, target) => {
      const distances = await pMap(peers, async (peer) => {
        const id = await exports2.convertPeerId(peer);
        return {
          peer,
          distance: uint8ArrayXor(id, target)
        };
      });
      return distances.sort(exports2.xorCompare).map((d) => d.peer);
    };
    exports2.xorCompare = (a, b) => {
      return uint8ArrayCompare(a.distance, b.distance);
    };
    exports2.pathSize = (resultsWanted, numPaths) => {
      return Math.ceil(resultsWanted / numPaths);
    };
    exports2.createPutRecord = (key, value) => {
      const timeReceived = new Date();
      const rec = new Record(key, value, timeReceived);
      return rec.serialize();
    };
    exports2.logger = (id, subsystem) => {
      const name5 = ["libp2p", "dht"];
      if (subsystem) {
        name5.push(subsystem);
      }
      if (id) {
        name5.push(`${id.toB58String().slice(0, 8)}`);
      }
      debug17.formatters.b = (v) => {
        return base58btc2.baseEncode(v);
      };
      const logger2 = Object.assign(debug17(name5.join(":")), {
        error: debug17(name5.concat(["error"]).join(":"))
      });
      return logger2;
    };
    exports2.TimeoutError = class TimeoutError extends Error {
      get code() {
        return "ETIMEDOUT";
      }
    };
    exports2.withTimeout = (asyncFn, time) => {
      async function timeoutFn(...args) {
        if (!time) {
          return asyncFn(...args);
        }
        let res;
        try {
          res = await pTimeout(asyncFn(...args), time);
        } catch (err) {
          if (err instanceof pTimeout.TimeoutError) {
            throw errcode7(err, "ETIMEDOUT");
          }
          throw err;
        }
        return res;
      }
      return timeoutFn;
    };
    exports2.mapParallel = async function(asyncIterator, asyncFn) {
      const tasks = [];
      for await (const item of asyncIterator) {
        tasks.push(asyncFn(item));
      }
      return Promise.all(tasks);
    };
  }
});

// node_modules/libp2p-kad-dht/src/routing-table/index.js
var require_routing_table = __commonJS({
  "node_modules/libp2p-kad-dht/src/routing-table/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var KBuck = require_k_bucket();
    var { xor: uint8ArrayXor } = (init_xor(), xor_exports);
    var GENERATED_PREFIXES = require_generated_prefix_list_browser();
    var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
    var crypto3 = require_src7();
    var PeerId2 = require_src6();
    var utils = require_utils15();
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:dht:routing-table"), {
      error: debug17("libp2p:dht:routing-table:error")
    });
    var length4 = require_it_length();
    var MAX_COMMON_PREFIX_LENGTH = 15;
    var RoutingTable = class {
      constructor(dht, { kBucketSize, refreshInterval } = {}) {
        this.peerId = dht.peerId;
        this.dht = dht;
        this._kBucketSize = kBucketSize || 20;
        this._refreshInterval = refreshInterval || 3e4;
        this.kb = new KBuck({
          numberOfNodesPerKBucket: this._kBucketSize,
          numberOfNodesToPing: 1
        });
        this.commonPrefixLengthRefreshedAt = [];
        this._refreshTable = this._refreshTable.bind(this);
        this._onPing = this._onPing.bind(this);
      }
      async start() {
        this.kb.localNodeId = await utils.convertPeerId(this.peerId);
        this.kb.on("ping", this._onPing);
        await this._refreshTable(true);
      }
      async stop() {
        if (this._refreshTimeoutId) {
          clearTimeout(this._refreshTimeoutId);
        }
      }
      async _refreshTable(force) {
        log15("refreshing routing table");
        const prefixLength = this._maxCommonPrefix();
        const refreshCpls = this._getTrackedCommonPrefixLengthsForRefresh(prefixLength);
        log15(`max common prefix length ${prefixLength}`);
        log15(`tracked CPLs [ ${refreshCpls.map((date) => `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, "0")}-${date.getDate().toString().padStart(2, "0")} ${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}:${date.getSeconds().toString().padStart(2, "0")}`).join(", ")} ]`);
        await Promise.all(refreshCpls.map(async (lastRefresh, index) => {
          try {
            await this._refreshCommonPrefixLength(index, lastRefresh, force === true);
            if (this._numPeersForCpl(prefixLength) === 0) {
              const lastCpl = Math.min(2 * (index + 1), refreshCpls.length - 1);
              for (let n = index + 1; n < lastCpl + 1; n++) {
                try {
                  await this._refreshCommonPrefixLength(n, lastRefresh, force === true);
                } catch (err) {
                  log15.error(err);
                }
              }
            }
          } catch (err) {
            log15.error(err);
          }
        }));
        this._refreshTimeoutId = setTimeout(this._refreshTable, this._refreshInterval);
        this._refreshTimeoutId.unref();
      }
      async _refreshCommonPrefixLength(cpl, lastRefresh, force) {
        if (!force && lastRefresh.getTime() > Date.now() - this._refreshInterval) {
          log15(`not running refresh for cpl ${cpl} as time since last refresh not above interval`);
          return;
        }
        const peerId = await this._generateRandomPeerId(cpl);
        log15(`starting refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`);
        const peers = await length4(this.dht.getClosestPeers(peerId.toBytes(), {}));
        log15(`found ${peers} peers that were close to imaginary peer ${peerId.toB58String()}`);
        log15(`finished refreshing cpl ${cpl} with key ${peerId.toB58String()} (routing table size was ${this.kb.count()})`);
      }
      _getTrackedCommonPrefixLengthsForRefresh(maxCommonPrefix) {
        if (maxCommonPrefix > MAX_COMMON_PREFIX_LENGTH) {
          maxCommonPrefix = MAX_COMMON_PREFIX_LENGTH;
        }
        const dates = [];
        for (let i = 0; i <= maxCommonPrefix; i++) {
          dates[i] = this.commonPrefixLengthRefreshedAt[i] || new Date();
        }
        return dates;
      }
      async _generateRandomPeerId(targetCommonPrefixLength) {
        const randomBytes = crypto3.randomBytes(2);
        const randomUint16 = (randomBytes[1] << 8) + randomBytes[0];
        const key = await this._makePeerId(this.kb.localNodeId, randomUint16, targetCommonPrefixLength);
        return PeerId2.createFromBytes(key);
      }
      async _makePeerId(localKadId, randomPrefix, targetCommonPrefixLength) {
        if (targetCommonPrefixLength > MAX_COMMON_PREFIX_LENGTH) {
          throw new Error(`Cannot generate peer ID for common prefix length greater than ${MAX_COMMON_PREFIX_LENGTH}`);
        }
        const view = new DataView(localKadId.buffer, localKadId.byteOffset, localKadId.byteLength);
        const localPrefix = view.getUint16(0, false);
        const toggledLocalPrefix = localPrefix ^ 32768 >> targetCommonPrefixLength;
        const mask = 65535 << 16 - (targetCommonPrefixLength + 1);
        const targetPrefix = toggledLocalPrefix & mask | randomPrefix & ~mask;
        const keyPrefix = GENERATED_PREFIXES[targetPrefix];
        const keyBuffer = new ArrayBuffer(34);
        const keyView = new DataView(keyBuffer, 0, keyBuffer.byteLength);
        keyView.setUint8(0, sha2562.code);
        keyView.setUint8(1, 32);
        keyView.setUint32(2, keyPrefix, false);
        return new Uint8Array(keyView.buffer, keyView.byteOffset, keyView.byteLength);
      }
      _maxCommonPrefix() {
        if (!this.kb.localNodeId) {
          return 0;
        }
        let prefixLength = 0;
        for (const length5 of this._prefixLengths()) {
          if (length5 > prefixLength) {
            prefixLength = length5;
          }
        }
        return prefixLength;
      }
      _numPeersForCpl(prefixLength) {
        let count = 0;
        for (const length5 of this._prefixLengths()) {
          if (length5 === prefixLength) {
            count++;
          }
        }
        return count;
      }
      *_prefixLengths() {
        for (const { id } of this.kb.toIterable()) {
          const distance = uint8ArrayXor(this.kb.localNodeId, id);
          let leadingZeros = 0;
          for (const byte of distance) {
            if (byte === 0) {
              leadingZeros++;
            } else {
              break;
            }
          }
          yield leadingZeros;
        }
      }
      _onPing(oldContacts, newContact) {
        const oldest = oldContacts[0];
        if (oldest) {
          this.kb.remove(oldest.id);
        }
        this.kb.add(newContact);
      }
      get size() {
        return this.kb.count();
      }
      async find(peer) {
        const key = await utils.convertPeerId(peer);
        const closest = this.closestPeer(key);
        if (closest && peer.equals(closest)) {
          return closest;
        }
      }
      closestPeer(key) {
        const res = this.closestPeers(key, 1);
        if (res.length > 0) {
          return res[0];
        }
      }
      closestPeers(key, count) {
        const closest = this.kb.closest(key, count);
        return closest.map((p) => p.peer);
      }
      async add(peer) {
        const id = await utils.convertPeerId(peer);
        this.kb.add({ id, peer });
      }
      async remove(peer) {
        const id = await utils.convertPeerId(peer);
        this.kb.remove(id);
      }
    };
    module2.exports = RoutingTable;
  }
});

// node_modules/libp2p-kad-dht/src/constants.js
var require_constants10 = __commonJS({
  "node_modules/libp2p-kad-dht/src/constants.js"(exports2) {
    init_node_globals();
    "use strict";
    var second = exports2.second = 1e3;
    var minute = exports2.minute = 60 * second;
    var hour = exports2.hour = 60 * minute;
    exports2.MAX_RECORD_AGE = 36 * hour;
    exports2.PROTOCOL_DHT = "/kad/1.0.0";
    exports2.PROVIDERS_KEY_PREFIX = "/providers/";
    exports2.PROVIDERS_LRU_CACHE_SIZE = 256;
    exports2.PROVIDERS_VALIDITY = 24 * hour;
    exports2.PROVIDERS_CLEANUP_INTERVAL = hour;
    exports2.READ_MESSAGE_TIMEOUT = 10 * second;
    exports2.GET_MANY_RECORD_COUNT = 16;
    exports2.K = 20;
    exports2.ALPHA = 3;
  }
});

// node_modules/streaming-iterables/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/streaming-iterables/dist/index.js"(exports2, module2) {
    init_node_globals();
    (function(global2, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, factory(global2.streamingIterables = {}));
    })(exports2, function(exports3) {
      "use strict";
      async function* _batch(size, iterable) {
        let dataBatch = [];
        for await (const data of iterable) {
          dataBatch.push(data);
          if (dataBatch.length === size) {
            yield dataBatch;
            dataBatch = [];
          }
        }
        if (dataBatch.length > 0) {
          yield dataBatch;
        }
      }
      function* _syncBatch(size, iterable) {
        let dataBatch = [];
        for (const data of iterable) {
          dataBatch.push(data);
          if (dataBatch.length === size) {
            yield dataBatch;
            dataBatch = [];
          }
        }
        if (dataBatch.length > 0) {
          yield dataBatch;
        }
      }
      function batch3(size, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => batch3(size, curriedIterable);
        }
        if (iterable[Symbol.asyncIterator]) {
          return _batch(size, iterable);
        }
        return _syncBatch(size, iterable);
      }
      function getIterator(iterable) {
        if (typeof iterable.next === "function") {
          return iterable;
        }
        if (typeof iterable[Symbol.iterator] === "function") {
          return iterable[Symbol.iterator]();
        }
        if (typeof iterable[Symbol.asyncIterator] === "function") {
          return iterable[Symbol.asyncIterator]();
        }
        throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols');
      }
      function defer() {
        let reject;
        let resolve6;
        const promise = new Promise((resolveFunc, rejectFunc) => {
          resolve6 = resolveFunc;
          reject = rejectFunc;
        });
        return {
          promise,
          reject,
          resolve: resolve6
        };
      }
      function _buffer(size, iterable) {
        const iterator = getIterator(iterable);
        const resultQueue = [];
        const readQueue = [];
        let reading = false;
        let ended = false;
        function fulfillReadQueue() {
          while (readQueue.length > 0 && resultQueue.length > 0) {
            const readDeferred = readQueue.shift();
            const { error, value } = resultQueue.shift();
            if (error) {
              readDeferred.reject(error);
            } else {
              readDeferred.resolve({ done: false, value });
            }
          }
          while (readQueue.length > 0 && ended) {
            const { resolve: resolve6 } = readQueue.shift();
            resolve6({ done: true, value: void 0 });
          }
        }
        async function fillQueue() {
          if (ended) {
            return;
          }
          if (reading) {
            return;
          }
          if (resultQueue.length >= size) {
            return;
          }
          reading = true;
          try {
            const { done, value } = await iterator.next();
            if (done) {
              ended = true;
            } else {
              resultQueue.push({ value });
            }
          } catch (error) {
            ended = true;
            resultQueue.push({ error });
          }
          fulfillReadQueue();
          reading = false;
          fillQueue();
        }
        async function next() {
          if (resultQueue.length > 0) {
            const { error, value } = resultQueue.shift();
            if (error) {
              throw error;
            }
            fillQueue();
            return { done: false, value };
          }
          if (ended) {
            return { done: true, value: void 0 };
          }
          const deferred = defer();
          readQueue.push(deferred);
          fillQueue();
          return deferred.promise;
        }
        const asyncIterableIterator = {
          next,
          [Symbol.asyncIterator]: () => asyncIterableIterator
        };
        return asyncIterableIterator;
      }
      function* syncBuffer(size, iterable) {
        const valueQueue = [];
        let e;
        try {
          for (const value of iterable) {
            valueQueue.push(value);
            if (valueQueue.length <= size) {
              continue;
            }
            yield valueQueue.shift();
          }
        } catch (error) {
          e = error;
        }
        for (const value of valueQueue) {
          yield value;
        }
        if (e) {
          throw e;
        }
      }
      function buffer2(size, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => buffer2(size, curriedIterable);
        }
        if (size === 0) {
          return iterable;
        }
        if (iterable[Symbol.asyncIterator]) {
          return _buffer(size, iterable);
        }
        return syncBuffer(size, iterable);
      }
      async function _collect(iterable) {
        const values = [];
        for await (const value of iterable) {
          values.push(value);
        }
        return values;
      }
      function collect(iterable) {
        if (iterable[Symbol.asyncIterator]) {
          return _collect(iterable);
        }
        return Array.from(iterable);
      }
      async function* _concat(iterables) {
        for await (const iterable of iterables) {
          yield* iterable;
        }
      }
      function* _syncConcat(iterables) {
        for (const iterable of iterables) {
          yield* iterable;
        }
      }
      function concat3(...iterables) {
        const hasAnyAsync = iterables.find((itr) => itr[Symbol.asyncIterator] !== void 0);
        if (hasAnyAsync) {
          return _concat(iterables);
        } else {
          return _syncConcat(iterables);
        }
      }
      async function _consume(iterable) {
        for await (const val of iterable) {
        }
      }
      function consume(iterable) {
        if (iterable[Symbol.asyncIterator]) {
          return _consume(iterable);
        }
        for (const val of iterable) {
        }
      }
      async function* _filter(filterFunc, iterable) {
        for await (const data of iterable) {
          if (await filterFunc(data)) {
            yield data;
          }
        }
      }
      function filter8(filterFunc, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => _filter(filterFunc, curriedIterable);
        }
        return _filter(filterFunc, iterable);
      }
      async function* flatten2(iterable) {
        for await (const maybeItr of iterable) {
          if (maybeItr && typeof maybeItr !== "string" && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {
            yield* flatten2(maybeItr);
          } else {
            yield maybeItr;
          }
        }
      }
      async function* _map(func, iterable) {
        for await (const val of iterable) {
          yield await func(val);
        }
      }
      function map8(func, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => _map(func, curriedIterable);
        }
        return _map(func, iterable);
      }
      function flatMap(func, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => flatMap(func, curriedIterable);
        }
        return filter8((i) => i !== void 0 && i !== null, flatten2(map8(func, iterable)));
      }
      function _flatTransform(concurrency, func, iterable) {
        const iterator = getIterator(iterable);
        const resultQueue = [];
        const readQueue = [];
        let ended = false;
        let reading = false;
        let inflightCount = 0;
        let lastError = null;
        function fulfillReadQueue() {
          while (readQueue.length > 0 && resultQueue.length > 0) {
            const { resolve: resolve6 } = readQueue.shift();
            const value = resultQueue.shift();
            resolve6({ done: false, value });
          }
          while (readQueue.length > 0 && inflightCount === 0 && ended) {
            const { resolve: resolve6, reject } = readQueue.shift();
            if (lastError) {
              reject(lastError);
              lastError = null;
            } else {
              resolve6({ done: true, value: void 0 });
            }
          }
        }
        async function fillQueue() {
          if (ended) {
            fulfillReadQueue();
            return;
          }
          if (reading) {
            return;
          }
          if (inflightCount + resultQueue.length >= concurrency) {
            return;
          }
          reading = true;
          inflightCount++;
          try {
            const { done, value } = await iterator.next();
            if (done) {
              ended = true;
              inflightCount--;
              fulfillReadQueue();
            } else {
              mapAndQueue(value);
            }
          } catch (error) {
            ended = true;
            inflightCount--;
            lastError = error;
            fulfillReadQueue();
          }
          reading = false;
          fillQueue();
        }
        async function mapAndQueue(itrValue) {
          try {
            const value = await func(itrValue);
            if (value && value[Symbol.asyncIterator]) {
              for await (const asyncVal of value) {
                resultQueue.push(asyncVal);
              }
            } else {
              resultQueue.push(value);
            }
          } catch (error) {
            ended = true;
            lastError = error;
          }
          inflightCount--;
          fulfillReadQueue();
          fillQueue();
        }
        async function next() {
          if (resultQueue.length === 0) {
            const deferred = defer();
            readQueue.push(deferred);
            fillQueue();
            return deferred.promise;
          }
          const value = resultQueue.shift();
          fillQueue();
          return { done: false, value };
        }
        const asyncIterableIterator = {
          next,
          [Symbol.asyncIterator]: () => asyncIterableIterator
        };
        return asyncIterableIterator;
      }
      function flatTransform(concurrency, func, iterable) {
        if (func === void 0) {
          return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);
        }
        if (iterable === void 0) {
          return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);
        }
        return filter8((i) => i !== void 0 && i !== null, flatten2(_flatTransform(concurrency, func, iterable)));
      }
      async function onceReadable(stream) {
        return new Promise((resolve6) => {
          stream.once("readable", () => {
            resolve6();
          });
        });
      }
      async function* _fromStream(stream) {
        while (true) {
          const data = stream.read();
          if (data !== null) {
            yield data;
            continue;
          }
          if (stream._readableState.ended) {
            break;
          }
          await onceReadable(stream);
        }
      }
      function fromStream(stream) {
        if (typeof stream[Symbol.asyncIterator] === "function") {
          return stream;
        }
        return _fromStream(stream);
      }
      async function* merge4(...iterables) {
        const sources = new Set(iterables.map(getIterator));
        while (sources.size > 0) {
          for (const iterator of sources) {
            const nextVal = await iterator.next();
            if (nextVal.done) {
              sources.delete(iterator);
            } else {
              yield nextVal.value;
            }
          }
        }
      }
      function pipeline(firstFn, ...fns) {
        let previousFn = firstFn();
        for (const func of fns) {
          previousFn = func(previousFn);
        }
        return previousFn;
      }
      async function* _parallelMap(concurrency, func, iterable) {
        let transformError = null;
        const wrapFunc = (value) => ({
          value: func(value)
        });
        const stopOnError = async function* (source) {
          for await (const value of source) {
            if (transformError) {
              return;
            }
            yield value;
          }
        };
        const output = pipeline(() => iterable, buffer2(1), stopOnError, map8(wrapFunc), buffer2(concurrency - 1));
        const itr = getIterator(output);
        while (true) {
          const { value, done } = await itr.next();
          if (done) {
            break;
          }
          try {
            const val = await value.value;
            if (!transformError) {
              yield val;
            }
          } catch (error) {
            transformError = error;
          }
        }
        if (transformError) {
          throw transformError;
        }
      }
      function parallelMap(concurrency, func, iterable) {
        if (func === void 0) {
          return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);
        }
        if (iterable === void 0) {
          return (curriedIterable) => parallelMap(concurrency, func, curriedIterable);
        }
        if (concurrency === 1) {
          return map8(func, iterable);
        }
        return _parallelMap(concurrency, func, iterable);
      }
      function parallelFlatMap(concurrency, func, iterable) {
        if (func === void 0) {
          return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);
        }
        if (iterable === void 0) {
          return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);
        }
        return filter8((i) => i !== void 0 && i !== null, flatten2(parallelMap(concurrency, func, iterable)));
      }
      async function* parallelMerge(...iterables) {
        const inputs = iterables.map(getIterator);
        const concurrentWork = new Set();
        const values = new Map();
        let lastError = null;
        let errCb = null;
        let valueCb = null;
        const notifyError = (err) => {
          lastError = err;
          if (errCb) {
            errCb(err);
          }
        };
        const notifyDone = (value) => {
          if (valueCb) {
            valueCb(value);
          }
        };
        const waitForQueue = () => new Promise((resolve6, reject) => {
          if (lastError) {
            reject(lastError);
          }
          if (values.size > 0) {
            return resolve6();
          }
          valueCb = resolve6;
          errCb = reject;
        });
        const queueNext = (input) => {
          const nextVal = Promise.resolve(input.next()).then(async ({ done, value }) => {
            if (!done) {
              values.set(input, value);
            }
            concurrentWork.delete(nextVal);
          });
          concurrentWork.add(nextVal);
          nextVal.then(notifyDone, notifyError);
        };
        for (const input of inputs) {
          queueNext(input);
        }
        while (true) {
          if (concurrentWork.size === 0 && values.size === 0) {
            return;
          }
          await waitForQueue();
          for (const [input, value] of values) {
            values.delete(input);
            yield value;
            queueNext(input);
          }
        }
      }
      async function _reduce(func, start, iterable) {
        let value = start;
        for await (const nextItem of iterable) {
          value = await func(value, nextItem);
        }
        return value;
      }
      function reduce2(func, start, iterable) {
        if (start === void 0) {
          return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce2(func, curriedStart);
        }
        if (iterable === void 0) {
          return (curriedIterable) => reduce2(func, start, curriedIterable);
        }
        return _reduce(func, start, iterable);
      }
      async function* _take(count, iterable) {
        let taken = 0;
        for await (const val of iterable) {
          yield await val;
          taken++;
          if (taken >= count) {
            break;
          }
        }
      }
      function* _syncTake(count, iterable) {
        let taken = 0;
        for (const val of iterable) {
          yield val;
          taken++;
          if (taken >= count) {
            break;
          }
        }
      }
      function take5(count, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => take5(count, curriedIterable);
        }
        if (iterable[Symbol.asyncIterator]) {
          return _take(count, iterable);
        }
        return _syncTake(count, iterable);
      }
      async function* _asyncTap(func, iterable) {
        for await (const val of iterable) {
          await func(val);
          yield val;
        }
      }
      function tap(func, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => _asyncTap(func, curriedIterable);
        }
        return _asyncTap(func, iterable);
      }
      function addTime(a, b) {
        let seconds = a[0] + b[0];
        let nanoseconds = a[1] + b[1];
        if (nanoseconds >= 1e9) {
          const remainder = nanoseconds % 1e9;
          seconds += (nanoseconds - remainder) / 1e9;
          nanoseconds = remainder;
        }
        return [seconds, nanoseconds];
      }
      async function* _asyncTime(config2, iterable) {
        const itr = iterable[Symbol.asyncIterator]();
        let total = [0, 0];
        while (true) {
          const start = process.hrtime();
          const { value, done } = await itr.next();
          const delta = process.hrtime(start);
          total = addTime(total, delta);
          if (config2.progress) {
            config2.progress(delta, total);
          }
          if (done) {
            if (config2.total) {
              config2.total(total);
            }
            return value;
          }
          yield value;
        }
      }
      function* _syncTime(config2, iterable) {
        const itr = iterable[Symbol.iterator]();
        let total = [0, 0];
        while (true) {
          const start = process.hrtime();
          const { value, done } = itr.next();
          const delta = process.hrtime(start);
          total = addTime(total, delta);
          if (config2.progress) {
            config2.progress(delta, total);
          }
          if (done) {
            if (config2.total) {
              config2.total(total);
            }
            return value;
          }
          yield value;
        }
      }
      function time(config2 = {}, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => time(config2, curriedIterable);
        }
        if (iterable[Symbol.asyncIterator] !== void 0) {
          return _asyncTime(config2, iterable);
        } else {
          return _syncTime(config2, iterable);
        }
      }
      function _transform(concurrency, func, iterable) {
        const iterator = getIterator(iterable);
        const resultQueue = [];
        const readQueue = [];
        let ended = false;
        let reading = false;
        let inflightCount = 0;
        let lastError = null;
        function fulfillReadQueue() {
          while (readQueue.length > 0 && resultQueue.length > 0) {
            const { resolve: resolve6 } = readQueue.shift();
            const value = resultQueue.shift();
            resolve6({ done: false, value });
          }
          while (readQueue.length > 0 && inflightCount === 0 && ended) {
            const { resolve: resolve6, reject } = readQueue.shift();
            if (lastError) {
              reject(lastError);
              lastError = null;
            } else {
              resolve6({ done: true, value: void 0 });
            }
          }
        }
        async function fillQueue() {
          if (ended) {
            fulfillReadQueue();
            return;
          }
          if (reading) {
            return;
          }
          if (inflightCount + resultQueue.length >= concurrency) {
            return;
          }
          reading = true;
          inflightCount++;
          try {
            const { done, value } = await iterator.next();
            if (done) {
              ended = true;
              inflightCount--;
              fulfillReadQueue();
            } else {
              mapAndQueue(value);
            }
          } catch (error) {
            ended = true;
            inflightCount--;
            lastError = error;
            fulfillReadQueue();
          }
          reading = false;
          fillQueue();
        }
        async function mapAndQueue(itrValue) {
          try {
            const value = await func(itrValue);
            resultQueue.push(value);
          } catch (error) {
            ended = true;
            lastError = error;
          }
          inflightCount--;
          fulfillReadQueue();
          fillQueue();
        }
        async function next() {
          if (resultQueue.length === 0) {
            const deferred = defer();
            readQueue.push(deferred);
            fillQueue();
            return deferred.promise;
          }
          const value = resultQueue.shift();
          fillQueue();
          return { done: false, value };
        }
        const asyncIterableIterator = {
          next,
          [Symbol.asyncIterator]: () => asyncIterableIterator
        };
        return asyncIterableIterator;
      }
      function transform(concurrency, func, iterable) {
        if (func === void 0) {
          return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);
        }
        if (iterable === void 0) {
          return (curriedIterable) => transform(concurrency, func, curriedIterable);
        }
        return _transform(concurrency, func, iterable);
      }
      async function _writeToStream(stream, iterable) {
        let lastError = null;
        let errCb = null;
        let drainCb = null;
        const notifyError = (err) => {
          lastError = err;
          if (errCb) {
            errCb(err);
          }
        };
        const notifyDrain = () => {
          if (drainCb) {
            drainCb();
          }
        };
        const cleanup = () => {
          stream.removeListener("error", notifyError);
          stream.removeListener("drain", notifyDrain);
        };
        stream.once("error", notifyError);
        const waitForDrain = () => new Promise((resolve6, reject) => {
          if (lastError) {
            return reject(lastError);
          }
          stream.once("drain", notifyDrain);
          drainCb = resolve6;
          errCb = reject;
        });
        for await (const value of iterable) {
          if (stream.write(value) === false) {
            await waitForDrain();
          }
          if (lastError) {
            break;
          }
        }
        cleanup();
        if (lastError) {
          throw lastError;
        }
      }
      function writeToStream(stream, iterable) {
        if (iterable === void 0) {
          return (curriedIterable) => _writeToStream(stream, curriedIterable);
        }
        return _writeToStream(stream, iterable);
      }
      exports3.batch = batch3;
      exports3.buffer = buffer2;
      exports3.collect = collect;
      exports3.concat = concat3;
      exports3.consume = consume;
      exports3.filter = filter8;
      exports3.flatMap = flatMap;
      exports3.flatTransform = flatTransform;
      exports3.flatten = flatten2;
      exports3.fromStream = fromStream;
      exports3.getIterator = getIterator;
      exports3.map = map8;
      exports3.merge = merge4;
      exports3.parallelFlatMap = parallelFlatMap;
      exports3.parallelMap = parallelMap;
      exports3.parallelMerge = parallelMerge;
      exports3.pipeline = pipeline;
      exports3.reduce = reduce2;
      exports3.take = take5;
      exports3.tap = tap;
      exports3.time = time;
      exports3.transform = transform;
      exports3.writeToStream = writeToStream;
      Object.defineProperty(exports3, "__esModule", { value: true });
    });
  }
});

// node_modules/libp2p-kad-dht/src/message/dht.js
var require_dht = __commonJS({
  "node_modules/libp2p-kad-dht/src/message/dht.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var $protobuf5 = require_minimal2();
    var $Reader5 = $protobuf5.Reader;
    var $Writer5 = $protobuf5.Writer;
    var $util5 = $protobuf5.util;
    var $root5 = $protobuf5.roots["libp2p-dht-message"] || ($protobuf5.roots["libp2p-dht-message"] = {});
    $root5.Record = function() {
      function Record(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Record.prototype.key = null;
      Record.prototype.value = null;
      Record.prototype.author = null;
      Record.prototype.signature = null;
      Record.prototype.timeReceived = null;
      var $oneOfFields;
      Object.defineProperty(Record.prototype, "_key", {
        get: $util5.oneOfGetter($oneOfFields = ["key"]),
        set: $util5.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Record.prototype, "_value", {
        get: $util5.oneOfGetter($oneOfFields = ["value"]),
        set: $util5.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Record.prototype, "_author", {
        get: $util5.oneOfGetter($oneOfFields = ["author"]),
        set: $util5.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Record.prototype, "_signature", {
        get: $util5.oneOfGetter($oneOfFields = ["signature"]),
        set: $util5.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Record.prototype, "_timeReceived", {
        get: $util5.oneOfGetter($oneOfFields = ["timeReceived"]),
        set: $util5.oneOfSetter($oneOfFields)
      });
      Record.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        if (m.key != null && Object.hasOwnProperty.call(m, "key"))
          w.uint32(10).bytes(m.key);
        if (m.value != null && Object.hasOwnProperty.call(m, "value"))
          w.uint32(18).bytes(m.value);
        if (m.author != null && Object.hasOwnProperty.call(m, "author"))
          w.uint32(26).bytes(m.author);
        if (m.signature != null && Object.hasOwnProperty.call(m, "signature"))
          w.uint32(34).bytes(m.signature);
        if (m.timeReceived != null && Object.hasOwnProperty.call(m, "timeReceived"))
          w.uint32(42).string(m.timeReceived);
        return w;
      };
      Record.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Record();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.key = r.bytes();
              break;
            case 2:
              m.value = r.bytes();
              break;
            case 3:
              m.author = r.bytes();
              break;
            case 4:
              m.signature = r.bytes();
              break;
            case 5:
              m.timeReceived = r.string();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Record.fromObject = function fromObject(d) {
        if (d instanceof $root5.Record)
          return d;
        var m = new $root5.Record();
        if (d.key != null) {
          if (typeof d.key === "string")
            $util5.base64.decode(d.key, m.key = $util5.newBuffer($util5.base64.length(d.key)), 0);
          else if (d.key.length)
            m.key = d.key;
        }
        if (d.value != null) {
          if (typeof d.value === "string")
            $util5.base64.decode(d.value, m.value = $util5.newBuffer($util5.base64.length(d.value)), 0);
          else if (d.value.length)
            m.value = d.value;
        }
        if (d.author != null) {
          if (typeof d.author === "string")
            $util5.base64.decode(d.author, m.author = $util5.newBuffer($util5.base64.length(d.author)), 0);
          else if (d.author.length)
            m.author = d.author;
        }
        if (d.signature != null) {
          if (typeof d.signature === "string")
            $util5.base64.decode(d.signature, m.signature = $util5.newBuffer($util5.base64.length(d.signature)), 0);
          else if (d.signature.length)
            m.signature = d.signature;
        }
        if (d.timeReceived != null) {
          m.timeReceived = String(d.timeReceived);
        }
        return m;
      };
      Record.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (m.key != null && m.hasOwnProperty("key")) {
          d.key = o.bytes === String ? $util5.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
          if (o.oneofs)
            d._key = "key";
        }
        if (m.value != null && m.hasOwnProperty("value")) {
          d.value = o.bytes === String ? $util5.base64.encode(m.value, 0, m.value.length) : o.bytes === Array ? Array.prototype.slice.call(m.value) : m.value;
          if (o.oneofs)
            d._value = "value";
        }
        if (m.author != null && m.hasOwnProperty("author")) {
          d.author = o.bytes === String ? $util5.base64.encode(m.author, 0, m.author.length) : o.bytes === Array ? Array.prototype.slice.call(m.author) : m.author;
          if (o.oneofs)
            d._author = "author";
        }
        if (m.signature != null && m.hasOwnProperty("signature")) {
          d.signature = o.bytes === String ? $util5.base64.encode(m.signature, 0, m.signature.length) : o.bytes === Array ? Array.prototype.slice.call(m.signature) : m.signature;
          if (o.oneofs)
            d._signature = "signature";
        }
        if (m.timeReceived != null && m.hasOwnProperty("timeReceived")) {
          d.timeReceived = m.timeReceived;
          if (o.oneofs)
            d._timeReceived = "timeReceived";
        }
        return d;
      };
      Record.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      return Record;
    }();
    $root5.Message = function() {
      function Message2(p) {
        this.closerPeers = [];
        this.providerPeers = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Message2.prototype.type = null;
      Message2.prototype.clusterLevelRaw = null;
      Message2.prototype.key = null;
      Message2.prototype.record = null;
      Message2.prototype.closerPeers = $util5.emptyArray;
      Message2.prototype.providerPeers = $util5.emptyArray;
      var $oneOfFields;
      Object.defineProperty(Message2.prototype, "_type", {
        get: $util5.oneOfGetter($oneOfFields = ["type"]),
        set: $util5.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Message2.prototype, "_clusterLevelRaw", {
        get: $util5.oneOfGetter($oneOfFields = ["clusterLevelRaw"]),
        set: $util5.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Message2.prototype, "_key", {
        get: $util5.oneOfGetter($oneOfFields = ["key"]),
        set: $util5.oneOfSetter($oneOfFields)
      });
      Object.defineProperty(Message2.prototype, "_record", {
        get: $util5.oneOfGetter($oneOfFields = ["record"]),
        set: $util5.oneOfSetter($oneOfFields)
      });
      Message2.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        if (m.type != null && Object.hasOwnProperty.call(m, "type"))
          w.uint32(8).int32(m.type);
        if (m.key != null && Object.hasOwnProperty.call(m, "key"))
          w.uint32(18).bytes(m.key);
        if (m.record != null && Object.hasOwnProperty.call(m, "record"))
          w.uint32(26).bytes(m.record);
        if (m.closerPeers != null && m.closerPeers.length) {
          for (var i = 0; i < m.closerPeers.length; ++i)
            $root5.Message.Peer.encode(m.closerPeers[i], w.uint32(66).fork()).ldelim();
        }
        if (m.providerPeers != null && m.providerPeers.length) {
          for (var i = 0; i < m.providerPeers.length; ++i)
            $root5.Message.Peer.encode(m.providerPeers[i], w.uint32(74).fork()).ldelim();
        }
        if (m.clusterLevelRaw != null && Object.hasOwnProperty.call(m, "clusterLevelRaw"))
          w.uint32(80).int32(m.clusterLevelRaw);
        return w;
      };
      Message2.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Message();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.type = r.int32();
              break;
            case 10:
              m.clusterLevelRaw = r.int32();
              break;
            case 2:
              m.key = r.bytes();
              break;
            case 3:
              m.record = r.bytes();
              break;
            case 8:
              if (!(m.closerPeers && m.closerPeers.length))
                m.closerPeers = [];
              m.closerPeers.push($root5.Message.Peer.decode(r, r.uint32()));
              break;
            case 9:
              if (!(m.providerPeers && m.providerPeers.length))
                m.providerPeers = [];
              m.providerPeers.push($root5.Message.Peer.decode(r, r.uint32()));
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Message2.fromObject = function fromObject(d) {
        if (d instanceof $root5.Message)
          return d;
        var m = new $root5.Message();
        switch (d.type) {
          case "PUT_VALUE":
          case 0:
            m.type = 0;
            break;
          case "GET_VALUE":
          case 1:
            m.type = 1;
            break;
          case "ADD_PROVIDER":
          case 2:
            m.type = 2;
            break;
          case "GET_PROVIDERS":
          case 3:
            m.type = 3;
            break;
          case "FIND_NODE":
          case 4:
            m.type = 4;
            break;
          case "PING":
          case 5:
            m.type = 5;
            break;
        }
        if (d.clusterLevelRaw != null) {
          m.clusterLevelRaw = d.clusterLevelRaw | 0;
        }
        if (d.key != null) {
          if (typeof d.key === "string")
            $util5.base64.decode(d.key, m.key = $util5.newBuffer($util5.base64.length(d.key)), 0);
          else if (d.key.length)
            m.key = d.key;
        }
        if (d.record != null) {
          if (typeof d.record === "string")
            $util5.base64.decode(d.record, m.record = $util5.newBuffer($util5.base64.length(d.record)), 0);
          else if (d.record.length)
            m.record = d.record;
        }
        if (d.closerPeers) {
          if (!Array.isArray(d.closerPeers))
            throw TypeError(".Message.closerPeers: array expected");
          m.closerPeers = [];
          for (var i = 0; i < d.closerPeers.length; ++i) {
            if (typeof d.closerPeers[i] !== "object")
              throw TypeError(".Message.closerPeers: object expected");
            m.closerPeers[i] = $root5.Message.Peer.fromObject(d.closerPeers[i]);
          }
        }
        if (d.providerPeers) {
          if (!Array.isArray(d.providerPeers))
            throw TypeError(".Message.providerPeers: array expected");
          m.providerPeers = [];
          for (var i = 0; i < d.providerPeers.length; ++i) {
            if (typeof d.providerPeers[i] !== "object")
              throw TypeError(".Message.providerPeers: object expected");
            m.providerPeers[i] = $root5.Message.Peer.fromObject(d.providerPeers[i]);
          }
        }
        return m;
      };
      Message2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.closerPeers = [];
          d.providerPeers = [];
        }
        if (m.type != null && m.hasOwnProperty("type")) {
          d.type = o.enums === String ? $root5.Message.MessageType[m.type] : m.type;
          if (o.oneofs)
            d._type = "type";
        }
        if (m.key != null && m.hasOwnProperty("key")) {
          d.key = o.bytes === String ? $util5.base64.encode(m.key, 0, m.key.length) : o.bytes === Array ? Array.prototype.slice.call(m.key) : m.key;
          if (o.oneofs)
            d._key = "key";
        }
        if (m.record != null && m.hasOwnProperty("record")) {
          d.record = o.bytes === String ? $util5.base64.encode(m.record, 0, m.record.length) : o.bytes === Array ? Array.prototype.slice.call(m.record) : m.record;
          if (o.oneofs)
            d._record = "record";
        }
        if (m.closerPeers && m.closerPeers.length) {
          d.closerPeers = [];
          for (var j = 0; j < m.closerPeers.length; ++j) {
            d.closerPeers[j] = $root5.Message.Peer.toObject(m.closerPeers[j], o);
          }
        }
        if (m.providerPeers && m.providerPeers.length) {
          d.providerPeers = [];
          for (var j = 0; j < m.providerPeers.length; ++j) {
            d.providerPeers[j] = $root5.Message.Peer.toObject(m.providerPeers[j], o);
          }
        }
        if (m.clusterLevelRaw != null && m.hasOwnProperty("clusterLevelRaw")) {
          d.clusterLevelRaw = m.clusterLevelRaw;
          if (o.oneofs)
            d._clusterLevelRaw = "clusterLevelRaw";
        }
        return d;
      };
      Message2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      Message2.MessageType = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "PUT_VALUE"] = 0;
        values[valuesById[1] = "GET_VALUE"] = 1;
        values[valuesById[2] = "ADD_PROVIDER"] = 2;
        values[valuesById[3] = "GET_PROVIDERS"] = 3;
        values[valuesById[4] = "FIND_NODE"] = 4;
        values[valuesById[5] = "PING"] = 5;
        return values;
      }();
      Message2.ConnectionType = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "NOT_CONNECTED"] = 0;
        values[valuesById[1] = "CONNECTED"] = 1;
        values[valuesById[2] = "CAN_CONNECT"] = 2;
        values[valuesById[3] = "CANNOT_CONNECT"] = 3;
        return values;
      }();
      Message2.Peer = function() {
        function Peer(p) {
          this.addrs = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Peer.prototype.id = null;
        Peer.prototype.addrs = $util5.emptyArray;
        Peer.prototype.connection = null;
        var $oneOfFields2;
        Object.defineProperty(Peer.prototype, "_id", {
          get: $util5.oneOfGetter($oneOfFields2 = ["id"]),
          set: $util5.oneOfSetter($oneOfFields2)
        });
        Object.defineProperty(Peer.prototype, "_connection", {
          get: $util5.oneOfGetter($oneOfFields2 = ["connection"]),
          set: $util5.oneOfSetter($oneOfFields2)
        });
        Peer.encode = function encode10(m, w) {
          if (!w)
            w = $Writer5.create();
          if (m.id != null && Object.hasOwnProperty.call(m, "id"))
            w.uint32(10).bytes(m.id);
          if (m.addrs != null && m.addrs.length) {
            for (var i = 0; i < m.addrs.length; ++i)
              w.uint32(18).bytes(m.addrs[i]);
          }
          if (m.connection != null && Object.hasOwnProperty.call(m, "connection"))
            w.uint32(24).int32(m.connection);
          return w;
        };
        Peer.decode = function decode12(r, l) {
          if (!(r instanceof $Reader5))
            r = $Reader5.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Message.Peer();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.id = r.bytes();
                break;
              case 2:
                if (!(m.addrs && m.addrs.length))
                  m.addrs = [];
                m.addrs.push(r.bytes());
                break;
              case 3:
                m.connection = r.int32();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        Peer.fromObject = function fromObject(d) {
          if (d instanceof $root5.Message.Peer)
            return d;
          var m = new $root5.Message.Peer();
          if (d.id != null) {
            if (typeof d.id === "string")
              $util5.base64.decode(d.id, m.id = $util5.newBuffer($util5.base64.length(d.id)), 0);
            else if (d.id.length)
              m.id = d.id;
          }
          if (d.addrs) {
            if (!Array.isArray(d.addrs))
              throw TypeError(".Message.Peer.addrs: array expected");
            m.addrs = [];
            for (var i = 0; i < d.addrs.length; ++i) {
              if (typeof d.addrs[i] === "string")
                $util5.base64.decode(d.addrs[i], m.addrs[i] = $util5.newBuffer($util5.base64.length(d.addrs[i])), 0);
              else if (d.addrs[i].length)
                m.addrs[i] = d.addrs[i];
            }
          }
          switch (d.connection) {
            case "NOT_CONNECTED":
            case 0:
              m.connection = 0;
              break;
            case "CONNECTED":
            case 1:
              m.connection = 1;
              break;
            case "CAN_CONNECT":
            case 2:
              m.connection = 2;
              break;
            case "CANNOT_CONNECT":
            case 3:
              m.connection = 3;
              break;
          }
          return m;
        };
        Peer.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.addrs = [];
          }
          if (m.id != null && m.hasOwnProperty("id")) {
            d.id = o.bytes === String ? $util5.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;
            if (o.oneofs)
              d._id = "id";
          }
          if (m.addrs && m.addrs.length) {
            d.addrs = [];
            for (var j = 0; j < m.addrs.length; ++j) {
              d.addrs[j] = o.bytes === String ? $util5.base64.encode(m.addrs[j], 0, m.addrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.addrs[j]) : m.addrs[j];
            }
          }
          if (m.connection != null && m.hasOwnProperty("connection")) {
            d.connection = o.enums === String ? $root5.Message.ConnectionType[m.connection] : m.connection;
            if (o.oneofs)
              d._connection = "connection";
          }
          return d;
        };
        Peer.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
        };
        return Peer;
      }();
      return Message2;
    }();
    module2.exports = $root5;
  }
});

// node_modules/libp2p-kad-dht/src/message/index.js
var require_message = __commonJS({
  "node_modules/libp2p-kad-dht/src/message/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var PeerId2 = require_src6();
    var { Multiaddr: Multiaddr18 } = require_src();
    var { Record } = require_src8();
    var Proto = require_dht();
    var MESSAGE_TYPE = Proto.Message.MessageType;
    var CONNECTION_TYPE = Proto.Message.ConnectionType;
    var Message2 = class {
      constructor(type, key, level) {
        if (key && !(key instanceof Uint8Array)) {
          throw new Error("Key must be a Uint8Array");
        }
        this.type = type;
        this.key = key;
        this._clusterLevelRaw = level;
        this.closerPeers = [];
        this.providerPeers = [];
        this.record = void 0;
      }
      get clusterLevel() {
        const level = this._clusterLevelRaw - 1;
        if (level < 0) {
          return 0;
        }
        return level;
      }
      set clusterLevel(level) {
        this._clusterLevelRaw = level;
      }
      serialize() {
        const obj = {
          key: this.key,
          type: this.type,
          clusterLevelRaw: this._clusterLevelRaw,
          closerPeers: this.closerPeers.map(toPbPeer),
          providerPeers: this.providerPeers.map(toPbPeer),
          record: void 0
        };
        if (this.record) {
          if (this.record instanceof Uint8Array) {
            obj.record = this.record;
          } else {
            obj.record = this.record.serialize();
          }
        }
        return Proto.Message.encode(obj).finish();
      }
      static deserialize(raw7) {
        const dec = Proto.Message.decode(raw7);
        const msg = new Message2(dec.type || 0, dec.key || Uint8Array.from([]), dec.clusterLevelRaw || 0);
        msg.closerPeers = dec.closerPeers.map(fromPbPeer);
        msg.providerPeers = dec.providerPeers.map(fromPbPeer);
        if (dec.record && dec.record.length) {
          msg.record = Record.deserialize(dec.record);
        }
        return msg;
      }
    };
    Message2.TYPES = MESSAGE_TYPE;
    Message2.CONNECTION_TYPES = CONNECTION_TYPE;
    function toPbPeer(peer) {
      const output = {
        id: peer.id.id,
        addrs: (peer.multiaddrs || []).map((m) => m.bytes),
        connection: CONNECTION_TYPE.CONNECTED
      };
      return output;
    }
    function fromPbPeer(peer) {
      return {
        id: new PeerId2(peer.id),
        multiaddrs: (peer.addrs || []).map((a) => new Multiaddr18(a))
      };
    }
    module2.exports = Message2;
  }
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/get-value.js
var require_get_value = __commonJS({
  "node_modules/libp2p-kad-dht/src/rpc/handlers/get-value.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { Record } = require_src8();
    var errcode7 = require_err_code();
    var Message2 = require_message();
    var utils = require_utils15();
    module2.exports = (dht) => {
      const log15 = utils.logger(dht.peerId, "rpc:get-value");
      async function getValue(peerId, msg) {
        const key = msg.key;
        log15("key: %b", key);
        if (!key || key.length === 0) {
          throw errcode7(new Error("Invalid key"), "ERR_INVALID_KEY");
        }
        const response = new Message2(Message2.TYPES.GET_VALUE, key, msg.clusterLevel);
        if (utils.isPublicKeyKey(key)) {
          log15("is public key");
          const idFromKey = utils.fromPublicKeyKey(key);
          let id;
          if (dht._isSelf(idFromKey)) {
            id = dht.peerId;
          } else {
            const peerData = dht.peerStore.get(idFromKey);
            id = peerData && peerData.id;
          }
          if (id && id.pubKey) {
            log15("returning found public key");
            response.record = new Record(key, id.pubKey.bytes);
            return response;
          }
        }
        const [record, closer] = await Promise.all([
          dht._checkLocalDatastore(key),
          dht._betterPeersToQuery(msg, peerId)
        ]);
        if (record) {
          log15("got record");
          response.record = record;
        }
        if (closer.length > 0) {
          log15("got closer %s", closer.length);
          response.closerPeers = closer;
        }
        return response;
      }
      return getValue;
    };
  }
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/put-value.js
var require_put_value = __commonJS({
  "node_modules/libp2p-kad-dht/src/rpc/handlers/put-value.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils15();
    var errcode7 = require_err_code();
    module2.exports = (dht) => {
      const log15 = utils.logger(dht.peerId, "rpc:put-value");
      async function putValue(peerId, msg) {
        const key = msg.key;
        log15("key: %b", key);
        const record = msg.record;
        if (!record) {
          const errMsg = `Empty record from: ${peerId.toB58String()}`;
          log15.error(errMsg);
          throw errcode7(new Error(errMsg), "ERR_EMPTY_RECORD");
        }
        await dht._verifyRecordLocally(record);
        record.timeReceived = new Date();
        const recordKey = utils.bufferToKey(record.key);
        await dht.datastore.put(recordKey, record.serialize());
        dht.onPut(record, peerId);
        return msg;
      }
      return putValue;
    };
  }
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/find-node.js
var require_find_node = __commonJS({
  "node_modules/libp2p-kad-dht/src/rpc/handlers/find-node.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var Message2 = require_message();
    var utils = require_utils15();
    module2.exports = (dht) => {
      const log15 = utils.logger(dht.peerId, "rpc:find-node");
      async function findNode(peerId, msg) {
        log15("start");
        let closer;
        if (uint8ArrayEquals(msg.key, dht.peerId.id)) {
          closer = [{
            id: dht.peerId,
            multiaddrs: dht.libp2p.multiaddrs
          }];
        } else {
          closer = await dht._betterPeersToQuery(msg, peerId);
        }
        const response = new Message2(msg.type, new Uint8Array(0), msg.clusterLevel);
        if (closer.length > 0) {
          response.closerPeers = closer;
        } else {
          log15("handle FindNode %s: could not find anything", peerId.toB58String());
        }
        return response;
      }
      return findNode;
    };
  }
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js
var require_add_provider = __commonJS({
  "node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { CID: CID2 } = (init_cid(), cid_exports);
    var errcode7 = require_err_code();
    var utils = require_utils15();
    module2.exports = (dht) => {
      const log15 = utils.logger(dht.peerId, "rpc:add-provider");
      async function addProvider(peerId, msg) {
        log15("start");
        if (!msg.key || msg.key.length === 0) {
          throw errcode7(new Error("Missing key"), "ERR_MISSING_KEY");
        }
        let cid;
        try {
          cid = CID2.decode(msg.key);
        } catch (err) {
          const errMsg = `Invalid CID: ${err.message}`;
          throw errcode7(new Error(errMsg), "ERR_INVALID_CID");
        }
        msg.providerPeers.forEach((pi) => {
          if (!pi.id.isEqual(peerId)) {
            log15("invalid provider peer %s from %s", pi.id.toB58String(), peerId.toB58String());
            return;
          }
          if (pi.multiaddrs.length < 1) {
            log15("no valid addresses for provider %s. Ignore", peerId.toB58String());
            return;
          }
          log15("received provider %s for %s (addrs %s)", peerId.toB58String(), cid.toString(), pi.multiaddrs.map((m) => m.toString()));
          if (!dht._isSelf(pi.id)) {
            dht.peerStore.addressBook.add(pi.id, pi.multiaddrs);
            return dht.providers.addProvider(cid, pi.id);
          }
        });
        return dht.providers.addProvider(cid, peerId);
      }
      return addProvider;
    };
  }
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js
var require_get_providers = __commonJS({
  "node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { CID: CID2 } = (init_cid(), cid_exports);
    var errcode7 = require_err_code();
    var Message2 = require_message();
    var utils = require_utils15();
    module2.exports = (dht) => {
      const log15 = utils.logger(dht.peerId, "rpc:get-providers");
      async function getProviders(peerId, msg) {
        let cid;
        try {
          cid = CID2.decode(msg.key);
        } catch (err) {
          throw errcode7(new Error(`Invalid CID: ${err.message}`), "ERR_INVALID_CID");
        }
        log15("%s", cid.toString());
        const dsKey = utils.bufferToKey(cid.bytes);
        const [has, peers, closer] = await Promise.all([
          dht.datastore.has(dsKey),
          dht.providers.getProviders(cid),
          dht._betterPeersToQuery(msg, peerId)
        ]);
        const providerPeers = peers.map((peerId2) => ({
          id: peerId2,
          multiaddrs: []
        }));
        const closerPeers = closer.map((c) => ({
          id: c.id,
          multiaddrs: []
        }));
        if (has) {
          providerPeers.push({
            id: dht.peerId,
            multiaddrs: []
          });
        }
        const response = new Message2(msg.type, msg.key, msg.clusterLevel);
        if (providerPeers.length > 0) {
          response.providerPeers = providerPeers;
        }
        if (closerPeers.length > 0) {
          response.closerPeers = closerPeers;
        }
        log15("got %s providers %s closerPeers", providerPeers.length, closerPeers.length);
        return response;
      }
      return getProviders;
    };
  }
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/ping.js
var require_ping = __commonJS({
  "node_modules/libp2p-kad-dht/src/rpc/handlers/ping.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils15();
    module2.exports = (dht) => {
      const log15 = utils.logger(dht.peerId, "rpc:ping");
      function ping(peerId, msg) {
        log15("from %s", peerId.toB58String());
        return msg;
      }
      return ping;
    };
  }
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/index.js
var require_handlers = __commonJS({
  "node_modules/libp2p-kad-dht/src/rpc/handlers/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var T = require_message().TYPES;
    module2.exports = (dht) => {
      const handlers = {
        [T.GET_VALUE]: require_get_value()(dht),
        [T.PUT_VALUE]: require_put_value()(dht),
        [T.FIND_NODE]: require_find_node()(dht),
        [T.ADD_PROVIDER]: require_add_provider()(dht),
        [T.GET_PROVIDERS]: require_get_providers()(dht),
        [T.PING]: require_ping()(dht)
      };
      function getMessageHandler(type) {
        return handlers[type];
      }
      return getMessageHandler;
    };
  }
});

// node_modules/libp2p-kad-dht/src/rpc/index.js
var require_rpc4 = __commonJS({
  "node_modules/libp2p-kad-dht/src/rpc/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { pipe: pipe4 } = require_it_pipe();
    var lp2 = require_src12();
    var Message2 = require_message();
    var handlers = require_handlers();
    var utils = require_utils15();
    module2.exports = (dht) => {
      const log15 = utils.logger(dht.peerId, "rpc");
      const getMessageHandler = handlers(dht);
      async function handleMessage(peerId, msg) {
        const handler = getMessageHandler(msg.type);
        try {
          await dht._add(peerId);
        } catch (err) {
          log15.error("Failed to update the kbucket store", err);
        }
        if (!handler) {
          log15.error(`no handler found for message type: ${msg.type}`);
          return;
        }
        return handler(peerId, msg);
      }
      async function onIncomingStream({ stream, connection }) {
        const peerId = connection.remotePeer;
        try {
          await dht._add(peerId);
        } catch (err) {
          log15.error(err);
        }
        const idB58Str = peerId.toB58String();
        log15("from: %s", idB58Str);
        await pipe4(stream.source, lp2.decode(), (source) => async function* () {
          for await (const msg of source) {
            const desMessage = Message2.deserialize(msg.slice());
            const res = await handleMessage(peerId, desMessage);
            if (res) {
              yield res.serialize();
            }
          }
        }(), lp2.encode(), stream.sink);
      }
      return onIncomingStream;
    };
  }
});

// node_modules/libp2p-kad-dht/src/network.js
var require_network = __commonJS({
  "node_modules/libp2p-kad-dht/src/network.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var { pipe: pipe4 } = require_it_pipe();
    var lp2 = require_src12();
    var pTimeout = require_p_timeout2();
    var { consume } = require_dist2();
    var first3 = require_it_first();
    var MulticodecTopology2 = require_multicodec_topology();
    var rpc = require_rpc4();
    var c = require_constants10();
    var Message2 = require_message();
    var utils = require_utils15();
    var Network2 = class {
      constructor(dht) {
        this.dht = dht;
        this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT;
        this._log = utils.logger(this.dht.peerId, "net");
        this._rpc = rpc(this.dht);
        this._onPeerConnected = this._onPeerConnected.bind(this);
        this._running = false;
      }
      start() {
        if (this._running) {
          return;
        }
        if (!this.dht.isStarted) {
          throw errcode7(new Error("Can not start network"), "ERR_CANNOT_START_NETWORK");
        }
        this._running = true;
        if (this.dht._clientMode === false) {
          this.dht.registrar.handle(this.dht.protocol, this._rpc);
        }
        const topology = new MulticodecTopology2({
          multicodecs: [this.dht.protocol],
          handlers: {
            onConnect: this._onPeerConnected,
            onDisconnect: () => {
            }
          }
        });
        this._registrarId = this.dht.registrar.register(topology);
      }
      stop() {
        if (!this.dht.isStarted && !this.isStarted) {
          return;
        }
        this._running = false;
        if (this._registrarId) {
          this.dht.registrar.unregister(this._registrarId);
        }
      }
      get isStarted() {
        return this._running;
      }
      get isConnected() {
        return this.dht.isStarted && this.isStarted;
      }
      async _onPeerConnected(peerId) {
        await this.dht._add(peerId);
        this._log("added to the routing table: %s", peerId.toB58String());
      }
      async sendRequest(to, msg) {
        if (!this.isConnected) {
          throw errcode7(new Error("Network is offline"), "ERR_NETWORK_OFFLINE");
        }
        const id = to.toB58String();
        this._log("sending to: %s", id);
        let conn = this.dht.registrar.connectionManager.get(to);
        if (!conn) {
          conn = await this.dht.dialer.connectToPeer(to);
        }
        const { stream } = await conn.newStream(this.dht.protocol);
        return this._writeReadMessage(stream, msg.serialize());
      }
      async sendMessage(to, msg) {
        if (!this.isConnected) {
          throw errcode7(new Error("Network is offline"), "ERR_NETWORK_OFFLINE");
        }
        const id = to.toB58String();
        this._log("sending to: %s", id);
        let conn = this.dht.registrar.connectionManager.get(to);
        if (!conn) {
          conn = await this.dht.dialer.connectToPeer(to);
        }
        const { stream } = await conn.newStream(this.dht.protocol);
        return this._writeMessage(stream, msg.serialize());
      }
      async _writeReadMessage(stream, msg) {
        return pTimeout(writeReadMessage(stream, msg), this.readMessageTimeout);
      }
      _writeMessage(stream, msg) {
        return pipe4([msg], lp2.encode(), stream, consume);
      }
    };
    async function writeReadMessage(stream, msg) {
      const res = await pipe4([msg], lp2.encode(), stream, lp2.decode(), async (source) => {
        const buf2 = await first3(source);
        if (buf2) {
          return buf2.slice();
        }
      });
      if (res.length === 0) {
        throw errcode7(new Error("No message received"), "ERR_NO_MESSAGE_RECEIVED");
      }
      return Message2.deserialize(res);
    }
    module2.exports = Network2;
  }
});

// node_modules/libp2p-kad-dht/src/peer-list/peer-distance-list.js
var require_peer_distance_list = __commonJS({
  "node_modules/libp2p-kad-dht/src/peer-list/peer-distance-list.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var utils = require_utils15();
    var pMap = require_p_map();
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var { compare: uint8ArrayCompare } = (init_compare(), compare_exports);
    var { xor: uint8ArrayXor } = (init_xor(), xor_exports);
    var PeerDistanceList = class {
      constructor(originDhtKey, capacity) {
        this.originDhtKey = originDhtKey;
        this.capacity = capacity;
        this.peerDistances = [];
      }
      get length() {
        return this.peerDistances.length;
      }
      get peers() {
        return this.peerDistances.map((pd) => pd.peerId);
      }
      async add(peerId) {
        if (this.peerDistances.find((pd) => uint8ArrayEquals(pd.peerId.id, peerId.id))) {
          return;
        }
        const dhtKey = await utils.convertPeerId(peerId);
        const el = {
          peerId,
          distance: uint8ArrayXor(this.originDhtKey, dhtKey)
        };
        this.peerDistances.push(el);
        this.peerDistances.sort((a, b) => uint8ArrayCompare(a.distance, b.distance));
        this.peerDistances = this.peerDistances.slice(0, this.capacity);
      }
      async anyCloser(peerIds) {
        if (!peerIds.length) {
          return false;
        }
        if (!this.length) {
          return true;
        }
        const dhtKeys = await pMap(peerIds, (peerId) => utils.convertPeerId(peerId));
        const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
        for (const dhtKey of dhtKeys) {
          const keyDistance = uint8ArrayXor(this.originDhtKey, dhtKey);
          if (uint8ArrayCompare(keyDistance, furthestDistance) < 0) {
            return true;
          }
        }
        return false;
      }
    };
    module2.exports = PeerDistanceList;
  }
});

// node_modules/heap/lib/heap.js
var require_heap = __commonJS({
  "node_modules/heap/lib/heap.js"(exports2, module2) {
    init_node_globals();
    (function() {
      var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;
      floor = Math.floor, min = Math.min;
      defaultCmp = function(x, y) {
        if (x < y) {
          return -1;
        }
        if (x > y) {
          return 1;
        }
        return 0;
      };
      insort = function(a, x, lo, hi, cmp) {
        var mid;
        if (lo == null) {
          lo = 0;
        }
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (lo < 0) {
          throw new Error("lo must be non-negative");
        }
        if (hi == null) {
          hi = a.length;
        }
        while (lo < hi) {
          mid = floor((lo + hi) / 2);
          if (cmp(x, a[mid]) < 0) {
            hi = mid;
          } else {
            lo = mid + 1;
          }
        }
        return [].splice.apply(a, [lo, lo - lo].concat(x)), x;
      };
      heappush = function(array2, item, cmp) {
        if (cmp == null) {
          cmp = defaultCmp;
        }
        array2.push(item);
        return _siftdown(array2, 0, array2.length - 1, cmp);
      };
      heappop = function(array2, cmp) {
        var lastelt, returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        lastelt = array2.pop();
        if (array2.length) {
          returnitem = array2[0];
          array2[0] = lastelt;
          _siftup(array2, 0, cmp);
        } else {
          returnitem = lastelt;
        }
        return returnitem;
      };
      heapreplace = function(array2, item, cmp) {
        var returnitem;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        returnitem = array2[0];
        array2[0] = item;
        _siftup(array2, 0, cmp);
        return returnitem;
      };
      heappushpop = function(array2, item, cmp) {
        var _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (array2.length && cmp(array2[0], item) < 0) {
          _ref = [array2[0], item], item = _ref[0], array2[0] = _ref[1];
          _siftup(array2, 0, cmp);
        }
        return item;
      };
      heapify = function(array2, cmp) {
        var i, _i, _j, _len, _ref, _ref1, _results, _results1;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        _ref1 = function() {
          _results1 = [];
          for (var _j2 = 0, _ref2 = floor(array2.length / 2); 0 <= _ref2 ? _j2 < _ref2 : _j2 > _ref2; 0 <= _ref2 ? _j2++ : _j2--) {
            _results1.push(_j2);
          }
          return _results1;
        }.apply(this).reverse();
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          i = _ref1[_i];
          _results.push(_siftup(array2, i, cmp));
        }
        return _results;
      };
      updateItem = function(array2, item, cmp) {
        var pos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        pos = array2.indexOf(item);
        if (pos === -1) {
          return;
        }
        _siftdown(array2, 0, pos, cmp);
        return _siftup(array2, pos, cmp);
      };
      nlargest = function(array2, n, cmp) {
        var elem, result, _i, _len, _ref;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        result = array2.slice(0, n);
        if (!result.length) {
          return result;
        }
        heapify(result, cmp);
        _ref = array2.slice(n);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          heappushpop(result, elem, cmp);
        }
        return result.sort(cmp).reverse();
      };
      nsmallest = function(array2, n, cmp) {
        var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        if (n * 10 <= array2.length) {
          result = array2.slice(0, n).sort(cmp);
          if (!result.length) {
            return result;
          }
          los = result[result.length - 1];
          _ref = array2.slice(n);
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            elem = _ref[_i];
            if (cmp(elem, los) < 0) {
              insort(result, elem, 0, null, cmp);
              result.pop();
              los = result[result.length - 1];
            }
          }
          return result;
        }
        heapify(array2, cmp);
        _results = [];
        for (i = _j = 0, _ref1 = min(n, array2.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          _results.push(heappop(array2, cmp));
        }
        return _results;
      };
      _siftdown = function(array2, startpos, pos, cmp) {
        var newitem, parent2, parentpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        newitem = array2[pos];
        while (pos > startpos) {
          parentpos = pos - 1 >> 1;
          parent2 = array2[parentpos];
          if (cmp(newitem, parent2) < 0) {
            array2[pos] = parent2;
            pos = parentpos;
            continue;
          }
          break;
        }
        return array2[pos] = newitem;
      };
      _siftup = function(array2, pos, cmp) {
        var childpos, endpos, newitem, rightpos, startpos;
        if (cmp == null) {
          cmp = defaultCmp;
        }
        endpos = array2.length;
        startpos = pos;
        newitem = array2[pos];
        childpos = 2 * pos + 1;
        while (childpos < endpos) {
          rightpos = childpos + 1;
          if (rightpos < endpos && !(cmp(array2[childpos], array2[rightpos]) < 0)) {
            childpos = rightpos;
          }
          array2[pos] = array2[childpos];
          pos = childpos;
          childpos = 2 * pos + 1;
        }
        array2[pos] = newitem;
        return _siftdown(array2, startpos, pos, cmp);
      };
      Heap = function() {
        Heap2.push = heappush;
        Heap2.pop = heappop;
        Heap2.replace = heapreplace;
        Heap2.pushpop = heappushpop;
        Heap2.heapify = heapify;
        Heap2.updateItem = updateItem;
        Heap2.nlargest = nlargest;
        Heap2.nsmallest = nsmallest;
        function Heap2(cmp) {
          this.cmp = cmp != null ? cmp : defaultCmp;
          this.nodes = [];
        }
        Heap2.prototype.push = function(x) {
          return heappush(this.nodes, x, this.cmp);
        };
        Heap2.prototype.pop = function() {
          return heappop(this.nodes, this.cmp);
        };
        Heap2.prototype.peek = function() {
          return this.nodes[0];
        };
        Heap2.prototype.contains = function(x) {
          return this.nodes.indexOf(x) !== -1;
        };
        Heap2.prototype.replace = function(x) {
          return heapreplace(this.nodes, x, this.cmp);
        };
        Heap2.prototype.pushpop = function(x) {
          return heappushpop(this.nodes, x, this.cmp);
        };
        Heap2.prototype.heapify = function() {
          return heapify(this.nodes, this.cmp);
        };
        Heap2.prototype.updateItem = function(x) {
          return updateItem(this.nodes, x, this.cmp);
        };
        Heap2.prototype.clear = function() {
          return this.nodes = [];
        };
        Heap2.prototype.empty = function() {
          return this.nodes.length === 0;
        };
        Heap2.prototype.size = function() {
          return this.nodes.length;
        };
        Heap2.prototype.clone = function() {
          var heap;
          heap = new Heap2();
          heap.nodes = this.nodes.slice(0);
          return heap;
        };
        Heap2.prototype.toArray = function() {
          return this.nodes.slice(0);
        };
        Heap2.prototype.insert = Heap2.prototype.push;
        Heap2.prototype.top = Heap2.prototype.peek;
        Heap2.prototype.front = Heap2.prototype.peek;
        Heap2.prototype.has = Heap2.prototype.contains;
        Heap2.prototype.copy = Heap2.prototype.clone;
        return Heap2;
      }();
      (function(root, factory) {
        if (typeof define === "function" && define.amd) {
          return define([], factory);
        } else if (typeof exports2 === "object") {
          return module2.exports = factory();
        } else {
          return root.Heap = factory();
        }
      })(this, function() {
        return Heap;
      });
    }).call(exports2);
  }
});

// node_modules/heap/index.js
var require_heap2 = __commonJS({
  "node_modules/heap/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = require_heap();
  }
});

// node_modules/libp2p-kad-dht/src/peer-list/peer-queue.js
var require_peer_queue = __commonJS({
  "node_modules/libp2p-kad-dht/src/peer-list/peer-queue.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var Heap = require_heap2();
    var { xor: uint8ArrayXor } = (init_xor(), xor_exports);
    var debug17 = require_browser2();
    var utils = require_utils15();
    var log15 = debug17("libp2p:dht:peer-queue");
    var PeerQueue = class {
      static async fromPeerId(id) {
        const key = await utils.convertPeerId(id);
        return new PeerQueue(key);
      }
      static async fromKey(keyBuffer) {
        const key = await utils.convertBuffer(keyBuffer);
        return new PeerQueue(key);
      }
      constructor(from3) {
        log15("create: %b", from3);
        this.from = from3;
        this.heap = new Heap(utils.xorCompare);
      }
      async enqueue(id) {
        log15("enqueue %s", id.toB58String());
        const key = await utils.convertPeerId(id);
        const el = {
          id,
          distance: uint8ArrayXor(this.from, key)
        };
        this.heap.push(el);
      }
      dequeue() {
        const el = this.heap.pop();
        log15("dequeue %s", el.id.toB58String());
        return el.id;
      }
      get length() {
        return this.heap.size();
      }
    };
    module2.exports = PeerQueue;
  }
});

// node_modules/libp2p-kad-dht/src/query/path.js
var require_path = __commonJS({
  "node_modules/libp2p-kad-dht/src/query/path.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var PeerQueue = require_peer_queue();
    var utils = require_utils15();
    var QUERY_FUNC_TIMEOUT = 3e4;
    var Path = class {
      constructor(run, queryFunc) {
        this.run = run;
        this.queryFunc = utils.withTimeout(queryFunc, QUERY_FUNC_TIMEOUT);
        if (!this.queryFunc)
          throw new Error("Path requires a `queryFn` to be specified");
        if (typeof this.queryFunc !== "function")
          throw new Error("Path expected `queryFn` to be a function. Got " + typeof this.queryFunc);
        this.initialPeers = [];
        this.peersToQuery = null;
        this.res = null;
      }
      addInitialPeer(peer) {
        this.initialPeers.push(peer);
      }
      async execute() {
        const queue = await PeerQueue.fromKey(this.run.query.key);
        this.peersToQuery = queue;
        await Promise.all(this.initialPeers.map((peer) => this.addPeerToQuery(peer)));
        await this.run.workerQueue(this);
      }
      async addPeerToQuery(peer) {
        if (this.run.query.dht._isSelf(peer)) {
          return;
        }
        if (this.run.peersSeen.has(peer.toB58String())) {
          return;
        }
        if (this.peersToQuery) {
          await this.peersToQuery.enqueue(peer);
        }
      }
    };
    module2.exports = Path;
  }
});

// node_modules/libp2p-kad-dht/src/query/worker-queue.js
var require_worker_queue = __commonJS({
  "node_modules/libp2p-kad-dht/src/query/worker-queue.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { default: Queue4 } = require_dist();
    var WorkerQueue = class {
      constructor(dht, run, path, log15) {
        this.dht = dht;
        this.run = run;
        this.path = path;
        this.log = log15;
        this.concurrency = this.dht.concurrency;
        this.queue = this.setupQueue();
        this.execution = null;
        this.queuedPeerIds = new Set();
      }
      setupQueue() {
        const q = new Queue4({
          concurrency: this.concurrency
        });
        q.on("idle", () => {
          if (this.path.peersToQuery && !this.path.peersToQuery.length) {
            this.log("queue:drain");
            this.stop();
          }
        });
        q.on("next", () => {
          if (!this.running) {
            return;
          }
          if (q.pending < this.concurrency) {
            this.fill();
          }
        });
        return q;
      }
      stop(err) {
        if (!this.running) {
          return;
        }
        this.running = false;
        this.queue.clear();
        this.log("worker:stop, %d workers still running", this.run.workers.filter((w) => w.running).length);
        if (this.execution) {
          if (err) {
            this.execution.reject(err);
          } else {
            this.execution.resolve();
          }
        }
      }
      async execute() {
        this.running = true;
        this.execution = null;
        const execPromise = new Promise((resolve6, reject) => {
          this.execution = {
            resolve: resolve6,
            reject
          };
        });
        this.fill();
        await execPromise;
      }
      fill() {
        if (!this.path.peersToQuery) {
          return;
        }
        while (this.queue.pending + this.queue.size < this.concurrency && this.path.peersToQuery.length > 0) {
          const peer = this.path.peersToQuery.dequeue();
          this.queuedPeerIds.add(peer);
          this.queue.add(() => {
            return this.processNext(peer).catch((err) => {
              this.log.error("queue", err);
              this.stop(err);
            }).finally(() => {
              this.queuedPeerIds.delete(peer);
            });
          });
        }
      }
      async processNext(peer) {
        if (!this.running) {
          return;
        }
        if (this.run.peersSeen.has(peer.toB58String())) {
          return;
        }
        let continueQuerying, continueQueryingError;
        try {
          continueQuerying = await this.run.continueQuerying(this);
        } catch (err) {
          continueQueryingError = err;
        }
        if (!this.running) {
          return;
        }
        if (continueQueryingError) {
          throw continueQueryingError;
        }
        if (!continueQuerying) {
          this.stop();
          return;
        }
        if (this.run.peersSeen.has(peer.toB58String())) {
          return;
        }
        this.run.peersSeen.add(peer.toB58String());
        this.log("queue:work");
        let state, execError;
        try {
          state = await this.execQuery(peer);
        } catch (err) {
          execError = err;
        }
        if (!this.running) {
          return;
        }
        this.log("queue:work:done", execError, state);
        if (execError) {
          throw execError;
        }
        if (state && state.queryComplete) {
          this.log("query:complete");
          this.run.stop();
          return;
        }
        if (state && state.pathComplete) {
          this.stop();
        }
      }
      async execQuery(peer) {
        let res, queryError;
        try {
          res = await this.path.queryFunc(peer);
        } catch (err) {
          queryError = err;
        }
        if (!this.running) {
          return;
        }
        if (queryError) {
          this.run.errors.push(queryError);
          return;
        }
        this.run.peersQueried && await this.run.peersQueried.add(peer);
        if (!res) {
          return;
        }
        if (res.pathComplete || res.queryComplete) {
          this.path.res = res;
          return {
            pathComplete: res.pathComplete,
            queryComplete: res.queryComplete
          };
        }
        if (res.closerPeers && res.closerPeers.length > 0) {
          const queryCloser = async (closer) => {
            if (this.dht._isSelf(closer.id)) {
              return;
            }
            this.dht._peerDiscovered(closer.id, closer.multiaddrs);
            await this.path.addPeerToQuery(closer.id);
          };
          await Promise.all(res.closerPeers.map(queryCloser));
        }
      }
    };
    module2.exports = WorkerQueue;
  }
});

// node_modules/libp2p-kad-dht/src/query/run.js
var require_run = __commonJS({
  "node_modules/libp2p-kad-dht/src/query/run.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var PeerDistanceList = require_peer_distance_list();
    var EventEmitter4 = require_events();
    var Path = require_path();
    var WorkerQueue = require_worker_queue();
    var utils = require_utils15();
    var Run = class extends EventEmitter4 {
      constructor(query) {
        super();
        this.query = query;
        this.running = false;
        this.workers = [];
        this.peersSeen = new Set();
        this.errors = [];
        this.peersQueried = null;
      }
      stop() {
        if (!this.running) {
          return;
        }
        this.running = false;
        for (const worker of this.workers) {
          worker.stop();
        }
      }
      async execute(peers) {
        const paths = [];
        const numPaths = Math.min(this.query.dht.disjointPaths, peers.length);
        for (let i = 0; i < numPaths; i++) {
          paths.push(new Path(this, this.query.makePath(i, numPaths)));
        }
        peers.forEach((peer, i) => {
          paths[i % numPaths].addInitialPeer(peer);
        });
        await this.executePaths(paths);
        const res = {
          finalSet: new Set(this.peersQueried && this.peersQueried.peers),
          paths: []
        };
        for (const path of paths) {
          if (path.res && (path.res.pathComplete || path.res.queryComplete)) {
            path.res.success = true;
            res.paths.push(path.res);
          }
        }
        return res;
      }
      async executePaths(paths) {
        this.running = true;
        this.emit("start");
        try {
          await Promise.all(paths.map((path) => path.execute()));
        } finally {
          this.stop();
          this.emit("complete");
        }
        if (this.errors.length === this.peersSeen.size) {
          throw this.errors[0];
        }
      }
      async workerQueue(path) {
        await this.init();
        await this.startWorker(path);
      }
      async startWorker(path) {
        const worker = new WorkerQueue(this.query.dht, this, path, this.query._log);
        this.workers.push(worker);
        await worker.execute();
      }
      async init() {
        if (this.peersQueried) {
          return;
        }
        if (this.peersQueriedPromise) {
          await this.peersQueriedPromise;
          return;
        }
        this.peersQueriedPromise = (async () => {
          const dhtKey = await utils.convertBuffer(this.query.key);
          this.peersQueried = new PeerDistanceList(dhtKey, this.query.dht.kBucketSize);
        })();
        await this.peersQueriedPromise;
        delete this.peersQueriedPromise;
      }
      async continueQuerying(worker) {
        if (this.peersQueried && this.peersQueried.length < this.peersQueried.capacity) {
          return true;
        }
        const running = Array.from(worker.queuedPeerIds);
        const someCloser = this.peersQueried && await this.peersQueried.anyCloser(running);
        if (someCloser) {
          return true;
        }
        return false;
      }
    };
    module2.exports = Run;
  }
});

// node_modules/libp2p-kad-dht/src/query/index.js
var require_query = __commonJS({
  "node_modules/libp2p-kad-dht/src/query/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { base58btc: base58btc2 } = (init_base58(), base58_exports);
    var utils = require_utils15();
    var Run = require_run();
    var Query = class {
      constructor(dht, key, makePath) {
        this.dht = dht;
        this.key = key;
        this.makePath = makePath;
        this._log = utils.logger(this.dht.peerId, "query:" + base58btc2.baseEncode(key));
        this.running = false;
        this._onStart = this._onStart.bind(this);
        this._onComplete = this._onComplete.bind(this);
      }
      async run(peers) {
        if (!this.dht._queryManager.running) {
          this._log.error("Attempt to run query after shutdown");
          return { finalSet: new Set(), paths: [] };
        }
        if (peers.length === 0) {
          this._log.error("Running query with no peers");
          return { finalSet: new Set(), paths: [] };
        }
        this._run = new Run(this);
        this._log(`query running with K=${this.dht.kBucketSize}, A=${this.dht.concurrency}, D=${Math.min(this.dht.disjointPaths, peers.length)}`);
        this._run.once("start", this._onStart);
        this._run.once("complete", this._onComplete);
        return this._run.execute(peers);
      }
      _onStart() {
        this.running = true;
        this._startTime = Date.now();
        this._log("query:start");
        this.dht._queryManager.queryStarted(this);
      }
      _onComplete() {
        this.stop();
      }
      stop() {
        this._log(`query:done in ${Date.now() - (this._startTime || 0)}ms`);
        if (this._run) {
          this._log(`${this._run.errors.length} of ${this._run.peersSeen.size} peers errored (${this._run.errors.length / this._run.peersSeen.size * 100}% fail rate)`);
        }
        if (!this.running) {
          return;
        }
        this.running = false;
        if (this._run) {
          this._run.removeListener("start", this._onStart);
          this._run.removeListener("complete", this._onComplete);
          this._run.stop();
        }
        this.dht._queryManager.queryCompleted(this);
      }
    };
    module2.exports = Query;
  }
});

// node_modules/libp2p-kad-dht/src/content-fetching/index.js
var require_content_fetching = __commonJS({
  "node_modules/libp2p-kad-dht/src/content-fetching/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var pTimeout = require_p_timeout2();
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var libp2pRecord = require_src8();
    var c = require_constants10();
    var Query = require_query();
    var utils = require_utils15();
    var Record = libp2pRecord.Record;
    module2.exports = (dht) => {
      const putLocal = async (key, rec) => {
        return dht.datastore.put(utils.bufferToKey(key), rec);
      };
      const getLocal = async (key) => {
        dht._log(`getLocal ${uint8ArrayToString(key, "base32")}`);
        const raw7 = await dht.datastore.get(utils.bufferToKey(key));
        dht._log(`found ${uint8ArrayToString(key, "base32")} in local datastore`);
        const rec = Record.deserialize(raw7);
        await dht._verifyRecordLocally(rec);
        return rec;
      };
      const sendCorrectionRecord = async (key, vals, best) => {
        const fixupRec = await utils.createPutRecord(key, best);
        return Promise.all(vals.map(async (v) => {
          if (uint8ArrayEquals(v.val, best)) {
            return;
          }
          if (dht._isSelf(v.from)) {
            try {
              await dht._putLocal(key, fixupRec);
            } catch (err) {
              dht._log.error("Failed error correcting self", err);
            }
            return;
          }
          try {
            await dht._putValueToPeer(key, fixupRec, v.from);
          } catch (err) {
            dht._log.error("Failed error correcting entry", err);
          }
        }));
      };
      return {
        async _putLocal(key, rec) {
          return putLocal(key, rec);
        },
        async put(key, value, options = {}) {
          dht._log("PutValue %b", key);
          const record = await utils.createPutRecord(key, value);
          await putLocal(key, record);
          let counterAll = 0;
          let counterSuccess = 0;
          await utils.mapParallel(dht.getClosestPeers(key, { shallow: true }), async (peer) => {
            try {
              counterAll += 1;
              await dht._putValueToPeer(key, record, peer);
              counterSuccess += 1;
            } catch (err) {
              dht._log.error("Failed to put to peer (%b): %s", peer.id, err);
            }
          });
          const minPeers = options.minPeers || counterAll;
          if (minPeers > counterSuccess) {
            const error = errcode7(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), "ERR_NOT_ENOUGH_PUT_PEERS");
            dht._log.error(error);
            throw error;
          }
        },
        async get(key, options = {}) {
          options.timeout = options.timeout || c.minute;
          dht._log("_get %b", key);
          const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options);
          const recs = vals.map((v) => v.val);
          let i = 0;
          try {
            i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);
          } catch (err) {
            if (err.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY") {
              throw err;
            }
          }
          const best = recs[i];
          dht._log("GetValue %b %s", key, best);
          if (!best) {
            throw errcode7(new Error("best value was not found"), "ERR_NOT_FOUND");
          }
          await sendCorrectionRecord(key, vals, best);
          return best;
        },
        async getMany(key, nvals, options = {}) {
          options.timeout = options.timeout || c.minute;
          dht._log("getMany %b (%s)", key, nvals);
          const vals = [];
          let localRec;
          try {
            localRec = await getLocal(key);
          } catch (err) {
            if (nvals === 0) {
              throw err;
            }
          }
          if (localRec) {
            vals.push({
              val: localRec.value,
              from: dht.peerId
            });
          }
          if (vals.length >= nvals) {
            return vals;
          }
          const id = await utils.convertBuffer(key);
          const rtp = dht.routingTable.closestPeers(id, dht.kBucketSize);
          dht._log("peers in rt: %d", rtp.length);
          if (rtp.length === 0) {
            const errMsg = "Failed to lookup key! No peers from routing table!";
            dht._log.error(errMsg);
            if (vals.length === 0) {
              throw errcode7(new Error(errMsg), "ERR_NO_PEERS_IN_ROUTING_TABLE");
            }
            return vals;
          }
          const valsLength = vals.length;
          function createQuery2(pathIndex, numPaths) {
            const pathSize = utils.pathSize(nvals - valsLength, numPaths);
            let queryResults = 0;
            async function disjointPathQuery(peer) {
              let rec, peers, lookupErr;
              try {
                const results = await dht._getValueOrPeers(peer, key);
                rec = results.record;
                peers = results.peers;
              } catch (err) {
                if (err.code !== "ERR_INVALID_RECORD") {
                  throw err;
                }
                lookupErr = err;
              }
              const res = {
                closerPeers: peers
              };
              if (rec && rec.value) {
                vals.push({
                  val: rec.value,
                  from: peer
                });
                queryResults++;
              } else if (lookupErr) {
                vals.push({
                  err: lookupErr,
                  from: peer
                });
                queryResults++;
              }
              if (queryResults >= pathSize) {
                res.pathComplete = true;
              }
              return res;
            }
            return disjointPathQuery;
          }
          const query = new Query(dht, key, createQuery2);
          try {
            await pTimeout(query.run(rtp), options.timeout);
          } catch (err) {
            if (vals.length === 0) {
              throw err;
            }
          } finally {
            query.stop();
          }
          return vals;
        }
      };
    };
  }
});

// node_modules/libp2p-kad-dht/src/peer-list/index.js
var require_peer_list = __commonJS({
  "node_modules/libp2p-kad-dht/src/peer-list/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var PeerList = class {
      constructor() {
        this.list = [];
      }
      push(peerData) {
        if (!this.has(peerData.id)) {
          this.list.push(peerData);
          return true;
        }
        return false;
      }
      has(peerId) {
        const match = this.list.find((i) => i.id.equals(peerId));
        return Boolean(match);
      }
      toArray() {
        return this.list.slice();
      }
      pop() {
        return this.list.pop();
      }
      get length() {
        return this.list.length;
      }
    };
    module2.exports = PeerList;
  }
});

// node_modules/libp2p-kad-dht/src/peer-list/limited-peer-list.js
var require_limited_peer_list = __commonJS({
  "node_modules/libp2p-kad-dht/src/peer-list/limited-peer-list.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var PeerList = require_peer_list();
    var LimitedPeerList = class extends PeerList {
      constructor(limit) {
        super();
        this.limit = limit;
      }
      push(peerData) {
        if (this.length < this.limit) {
          return super.push(peerData);
        }
        return false;
      }
    };
    module2.exports = LimitedPeerList;
  }
});

// node_modules/libp2p-kad-dht/src/content-routing/index.js
var require_content_routing = __commonJS({
  "node_modules/libp2p-kad-dht/src/content-routing/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var pTimeout = require_p_timeout2();
    var c = require_constants10();
    var LimitedPeerList = require_limited_peer_list();
    var Message2 = require_message();
    var Query = require_query();
    var utils = require_utils15();
    module2.exports = (dht) => {
      const findProvidersSingle = async (peer, key) => {
        const msg = new Message2(Message2.TYPES.GET_PROVIDERS, key.bytes, 0);
        return dht.network.sendRequest(peer, msg);
      };
      return {
        async provide(key) {
          dht._log(`provide: ${key}`);
          const errors2 = [];
          await dht.providers.addProvider(key, dht.peerId);
          const multiaddrs = dht.libp2p ? dht.libp2p.multiaddrs : [];
          const msg = new Message2(Message2.TYPES.ADD_PROVIDER, key.bytes, 0);
          msg.providerPeers = [{
            id: dht.peerId,
            multiaddrs
          }];
          async function mapPeer(peer) {
            dht._log(`putProvider ${key} to ${peer.toB58String()}`);
            try {
              await dht.network.sendMessage(peer, msg);
            } catch (err) {
              errors2.push(err);
            }
          }
          await utils.mapParallel(dht.getClosestPeers(key.bytes), mapPeer);
          if (errors2.length) {
            throw errcode7(new Error(`Failed to provide to ${errors2.length} of ${dht.kBucketSize} peers`), "ERR_SOME_PROVIDES_FAILED", { errors: errors2 });
          }
        },
        async *findProviders(key, options = { timeout: 6e4, maxNumProviders: 5 }) {
          const providerTimeout = options.timeout || c.minute;
          const n = options.maxNumProviders || c.K;
          dht._log(`findProviders ${key}`);
          const out = new LimitedPeerList(n);
          const provs = await dht.providers.getProviders(key);
          provs.forEach((id) => {
            const peerData = dht.peerStore.get(id);
            if (peerData) {
              out.push({
                id: peerData.id,
                multiaddrs: peerData.addresses.map((address) => address.multiaddr)
              });
            } else {
              out.push({
                id,
                multiaddrs: []
              });
            }
          });
          if (out.length >= n) {
            for (const pData of out.toArray()) {
              yield pData;
            }
            return;
          }
          const paths = [];
          function makePath(pathIndex, numPaths) {
            const pathSize = utils.pathSize(n - out.length, numPaths);
            const pathProviders = new LimitedPeerList(pathSize);
            paths.push(pathProviders);
            async function queryDisjointPath(peer) {
              const msg = await findProvidersSingle(peer, key);
              const provs2 = msg.providerPeers;
              dht._log(`Found ${provs2.length} provider entries for ${key}`);
              provs2.forEach((prov) => {
                pathProviders.push({
                  ...prov
                });
              });
              if (pathProviders.length >= pathSize) {
                return { pathComplete: true };
              }
              return { closerPeers: msg.closerPeers };
            }
            return queryDisjointPath;
          }
          const query = new Query(dht, key.bytes, makePath);
          const peers = dht.routingTable.closestPeers(key.bytes, dht.kBucketSize);
          try {
            await pTimeout(query.run(peers), providerTimeout);
          } catch (err) {
            if (err.name !== pTimeout.TimeoutError.name) {
              throw err;
            }
          } finally {
            query.stop();
          }
          paths.forEach((path) => {
            path.toArray().forEach((peer) => {
              out.push(peer);
            });
          });
          for (const pData of out.toArray()) {
            yield pData;
          }
        }
      };
    };
  }
});

// node_modules/libp2p-kad-dht/src/peer-routing/index.js
var require_peer_routing = __commonJS({
  "node_modules/libp2p-kad-dht/src/peer-routing/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var pTimeout = require_p_timeout2();
    var PeerId2 = require_src6();
    var crypto3 = require_src7();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var c = require_constants10();
    var Message2 = require_message();
    var Query = require_query();
    var utils = require_utils15();
    module2.exports = (dht) => {
      const findPeerLocal = async (peer) => {
        dht._log(`findPeerLocal ${peer.toB58String()}`);
        const p = await dht.routingTable.find(peer);
        const peerData = p && dht.peerStore.get(p);
        if (peerData) {
          return {
            id: peerData.id,
            multiaddrs: peerData.addresses.map((address) => address.multiaddr)
          };
        }
      };
      const getValueSingle = async (peer, key) => {
        const msg = new Message2(Message2.TYPES.GET_VALUE, key, 0);
        return dht.network.sendRequest(peer, msg);
      };
      const closerPeersSingle = async (key, peer) => {
        dht._log(`closerPeersSingle ${uint8ArrayToString(key, "base32")} from ${peer.toB58String()}`);
        const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId2(key));
        return msg.closerPeers.filter((peerData) => !dht._isSelf(peerData.id)).map((peerData) => {
          dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs);
          return peerData;
        });
      };
      const getPublicKeyFromNode = async (peer) => {
        const pkKey = utils.keyForPublicKey(peer);
        const msg = await getValueSingle(peer, pkKey);
        if (!msg.record || !msg.record.value) {
          throw errcode7(new Error(`Node not responding with its public key: ${peer.toB58String()}`), "ERR_INVALID_RECORD");
        }
        const recPeer = await PeerId2.createFromPubKey(msg.record.value);
        if (!recPeer.equals(peer)) {
          throw errcode7(new Error("public key does not match id"), "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");
        }
        return recPeer.pubKey;
      };
      return {
        async _findPeerSingle(peer, target) {
          dht._log("findPeerSingle %s", peer.toB58String());
          const msg = new Message2(Message2.TYPES.FIND_NODE, target.id, 0);
          return dht.network.sendRequest(peer, msg);
        },
        async findPeer(id, options = { timeout: 6e4 }) {
          options.timeout = options.timeout || c.minute;
          dht._log("findPeer %s", id.toB58String());
          const pi = await findPeerLocal(id);
          if (pi != null) {
            dht._log("found local");
            return pi;
          }
          const key = await utils.convertPeerId(id);
          const peers = dht.routingTable.closestPeers(key, dht.kBucketSize);
          if (peers.length === 0) {
            throw errcode7(new Error("Peer lookup failed"), "ERR_LOOKUP_FAILED");
          }
          const match = peers.find((p) => p.isEqual(id));
          if (match) {
            const peer = dht.peerStore.get(id);
            if (peer) {
              dht._log("found in peerStore");
              return {
                id: peer.id,
                multiaddrs: peer.addresses.map((address) => address.multiaddr)
              };
            }
          }
          const query = new Query(dht, id.id, () => {
            const queryFn = async (peer) => {
              const msg = await this._findPeerSingle(peer, id);
              const match2 = msg.closerPeers.find((p) => p.id.isEqual(id));
              if (match2) {
                return {
                  peer: match2,
                  queryComplete: true
                };
              }
              return {
                closerPeers: msg.closerPeers
              };
            };
            return queryFn;
          });
          let result;
          try {
            result = await pTimeout(query.run(peers), options.timeout);
          } finally {
            query.stop();
          }
          let success = false;
          result.paths.forEach((result2) => {
            if (result2.success && result2.peer) {
              success = true;
              dht.peerStore.addressBook.add(result2.peer.id, result2.peer.multiaddrs);
            }
          });
          dht._log("findPeer %s: %s", id.toB58String(), success);
          if (!success) {
            throw errcode7(new Error("No peer found"), "ERR_NOT_FOUND");
          }
          const peerData = dht.peerStore.get(id);
          if (!peerData) {
            throw errcode7(new Error("No peer found in peer store"), "ERR_NOT_FOUND");
          }
          return {
            id: peerData.id,
            multiaddrs: peerData.addresses.map((address) => address.multiaddr)
          };
        },
        async *getClosestPeers(key, options = { shallow: false }) {
          dht._log("getClosestPeers to %b", key);
          const id = await utils.convertBuffer(key);
          const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);
          const q = new Query(dht, key, () => {
            return async (peer) => {
              const closer = await closerPeersSingle(key, peer);
              return {
                closerPeers: closer,
                pathComplete: options.shallow ? true : void 0
              };
            };
          });
          const res = await q.run(tablePeers);
          if (!res || !res.finalSet) {
            return [];
          }
          const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id);
          for (const pId of sorted.slice(0, dht.kBucketSize)) {
            yield pId;
          }
        },
        async getPublicKey(peer) {
          dht._log("getPublicKey %s", peer.toB58String());
          const peerData = dht.peerStore.get(peer);
          if (peerData && peerData.id.pubKey) {
            dht._log("getPublicKey: found local copy");
            return peerData.id.pubKey;
          }
          let pk;
          try {
            pk = await getPublicKeyFromNode(peer);
          } catch (err) {
            const pkKey = utils.keyForPublicKey(peer);
            const value = await dht.get(pkKey);
            pk = crypto3.keys.unmarshalPublicKey(value);
          }
          const peerId = new PeerId2(peer.id, void 0, pk);
          const addrs = (peerData && peerData.addresses || []).map((address) => address.multiaddr);
          dht.peerStore.addressBook.add(peerId, addrs);
          dht.peerStore.keyBook.set(peerId, pk);
          return pk;
        }
      };
    };
  }
});

// node_modules/libp2p-kad-dht/src/providers.js
var require_providers = __commonJS({
  "node_modules/libp2p-kad-dht/src/providers.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var cache2 = require_hashlru();
    var varint7 = require_varint();
    var PeerId2 = require_src6();
    var { Key: Key2 } = (init_key(), key_exports);
    var { default: Queue4 } = require_dist();
    var c = require_constants10();
    var utils = require_utils15();
    var Providers = class {
      constructor(datastore, self2, cacheSize) {
        this.datastore = datastore;
        this._log = utils.logger(self2, "providers");
        this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL;
        this.provideValidity = c.PROVIDERS_VALIDITY;
        this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE;
        this.providers = cache2(this.lruCacheSize);
        this.syncQueue = new Queue4({ concurrency: 1 });
      }
      start() {
        if (this._started) {
          return;
        }
        this._started = true;
        this._cleaner = setInterval(() => this._cleanup(), this.cleanupInterval);
      }
      stop() {
        this._started = false;
        if (this._cleaner) {
          clearInterval(this._cleaner);
          this._cleaner = null;
        }
      }
      _cleanup() {
        return this.syncQueue.add(async () => {
          this._log("start cleanup");
          const start = Date.now();
          let count = 0;
          let deleteCount = 0;
          const deleted = new Map();
          const batch3 = this.datastore.batch();
          const query = this.datastore.query({ prefix: c.PROVIDERS_KEY_PREFIX });
          for await (const entry of query) {
            try {
              const { cid, peerId } = parseProviderKey(entry.key);
              const time = readTime(entry.value);
              const now = Date.now();
              const delta = now - time;
              const expired = delta > this.provideValidity;
              this._log("comparing: %d - %d = %d > %d %s", now, time, delta, this.provideValidity, expired ? "(expired)" : "");
              if (expired) {
                deleteCount++;
                batch3.delete(entry.key);
                const peers = deleted.get(cid) || new Set();
                peers.add(peerId);
                deleted.set(cid, peers);
              }
              count++;
            } catch (err) {
              this._log.error(err.message);
            }
          }
          this._log("deleting %d / %d entries", deleteCount, count);
          if (deleted.size) {
            await batch3.commit();
          }
          for (const [cid, peers] of deleted) {
            const key = makeProviderKey(cid);
            const provs = this.providers.get(key);
            if (provs) {
              for (const peerId of peers) {
                provs.delete(peerId);
              }
              if (provs.size === 0) {
                this.providers.remove(key);
              } else {
                this.providers.set(key, provs);
              }
            }
          }
          this._log("Cleanup successful (%dms)", Date.now() - start);
        });
      }
      async _getProvidersMap(cid) {
        const cacheKey = makeProviderKey(cid);
        let provs = this.providers.get(cacheKey);
        if (!provs) {
          provs = await loadProviders(this.datastore, cid);
          this.providers.set(cacheKey, provs);
        }
        return provs;
      }
      async addProvider(cid, provider) {
        return this.syncQueue.add(async () => {
          this._log("addProvider %s", cid.toString());
          const provs = await this._getProvidersMap(cid);
          this._log("loaded %s provs", provs.size);
          const now = new Date();
          provs.set(utils.encodeBase32(provider.id), now);
          const dsKey = makeProviderKey(cid);
          this.providers.set(dsKey, provs);
          return writeProviderEntry(this.datastore, cid, provider, now);
        });
      }
      async getProviders(cid) {
        return this.syncQueue.add(async () => {
          this._log("getProviders %s", cid.toString());
          const provs = await this._getProvidersMap(cid);
          return [...provs.keys()].map((base32PeerId) => {
            return new PeerId2(utils.decodeBase32(base32PeerId));
          });
        });
      }
    };
    function makeProviderKey(cid) {
      cid = typeof cid === "string" ? cid : utils.encodeBase32(cid.bytes);
      return c.PROVIDERS_KEY_PREFIX + cid;
    }
    async function writeProviderEntry(store, cid, peer, time) {
      const dsKey = [
        makeProviderKey(cid),
        "/",
        utils.encodeBase32(peer.id)
      ].join("");
      const key = new Key2(dsKey);
      const buffer2 = Uint8Array.from(varint7.encode(time.getTime()));
      return store.put(key, buffer2);
    }
    function parseProviderKey(key) {
      const parts = key.toString().split("/");
      if (parts.length !== 4) {
        throw new Error("incorrectly formatted provider entry key in datastore: " + key);
      }
      return {
        cid: parts[2],
        peerId: parts[3]
      };
    }
    async function loadProviders(store, cid) {
      const providers = new Map();
      const query = store.query({ prefix: makeProviderKey(cid) });
      for await (const entry of query) {
        const { peerId } = parseProviderKey(entry.key);
        providers.set(peerId, readTime(entry.value));
      }
      return providers;
    }
    function readTime(buf2) {
      return varint7.decode(buf2);
    }
    module2.exports = Providers;
  }
});

// node_modules/libp2p-kad-dht/src/query-manager.js
var require_query_manager = __commonJS({
  "node_modules/libp2p-kad-dht/src/query-manager.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var QueryManager = class {
      constructor() {
        this.queries = new Set();
        this.running = false;
      }
      queryStarted(query) {
        this.queries.add(query);
      }
      queryCompleted(query) {
        this.queries.delete(query);
      }
      start() {
        this.running = true;
      }
      stop() {
        this.running = false;
        for (const query of this.queries) {
          query.stop();
        }
        this.queries.clear();
      }
    };
    module2.exports = QueryManager;
  }
});

// node_modules/libp2p-kad-dht/src/index.js
var require_src23 = __commonJS({
  "node_modules/libp2p-kad-dht/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { EventEmitter: EventEmitter4 } = require_events();
    var errcode7 = require_err_code();
    var libp2pRecord = require_src8();
    var { MemoryDatastore: MemoryDatastore2 } = (init_memory(), memory_exports);
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var RoutingTable = require_routing_table();
    var utils = require_utils15();
    var c = require_constants10();
    var Network2 = require_network();
    var contentFetching = require_content_fetching();
    var contentRouting = require_content_routing();
    var peerRouting = require_peer_routing();
    var Message2 = require_message();
    var Providers = require_providers();
    var QueryManager = require_query_manager();
    var Record = libp2pRecord.Record;
    var KadDHT2 = class extends EventEmitter4 {
      constructor({
        libp2p,
        dialer,
        peerId,
        peerStore,
        registrar,
        protocolPrefix = "/ipfs",
        forceProtocolLegacy = false,
        datastore = new MemoryDatastore2(),
        kBucketSize = c.K,
        clientMode = false,
        concurrency = c.ALPHA,
        validators = {},
        selectors = {},
        onPut = () => {
        },
        onRemove = () => {
        }
      }) {
        super();
        if (!dialer) {
          throw new Error("libp2p-kad-dht requires an instance of Dialer");
        }
        this.libp2p = libp2p;
        this.dialer = dialer;
        this.peerId = peerId;
        this.peerStore = peerStore;
        this.registrar = registrar;
        this.protocol = protocolPrefix + (forceProtocolLegacy ? "" : c.PROTOCOL_DHT);
        this.kBucketSize = kBucketSize;
        this._clientMode = clientMode;
        this.concurrency = concurrency;
        this.disjointPaths = Math.ceil(this.kBucketSize / 2);
        this.routingTable = new RoutingTable(this, { kBucketSize: this.kBucketSize });
        this.datastore = datastore;
        this.providers = new Providers(this.datastore, this.peerId);
        this.validators = {
          pk: libp2pRecord.validator.validators.pk,
          ...validators
        };
        this.selectors = {
          pk: libp2pRecord.selection.selectors.pk,
          ...selectors
        };
        this.network = new Network2(this);
        this._log = utils.logger(this.peerId);
        this._queryManager = new QueryManager();
        this._running = false;
        this.contentFetching = contentFetching(this);
        this.contentRouting = contentRouting(this);
        this.peerRouting = peerRouting(this);
        this.onPut = onPut;
        this.onRemove = onRemove;
      }
      get isStarted() {
        return this._running;
      }
      start() {
        this._running = true;
        return Promise.all([
          this.providers.start(),
          this._queryManager.start(),
          this.network.start(),
          this.routingTable.start()
        ]);
      }
      stop() {
        this._running = false;
        return Promise.all([
          this.providers.stop(),
          this._queryManager.stop(),
          this.network.stop(),
          this.routingTable.stop()
        ]);
      }
      async put(key, value, options = {}) {
        return this.contentFetching.put(key, value, options);
      }
      async get(key, options = {}) {
        return this.contentFetching.get(key, options);
      }
      async getMany(key, nvals, options = {}) {
        return this.contentFetching.getMany(key, nvals, options);
      }
      async removeLocal(key) {
        this._log(`removeLocal: ${uint8ArrayToString(key, "base32")}`);
        const dsKey = utils.bufferToKey(key);
        try {
          await this.datastore.delete(dsKey);
        } catch (err) {
          if (err.code === "ERR_NOT_FOUND") {
            return void 0;
          }
          throw err;
        }
      }
      async _putLocal(key, value) {
        this._log(`_putLocal: ${uint8ArrayToString(key, "base32")}`);
        const dsKey = utils.bufferToKey(key);
        await this.datastore.put(dsKey, value);
      }
      async provide(key) {
        return this.contentRouting.provide(key);
      }
      async *findProviders(key, options = { timeout: 6e3, maxNumProviders: 5 }) {
        for await (const peerData of this.contentRouting.findProviders(key, options)) {
          yield peerData;
        }
      }
      async findPeer(id, options = { timeout: 6e4 }) {
        return this.peerRouting.findPeer(id, options);
      }
      async *getClosestPeers(key, options = { shallow: false }) {
        yield* this.peerRouting.getClosestPeers(key, options);
      }
      getPublicKey(peer) {
        return this.peerRouting.getPublicKey(peer);
      }
      _peerDiscovered(peerId, multiaddrs) {
        this.emit("peer", {
          id: peerId,
          multiaddrs
        });
      }
      async _nearestPeersToQuery(msg) {
        const key = await utils.convertBuffer(msg.key);
        const ids = this.routingTable.closestPeers(key, this.kBucketSize);
        return ids.map((p) => {
          const peer = this.peerStore.get(p);
          return {
            id: p,
            multiaddrs: peer ? peer.addresses.map((address) => address.multiaddr) : []
          };
        });
      }
      async _betterPeersToQuery(msg, peerId) {
        this._log("betterPeersToQuery");
        const closer = await this._nearestPeersToQuery(msg);
        return closer.filter((closer2) => {
          if (this._isSelf(closer2.id)) {
            this._log.error("trying to return self as closer");
            return false;
          }
          return !closer2.id.isEqual(peerId);
        });
      }
      async _checkLocalDatastore(key) {
        this._log(`checkLocalDatastore: ${uint8ArrayToString(key)} %b`, key);
        const dsKey = utils.bufferToKey(key);
        let rawRecord;
        try {
          rawRecord = await this.datastore.get(dsKey);
        } catch (err) {
          if (err.code === "ERR_NOT_FOUND") {
            return void 0;
          }
          throw err;
        }
        const record = Record.deserialize(rawRecord);
        if (!record) {
          throw errcode7(new Error("Invalid record"), "ERR_INVALID_RECORD");
        }
        if (record.timeReceived == null || utils.now() - record.timeReceived.getTime() > c.MAX_RECORD_AGE) {
          await this.datastore.delete(dsKey);
          this.onRemove(record);
          return void 0;
        }
        return record;
      }
      async _add(peerId) {
        await this.routingTable.add(peerId);
      }
      async _verifyRecordLocally(record) {
        this._log("verifyRecordLocally");
        await libp2pRecord.validator.verifyRecord(this.validators, record);
      }
      _isSelf(other) {
        return other && uint8ArrayEquals(this.peerId.id, other.id);
      }
      async _putValueToPeer(key, rec, target) {
        const msg = new Message2(Message2.TYPES.PUT_VALUE, key, 0);
        msg.record = Record.deserialize(rec);
        const resp = await this.network.sendRequest(target, msg);
        if (resp.record && !uint8ArrayEquals(resp.record.value, Record.deserialize(rec).value)) {
          throw errcode7(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID");
        }
      }
      async _getValueOrPeers(peer, key) {
        const msg = await this._getValueSingle(peer, key);
        const peers = msg.closerPeers;
        const record = msg.record;
        if (record) {
          try {
            await this._verifyRecordOnline(record);
          } catch (err) {
            const errMsg = "invalid record received, discarded";
            this._log(errMsg);
            throw errcode7(new Error(errMsg), "ERR_INVALID_RECORD");
          }
          return { record, peers };
        }
        if (peers.length > 0) {
          return { peers };
        }
        throw errcode7(new Error("Not found"), "ERR_NOT_FOUND");
      }
      async _getValueSingle(peer, key) {
        const msg = new Message2(Message2.TYPES.GET_VALUE, key, 0);
        return this.network.sendRequest(peer, msg);
      }
      async _verifyRecordOnline(record) {
        await libp2pRecord.validator.verifyRecord(this.validators, record);
      }
    };
    module2.exports = KadDHT2;
    module2.exports.multicodec = "/ipfs" + c.PROTOCOL_DHT;
  }
});

// node_modules/ipfs-core-config/esm/src/utils/ipns.js
function selector(_k, records) {
  return validator.select(records[0], records[1]);
}
var validator2;
var init_ipns2 = __esm({
  "node_modules/ipfs-core-config/esm/src/utils/ipns.js"() {
    init_node_globals();
    init_src4();
    validator2 = { func: (key, record) => validator.validate(record, key) };
  }
});

// node_modules/ipfs-core-config/esm/src/libp2p.browser.js
var libp2p_browser_exports = {};
__export(libp2p_browser_exports, {
  libp2pConfig: () => libp2pConfig
});
function libp2pConfig() {
  const options = {
    dialer: {
      maxParallelDials: 150,
      maxDialsPerPeer: 4,
      dialTimeout: 1e4
    },
    modules: {
      transport: [
        import_libp2p_websockets.default,
        import_libp2p_webrtc_star.default
      ],
      streamMuxer: [import_libp2p_mplex.default],
      connEncryption: [import_libp2p_noise.NOISE],
      peerDiscovery: [],
      dht: import_libp2p_kad_dht.default,
      pubsub: import_libp2p_gossipsub2.default
    },
    config: {
      peerDiscovery: {
        autoDial: true,
        bootstrap: { enabled: true },
        webRTCStar: { enabled: true }
      },
      dht: {
        kBucketSize: 20,
        enabled: false,
        clientMode: true,
        randomWalk: { enabled: false },
        validators: { ipns: validator2 },
        selectors: { ipns: selector }
      },
      pubsub: {
        enabled: true,
        emitSelf: true
      },
      nat: { enabled: false }
    },
    metrics: { enabled: true },
    peerStore: {
      persistence: true,
      threshold: 1
    }
  };
  return options;
}
var import_libp2p_websockets, import_libp2p_webrtc_star, import_libp2p_mplex, import_libp2p_noise, import_libp2p_kad_dht, import_libp2p_gossipsub2;
var init_libp2p_browser = __esm({
  "node_modules/ipfs-core-config/esm/src/libp2p.browser.js"() {
    init_node_globals();
    import_libp2p_websockets = __toModule(require_src17());
    import_libp2p_webrtc_star = __toModule(require_src18());
    import_libp2p_mplex = __toModule(require_src19());
    import_libp2p_noise = __toModule(require_src22());
    import_libp2p_kad_dht = __toModule(require_src23());
    import_libp2p_gossipsub2 = __toModule(require_src14());
    init_ipns2();
  }
});

// node_modules/libp2p-bootstrap/src/index.js
var require_src24 = __commonJS({
  "node_modules/libp2p-bootstrap/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var PeerId2 = require_src6();
    var { Multiaddr: Multiaddr18 } = require_src();
    var mafmt = require_src2();
    var { EventEmitter: EventEmitter4 } = require_events();
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:bootstrap"), {
      error: debug17("libp2p:bootstrap:error")
    });
    var Bootstrap = class extends EventEmitter4 {
      constructor(options = { list: [] }) {
        if (!options.list || !options.list.length) {
          throw new Error("Bootstrap requires a list of peer addresses");
        }
        super();
        this._list = options.list;
        this._interval = options.interval || 1e4;
        this._timer = null;
      }
      start() {
        if (this._timer) {
          return;
        }
        this._timer = setInterval(() => this._discoverBootstrapPeers(), this._interval);
        log15("Starting bootstrap node discovery");
        this._discoverBootstrapPeers();
      }
      _discoverBootstrapPeers() {
        if (!this._timer) {
          return;
        }
        this._list.forEach((candidate) => {
          if (!mafmt.P2P.matches(candidate)) {
            return log15.error("Invalid multiaddr");
          }
          const ma = new Multiaddr18(candidate);
          const peerIdStr = ma.getPeerId();
          if (!peerIdStr) {
            log15.error("Invalid bootstrap multiaddr without peer id");
            return;
          }
          const peerId = PeerId2.createFromB58String(peerIdStr);
          try {
            this.emit("peer", {
              id: peerId,
              multiaddrs: [ma]
            });
          } catch (err) {
            log15.error("Invalid bootstrap peer id", err);
          }
        });
      }
      stop() {
        if (this._timer)
          clearInterval(this._timer);
        this._timer = null;
      }
    };
    exports2 = module2.exports = Bootstrap;
    exports2.tag = "bootstrap";
  }
});

// node_modules/libp2p/src/content-routing/utils.js
var require_utils16 = __commonJS({
  "node_modules/libp2p/src/content-routing/utils.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errCode32 = require_err_code();
    var filter8 = require_it_filter();
    var map8 = require_it_map();
    var take5 = require_it_take();
    function storeAddresses(source, peerStore) {
      return map8(source, (peer) => {
        peerStore.addressBook.add(peer.id, peer.multiaddrs);
        return peer;
      });
    }
    function uniquePeers(source) {
      const seen = new Set();
      return filter8(source, (peer) => {
        if (seen.has(peer.id.toString())) {
          return false;
        }
        seen.add(peer.id.toString());
        return true;
      });
    }
    async function* requirePeers(source, min = 1) {
      let seen = 0;
      for await (const peer of source) {
        seen++;
        yield peer;
      }
      if (seen < min) {
        throw errCode32(new Error("not found"), "NOT_FOUND");
      }
    }
    function maybeLimitSource(source, max) {
      if (max) {
        return take5(source, max);
      }
      return source;
    }
    module2.exports = {
      storeAddresses,
      uniquePeers,
      requirePeers,
      maybeLimitSource
    };
  }
});

// node_modules/set-delayed-interval/src/index.js
var require_src25 = __commonJS({
  "node_modules/set-delayed-interval/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var intervals = new Map();
    var _generateId = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`;
    async function _runPeriodically(task, interval, id) {
      while (intervals.get(id)) {
        try {
          await task();
        } catch (err) {
          setTimeout(() => {
            throw err;
          }, 1);
          break;
        }
        if (!intervals.get(id)) {
          break;
        }
        await new Promise((resolve6) => {
          const _timeout = setTimeout(resolve6, interval);
          intervals.set(id, _timeout);
        });
      }
    }
    function setDelayedInterval(task, interval, delay) {
      delay = delay || interval;
      const id = _generateId();
      const _timeout = setTimeout(() => {
        _runPeriodically(task, interval, id);
      }, delay);
      intervals.set(id, _timeout);
      return id;
    }
    function clearDelayedInterval(id) {
      const _timeout = intervals.get(id);
      if (_timeout) {
        clearTimeout(_timeout);
        intervals.delete(id);
      }
    }
    module2.exports = {
      setDelayedInterval,
      clearDelayedInterval
    };
  }
});

// node_modules/libp2p/src/peer-routing.js
var require_peer_routing2 = __commonJS({
  "node_modules/libp2p/src/peer-routing.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:peer-routing"), {
      error: debug17("libp2p:peer-routing:err")
    });
    var errCode32 = require_err_code();
    var {
      storeAddresses,
      uniquePeers,
      requirePeers
    } = require_utils16();
    var merge4 = require_it_merge();
    var { pipe: pipe4 } = require_it_pipe();
    var first3 = require_it_first();
    var drain6 = require_it_drain();
    var filter8 = require_it_filter();
    var {
      setDelayedInterval,
      clearDelayedInterval
    } = require_src25();
    var PeerRouting = class {
      constructor(libp2p) {
        this._peerId = libp2p.peerId;
        this._peerStore = libp2p.peerStore;
        this._routers = libp2p._modules.peerRouting || [];
        if (libp2p._dht && libp2p._config.dht.enabled) {
          this._routers.push(libp2p._dht);
        }
        this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager;
        this._findClosestPeersTask = this._findClosestPeersTask.bind(this);
      }
      start() {
        if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {
          return;
        }
        this._timeoutId = setDelayedInterval(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay);
      }
      async _findClosestPeersTask() {
        try {
          await drain6(this.getClosestPeers(this._peerId.id));
        } catch (err) {
          log15.error(err);
        }
      }
      stop() {
        clearDelayedInterval(this._timeoutId);
      }
      async findPeer(id, options) {
        if (!this._routers.length) {
          throw errCode32(new Error("No peer routers available"), "NO_ROUTERS_AVAILABLE");
        }
        if (id.toB58String() === this._peerId.toB58String()) {
          throw errCode32(new Error("Should not try to find self"), "ERR_FIND_SELF");
        }
        const output = await pipe4(merge4(...this._routers.map((router) => [router.findPeer(id, options)])), (source) => filter8(source, Boolean), (source) => storeAddresses(source, this._peerStore), (source) => first3(source));
        if (output) {
          return output;
        }
        throw errCode32(new Error("not found"), "NOT_FOUND");
      }
      async *getClosestPeers(key, options = { timeout: 3e4 }) {
        if (!this._routers.length) {
          throw errCode32(new Error("No peer routers available"), "NO_ROUTERS_AVAILABLE");
        }
        yield* pipe4(merge4(...this._routers.map((router) => router.getClosestPeers(key, options))), (source) => storeAddresses(source, this._peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
      }
    };
    module2.exports = PeerRouting;
  }
});

// node_modules/libp2p/src/content-routing/index.js
var require_content_routing2 = __commonJS({
  "node_modules/libp2p/src/content-routing/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errCode32 = require_err_code();
    var { messages, codes } = require_errors4();
    var {
      storeAddresses,
      uniquePeers,
      requirePeers,
      maybeLimitSource
    } = require_utils16();
    var merge4 = require_it_merge();
    var { pipe: pipe4 } = require_it_pipe();
    var ContentRouting = class {
      constructor(libp2p) {
        this.libp2p = libp2p;
        this.routers = libp2p._modules.contentRouting || [];
        this.dht = libp2p._dht;
        if (this.dht && libp2p._config.dht.enabled) {
          this.routers.push(this.dht);
        }
      }
      async *findProviders(key, options = {}) {
        if (!this.routers.length) {
          throw errCode32(new Error("No content this.routers available"), "NO_ROUTERS_AVAILABLE");
        }
        yield* pipe4(merge4(...this.routers.map((router) => router.findProviders(key, options))), (source) => storeAddresses(source, this.libp2p.peerStore), (source) => uniquePeers(source), (source) => maybeLimitSource(source, options.maxNumProviders), (source) => requirePeers(source));
      }
      async provide(key) {
        if (!this.routers.length) {
          throw errCode32(new Error("No content routers available"), "NO_ROUTERS_AVAILABLE");
        }
        await Promise.all(this.routers.map((router) => router.provide(key)));
      }
      put(key, value, options) {
        if (!this.libp2p.isStarted() || !this.dht.isStarted) {
          throw errCode32(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
        }
        return this.dht.put(key, value, options);
      }
      get(key, options) {
        if (!this.libp2p.isStarted() || !this.dht.isStarted) {
          throw errCode32(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
        }
        return this.dht.get(key, options);
      }
      async getMany(key, nVals, options) {
        if (!this.libp2p.isStarted() || !this.dht.isStarted) {
          throw errCode32(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
        }
        return this.dht.getMany(key, nVals, options);
      }
    };
    module2.exports = ContentRouting;
  }
});

// node_modules/libp2p/src/get-peer.js
var require_get_peer = __commonJS({
  "node_modules/libp2p/src/get-peer.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var PeerId2 = require_src6();
    var { Multiaddr: Multiaddr18 } = require_src();
    var errCode32 = require_err_code();
    var { codes } = require_errors4();
    function getPeer(peer) {
      if (typeof peer === "string") {
        peer = new Multiaddr18(peer);
      }
      let addr;
      if (Multiaddr18.isMultiaddr(peer)) {
        addr = peer;
        const idStr = peer.getPeerId();
        if (!idStr) {
          throw errCode32(new Error(`${peer} does not have a valid peer type`), codes.ERR_INVALID_MULTIADDR);
        }
        try {
          peer = PeerId2.createFromB58String(idStr);
        } catch (err) {
          throw errCode32(new Error(`${peer} is not a valid peer type`), codes.ERR_INVALID_MULTIADDR);
        }
      }
      return {
        id: peer,
        multiaddrs: addr ? [addr] : void 0
      };
    }
    module2.exports = getPeer;
  }
});

// node_modules/receptacle/index.js
var require_receptacle = __commonJS({
  "node_modules/receptacle/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = Receptacle;
    var toMS = require_ms();
    var cache2 = Receptacle.prototype;
    var counter = new Date() % 1e9;
    function getUID() {
      return (Math.random() * 1e9 >>> 0) + counter++;
    }
    function Receptacle(options) {
      options = options || {};
      this.id = options.id || getUID();
      this.max = options.max || Infinity;
      this.items = options.items || [];
      this._lookup = {};
      this.size = this.items.length;
      this.lastModified = new Date(options.lastModified || new Date());
      for (var item, ttl2, i = this.items.length; i--; ) {
        item = this.items[i];
        ttl2 = new Date(item.expires) - new Date();
        this._lookup[item.key] = item;
        if (ttl2 > 0)
          this.expire(item.key, ttl2);
        else if (ttl2 <= 0)
          this.delete(item.key);
      }
    }
    cache2.has = function(key) {
      return key in this._lookup;
    };
    cache2.get = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (record.refresh)
        this.expire(key, record.refresh);
      this.items.splice(this.items.indexOf(record), 1);
      this.items.push(record);
      return record.value;
    };
    cache2.meta = function(key) {
      if (!this.has(key))
        return null;
      var record = this._lookup[key];
      if (!("meta" in record))
        return null;
      return record.meta;
    };
    cache2.set = function(key, value, options) {
      var oldRecord = this._lookup[key];
      var record = this._lookup[key] = { key, value };
      this.lastModified = new Date();
      if (oldRecord) {
        clearTimeout(oldRecord.timeout);
        this.items.splice(this.items.indexOf(oldRecord), 1, record);
      } else {
        if (this.size >= this.max)
          this.delete(this.items[0].key);
        this.items.push(record);
        this.size++;
      }
      if (options) {
        if ("ttl" in options)
          this.expire(key, options.ttl);
        if ("meta" in options)
          record.meta = options.meta;
        if (options.refresh)
          record.refresh = options.ttl;
      }
      return this;
    };
    cache2.delete = function(key) {
      var record = this._lookup[key];
      if (!record)
        return false;
      this.lastModified = new Date();
      this.items.splice(this.items.indexOf(record), 1);
      clearTimeout(record.timeout);
      delete this._lookup[key];
      this.size--;
      return this;
    };
    cache2.expire = function(key, ttl2) {
      var ms = ttl2 || 0;
      var record = this._lookup[key];
      if (!record)
        return this;
      if (typeof ms === "string")
        ms = toMS(ttl2);
      if (typeof ms !== "number")
        throw new TypeError("Expiration time must be a string or number.");
      clearTimeout(record.timeout);
      record.timeout = setTimeout(this.delete.bind(this, record.key), ms);
      record.expires = Number(new Date()) + ms;
      return this;
    };
    cache2.clear = function() {
      for (var i = this.items.length; i--; )
        this.delete(this.items[i].key);
      return this;
    };
    cache2.toJSON = function() {
      var items = new Array(this.items.length);
      var item;
      for (var i = items.length; i--; ) {
        item = this.items[i];
        items[i] = {
          key: item.key,
          meta: item.meta,
          value: item.value,
          expires: item.expires,
          refresh: item.refresh
        };
      }
      return {
        id: this.id,
        max: isFinite(this.max) ? this.max : void 0,
        lastModified: this.lastModified,
        items
      };
    };
  }
});

// node_modules/dns-over-http-resolver/src/utils.js
var require_utils17 = __commonJS({
  "node_modules/dns-over-http-resolver/src/utils.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { default: nativeFetch, Headers } = require_src5();
    function buildResource({ serverResolver, hostname, recordType }) {
      return `${serverResolver}?name=${hostname}&type=${recordType}`;
    }
    function fetch(resource) {
      return nativeFetch(resource, {
        headers: new Headers({
          accept: "application/dns-json"
        })
      });
    }
    function getCacheKey(hostname, recordType) {
      return `${recordType}_${hostname}`;
    }
    module2.exports = {
      buildResource,
      fetch,
      getCacheKey
    };
  }
});

// node_modules/dns-over-http-resolver/src/index.js
var require_src26 = __commonJS({
  "node_modules/dns-over-http-resolver/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = debug17("dns-over-http-resolver");
    log15.error = debug17("dns-over-http-resolver:error");
    var Receptacle = require_receptacle();
    var utils = require_utils17();
    var Resolver = class {
      constructor({ maxCache = 100 } = {}) {
        this._cache = new Receptacle({ max: maxCache });
        this._servers = [
          "https://cloudflare-dns.com/dns-query",
          "https://dns.google/resolve"
        ];
      }
      getServers() {
        return this._servers;
      }
      _getShuffledServers() {
        const newServers = [].concat(this._servers);
        for (let i = newServers.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * i);
          const temp = newServers[i];
          newServers[i] = newServers[j];
          newServers[j] = temp;
        }
        return newServers;
      }
      setServers(servers) {
        this._servers = servers;
      }
      resolve(hostname, rrType = "A") {
        switch (rrType) {
          case "A":
            return this.resolve4(hostname);
          case "AAAA":
            return this.resolve6(hostname);
          case "TXT":
            return this.resolveTxt(hostname);
          default:
            throw new Error(`${rrType} is not supported`);
        }
      }
      async resolve4(hostname) {
        const recordType = "A";
        const cached = this._cache.get(utils.getCacheKey(hostname, recordType));
        if (cached) {
          return cached;
        }
        for (const server of this._getShuffledServers()) {
          try {
            const response = await utils.fetch(utils.buildResource({
              serverResolver: server,
              hostname,
              recordType
            }));
            const d = await response.json();
            const data = d.Answer.map((a) => a.data);
            const ttl2 = Math.min(d.Answer.map((a) => a.TTL));
            this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl: ttl2 });
            return data;
          } catch (err) {
            log15.error(`${server} could not resolve ${hostname} record ${recordType}`);
          }
        }
        throw new Error(`Could not resolve ${hostname} record ${recordType}`);
      }
      async resolve6(hostname) {
        const recordType = "AAAA";
        const cached = this._cache.get(utils.getCacheKey(hostname, recordType));
        if (cached) {
          return cached;
        }
        for (const server of this._getShuffledServers()) {
          try {
            const response = await utils.fetch(utils.buildResource({
              serverResolver: server,
              hostname,
              recordType
            }));
            const d = await response.json();
            const data = d.Answer.map((a) => a.data);
            const ttl2 = Math.min(d.Answer.map((a) => a.TTL));
            this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl: ttl2 });
            return data;
          } catch (err) {
            log15.error(`${server} could not resolve ${hostname} record ${recordType}`);
          }
        }
        throw new Error(`Could not resolve ${hostname} record ${recordType}`);
      }
      async resolveTxt(hostname) {
        const recordType = "TXT";
        const cached = this._cache.get(utils.getCacheKey(hostname, recordType));
        if (cached) {
          return cached;
        }
        for (const server of this._getShuffledServers()) {
          try {
            const response = await utils.fetch(utils.buildResource({
              serverResolver: server,
              hostname,
              recordType
            }));
            const d = await response.json();
            const data = d.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
            const ttl2 = Math.min(d.Answer.map((a) => a.TTL));
            this._cache.set(utils.getCacheKey(hostname, recordType), data, { ttl: ttl2 });
            return data;
          } catch (err) {
            log15.error(`${server} could not resolve ${hostname} record ${recordType}`);
          }
        }
        throw new Error(`Could not resolve ${hostname} record ${recordType}`);
      }
    };
    Resolver.Resolver = Resolver;
    module2.exports = Resolver;
  }
});

// node_modules/multiaddr/src/resolvers/dns.browser.js
var require_dns_browser = __commonJS({
  "node_modules/multiaddr/src/resolvers/dns.browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var dns = require_src26();
    module2.exports = dns;
  }
});

// node_modules/multiaddr/src/resolvers/index.js
var require_resolvers = __commonJS({
  "node_modules/multiaddr/src/resolvers/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var protocols = require_protocols_table();
    var { code: dnsaddrCode } = protocols("dnsaddr");
    async function dnsaddrResolver(addr) {
      const Resolver = require_dns_browser();
      const resolver = new Resolver();
      const peerId = addr.getPeerId();
      const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) || [];
      const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
      let addresses = records.flat().map((a) => a.split("=")[1]);
      if (peerId) {
        addresses = addresses.filter((entry) => entry.includes(peerId));
      }
      return addresses;
    }
    module2.exports = {
      dnsaddrResolver
    };
  }
});

// node_modules/libp2p/src/constants.js
var require_constants11 = __commonJS({
  "node_modules/libp2p/src/constants.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {
      DIAL_TIMEOUT: 3e4,
      MAX_PARALLEL_DIALS: 100,
      MAX_PER_PEER_DIALS: 4,
      MAX_ADDRS_TO_DIAL: 25,
      METRICS: {
        computeThrottleMaxQueueSize: 1e3,
        computeThrottleTimeout: 2e3,
        movingAverageIntervals: [
          60 * 1e3,
          5 * 60 * 1e3,
          15 * 60 * 1e3
        ],
        maxOldPeersRetention: 50
      }
    };
  }
});

// node_modules/libp2p/package.json
var require_package2 = __commonJS({
  "node_modules/libp2p/package.json"(exports2, module2) {
    module2.exports = {
      name: "libp2p",
      version: "0.33.0",
      description: "JavaScript implementation of libp2p, a modular peer to peer network stack",
      leadMaintainer: "Jacob Heun <jacobheun@gmail.com>",
      main: "src/index.js",
      types: "dist/src/index.d.ts",
      typesVersions: {
        "*": {
          "src/*": [
            "dist/src/*",
            "dist/src/*/index"
          ]
        }
      },
      files: [
        "dist",
        "src"
      ],
      scripts: {
        lint: "aegir lint",
        build: "aegir build",
        "build:proto": "npm run build:proto:circuit && npm run build:proto:identify && npm run build:proto:plaintext && npm run build:proto:address-book && npm run build:proto:proto-book && npm run build:proto:peer-record && npm run build:proto:envelope",
        "build:proto:circuit": "pbjs -t static-module -w commonjs -r libp2p-circuit --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/circuit/protocol/index.js ./src/circuit/protocol/index.proto",
        "build:proto:identify": "pbjs -t static-module -w commonjs -r libp2p-identify --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/identify/message.js ./src/identify/message.proto",
        "build:proto:plaintext": "pbjs -t static-module -w commonjs -r libp2p-plaintext --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/insecure/proto.js ./src/insecure/proto.proto",
        "build:proto:address-book": "pbjs -t static-module -w commonjs -r libp2p-address-book --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/peer-store/persistent/pb/address-book.js ./src/peer-store/persistent/pb/address-book.proto",
        "build:proto:proto-book": "pbjs -t static-module -w commonjs -r libp2p-proto-book --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/peer-store/persistent/pb/proto-book.js ./src/peer-store/persistent/pb/proto-book.proto",
        "build:proto:peer-record": "pbjs -t static-module -w commonjs -r libp2p-peer-record --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/record/peer-record/peer-record.js ./src/record/peer-record/peer-record.proto",
        "build:proto:envelope": "pbjs -t static-module -w commonjs -r libp2p-envelope --force-number --no-verify --no-delimited --no-create --no-beautify --no-defaults --lint eslint-disable -o src/record/envelope/envelope.js ./src/record/envelope/envelope.proto",
        "build:proto-types": "npm run build:proto-types:circuit && npm run build:proto-types:identify && npm run build:proto-types:plaintext && npm run build:proto-types:address-book && npm run build:proto-types:proto-book && npm run build:proto-types:peer-record && npm run build:proto-types:envelope",
        "build:proto-types:circuit": "pbts -o src/circuit/protocol/index.d.ts src/circuit/protocol/index.js",
        "build:proto-types:identify": "pbts -o src/identify/message.d.ts src/identify/message.js",
        "build:proto-types:plaintext": "pbts -o src/insecure/proto.d.ts src/insecure/proto.js",
        "build:proto-types:address-book": "pbts -o src/peer-store/persistent/pb/address-book.d.ts src/peer-store/persistent/pb/address-book.js",
        "build:proto-types:proto-book": "pbts -o src/peer-store/persistent/pb/proto-book.d.ts src/peer-store/persistent/pb/proto-book.js",
        "build:proto-types:peer-record": "pbts -o src/record/peer-record/peer-record.d.ts src/record/peer-record/peer-record.js",
        "build:proto-types:envelope": "pbts -o src/record/envelope/envelope.d.ts src/record/envelope/envelope.js",
        test: "aegir test",
        "test:ts": "aegir build --no-bundle && npm run test --prefix test/ts-use",
        "test:node": 'aegir test -t node -f "./test/**/*.{node,spec}.js"',
        "test:browser": "aegir test -t browser",
        "test:examples": "cd examples && npm run test:all",
        prepare: "aegir build --no-bundle",
        release: "aegir release -t node -t browser",
        "release-minor": "aegir release --type minor -t node -t browser",
        "release-major": "aegir release --type major -t node -t browser",
        coverage: "nyc --reporter=text --reporter=lcov npm run test:node"
      },
      repository: {
        type: "git",
        url: "https://github.com/libp2p/js-libp2p.git"
      },
      keywords: [
        "libp2p",
        "network",
        "p2p",
        "peer",
        "peer-to-peer",
        "IPFS"
      ],
      bugs: {
        url: "https://github.com/libp2p/js-libp2p/issues"
      },
      homepage: "https://libp2p.io",
      license: "MIT",
      engines: {
        node: ">=14.0.0"
      },
      browser: {
        "@motrix/nat-api": false
      },
      eslintConfig: {
        extends: "ipfs",
        ignorePatterns: [
          "!.aegir.js",
          "test/ts-use"
        ]
      },
      dependencies: {
        "abortable-iterator": "^3.0.0",
        "@motrix/nat-api": "^0.3.1",
        "@vascosantos/moving-average": "^1.1.0",
        "abort-controller": "^3.0.0",
        "aggregate-error": "^3.1.0",
        "any-signal": "^2.1.1",
        "bignumber.js": "^9.0.1",
        "class-is": "^1.1.0",
        debug: "^4.3.1",
        "err-code": "^3.0.0",
        "es6-promisify": "^7.0.0",
        events: "^3.3.0",
        hashlru: "^2.3.0",
        "interface-datastore": "^6.0.2",
        "it-all": "^1.0.4",
        "it-buffer": "^0.1.2",
        "it-drain": "^1.0.3",
        "it-filter": "^1.0.1",
        "it-first": "^1.0.4",
        "it-handshake": "^2.0.0",
        "it-length-prefixed": "^5.0.2",
        "it-map": "^1.0.4",
        "it-merge": "^1.0.0",
        "it-pipe": "^1.1.0",
        "it-take": "^1.0.0",
        "libp2p-crypto": "^0.19.4",
        "libp2p-interfaces": "^1.0.0",
        "libp2p-utils": "^0.4.0",
        mafmt: "^10.0.0",
        "merge-options": "^3.0.4",
        multiaddr: "^10.0.0",
        multiformats: "^9.0.0",
        "multistream-select": "^2.0.0",
        "mutable-proxy": "^1.0.0",
        "node-forge": "^0.10.0",
        "p-any": "^3.0.0",
        "p-fifo": "^1.0.0",
        "p-retry": "^4.4.0",
        "p-settle": "^4.1.1",
        "peer-id": "^0.15.0",
        "private-ip": "^2.1.0",
        protobufjs: "^6.10.2",
        retimer: "^3.0.0",
        "sanitize-filename": "^1.6.3",
        "set-delayed-interval": "^1.0.0",
        "streaming-iterables": "^6.0.0",
        "timeout-abort-controller": "^1.1.1",
        uint8arrays: "^3.0.0",
        varint: "^6.0.0",
        wherearewe: "^1.0.0",
        xsalsa20: "^1.1.0"
      },
      devDependencies: {
        "@chainsafe/libp2p-noise": "^4.0.0",
        "@nodeutils/defaults-deep": "^1.1.0",
        "@types/es6-promisify": "^6.0.0",
        "@types/node": "^16.0.1",
        "@types/node-forge": "^0.10.1",
        "@types/varint": "^6.0.0",
        aegir: "^33.1.1",
        buffer: "^6.0.3",
        "datastore-core": "^6.0.7",
        delay: "^5.0.0",
        "interop-libp2p": "^0.4.0",
        "into-stream": "^7.0.0",
        "ipfs-http-client": "^52.0.2",
        "it-concat": "^2.0.0",
        "it-pair": "^1.0.0",
        "it-pushable": "^1.4.0",
        libp2p: ".",
        "libp2p-bootstrap": "^0.13.0",
        "libp2p-delegated-content-routing": "^0.11.0",
        "libp2p-delegated-peer-routing": "^0.10.0",
        "libp2p-floodsub": "^0.27.0",
        "libp2p-gossipsub": "^0.11.0",
        "libp2p-interfaces-compliance-tests": "^1.0.0",
        "libp2p-kad-dht": "^0.24.2",
        "libp2p-mdns": "^0.17.0",
        "libp2p-mplex": "^0.10.1",
        "libp2p-tcp": "^0.17.0",
        "libp2p-webrtc-star": "^0.23.0",
        "libp2p-websockets": "^0.16.0",
        nock: "^13.0.3",
        "p-defer": "^3.0.0",
        "p-times": "^3.0.0",
        "p-wait-for": "^3.2.0",
        rimraf: "^3.0.2",
        sinon: "^11.1.1",
        util: "^0.12.3"
      },
      contributors: [
        "Vasco Santos <vasco.santos@moxy.studio>",
        "David Dias <daviddias.p@gmail.com>",
        "Jacob Heun <jacobheun@gmail.com>",
        "Alex Potsides <alex@achingbrain.net>",
        "Alan Shaw <alan@tableflip.io>",
        "Cayman <caymannava@gmail.com>",
        "Pedro Teixeira <i@pgte.me>",
        "Friedel Ziegelmayer <dignifiedquire@gmail.com>",
        "Maciej Kr\xFCger <mkg20001@gmail.com>",
        "Hugo Dias <mail@hugodias.me>",
        "Chris Dostert <chrisdostert@users.noreply.github.com>",
        "dirkmc <dirkmdev@gmail.com>",
        "Volker Mische <volker.mische@gmail.com>",
        "zeim839 <50573884+zeim839@users.noreply.github.com>",
        "Richard Littauer <richard.littauer@gmail.com>",
        "a1300 <matthias-knopp@gmx.net>",
        "Ryan Bell <ryan@piing.net>",
        "\u1D20\u026A\u1D04\u1D1B\u1D0F\u0280 \u0299\u1D0A\u1D07\u029F\u1D0B\u029C\u1D0F\u029F\u1D0D <victorbjelkholm@gmail.com>",
        "Franck Royer <franck@royer.one>",
        "Thomas Eizinger <thomas@eizinger.io>",
        "Giovanni T. Parra <fiatjaf@gmail.com>",
        "acolytec3 <17355484+acolytec3@users.noreply.github.com>",
        "Elven <mon.samuel@qq.com>",
        "Andrew Nesbitt <andrewnez@gmail.com>",
        "Samlior <samlior@foxmail.com>",
        "Didrik Nordstr\xF6m <didrik.nordstrom@gmail.com>",
        "RasmusErik Voel Jensen <github@solsort.com>",
        "Robert Kiel <robert.kiel@hoprnet.org>",
        "Smite Chow <xiaopengyou@live.com>",
        "Soeren <nikorpoulsen@gmail.com>",
        "S\xF6nke Hahn <soenkehahn@gmail.com>",
        "TJKoury <TJKoury@gmail.com>",
        "Tiago Alves <alvesjtiago@gmail.com>",
        "XiaoZhang <zxinmyth@gmail.com>",
        "Yusef Napora <yusef@napora.org>",
        "Zane Starr <zcstarr@gmail.com>",
        "ebinks <elizabethjbinks@gmail.com>",
        "Aditya Bose <13054902+adbose@users.noreply.github.com>",
        "isan_rivkin <isanrivkin@gmail.com>",
        "mayerwin <mayerwin@users.noreply.github.com>",
        "mcclure <andi.m.mcclure@gmail.com>",
        "phillmac <phillmac@users.noreply.github.com>",
        "robertkiel <robert.kiel@validitylabs.org>",
        "shresthagrawal <34920931+shresthagrawal@users.noreply.github.com>",
        "swedneck <40505480+swedneck@users.noreply.github.com>",
        "greenSnot <greenSnot@users.noreply.github.com>",
        "Aleksei <vozhdb@gmail.com>",
        "Bernd Strehl <bernd.strehl@gmail.com>",
        "Chris Bratlien <chrisbratlien@gmail.com>",
        "Cindy Wu <ciindy.wu@gmail.com>",
        "Daijiro Wachi <daijiro.wachi@gmail.com>",
        "Diogo Silva <fsdiogo@gmail.com>",
        "Dmitriy Ryajov <dryajov@gmail.com>",
        "Ethan Lam <elmemphis2000@gmail.com>",
        "Fei Liu <liu.feiwood@gmail.com>",
        "Felipe Martins <felipebrasil93@gmail.com>",
        "Florian-Merle <florian.david.merle@gmail.com>",
        "Francis Gulotta <wizard@roborooter.com>",
        "Guy Sviry <32539816+guysv@users.noreply.github.com>",
        "Henrique Dias <hacdias@gmail.com>",
        "Irakli Gozalishvili <rfobic@gmail.com>",
        "Joel Gustafson <joelg@mit.edu>",
        "John Rees <johnrees@users.noreply.github.com>",
        "Jo\xE3o Santos <joaosantos15@users.noreply.github.com>",
        "Julien Bouquillon <contact@revolunet.com>",
        "Kevin Kwok <antimatter15@gmail.com>",
        "Kevin Lacker <lacker@gmail.com>",
        "Lars Gierth <lgierth@users.noreply.github.com>",
        "Leask Wong <i@leaskh.com>",
        "Marcin Tojek <mtojek@users.noreply.github.com>",
        "Michael Burns <5170+mburns@users.noreply.github.com>",
        "Miguel Mota <miguelmota2@gmail.com>",
        "Nuno Nogueira <nunofmn@gmail.com>",
        "Philipp Muens <raute1337@gmx.de>"
      ]
    };
  }
});

// node_modules/libp2p/src/identify/consts.js
var require_consts = __commonJS({
  "node_modules/libp2p/src/identify/consts.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var libp2pVersion = require_package2().version;
    module2.exports.PROTOCOL_VERSION = "ipfs/0.1.0";
    module2.exports.AGENT_VERSION = `js-libp2p/${libp2pVersion}`;
    module2.exports.MULTICODEC_IDENTIFY = "/ipfs/id/1.0.0";
    module2.exports.MULTICODEC_IDENTIFY_PUSH = "/ipfs/id/push/1.0.0";
    module2.exports.IDENTIFY_PROTOCOL_VERSION = "0.1.0";
    module2.exports.MULTICODEC_IDENTIFY_PROTOCOL_NAME = "id";
    module2.exports.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME = "id/push";
    module2.exports.MULTICODEC_IDENTIFY_PROTOCOL_VERSION = "1.0.0";
    module2.exports.MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION = "1.0.0";
  }
});

// node_modules/libp2p/src/circuit/constants.js
var require_constants12 = __commonJS({
  "node_modules/libp2p/src/circuit/constants.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var minute = 60 * 1e3;
    module2.exports = {
      ADVERTISE_BOOT_DELAY: 15 * minute,
      ADVERTISE_TTL: 30 * minute,
      CIRCUIT_PROTO_CODE: 290,
      HOP_METADATA_KEY: "hop_relay",
      HOP_METADATA_VALUE: "true",
      RELAY_RENDEZVOUS_NS: "/libp2p/relay"
    };
  }
});

// node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS({
  "node_modules/netmask/lib/netmask.js"(exports2) {
    init_node_globals();
    (function() {
      var Netmask, atob, chr, chr0, chrA, chra, ip2long, long2ip;
      long2ip = function(long) {
        var a, b, c, d;
        a = (long & 255 << 24) >>> 24;
        b = (long & 255 << 16) >>> 16;
        c = (long & 255 << 8) >>> 8;
        d = long & 255;
        return [a, b, c, d].join(".");
      };
      ip2long = function(ip) {
        var b, c, i, j, n, ref;
        b = [];
        for (i = j = 0; j <= 3; i = ++j) {
          if (ip.length === 0) {
            break;
          }
          if (i > 0) {
            if (ip[0] !== ".") {
              throw new Error("Invalid IP");
            }
            ip = ip.substring(1);
          }
          ref = atob(ip), n = ref[0], c = ref[1];
          ip = ip.substring(c);
          b.push(n);
        }
        if (ip.length !== 0) {
          throw new Error("Invalid IP");
        }
        switch (b.length) {
          case 1:
            if (b[0] > 4294967295) {
              throw new Error("Invalid IP");
            }
            return b[0] >>> 0;
          case 2:
            if (b[0] > 255 || b[1] > 16777215) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1]) >>> 0;
          case 3:
            if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
          case 4:
            if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
              throw new Error("Invalid IP");
            }
            return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
          default:
            throw new Error("Invalid IP");
        }
      };
      chr = function(b) {
        return b.charCodeAt(0);
      };
      chr0 = chr("0");
      chra = chr("a");
      chrA = chr("A");
      atob = function(s) {
        var base3, dmax, i, n, start;
        n = 0;
        base3 = 10;
        dmax = "9";
        i = 0;
        if (s.length > 1 && s[i] === "0") {
          if (s[i + 1] === "x" || s[i + 1] === "X") {
            i += 2;
            base3 = 16;
          } else if ("0" <= s[i + 1] && s[i + 1] <= "9") {
            i++;
            base3 = 8;
            dmax = "7";
          }
        }
        start = i;
        while (i < s.length) {
          if ("0" <= s[i] && s[i] <= dmax) {
            n = n * base3 + (chr(s[i]) - chr0) >>> 0;
          } else if (base3 === 16) {
            if ("a" <= s[i] && s[i] <= "f") {
              n = n * base3 + (10 + chr(s[i]) - chra) >>> 0;
            } else if ("A" <= s[i] && s[i] <= "F") {
              n = n * base3 + (10 + chr(s[i]) - chrA) >>> 0;
            } else {
              break;
            }
          } else {
            break;
          }
          if (n > 4294967295) {
            throw new Error("too large");
          }
          i++;
        }
        if (i === start) {
          throw new Error("empty octet");
        }
        return [n, i];
      };
      Netmask = function() {
        function Netmask2(net, mask) {
          var error, i, j, ref;
          if (typeof net !== "string") {
            throw new Error("Missing `net' parameter");
          }
          if (!mask) {
            ref = net.split("/", 2), net = ref[0], mask = ref[1];
          }
          if (!mask) {
            mask = 32;
          }
          if (typeof mask === "string" && mask.indexOf(".") > -1) {
            try {
              this.maskLong = ip2long(mask);
            } catch (error1) {
              error = error1;
              throw new Error("Invalid mask: " + mask);
            }
            for (i = j = 32; j >= 0; i = --j) {
              if (this.maskLong === 4294967295 << 32 - i >>> 0) {
                this.bitmask = i;
                break;
              }
            }
          } else if (mask || mask === 0) {
            this.bitmask = parseInt(mask, 10);
            this.maskLong = 0;
            if (this.bitmask > 0) {
              this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
            }
          } else {
            throw new Error("Invalid mask: empty");
          }
          try {
            this.netLong = (ip2long(net) & this.maskLong) >>> 0;
          } catch (error1) {
            error = error1;
            throw new Error("Invalid net address: " + net);
          }
          if (!(this.bitmask <= 32)) {
            throw new Error("Invalid mask for ip4: " + mask);
          }
          this.size = Math.pow(2, 32 - this.bitmask);
          this.base = long2ip(this.netLong);
          this.mask = long2ip(this.maskLong);
          this.hostmask = long2ip(~this.maskLong);
          this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
          this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
          this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
        }
        Netmask2.prototype.contains = function(ip) {
          if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
            ip = new Netmask2(ip);
          }
          if (ip instanceof Netmask2) {
            return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
          } else {
            return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
          }
        };
        Netmask2.prototype.next = function(count) {
          if (count == null) {
            count = 1;
          }
          return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
        };
        Netmask2.prototype.forEach = function(fn) {
          var index, lastLong, long;
          long = ip2long(this.first);
          lastLong = ip2long(this.last);
          index = 0;
          while (long <= lastLong) {
            fn(long2ip(long), long, index);
            index++;
            long++;
          }
        };
        Netmask2.prototype.toString = function() {
          return this.base + "/" + this.bitmask;
        };
        return Netmask2;
      }();
      exports2.ip2long = ip2long;
      exports2.long2ip = long2ip;
      exports2.Netmask = Netmask;
    }).call(exports2);
  }
});

// node_modules/ipaddr.js/lib/ipaddr.js
var require_ipaddr = __commonJS({
  "node_modules/ipaddr.js/lib/ipaddr.js"(exports2, module2) {
    init_node_globals();
    (function(root) {
      "use strict";
      const ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
      const ipv4Regexes = {
        fourOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        threeOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}$`, "i"),
        twoOctet: new RegExp(`^${ipv4Part}\\.${ipv4Part}$`, "i"),
        longValue: new RegExp(`^${ipv4Part}$`, "i")
      };
      const octalRegex = new RegExp(`^0[0-7]+$`, "i");
      const hexRegex = new RegExp(`^0x[a-f0-9]+$`, "i");
      const zoneIndex = "%[0-9a-z]{1,}";
      const ipv6Part = "(?:[0-9a-f]+::?)+";
      const ipv6Regexes = {
        zoneIndex: new RegExp(zoneIndex, "i"),
        "native": new RegExp(`^(::)?(${ipv6Part})?([0-9a-f]+)?(::)?(${zoneIndex})?$`, "i"),
        deprecatedTransitional: new RegExp(`^(?:::)(${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?)$`, "i"),
        transitional: new RegExp(`^((?:${ipv6Part})|(?:::)(?:${ipv6Part})?)${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}(${zoneIndex})?$`, "i")
      };
      function expandIPv6(string3, parts) {
        if (string3.indexOf("::") !== string3.lastIndexOf("::")) {
          return null;
        }
        let colonCount = 0;
        let lastColon = -1;
        let zoneId = (string3.match(ipv6Regexes.zoneIndex) || [])[0];
        let replacement, replacementCount;
        if (zoneId) {
          zoneId = zoneId.substring(1);
          string3 = string3.replace(/%.+$/, "");
        }
        while ((lastColon = string3.indexOf(":", lastColon + 1)) >= 0) {
          colonCount++;
        }
        if (string3.substr(0, 2) === "::") {
          colonCount--;
        }
        if (string3.substr(-2, 2) === "::") {
          colonCount--;
        }
        if (colonCount > parts) {
          return null;
        }
        replacementCount = parts - colonCount;
        replacement = ":";
        while (replacementCount--) {
          replacement += "0:";
        }
        string3 = string3.replace("::", replacement);
        if (string3[0] === ":") {
          string3 = string3.slice(1);
        }
        if (string3[string3.length - 1] === ":") {
          string3 = string3.slice(0, -1);
        }
        parts = function() {
          const ref = string3.split(":");
          const results = [];
          for (let i = 0; i < ref.length; i++) {
            results.push(parseInt(ref[i], 16));
          }
          return results;
        }();
        return {
          parts,
          zoneId
        };
      }
      function matchCIDR(first3, second, partSize, cidrBits) {
        if (first3.length !== second.length) {
          throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
        }
        let part = 0;
        let shift;
        while (cidrBits > 0) {
          shift = partSize - cidrBits;
          if (shift < 0) {
            shift = 0;
          }
          if (first3[part] >> shift !== second[part] >> shift) {
            return false;
          }
          cidrBits -= partSize;
          part += 1;
        }
        return true;
      }
      function parseIntAuto(string3) {
        if (hexRegex.test(string3)) {
          return parseInt(string3, 16);
        }
        if (string3[0] === "0" && !isNaN(parseInt(string3[1], 10))) {
          if (octalRegex.test(string3)) {
            return parseInt(string3, 8);
          }
          throw new Error(`ipaddr: cannot parse ${string3} as octal`);
        }
        return parseInt(string3, 10);
      }
      function padPart(part, length4) {
        while (part.length < length4) {
          part = `0${part}`;
        }
        return part;
      }
      const ipaddr = {};
      ipaddr.IPv4 = function() {
        function IPv4(octets) {
          if (octets.length !== 4) {
            throw new Error("ipaddr: ipv4 octet count should be 4");
          }
          let i, octet;
          for (i = 0; i < octets.length; i++) {
            octet = octets[i];
            if (!(0 <= octet && octet <= 255)) {
              throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
            }
          }
          this.octets = octets;
        }
        IPv4.prototype.SpecialRanges = {
          unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
          broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
          multicast: [[new IPv4([224, 0, 0, 0]), 4]],
          linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
          loopback: [[new IPv4([127, 0, 0, 0]), 8]],
          carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
          "private": [
            [new IPv4([10, 0, 0, 0]), 8],
            [new IPv4([172, 16, 0, 0]), 12],
            [new IPv4([192, 168, 0, 0]), 16]
          ],
          reserved: [
            [new IPv4([192, 0, 0, 0]), 24],
            [new IPv4([192, 0, 2, 0]), 24],
            [new IPv4([192, 88, 99, 0]), 24],
            [new IPv4([198, 51, 100, 0]), 24],
            [new IPv4([203, 0, 113, 0]), 24],
            [new IPv4([240, 0, 0, 0]), 4]
          ]
        };
        IPv4.prototype.kind = function() {
          return "ipv4";
        };
        IPv4.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv4") {
            throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
          }
          return matchCIDR(this.octets, other.octets, 8, cidrRange);
        };
        IPv4.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 8,
            128: 7,
            192: 6,
            224: 5,
            240: 4,
            248: 3,
            252: 2,
            254: 1,
            255: 0
          };
          let i, octet, zeros;
          for (i = 3; i >= 0; i -= 1) {
            octet = this.octets[i];
            if (octet in zerotable) {
              zeros = zerotable[octet];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 8) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 32 - cidr;
        };
        IPv4.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv4.prototype.toByteArray = function() {
          return this.octets.slice(0);
        };
        IPv4.prototype.toIPv4MappedAddress = function() {
          return ipaddr.IPv6.parse(`::ffff:${this.toString()}`);
        };
        IPv4.prototype.toNormalizedString = function() {
          return this.toString();
        };
        IPv4.prototype.toString = function() {
          return this.octets.join(".");
        };
        return IPv4;
      }();
      ipaddr.IPv4.broadcastAddressFromCIDR = function(string3) {
        try {
          const cidr = this.parseCIDR(string3);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.isIPv4 = function(string3) {
        return this.parser(string3) !== null;
      };
      ipaddr.IPv4.isValid = function(string3) {
        try {
          new this(this.parser(string3));
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv4.isValidFourPartDecimal = function(string3) {
        if (ipaddr.IPv4.isValid(string3) && string3.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
          return true;
        } else {
          return false;
        }
      };
      ipaddr.IPv4.networkAddressFromCIDR = function(string3) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string3);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 4) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error("ipaddr: the address does not have IPv4 CIDR format");
        }
      };
      ipaddr.IPv4.parse = function(string3) {
        const parts = this.parser(string3);
        if (parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv4 Address");
        }
        return new this(parts);
      };
      ipaddr.IPv4.parseCIDR = function(string3) {
        let match;
        if (match = string3.match(/^(.+)\/(\d+)$/)) {
          const maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 32) {
            const parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
      };
      ipaddr.IPv4.parser = function(string3) {
        let match, part, value;
        if (match = string3.match(ipv4Regexes.fourOctet)) {
          return function() {
            const ref = match.slice(1, 6);
            const results = [];
            for (let i = 0; i < ref.length; i++) {
              part = ref[i];
              results.push(parseIntAuto(part));
            }
            return results;
          }();
        } else if (match = string3.match(ipv4Regexes.longValue)) {
          value = parseIntAuto(match[1]);
          if (value > 4294967295 || value < 0) {
            throw new Error("ipaddr: address outside defined range");
          }
          return function() {
            const results = [];
            let shift;
            for (shift = 0; shift <= 24; shift += 8) {
              results.push(value >> shift & 255);
            }
            return results;
          }().reverse();
        } else if (match = string3.match(ipv4Regexes.twoOctet)) {
          return function() {
            const ref = match.slice(1, 4);
            const results = [];
            value = parseIntAuto(ref[1]);
            if (value > 16777215 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(value >> 16 & 255);
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else if (match = string3.match(ipv4Regexes.threeOctet)) {
          return function() {
            const ref = match.slice(1, 5);
            const results = [];
            value = parseIntAuto(ref[2]);
            if (value > 65535 || value < 0) {
              throw new Error("ipaddr: address outside defined range");
            }
            results.push(parseIntAuto(ref[0]));
            results.push(parseIntAuto(ref[1]));
            results.push(value >> 8 & 255);
            results.push(value & 255);
            return results;
          }();
        } else {
          return null;
        }
      };
      ipaddr.IPv4.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 32) {
          throw new Error("ipaddr: invalid IPv4 prefix length");
        }
        const octets = [0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 4) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.IPv6 = function() {
        function IPv6(parts, zoneId) {
          let i, part;
          if (parts.length === 16) {
            this.parts = [];
            for (i = 0; i <= 14; i += 2) {
              this.parts.push(parts[i] << 8 | parts[i + 1]);
            }
          } else if (parts.length === 8) {
            this.parts = parts;
          } else {
            throw new Error("ipaddr: ipv6 part count should be 8 or 16");
          }
          for (i = 0; i < this.parts.length; i++) {
            part = this.parts[i];
            if (!(0 <= part && part <= 65535)) {
              throw new Error("ipaddr: ipv6 part should fit in 16 bits");
            }
          }
          if (zoneId) {
            this.zoneId = zoneId;
          }
        }
        IPv6.prototype.SpecialRanges = {
          unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
          linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
          multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
          loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
          uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
          ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
          rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
          rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
          "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
          teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
          reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
        };
        IPv6.prototype.isIPv4MappedAddress = function() {
          return this.range() === "ipv4Mapped";
        };
        IPv6.prototype.kind = function() {
          return "ipv6";
        };
        IPv6.prototype.match = function(other, cidrRange) {
          let ref;
          if (cidrRange === void 0) {
            ref = other;
            other = ref[0];
            cidrRange = ref[1];
          }
          if (other.kind() !== "ipv6") {
            throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
          }
          return matchCIDR(this.parts, other.parts, 16, cidrRange);
        };
        IPv6.prototype.prefixLengthFromSubnetMask = function() {
          let cidr = 0;
          let stop = false;
          const zerotable = {
            0: 16,
            32768: 15,
            49152: 14,
            57344: 13,
            61440: 12,
            63488: 11,
            64512: 10,
            65024: 9,
            65280: 8,
            65408: 7,
            65472: 6,
            65504: 5,
            65520: 4,
            65528: 3,
            65532: 2,
            65534: 1,
            65535: 0
          };
          let part, zeros;
          for (let i = 7; i >= 0; i -= 1) {
            part = this.parts[i];
            if (part in zerotable) {
              zeros = zerotable[part];
              if (stop && zeros !== 0) {
                return null;
              }
              if (zeros !== 16) {
                stop = true;
              }
              cidr += zeros;
            } else {
              return null;
            }
          }
          return 128 - cidr;
        };
        IPv6.prototype.range = function() {
          return ipaddr.subnetMatch(this, this.SpecialRanges);
        };
        IPv6.prototype.toByteArray = function() {
          let part;
          const bytes3 = [];
          const ref = this.parts;
          for (let i = 0; i < ref.length; i++) {
            part = ref[i];
            bytes3.push(part >> 8);
            bytes3.push(part & 255);
          }
          return bytes3;
        };
        IPv6.prototype.toFixedLengthString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(padPart(this.parts[i].toString(16), 4));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toIPv4Address = function() {
          if (!this.isIPv4MappedAddress()) {
            throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
          }
          const ref = this.parts.slice(-2);
          const high = ref[0];
          const low = ref[1];
          return new ipaddr.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
        };
        IPv6.prototype.toNormalizedString = function() {
          const addr = function() {
            const results = [];
            for (let i = 0; i < this.parts.length; i++) {
              results.push(this.parts[i].toString(16));
            }
            return results;
          }.call(this).join(":");
          let suffix = "";
          if (this.zoneId) {
            suffix = `%${this.zoneId}`;
          }
          return addr + suffix;
        };
        IPv6.prototype.toRFC5952String = function() {
          const regex = /((^|:)(0(:|$)){2,})/g;
          const string3 = this.toNormalizedString();
          let bestMatchIndex = 0;
          let bestMatchLength = -1;
          let match;
          while (match = regex.exec(string3)) {
            if (match[0].length > bestMatchLength) {
              bestMatchIndex = match.index;
              bestMatchLength = match[0].length;
            }
          }
          if (bestMatchLength < 0) {
            return string3;
          }
          return `${string3.substring(0, bestMatchIndex)}::${string3.substring(bestMatchIndex + bestMatchLength)}`;
        };
        IPv6.prototype.toString = function() {
          return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
        };
        return IPv6;
      }();
      ipaddr.IPv6.broadcastAddressFromCIDR = function(string3) {
        try {
          const cidr = this.parseCIDR(string3);
          const ipInterfaceOctets = cidr[0].toByteArray();
          const subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          const octets = [];
          let i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.isIPv6 = function(string3) {
        return this.parser(string3) !== null;
      };
      ipaddr.IPv6.isValid = function(string3) {
        if (typeof string3 === "string" && string3.indexOf(":") === -1) {
          return false;
        }
        try {
          const addr = this.parser(string3);
          new this(addr.parts, addr.zoneId);
          return true;
        } catch (e) {
          return false;
        }
      };
      ipaddr.IPv6.networkAddressFromCIDR = function(string3) {
        let cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
        try {
          cidr = this.parseCIDR(string3);
          ipInterfaceOctets = cidr[0].toByteArray();
          subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
          octets = [];
          i = 0;
          while (i < 16) {
            octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
            i++;
          }
          return new this(octets);
        } catch (e) {
          throw new Error(`ipaddr: the address does not have IPv6 CIDR format (${e})`);
        }
      };
      ipaddr.IPv6.parse = function(string3) {
        const addr = this.parser(string3);
        if (addr.parts === null) {
          throw new Error("ipaddr: string is not formatted like an IPv6 Address");
        }
        return new this(addr.parts, addr.zoneId);
      };
      ipaddr.IPv6.parseCIDR = function(string3) {
        let maskLength, match, parsed;
        if (match = string3.match(/^(.+)\/(\d+)$/)) {
          maskLength = parseInt(match[2]);
          if (maskLength >= 0 && maskLength <= 128) {
            parsed = [this.parse(match[1]), maskLength];
            Object.defineProperty(parsed, "toString", {
              value: function() {
                return this.join("/");
              }
            });
            return parsed;
          }
        }
        throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
      };
      ipaddr.IPv6.parser = function(string3) {
        let addr, i, match, octet, octets, zoneId;
        if (match = string3.match(ipv6Regexes.deprecatedTransitional)) {
          return this.parser(`::ffff:${match[1]}`);
        }
        if (ipv6Regexes.native.test(string3)) {
          return expandIPv6(string3, 8);
        }
        if (match = string3.match(ipv6Regexes.transitional)) {
          zoneId = match[6] || "";
          addr = expandIPv6(match[1].slice(0, -1) + zoneId, 6);
          if (addr.parts) {
            octets = [
              parseInt(match[2]),
              parseInt(match[3]),
              parseInt(match[4]),
              parseInt(match[5])
            ];
            for (i = 0; i < octets.length; i++) {
              octet = octets[i];
              if (!(0 <= octet && octet <= 255)) {
                return null;
              }
            }
            addr.parts.push(octets[0] << 8 | octets[1]);
            addr.parts.push(octets[2] << 8 | octets[3]);
            return {
              parts: addr.parts,
              zoneId: addr.zoneId
            };
          }
        }
        return null;
      };
      ipaddr.IPv6.subnetMaskFromPrefixLength = function(prefix) {
        prefix = parseInt(prefix);
        if (prefix < 0 || prefix > 128) {
          throw new Error("ipaddr: invalid IPv6 prefix length");
        }
        const octets = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
        let j = 0;
        const filledOctetCount = Math.floor(prefix / 8);
        while (j < filledOctetCount) {
          octets[j] = 255;
          j++;
        }
        if (filledOctetCount < 16) {
          octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
        }
        return new this(octets);
      };
      ipaddr.fromByteArray = function(bytes3) {
        const length4 = bytes3.length;
        if (length4 === 4) {
          return new ipaddr.IPv4(bytes3);
        } else if (length4 === 16) {
          return new ipaddr.IPv6(bytes3);
        } else {
          throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
        }
      };
      ipaddr.isValid = function(string3) {
        return ipaddr.IPv6.isValid(string3) || ipaddr.IPv4.isValid(string3);
      };
      ipaddr.parse = function(string3) {
        if (ipaddr.IPv6.isValid(string3)) {
          return ipaddr.IPv6.parse(string3);
        } else if (ipaddr.IPv4.isValid(string3)) {
          return ipaddr.IPv4.parse(string3);
        } else {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
        }
      };
      ipaddr.parseCIDR = function(string3) {
        try {
          return ipaddr.IPv6.parseCIDR(string3);
        } catch (e) {
          try {
            return ipaddr.IPv4.parseCIDR(string3);
          } catch (e2) {
            throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
          }
        }
      };
      ipaddr.process = function(string3) {
        const addr = this.parse(string3);
        if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
          return addr.toIPv4Address();
        } else {
          return addr;
        }
      };
      ipaddr.subnetMatch = function(address, rangeList, defaultName) {
        let i, rangeName, rangeSubnets, subnet;
        if (defaultName === void 0 || defaultName === null) {
          defaultName = "unicast";
        }
        for (rangeName in rangeList) {
          if (Object.prototype.hasOwnProperty.call(rangeList, rangeName)) {
            rangeSubnets = rangeList[rangeName];
            if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
              rangeSubnets = [rangeSubnets];
            }
            for (i = 0; i < rangeSubnets.length; i++) {
              subnet = rangeSubnets[i];
              if (address.kind() === subnet[0].kind() && address.match.apply(address, subnet)) {
                return rangeName;
              }
            }
          }
        }
        return defaultName;
      };
      if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = ipaddr;
      } else {
        root.ipaddr = ipaddr;
      }
    })(exports2);
  }
});

// node_modules/private-ip/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/private-ip/lib/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var netmask_1 = require_netmask();
    var ip_regex_1 = __importDefault(require_ip_regex());
    var is_ip_1 = __importDefault(require_is_ip());
    var ipaddr_js_1 = require_ipaddr();
    var PRIVATE_IP_RANGES = [
      "0.0.0.0/8",
      "10.0.0.0/8",
      "100.64.0.0/10",
      "127.0.0.0/8",
      "169.254.0.0/16",
      "172.16.0.0/12",
      "192.0.0.0/24",
      "192.0.0.0/29",
      "192.0.0.8/32",
      "192.0.0.9/32",
      "192.0.0.10/32",
      "192.0.0.170/32",
      "192.0.0.171/32",
      "192.0.2.0/24",
      "192.31.196.0/24",
      "192.52.193.0/24",
      "192.88.99.0/24",
      "192.168.0.0/16",
      "192.175.48.0/24",
      "198.18.0.0/15",
      "198.51.100.0/24",
      "203.0.113.0/24",
      "240.0.0.0/4",
      "255.255.255.255/32"
    ];
    var NETMASK_RANGES = PRIVATE_IP_RANGES.map((ip_range) => new netmask_1.Netmask(ip_range));
    function ipv4_check(ip_addr) {
      for (let r of NETMASK_RANGES) {
        if (r.contains(ip_addr))
          return true;
      }
      return false;
    }
    function ipv6_check(ip_addr) {
      return /^::$/.test(ip_addr) || /^::1$/.test(ip_addr) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(ip_addr) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(ip_addr) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(ip_addr) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(ip_addr) || /^ff([0-9a-fA-F]{2,2}):/i.test(ip_addr);
    }
    exports2.default = (ip) => {
      if (ipaddr_js_1.isValid(ip)) {
        const parsed = ipaddr_js_1.parse(ip);
        if (parsed.kind() === "ipv4")
          return ipv4_check(parsed.toNormalizedString());
        else if (parsed.kind() === "ipv6")
          return ipv6_check(ip);
      } else if (is_ip_1.default(ip) && ip_regex_1.default.v6().test(ip))
        return ipv6_check(ip);
      return void 0;
    };
  }
});

// node_modules/private-ip/index.js
var require_private_ip = __commonJS({
  "node_modules/private-ip/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = require_lib4().default;
  }
});

// node_modules/libp2p-utils/src/multiaddr/is-private.js
var require_is_private = __commonJS({
  "node_modules/libp2p-utils/src/multiaddr/is-private.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var isIpPrivate = require_private_ip();
    function isPrivate(ma) {
      const { address } = ma.nodeAddress();
      return isIpPrivate(address);
    }
    module2.exports = isPrivate;
  }
});

// node_modules/libp2p-utils/src/address-sort.js
var require_address_sort = __commonJS({
  "node_modules/libp2p-utils/src/address-sort.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var isPrivate = require_is_private();
    function addressesPublicFirstCompareFunction(a, b) {
      const isAPrivate = isPrivate(a.multiaddr);
      const isBPrivate = isPrivate(b.multiaddr);
      if (isAPrivate && !isBPrivate) {
        return 1;
      } else if (!isAPrivate && isBPrivate) {
        return -1;
      }
      if (a.isCertified && !b.isCertified) {
        return -1;
      } else if (!a.isCertified && b.isCertified) {
        return 1;
      }
      return 0;
    }
    function publicAddressesFirst(addresses) {
      return [...addresses].sort(addressesPublicFirstCompareFunction);
    }
    module2.exports.publicAddressesFirst = publicAddressesFirst;
  }
});

// node_modules/p-reflect/index.js
var require_p_reflect = __commonJS({
  "node_modules/p-reflect/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var pReflect = async (promise) => {
      try {
        const value = await promise;
        return {
          isFulfilled: true,
          isRejected: false,
          value
        };
      } catch (error) {
        return {
          isFulfilled: false,
          isRejected: true,
          reason: error
        };
      }
    };
    module2.exports = pReflect;
    module2.exports.default = pReflect;
  }
});

// node_modules/p-try/index.js
var require_p_try = __commonJS({
  "node_modules/p-try/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var pTry = (fn, ...arguments_) => new Promise((resolve6) => {
      resolve6(fn(...arguments_));
    });
    module2.exports = pTry;
    module2.exports.default = pTry;
  }
});

// node_modules/p-limit/index.js
var require_p_limit = __commonJS({
  "node_modules/p-limit/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var pTry = require_p_try();
    var pLimit = (concurrency) => {
      if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
        return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
      }
      const queue = [];
      let activeCount = 0;
      const next = () => {
        activeCount--;
        if (queue.length > 0) {
          queue.shift()();
        }
      };
      const run = (fn, resolve6, ...args) => {
        activeCount++;
        const result = pTry(fn, ...args);
        resolve6(result);
        result.then(next, next);
      };
      const enqueue = (fn, resolve6, ...args) => {
        if (activeCount < concurrency) {
          run(fn, resolve6, ...args);
        } else {
          queue.push(run.bind(null, fn, resolve6, ...args));
        }
      };
      const generator = (fn, ...args) => new Promise((resolve6) => enqueue(fn, resolve6, ...args));
      Object.defineProperties(generator, {
        activeCount: {
          get: () => activeCount
        },
        pendingCount: {
          get: () => queue.length
        },
        clearQueue: {
          value: () => {
            queue.length = 0;
          }
        }
      });
      return generator;
    };
    module2.exports = pLimit;
    module2.exports.default = pLimit;
  }
});

// node_modules/p-settle/index.js
var require_p_settle = __commonJS({
  "node_modules/p-settle/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var pReflect = require_p_reflect();
    var pLimit = require_p_limit();
    module2.exports = async (array2, options = {}) => {
      const { concurrency = Infinity } = options;
      const limit = pLimit(concurrency);
      return Promise.all(array2.map((element) => {
        if (element && typeof element.then === "function") {
          return pReflect(element);
        }
        if (typeof element === "function") {
          return pReflect(limit(() => element()));
        }
        return pReflect(Promise.resolve(element));
      }));
    };
  }
});

// node_modules/libp2p-utils/src/array-equals.js
var require_array_equals = __commonJS({
  "node_modules/libp2p-utils/src/array-equals.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function arrayEquals(a, b) {
      return a.length === b.length && b.sort() && a.sort().every((item, index) => b[index].equals(item));
    }
    module2.exports = arrayEquals;
  }
});

// node_modules/libp2p/src/record/peer-record/peer-record.js
var require_peer_record = __commonJS({
  "node_modules/libp2p/src/record/peer-record/peer-record.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var $protobuf5 = require_minimal2();
    var $Reader5 = $protobuf5.Reader;
    var $Writer5 = $protobuf5.Writer;
    var $util5 = $protobuf5.util;
    var $root5 = $protobuf5.roots["libp2p-peer-record"] || ($protobuf5.roots["libp2p-peer-record"] = {});
    $root5.PeerRecord = function() {
      function PeerRecord(p) {
        this.addresses = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      PeerRecord.prototype.peerId = $util5.newBuffer([]);
      PeerRecord.prototype.seq = $util5.Long ? $util5.Long.fromBits(0, 0, true) : 0;
      PeerRecord.prototype.addresses = $util5.emptyArray;
      PeerRecord.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        if (m.peerId != null && Object.hasOwnProperty.call(m, "peerId"))
          w.uint32(10).bytes(m.peerId);
        if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
          w.uint32(16).uint64(m.seq);
        if (m.addresses != null && m.addresses.length) {
          for (var i = 0; i < m.addresses.length; ++i)
            $root5.PeerRecord.AddressInfo.encode(m.addresses[i], w.uint32(26).fork()).ldelim();
        }
        return w;
      };
      PeerRecord.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.PeerRecord();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.peerId = r.bytes();
              break;
            case 2:
              m.seq = r.uint64();
              break;
            case 3:
              if (!(m.addresses && m.addresses.length))
                m.addresses = [];
              m.addresses.push($root5.PeerRecord.AddressInfo.decode(r, r.uint32()));
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      PeerRecord.fromObject = function fromObject(d) {
        if (d instanceof $root5.PeerRecord)
          return d;
        var m = new $root5.PeerRecord();
        if (d.peerId != null) {
          if (typeof d.peerId === "string")
            $util5.base64.decode(d.peerId, m.peerId = $util5.newBuffer($util5.base64.length(d.peerId)), 0);
          else if (d.peerId.length)
            m.peerId = d.peerId;
        }
        if (d.seq != null) {
          if ($util5.Long)
            (m.seq = $util5.Long.fromValue(d.seq)).unsigned = true;
          else if (typeof d.seq === "string")
            m.seq = parseInt(d.seq, 10);
          else if (typeof d.seq === "number")
            m.seq = d.seq;
          else if (typeof d.seq === "object")
            m.seq = new $util5.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
        }
        if (d.addresses) {
          if (!Array.isArray(d.addresses))
            throw TypeError(".PeerRecord.addresses: array expected");
          m.addresses = [];
          for (var i = 0; i < d.addresses.length; ++i) {
            if (typeof d.addresses[i] !== "object")
              throw TypeError(".PeerRecord.addresses: object expected");
            m.addresses[i] = $root5.PeerRecord.AddressInfo.fromObject(d.addresses[i]);
          }
        }
        return m;
      };
      PeerRecord.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.addresses = [];
        }
        if (o.defaults) {
          if (o.bytes === String)
            d.peerId = "";
          else {
            d.peerId = [];
            if (o.bytes !== Array)
              d.peerId = $util5.newBuffer(d.peerId);
          }
          if ($util5.Long) {
            var n = new $util5.Long(0, 0, true);
            d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
          } else
            d.seq = o.longs === String ? "0" : 0;
        }
        if (m.peerId != null && m.hasOwnProperty("peerId")) {
          d.peerId = o.bytes === String ? $util5.base64.encode(m.peerId, 0, m.peerId.length) : o.bytes === Array ? Array.prototype.slice.call(m.peerId) : m.peerId;
        }
        if (m.seq != null && m.hasOwnProperty("seq")) {
          if (typeof m.seq === "number")
            d.seq = o.longs === String ? String(m.seq) : m.seq;
          else
            d.seq = o.longs === String ? $util5.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util5.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
        }
        if (m.addresses && m.addresses.length) {
          d.addresses = [];
          for (var j = 0; j < m.addresses.length; ++j) {
            d.addresses[j] = $root5.PeerRecord.AddressInfo.toObject(m.addresses[j], o);
          }
        }
        return d;
      };
      PeerRecord.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      PeerRecord.AddressInfo = function() {
        function AddressInfo(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        AddressInfo.prototype.multiaddr = $util5.newBuffer([]);
        AddressInfo.encode = function encode10(m, w) {
          if (!w)
            w = $Writer5.create();
          if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
            w.uint32(10).bytes(m.multiaddr);
          return w;
        };
        AddressInfo.decode = function decode12(r, l) {
          if (!(r instanceof $Reader5))
            r = $Reader5.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root5.PeerRecord.AddressInfo();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.multiaddr = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        AddressInfo.fromObject = function fromObject(d) {
          if (d instanceof $root5.PeerRecord.AddressInfo)
            return d;
          var m = new $root5.PeerRecord.AddressInfo();
          if (d.multiaddr != null) {
            if (typeof d.multiaddr === "string")
              $util5.base64.decode(d.multiaddr, m.multiaddr = $util5.newBuffer($util5.base64.length(d.multiaddr)), 0);
            else if (d.multiaddr.length)
              m.multiaddr = d.multiaddr;
          }
          return m;
        };
        AddressInfo.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            if (o.bytes === String)
              d.multiaddr = "";
            else {
              d.multiaddr = [];
              if (o.bytes !== Array)
                d.multiaddr = $util5.newBuffer(d.multiaddr);
            }
          }
          if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
            d.multiaddr = o.bytes === String ? $util5.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
          }
          return d;
        };
        AddressInfo.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
        };
        return AddressInfo;
      }();
      return PeerRecord;
    }();
    module2.exports = $root5;
  }
});

// node_modules/libp2p/src/record/peer-record/consts.js
var require_consts2 = __commonJS({
  "node_modules/libp2p/src/record/peer-record/consts.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var domain = "libp2p-peer-record";
    var payloadType = Uint8Array.from([3, 1]);
    module2.exports = {
      ENVELOPE_DOMAIN_PEER_RECORD: domain,
      ENVELOPE_PAYLOAD_TYPE_PEER_RECORD: payloadType
    };
  }
});

// node_modules/libp2p/src/record/peer-record/index.js
var require_peer_record2 = __commonJS({
  "node_modules/libp2p/src/record/peer-record/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { Multiaddr: Multiaddr18 } = require_src();
    var PeerId2 = require_src6();
    var arrayEquals = require_array_equals();
    var { PeerRecord: Protobuf } = require_peer_record();
    var {
      ENVELOPE_DOMAIN_PEER_RECORD,
      ENVELOPE_PAYLOAD_TYPE_PEER_RECORD
    } = require_consts2();
    var PeerRecord = class {
      constructor({ peerId, multiaddrs = [], seqNumber = Date.now() }) {
        this.domain = ENVELOPE_DOMAIN_PEER_RECORD;
        this.codec = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
        this.peerId = peerId;
        this.multiaddrs = multiaddrs;
        this.seqNumber = seqNumber;
        this._marshal = void 0;
      }
      marshal() {
        if (this._marshal) {
          return this._marshal;
        }
        this._marshal = Protobuf.encode({
          peerId: this.peerId.toBytes(),
          seq: this.seqNumber,
          addresses: this.multiaddrs.map((m) => ({
            multiaddr: m.bytes
          }))
        }).finish();
        return this._marshal;
      }
      equals(other) {
        if (!(other instanceof PeerRecord)) {
          return false;
        }
        if (!this.peerId.equals(other.peerId)) {
          return false;
        }
        if (this.seqNumber !== other.seqNumber) {
          return false;
        }
        if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
          return false;
        }
        return true;
      }
    };
    PeerRecord.createFromProtobuf = (buf2) => {
      const peerRecord = Protobuf.decode(buf2);
      const peerId = PeerId2.createFromBytes(peerRecord.peerId);
      const multiaddrs = (peerRecord.addresses || []).map((a) => new Multiaddr18(a.multiaddr));
      const seqNumber = Number(peerRecord.seq);
      return new PeerRecord({ peerId, multiaddrs, seqNumber });
    };
    PeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
    module2.exports = PeerRecord;
  }
});

// node_modules/libp2p/src/record/utils.js
var require_utils18 = __commonJS({
  "node_modules/libp2p/src/record/utils.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var Envelope = require_envelope2();
    var PeerRecord = require_peer_record2();
    async function updateSelfPeerRecord(libp2p) {
      const peerRecord = new PeerRecord({
        peerId: libp2p.peerId,
        multiaddrs: libp2p.multiaddrs
      });
      const envelope = await Envelope.seal(peerRecord, libp2p.peerId);
      libp2p.peerStore.addressBook.consumePeerRecord(envelope);
    }
    module2.exports.updateSelfPeerRecord = updateSelfPeerRecord;
  }
});

// node_modules/libp2p/src/transport-manager.js
var require_transport_manager = __commonJS({
  "node_modules/libp2p/src/transport-manager.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:transports"), {
      error: debug17("libp2p:transports:err")
    });
    var pSettle = require_p_settle();
    var { codes } = require_errors4();
    var errCode32 = require_err_code();
    var { updateSelfPeerRecord } = require_utils18();
    var TransportManager = class {
      constructor({ libp2p, upgrader, faultTolerance = FAULT_TOLERANCE.FATAL_ALL }) {
        this.libp2p = libp2p;
        this.upgrader = upgrader;
        this._transports = new Map();
        this._listeners = new Map();
        this._listenerOptions = new Map();
        this.faultTolerance = faultTolerance;
      }
      add(key, Transport, transportOptions = {}) {
        log15("adding %s", key);
        if (!key) {
          throw errCode32(new Error(`Transport must have a valid key, was given '${key}'`), codes.ERR_INVALID_KEY);
        }
        if (this._transports.has(key)) {
          throw errCode32(new Error("There is already a transport with this key"), codes.ERR_DUPLICATE_TRANSPORT);
        }
        const transport = new Transport({
          ...transportOptions,
          libp2p: this.libp2p,
          upgrader: this.upgrader
        });
        this._transports.set(key, transport);
        this._listenerOptions.set(key, transportOptions.listenerOptions || {});
        if (!this._listeners.has(key)) {
          this._listeners.set(key, []);
        }
      }
      async close() {
        const tasks = [];
        for (const [key, listeners] of this._listeners) {
          log15("closing listeners for %s", key);
          while (listeners.length) {
            const listener = listeners.pop();
            listener.removeAllListeners("listening");
            listener.removeAllListeners("close");
            tasks.push(listener.close());
          }
        }
        await Promise.all(tasks);
        log15("all listeners closed");
        for (const key of this._listeners.keys()) {
          this._listeners.set(key, []);
        }
      }
      async dial(ma, options) {
        const transport = this.transportForMultiaddr(ma);
        if (!transport) {
          throw errCode32(new Error(`No transport available for address ${String(ma)}`), codes.ERR_TRANSPORT_UNAVAILABLE);
        }
        try {
          return await transport.dial(ma, options);
        } catch (err) {
          if (!err.code)
            err.code = codes.ERR_TRANSPORT_DIAL_FAILED;
          throw err;
        }
      }
      getAddrs() {
        let addrs = [];
        for (const listeners of this._listeners.values()) {
          for (const listener of listeners) {
            addrs = [...addrs, ...listener.getAddrs()];
          }
        }
        return addrs;
      }
      getTransports() {
        return this._transports.values();
      }
      transportForMultiaddr(ma) {
        for (const transport of this._transports.values()) {
          const addrs = transport.filter([ma]);
          if (addrs.length)
            return transport;
        }
        return null;
      }
      async listen(addrs) {
        if (!addrs || addrs.length === 0) {
          log15("no addresses were provided for listening, this node is dial only");
          return;
        }
        const couldNotListen = [];
        for (const [key, transport] of this._transports.entries()) {
          const supportedAddrs = transport.filter(addrs);
          const tasks = [];
          for (const addr of supportedAddrs) {
            log15("creating listener for %s on %s", key, addr);
            const listener = transport.createListener(this._listenerOptions.get(key));
            this._listeners.get(key).push(listener);
            listener.on("listening", () => updateSelfPeerRecord(this.libp2p));
            listener.on("close", () => updateSelfPeerRecord(this.libp2p));
            tasks.push(listener.listen(addr));
          }
          if (tasks.length === 0) {
            couldNotListen.push(key);
            continue;
          }
          const results = await pSettle(tasks);
          const isListening = results.find((r) => r.isFulfilled === true);
          if (!isListening && this.faultTolerance !== FAULT_TOLERANCE.NO_FATAL) {
            throw errCode32(new Error(`Transport (${key}) could not listen on any available address`), codes.ERR_NO_VALID_ADDRESSES);
          }
        }
        if (couldNotListen.length === this._transports.size) {
          const message = `no valid addresses were provided for transports [${couldNotListen}]`;
          if (this.faultTolerance === FAULT_TOLERANCE.FATAL_ALL) {
            throw errCode32(new Error(message), codes.ERR_NO_VALID_ADDRESSES);
          }
          log15(`libp2p in dial mode only: ${message}`);
        }
      }
      async remove(key) {
        log15("removing %s", key);
        if (this._listeners.has(key)) {
          for (const listener of this._listeners.get(key)) {
            listener.removeAllListeners("listening");
            listener.removeAllListeners("close");
            await listener.close();
          }
        }
        this._transports.delete(key);
        this._listeners.delete(key);
      }
      async removeAll() {
        const tasks = [];
        for (const key of this._transports.keys()) {
          tasks.push(this.remove(key));
        }
        await Promise.all(tasks);
      }
    };
    var FAULT_TOLERANCE = {
      FATAL_ALL: 0,
      NO_FATAL: 1
    };
    TransportManager.FaultTolerance = FAULT_TOLERANCE;
    module2.exports = TransportManager;
  }
});

// node_modules/libp2p/src/config.js
var require_config3 = __commonJS({
  "node_modules/libp2p/src/config.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var mergeOptions2 = require_merge_options();
    var { dnsaddrResolver } = require_resolvers();
    var Constants = require_constants11();
    var { AGENT_VERSION } = require_consts();
    var RelayConstants = require_constants12();
    var { publicAddressesFirst } = require_address_sort();
    var { FaultTolerance } = require_transport_manager();
    var DefaultConfig = {
      addresses: {
        listen: [],
        announce: [],
        noAnnounce: [],
        announceFilter: (multiaddrs) => multiaddrs
      },
      connectionManager: {
        minConnections: 25
      },
      transportManager: {
        faultTolerance: FaultTolerance.FATAL_ALL
      },
      dialer: {
        maxParallelDials: Constants.MAX_PARALLEL_DIALS,
        maxDialsPerPeer: Constants.MAX_PER_PEER_DIALS,
        dialTimeout: Constants.DIAL_TIMEOUT,
        resolvers: {
          dnsaddr: dnsaddrResolver
        },
        addressSorter: publicAddressesFirst
      },
      host: {
        agentVersion: AGENT_VERSION
      },
      metrics: {
        enabled: false
      },
      peerStore: {
        persistence: false,
        threshold: 5
      },
      peerRouting: {
        refreshManager: {
          enabled: true,
          interval: 6e5,
          bootDelay: 1e4
        }
      },
      config: {
        protocolPrefix: "ipfs",
        dht: {
          enabled: false,
          kBucketSize: 20,
          randomWalk: {
            enabled: false,
            queriesPerPeriod: 1,
            interval: 3e5,
            timeout: 1e4
          }
        },
        nat: {
          enabled: true,
          ttl: 7200,
          keepAlive: true,
          gateway: null,
          externalIp: null,
          pmp: {
            enabled: false
          }
        },
        peerDiscovery: {
          autoDial: true
        },
        pubsub: {
          enabled: true
        },
        relay: {
          enabled: true,
          advertise: {
            bootDelay: RelayConstants.ADVERTISE_BOOT_DELAY,
            enabled: false,
            ttl: RelayConstants.ADVERTISE_TTL
          },
          hop: {
            enabled: false,
            active: false
          },
          autoRelay: {
            enabled: false,
            maxListeners: 2
          }
        },
        transport: {}
      }
    };
    module2.exports.validate = (opts) => {
      const resultingOptions = mergeOptions2(DefaultConfig, opts);
      if (resultingOptions.modules.transport.length < 1)
        throw new Error("'options.modules.transport' must contain at least 1 transport");
      return resultingOptions;
    };
  }
});

// node_modules/libp2p/src/address-manager/index.js
var require_address_manager = __commonJS({
  "node_modules/libp2p/src/address-manager/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { EventEmitter: EventEmitter4 } = require_events();
    var { Multiaddr: Multiaddr18 } = require_src();
    var PeerId2 = require_src6();
    var AddressManager = class extends EventEmitter4 {
      constructor(peerId, { listen = [], announce = [] } = {}) {
        super();
        this.peerId = peerId;
        this.listen = new Set(listen.map((ma) => ma.toString()));
        this.announce = new Set(announce.map((ma) => ma.toString()));
        this.observed = new Set();
      }
      getListenAddrs() {
        return Array.from(this.listen).map((a) => new Multiaddr18(a));
      }
      getAnnounceAddrs() {
        return Array.from(this.announce).map((a) => new Multiaddr18(a));
      }
      getObservedAddrs() {
        return Array.from(this.observed).map((a) => new Multiaddr18(a));
      }
      addObservedAddr(addr) {
        let ma = new Multiaddr18(addr);
        const remotePeer = ma.getPeerId();
        if (remotePeer) {
          const remotePeerId = PeerId2.createFromB58String(remotePeer);
          if (remotePeerId.equals(this.peerId)) {
            ma = ma.decapsulate(new Multiaddr18(`/p2p/${this.peerId}`));
          }
        }
        const addrString = ma.toString();
        if (this.observed.has(addrString)) {
          return;
        }
        this.observed.add(addrString);
        this.emit("change:addresses");
      }
    };
    module2.exports = AddressManager;
  }
});

// node_modules/libp2p/src/connection-manager/visibility-change-emitter.js
var require_visibility_change_emitter = __commonJS({
  "node_modules/libp2p/src/connection-manager/visibility-change-emitter.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { EventEmitter: EventEmitter4 } = require_events();
    var debug17 = require_browser2()("latency-monitor:VisibilityChangeEmitter");
    var VisibilityChangeEmitter = class extends EventEmitter4 {
      constructor() {
        super();
        if (typeof document === "undefined") {
          debug17('This is not a browser, no "document" found. Stopping.');
          return;
        }
        this._initializeVisibilityVarNames();
        this._addVisibilityChangeListener();
      }
      _initializeVisibilityVarNames() {
        let hidden2;
        let visibilityChange;
        if (typeof document.hidden !== "undefined") {
          hidden2 = "hidden";
          visibilityChange = "visibilitychange";
        } else if (typeof document.mozHidden !== "undefined") {
          hidden2 = "mozHidden";
          visibilityChange = "mozvisibilitychange";
        } else if (typeof document.msHidden !== "undefined") {
          hidden2 = "msHidden";
          visibilityChange = "msvisibilitychange";
        } else if (typeof document.webkitHidden !== "undefined") {
          hidden2 = "webkitHidden";
          visibilityChange = "webkitvisibilitychange";
        }
        this._hidden = hidden2;
        this._visibilityChange = visibilityChange;
      }
      _addVisibilityChangeListener() {
        if (typeof document.addEventListener === "undefined" || typeof document[this._hidden] === "undefined") {
          debug17("Checking page visibility requires a browser that supports the Page Visibility API.");
        } else {
          document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), false);
        }
      }
      isVisible() {
        if (this._hidden === void 0 || document[this._hidden] === void 0) {
          return void 0;
        }
        return !document[this._hidden];
      }
      _handleVisibilityChange() {
        const visible = !document[this._hidden];
        debug17(visible ? "Page Visible" : "Page Hidden");
        this.emit("visibilityChange", visible);
      }
    };
    module2.exports = VisibilityChangeEmitter;
  }
});

// node_modules/libp2p/src/connection-manager/latency-monitor.js
var require_latency_monitor = __commonJS({
  "node_modules/libp2p/src/connection-manager/latency-monitor.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { EventEmitter: EventEmitter4 } = require_events();
    var VisibilityChangeEmitter = require_visibility_change_emitter();
    var debug17 = require_browser2()("latency-monitor:LatencyMonitor");
    var LatencyMonitor = class extends EventEmitter4 {
      constructor({ latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage } = {}) {
        super();
        const that = this;
        that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500;
        that.latencyRandomPercentage = latencyRandomPercentage || 10;
        that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100) * that.latencyCheckIntervalMs;
        that._latecyCheckSubtract = that._latecyCheckMultiply / 2;
        that.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? void 0 : dataEmitIntervalMs || 5 * 1e3;
        debug17("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", that.latencyCheckIntervalMs, that.dataEmitIntervalMs);
        if (that.dataEmitIntervalMs) {
          debug17("Expecting ~%s events per summary", that.latencyCheckIntervalMs / that.dataEmitIntervalMs);
        } else {
          debug17("Not emitting summaries");
        }
        that.asyncTestFn = asyncTestFn;
      }
      start() {
        if (globalThis.process && globalThis.process.hrtime) {
          debug17("Using process.hrtime for timing");
          this.now = globalThis.process.hrtime;
          this.getDeltaMS = (startTime) => {
            const hrtime = this.now(startTime);
            return hrtime[0] * 1e3 + hrtime[1] / 1e6;
          };
        } else if (typeof window !== "undefined" && window.performance && window.performance.now) {
          debug17("Using performance.now for timing");
          this.now = window.performance.now.bind(window.performance);
          this.getDeltaMS = (startTime) => Math.round(this.now() - startTime);
        } else {
          debug17("Using Date.now for timing");
          this.now = Date.now;
          this.getDeltaMS = (startTime) => this.now() - startTime;
        }
        this._latencyData = this._initLatencyData();
        if (isBrowser2()) {
          this._visibilityChangeEmitter = new VisibilityChangeEmitter();
          this._visibilityChangeEmitter.on("visibilityChange", (pageInFocus) => {
            if (pageInFocus) {
              this._startTimers();
            } else {
              this._emitSummary();
              this._stopTimers();
            }
          });
        }
        if (!this._visibilityChangeEmitter || this._visibilityChangeEmitter.isVisible()) {
          this._startTimers();
        }
      }
      stop() {
        this._stopTimers();
      }
      _startTimers() {
        if (this._checkLatencyID) {
          return;
        }
        this._checkLatency();
        if (this.dataEmitIntervalMs) {
          this._emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);
          if (typeof this._emitIntervalID.unref === "function") {
            this._emitIntervalID.unref();
          }
        }
      }
      _stopTimers() {
        if (this._checkLatencyID) {
          clearTimeout(this._checkLatencyID);
          this._checkLatencyID = void 0;
        }
        if (this._emitIntervalID) {
          clearInterval(this._emitIntervalID);
          this._emitIntervalID = void 0;
        }
      }
      _emitSummary() {
        const summary = this.getSummary();
        if (summary.events > 0) {
          this.emit("data", summary);
        }
      }
      getSummary() {
        const latency = {
          events: this._latencyData.events,
          minMs: this._latencyData.minMs,
          maxMs: this._latencyData.maxMs,
          avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events : Number.POSITIVE_INFINITY,
          lengthMs: this.getDeltaMS(this._latencyData.startTime)
        };
        this._latencyData = this._initLatencyData();
        debug17("Summary: %O", latency);
        return latency;
      }
      _checkLatency() {
        const that = this;
        const randomness = Math.random() * that._latecyCheckMultiply - that._latecyCheckSubtract;
        const localData = {
          deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),
          startTime: that.now()
        };
        const cb = () => {
          if (!this._checkLatencyID) {
            return;
          }
          const deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;
          that._checkLatency();
          that._latencyData.events++;
          that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);
          that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);
          that._latencyData.totalMs += deltaMS;
          debug17("MS: %s Data: %O", deltaMS, that._latencyData);
        };
        debug17("localData: %O", localData);
        this._checkLatencyID = setTimeout(() => {
          if (that.asyncTestFn) {
            localData.deltaOffset = 0;
            localData.startTime = that.now();
            that.asyncTestFn(cb);
          } else {
            localData.deltaOffset -= 1;
            cb();
          }
        }, localData.deltaOffset);
        if (typeof this._checkLatencyID.unref === "function") {
          this._checkLatencyID.unref();
        }
      }
      _initLatencyData() {
        return {
          startTime: this.now(),
          minMs: Number.POSITIVE_INFINITY,
          maxMs: Number.NEGATIVE_INFINITY,
          events: 0,
          totalMs: 0
        };
      }
    };
    function isBrowser2() {
      return typeof window !== "undefined";
    }
    module2.exports = LatencyMonitor;
  }
});

// node_modules/retimer/time-browser.js
var require_time_browser2 = __commonJS({
  "node_modules/retimer/time-browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = function getTime() {
      return Date.now();
    };
  }
});

// node_modules/retimer/retimer.js
var require_retimer2 = __commonJS({
  "node_modules/retimer/retimer.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var getTime = require_time_browser2();
    var Retimer = class {
      constructor(callback, timeout, args) {
        const that = this;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._args = args;
        this._triggered = false;
        this._timerWrapper = () => {
          if (that._rescheduled > 0) {
            that._scheduled = that._rescheduled - (getTime() - that._started);
            that._schedule(that._scheduled);
          } else {
            that._triggered = true;
            callback.apply(null, that._args);
          }
        };
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      reschedule(timeout) {
        if (!timeout) {
          timeout = this._scheduled;
        }
        const now = getTime();
        if (now + timeout - (this._started + this._scheduled) < 0) {
          clearTimeout(this._timer);
          this._schedule(timeout);
        } else if (!this._triggered) {
          this._started = now;
          this._rescheduled = timeout;
        } else {
          this._schedule(timeout);
        }
      }
      _schedule(timeout) {
        this._triggered = false;
        this._started = getTime();
        this._rescheduled = 0;
        this._scheduled = timeout;
        this._timer = setTimeout(this._timerWrapper, timeout);
      }
      clear() {
        clearTimeout(this._timer);
      }
    };
    function retimer() {
      if (typeof arguments[0] !== "function") {
        throw new Error("callback needed");
      }
      if (typeof arguments[1] !== "number") {
        throw new Error("timeout needed");
      }
      let args;
      if (arguments.length > 0) {
        args = new Array(arguments.length - 2);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 2];
        }
      }
      return new Retimer(arguments[0], arguments[1], args);
    }
    module2.exports = retimer;
  }
});

// node_modules/libp2p/src/connection-manager/index.js
var require_connection_manager = __commonJS({
  "node_modules/libp2p/src/connection-manager/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:connection-manager"), {
      error: debug17("libp2p:connection-manager:err")
    });
    var errcode7 = require_err_code();
    var mergeOptions2 = require_merge_options();
    var LatencyMonitor = require_latency_monitor();
    var retimer = require_retimer2();
    var { EventEmitter: EventEmitter4 } = require_events();
    var PeerId2 = require_src6();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors4();
    var defaultOptions4 = {
      maxConnections: Infinity,
      minConnections: 0,
      maxData: Infinity,
      maxSentData: Infinity,
      maxReceivedData: Infinity,
      maxEventLoopDelay: Infinity,
      pollInterval: 2e3,
      autoDialInterval: 1e4,
      movingAverageInterval: 6e4,
      defaultPeerValue: 1
    };
    var ConnectionManager = class extends EventEmitter4 {
      constructor(libp2p, options = {}) {
        super();
        this._libp2p = libp2p;
        this._peerId = libp2p.peerId.toB58String();
        this._options = mergeOptions2.call({ ignoreUndefined: true }, defaultOptions4, options);
        if (this._options.maxConnections < this._options.minConnections) {
          throw errcode7(new Error("Connection Manager maxConnections must be greater than minConnections"), ERR_INVALID_PARAMETERS);
        }
        log15("options: %j", this._options);
        this._peerValues = new Map();
        this.connections = new Map();
        this._started = false;
        this._timer = null;
        this._autoDialTimeout = null;
        this._checkMetrics = this._checkMetrics.bind(this);
        this._autoDial = this._autoDial.bind(this);
        this._latencyMonitor = new LatencyMonitor({
          latencyCheckIntervalMs: this._options.pollInterval,
          dataEmitIntervalMs: this._options.pollInterval
        });
      }
      get size() {
        return Array.from(this.connections.values()).reduce((accumulator, value) => accumulator + value.length, 0);
      }
      start() {
        if (this._libp2p.metrics) {
          this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);
        }
        this._latencyMonitor.start();
        this._onLatencyMeasure = this._onLatencyMeasure.bind(this);
        this._latencyMonitor.on("data", this._onLatencyMeasure);
        this._started = true;
        log15("started");
        this._options.autoDial && this._autoDial();
      }
      async stop() {
        this._autoDialTimeout && this._autoDialTimeout.clear();
        this._timer && this._timer.clear();
        this._latencyMonitor.removeListener("data", this._onLatencyMeasure);
        this._latencyMonitor.stop();
        this._started = false;
        await this._close();
        log15("stopped");
      }
      async _close() {
        const tasks = [];
        for (const connectionList of this.connections.values()) {
          for (const connection of connectionList) {
            tasks.push(connection.close());
          }
        }
        await Promise.all(tasks);
        this.connections.clear();
      }
      setPeerValue(peerId, value) {
        if (value < 0 || value > 1) {
          throw new Error("value should be a number between 0 and 1");
        }
        this._peerValues.set(peerId.toB58String(), value);
      }
      _checkMetrics() {
        if (this._libp2p.metrics) {
          const movingAverages = this._libp2p.metrics.global.movingAverages;
          const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();
          this._checkMaxLimit("maxReceivedData", received);
          const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();
          this._checkMaxLimit("maxSentData", sent);
          const total = received + sent;
          this._checkMaxLimit("maxData", total);
          log15("metrics update", total);
          this._timer = retimer(this._checkMetrics, this._options.pollInterval);
        }
      }
      onConnect(connection) {
        const peerId = connection.remotePeer;
        const peerIdStr = peerId.toB58String();
        const storedConn = this.connections.get(peerIdStr);
        this.emit("peer:connect", connection);
        if (storedConn) {
          storedConn.push(connection);
        } else {
          this.connections.set(peerIdStr, [connection]);
        }
        this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey);
        if (!this._peerValues.has(peerIdStr)) {
          this._peerValues.set(peerIdStr, this._options.defaultPeerValue);
        }
        this._checkMaxLimit("maxConnections", this.size);
      }
      onDisconnect(connection) {
        const peerId = connection.remotePeer.toB58String();
        let storedConn = this.connections.get(peerId);
        if (storedConn && storedConn.length > 1) {
          storedConn = storedConn.filter((conn) => conn.id !== connection.id);
          this.connections.set(peerId, storedConn);
        } else if (storedConn) {
          this.connections.delete(peerId);
          this._peerValues.delete(connection.remotePeer.toB58String());
          this.emit("peer:disconnect", connection);
        }
      }
      get(peerId) {
        const connections = this.getAll(peerId);
        if (connections.length) {
          return connections[0];
        }
        return null;
      }
      getAll(peerId) {
        if (!PeerId2.isPeerId(peerId)) {
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const id = peerId.toB58String();
        const connections = this.connections.get(id);
        if (connections) {
          return connections.filter((connection) => connection.stat.status === "open");
        }
        return [];
      }
      _onLatencyMeasure(summary) {
        this._checkMaxLimit("maxEventLoopDelay", summary.avgMs);
      }
      _checkMaxLimit(name5, value) {
        const limit = this._options[name5];
        log15("checking limit of %s. current value: %d of %d", name5, value, limit);
        if (value > limit) {
          log15("%s: limit exceeded: %s, %d", this._peerId, name5, value);
          this._maybeDisconnectOne();
        }
      }
      async _autoDial() {
        const minConnections = this._options.minConnections;
        if (this.size >= minConnections) {
          this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);
          return;
        }
        const peers = Array.from(this._libp2p.peerStore.peers.values()).sort((a, b) => {
          if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {
            return 1;
          } else if (b.id.pubKey && !a.id.pubKey) {
            return 1;
          }
          return -1;
        });
        for (let i = 0; i < peers.length && this.size < minConnections; i++) {
          if (!this.get(peers[i].id)) {
            log15("connecting to a peerStore stored peer %s", peers[i].id.toB58String());
            try {
              await this._libp2p.dialer.connectToPeer(peers[i].id);
              if (!this._started) {
                return;
              }
            } catch (err) {
              log15.error("could not connect to peerStore stored peer", err);
            }
          }
        }
        this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);
      }
      _maybeDisconnectOne() {
        if (this._options.minConnections < this.connections.size) {
          const peerValues = Array.from(new Map([...this._peerValues.entries()].sort((a, b) => a[1] - b[1])));
          log15("%s: sorted peer values: %j", this._peerId, peerValues);
          const disconnectPeer = peerValues[0];
          if (disconnectPeer) {
            const peerId = disconnectPeer[0];
            log15("%s: lowest value peer is %s", this._peerId, peerId);
            log15("%s: closing a connection to %j", this._peerId, peerId);
            for (const connections of this.connections.values()) {
              if (connections[0].remotePeer.toB58String() === peerId) {
                connections[0].close();
                break;
              }
            }
          }
        }
      }
    };
    module2.exports = ConnectionManager;
  }
});

// node_modules/libp2p/src/circuit/protocol/index.js
var require_protocol = __commonJS({
  "node_modules/libp2p/src/circuit/protocol/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var $protobuf5 = require_minimal2();
    var $Reader5 = $protobuf5.Reader;
    var $Writer5 = $protobuf5.Writer;
    var $util5 = $protobuf5.util;
    var $root5 = $protobuf5.roots["libp2p-circuit"] || ($protobuf5.roots["libp2p-circuit"] = {});
    $root5.CircuitRelay = function() {
      function CircuitRelay(p) {
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      CircuitRelay.prototype.type = 1;
      CircuitRelay.prototype.srcPeer = null;
      CircuitRelay.prototype.dstPeer = null;
      CircuitRelay.prototype.code = 100;
      CircuitRelay.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        if (m.type != null && Object.hasOwnProperty.call(m, "type"))
          w.uint32(8).int32(m.type);
        if (m.srcPeer != null && Object.hasOwnProperty.call(m, "srcPeer"))
          $root5.CircuitRelay.Peer.encode(m.srcPeer, w.uint32(18).fork()).ldelim();
        if (m.dstPeer != null && Object.hasOwnProperty.call(m, "dstPeer"))
          $root5.CircuitRelay.Peer.encode(m.dstPeer, w.uint32(26).fork()).ldelim();
        if (m.code != null && Object.hasOwnProperty.call(m, "code"))
          w.uint32(32).int32(m.code);
        return w;
      };
      CircuitRelay.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.CircuitRelay();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.type = r.int32();
              break;
            case 2:
              m.srcPeer = $root5.CircuitRelay.Peer.decode(r, r.uint32());
              break;
            case 3:
              m.dstPeer = $root5.CircuitRelay.Peer.decode(r, r.uint32());
              break;
            case 4:
              m.code = r.int32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      CircuitRelay.fromObject = function fromObject(d) {
        if (d instanceof $root5.CircuitRelay)
          return d;
        var m = new $root5.CircuitRelay();
        switch (d.type) {
          case "HOP":
          case 1:
            m.type = 1;
            break;
          case "STOP":
          case 2:
            m.type = 2;
            break;
          case "STATUS":
          case 3:
            m.type = 3;
            break;
          case "CAN_HOP":
          case 4:
            m.type = 4;
            break;
        }
        if (d.srcPeer != null) {
          if (typeof d.srcPeer !== "object")
            throw TypeError(".CircuitRelay.srcPeer: object expected");
          m.srcPeer = $root5.CircuitRelay.Peer.fromObject(d.srcPeer);
        }
        if (d.dstPeer != null) {
          if (typeof d.dstPeer !== "object")
            throw TypeError(".CircuitRelay.dstPeer: object expected");
          m.dstPeer = $root5.CircuitRelay.Peer.fromObject(d.dstPeer);
        }
        switch (d.code) {
          case "SUCCESS":
          case 100:
            m.code = 100;
            break;
          case "HOP_SRC_ADDR_TOO_LONG":
          case 220:
            m.code = 220;
            break;
          case "HOP_DST_ADDR_TOO_LONG":
          case 221:
            m.code = 221;
            break;
          case "HOP_SRC_MULTIADDR_INVALID":
          case 250:
            m.code = 250;
            break;
          case "HOP_DST_MULTIADDR_INVALID":
          case 251:
            m.code = 251;
            break;
          case "HOP_NO_CONN_TO_DST":
          case 260:
            m.code = 260;
            break;
          case "HOP_CANT_DIAL_DST":
          case 261:
            m.code = 261;
            break;
          case "HOP_CANT_OPEN_DST_STREAM":
          case 262:
            m.code = 262;
            break;
          case "HOP_CANT_SPEAK_RELAY":
          case 270:
            m.code = 270;
            break;
          case "HOP_CANT_RELAY_TO_SELF":
          case 280:
            m.code = 280;
            break;
          case "STOP_SRC_ADDR_TOO_LONG":
          case 320:
            m.code = 320;
            break;
          case "STOP_DST_ADDR_TOO_LONG":
          case 321:
            m.code = 321;
            break;
          case "STOP_SRC_MULTIADDR_INVALID":
          case 350:
            m.code = 350;
            break;
          case "STOP_DST_MULTIADDR_INVALID":
          case 351:
            m.code = 351;
            break;
          case "STOP_RELAY_REFUSED":
          case 390:
            m.code = 390;
            break;
          case "MALFORMED_MESSAGE":
          case 400:
            m.code = 400;
            break;
        }
        return m;
      };
      CircuitRelay.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.defaults) {
          d.type = o.enums === String ? "HOP" : 1;
          d.srcPeer = null;
          d.dstPeer = null;
          d.code = o.enums === String ? "SUCCESS" : 100;
        }
        if (m.type != null && m.hasOwnProperty("type")) {
          d.type = o.enums === String ? $root5.CircuitRelay.Type[m.type] : m.type;
        }
        if (m.srcPeer != null && m.hasOwnProperty("srcPeer")) {
          d.srcPeer = $root5.CircuitRelay.Peer.toObject(m.srcPeer, o);
        }
        if (m.dstPeer != null && m.hasOwnProperty("dstPeer")) {
          d.dstPeer = $root5.CircuitRelay.Peer.toObject(m.dstPeer, o);
        }
        if (m.code != null && m.hasOwnProperty("code")) {
          d.code = o.enums === String ? $root5.CircuitRelay.Status[m.code] : m.code;
        }
        return d;
      };
      CircuitRelay.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      CircuitRelay.Status = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[100] = "SUCCESS"] = 100;
        values[valuesById[220] = "HOP_SRC_ADDR_TOO_LONG"] = 220;
        values[valuesById[221] = "HOP_DST_ADDR_TOO_LONG"] = 221;
        values[valuesById[250] = "HOP_SRC_MULTIADDR_INVALID"] = 250;
        values[valuesById[251] = "HOP_DST_MULTIADDR_INVALID"] = 251;
        values[valuesById[260] = "HOP_NO_CONN_TO_DST"] = 260;
        values[valuesById[261] = "HOP_CANT_DIAL_DST"] = 261;
        values[valuesById[262] = "HOP_CANT_OPEN_DST_STREAM"] = 262;
        values[valuesById[270] = "HOP_CANT_SPEAK_RELAY"] = 270;
        values[valuesById[280] = "HOP_CANT_RELAY_TO_SELF"] = 280;
        values[valuesById[320] = "STOP_SRC_ADDR_TOO_LONG"] = 320;
        values[valuesById[321] = "STOP_DST_ADDR_TOO_LONG"] = 321;
        values[valuesById[350] = "STOP_SRC_MULTIADDR_INVALID"] = 350;
        values[valuesById[351] = "STOP_DST_MULTIADDR_INVALID"] = 351;
        values[valuesById[390] = "STOP_RELAY_REFUSED"] = 390;
        values[valuesById[400] = "MALFORMED_MESSAGE"] = 400;
        return values;
      }();
      CircuitRelay.Type = function() {
        var valuesById = {}, values = Object.create(valuesById);
        values[valuesById[1] = "HOP"] = 1;
        values[valuesById[2] = "STOP"] = 2;
        values[valuesById[3] = "STATUS"] = 3;
        values[valuesById[4] = "CAN_HOP"] = 4;
        return values;
      }();
      CircuitRelay.Peer = function() {
        function Peer(p) {
          this.addrs = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Peer.prototype.id = $util5.newBuffer([]);
        Peer.prototype.addrs = $util5.emptyArray;
        Peer.encode = function encode10(m, w) {
          if (!w)
            w = $Writer5.create();
          w.uint32(10).bytes(m.id);
          if (m.addrs != null && m.addrs.length) {
            for (var i = 0; i < m.addrs.length; ++i)
              w.uint32(18).bytes(m.addrs[i]);
          }
          return w;
        };
        Peer.decode = function decode12(r, l) {
          if (!(r instanceof $Reader5))
            r = $Reader5.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root5.CircuitRelay.Peer();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.id = r.bytes();
                break;
              case 2:
                if (!(m.addrs && m.addrs.length))
                  m.addrs = [];
                m.addrs.push(r.bytes());
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          if (!m.hasOwnProperty("id"))
            throw $util5.ProtocolError("missing required 'id'", { instance: m });
          return m;
        };
        Peer.fromObject = function fromObject(d) {
          if (d instanceof $root5.CircuitRelay.Peer)
            return d;
          var m = new $root5.CircuitRelay.Peer();
          if (d.id != null) {
            if (typeof d.id === "string")
              $util5.base64.decode(d.id, m.id = $util5.newBuffer($util5.base64.length(d.id)), 0);
            else if (d.id.length)
              m.id = d.id;
          }
          if (d.addrs) {
            if (!Array.isArray(d.addrs))
              throw TypeError(".CircuitRelay.Peer.addrs: array expected");
            m.addrs = [];
            for (var i = 0; i < d.addrs.length; ++i) {
              if (typeof d.addrs[i] === "string")
                $util5.base64.decode(d.addrs[i], m.addrs[i] = $util5.newBuffer($util5.base64.length(d.addrs[i])), 0);
              else if (d.addrs[i].length)
                m.addrs[i] = d.addrs[i];
            }
          }
          return m;
        };
        Peer.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.addrs = [];
          }
          if (o.defaults) {
            if (o.bytes === String)
              d.id = "";
            else {
              d.id = [];
              if (o.bytes !== Array)
                d.id = $util5.newBuffer(d.id);
            }
          }
          if (m.id != null && m.hasOwnProperty("id")) {
            d.id = o.bytes === String ? $util5.base64.encode(m.id, 0, m.id.length) : o.bytes === Array ? Array.prototype.slice.call(m.id) : m.id;
          }
          if (m.addrs && m.addrs.length) {
            d.addrs = [];
            for (var j = 0; j < m.addrs.length; ++j) {
              d.addrs[j] = o.bytes === String ? $util5.base64.encode(m.addrs[j], 0, m.addrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.addrs[j]) : m.addrs[j];
            }
          }
          return d;
        };
        Peer.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
        };
        return Peer;
      }();
      return CircuitRelay;
    }();
    module2.exports = $root5;
  }
});

// node_modules/libp2p-utils/src/stream-to-ma-conn.js
var require_stream_to_ma_conn = __commonJS({
  "node_modules/libp2p-utils/src/stream-to-ma-conn.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { source: abortable } = require_abortable_iterator();
    var debug17 = require_browser2();
    var log15 = debug17("libp2p:stream:converter");
    function streamToMaConnection({ stream, remoteAddr, localAddr }, options = {}) {
      const { sink, source } = stream;
      const maConn = {
        async sink(source2) {
          if (options.signal) {
            source2 = abortable(source2, options.signal);
          }
          try {
            await sink(source2);
          } catch (err) {
            if (err.type !== "aborted") {
              log15(err);
            }
          }
          close();
        },
        source: options.signal ? abortable(source, options.signal) : source,
        conn: stream,
        localAddr,
        remoteAddr,
        timeline: { open: Date.now(), close: void 0 },
        close() {
          sink(new Uint8Array(0));
          return close();
        }
      };
      function close() {
        if (!maConn.timeline.close) {
          maConn.timeline.close = Date.now();
        }
        return Promise.resolve();
      }
      return maConn;
    }
    module2.exports = streamToMaConnection;
  }
});

// node_modules/libp2p/src/circuit/multicodec.js
var require_multicodec = __commonJS({
  "node_modules/libp2p/src/circuit/multicodec.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {
      relay: "/libp2p/circuit/relay/0.1.0"
    };
  }
});

// node_modules/libp2p/src/circuit/listener.js
var require_listener2 = __commonJS({
  "node_modules/libp2p/src/circuit/listener.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { EventEmitter: EventEmitter4 } = require_events();
    var { Multiaddr: Multiaddr18 } = require_src();
    module2.exports = (libp2p) => {
      const listeningAddrs = new Map();
      async function listen(addr) {
        const addrString = String(addr).split("/p2p-circuit").find((a) => a !== "");
        const relayConn = await libp2p.dial(new Multiaddr18(addrString));
        const relayedAddr = relayConn.remoteAddr.encapsulate("/p2p-circuit");
        listeningAddrs.set(relayConn.remotePeer.toB58String(), relayedAddr);
        listener.emit("listening");
      }
      function getAddrs() {
        const addrs = [];
        for (const addr of listeningAddrs.values()) {
          addrs.push(addr);
        }
        return addrs;
      }
      const listener = Object.assign(new EventEmitter4(), {
        close: () => Promise.resolve(),
        listen,
        getAddrs
      });
      libp2p.connectionManager.on("peer:disconnect", (connection) => {
        const deleted = listeningAddrs.delete(connection.remotePeer.toB58String());
        if (deleted) {
          listener.emit("close");
        }
      });
      return listener;
    };
  }
});

// node_modules/libp2p/src/circuit/circuit/utils.js
var require_utils19 = __commonJS({
  "node_modules/libp2p/src/circuit/circuit/utils.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { Multiaddr: Multiaddr18 } = require_src();
    var { CircuitRelay } = require_protocol();
    function writeResponse(streamHandler, status) {
      streamHandler.write({
        type: CircuitRelay.Type.STATUS,
        code: status
      });
    }
    function validateAddrs(msg, streamHandler) {
      try {
        if (msg.dstPeer && msg.dstPeer.addrs) {
          msg.dstPeer.addrs.forEach((addr) => {
            return new Multiaddr18(addr);
          });
        }
      } catch (err) {
        writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);
        throw err;
      }
      try {
        if (msg.srcPeer && msg.srcPeer.addrs) {
          msg.srcPeer.addrs.forEach((addr) => {
            return new Multiaddr18(addr);
          });
        }
      } catch (err) {
        writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);
        throw err;
      }
    }
    module2.exports = {
      validateAddrs
    };
  }
});

// node_modules/libp2p/src/circuit/circuit/stream-handler.js
var require_stream_handler = __commonJS({
  "node_modules/libp2p/src/circuit/circuit/stream-handler.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:circuit:stream-handler"), {
      error: debug17("libp2p:circuit:stream-handler:err")
    });
    var lp2 = require_src12();
    var handshake = require_src20();
    var { CircuitRelay } = require_protocol();
    var StreamHandler = class {
      constructor({ stream, maxLength = 4096 }) {
        this.stream = stream;
        this.shake = handshake(this.stream);
        this.decoder = lp2.decode.fromReader(this.shake.reader, { maxDataLength: maxLength });
      }
      async read() {
        const msg = await this.decoder.next();
        if (msg.value) {
          const value = CircuitRelay.decode(msg.value.slice());
          log15("read message type", value.type);
          return value;
        }
        log15("read received no value, closing stream");
        this.close();
      }
      write(msg) {
        log15("write message type %s", msg.type);
        this.shake.write(lp2.encode.single(CircuitRelay.encode(msg).finish()));
      }
      rest() {
        this.shake.rest();
        return this.shake.stream;
      }
      end(msg) {
        this.write(msg);
        this.close();
      }
      close() {
        log15("closing the stream");
        this.rest().sink([]);
      }
    };
    module2.exports = StreamHandler;
  }
});

// node_modules/libp2p/src/circuit/circuit/stop.js
var require_stop2 = __commonJS({
  "node_modules/libp2p/src/circuit/circuit/stop.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:circuit:stop"), {
      error: debug17("libp2p:circuit:stop:err")
    });
    var { CircuitRelay: CircuitPB } = require_protocol();
    var multicodec = require_multicodec();
    var StreamHandler = require_stream_handler();
    var { validateAddrs } = require_utils19();
    module2.exports.handleStop = function handleStop({
      connection,
      request,
      streamHandler
    }) {
      try {
        validateAddrs(request, streamHandler);
      } catch (err) {
        return log15.error("invalid stop request via peer %s", connection.remotePeer.toB58String(), err);
      }
      log15("stop request is valid");
      streamHandler.write({
        type: CircuitPB.Type.STATUS,
        code: CircuitPB.Status.SUCCESS
      });
      return streamHandler.rest();
    };
    module2.exports.stop = async function stop({
      connection,
      request
    }) {
      const { stream } = await connection.newStream([multicodec.relay]);
      log15("starting stop request to %s", connection.remotePeer.toB58String());
      const streamHandler = new StreamHandler({ stream });
      streamHandler.write(request);
      const response = await streamHandler.read();
      if (!response) {
        return streamHandler.close();
      }
      if (response.code === CircuitPB.Status.SUCCESS) {
        log15("stop request to %s was successful", connection.remotePeer.toB58String());
        return streamHandler.rest();
      }
      log15("stop request failed with code %d", response.code);
      streamHandler.close();
    };
  }
});

// node_modules/libp2p/src/circuit/circuit/hop.js
var require_hop = __commonJS({
  "node_modules/libp2p/src/circuit/circuit/hop.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:circuit:hop"), {
      error: debug17("libp2p:circuit:hop:err")
    });
    var errCode32 = require_err_code();
    var PeerId2 = require_src6();
    var { validateAddrs } = require_utils19();
    var StreamHandler = require_stream_handler();
    var { CircuitRelay: CircuitPB } = require_protocol();
    var { pipe: pipe4 } = require_it_pipe();
    var { codes: Errors8 } = require_errors4();
    var { stop } = require_stop2();
    var multicodec = require_multicodec();
    async function handleHop({
      connection,
      request,
      streamHandler,
      circuit
    }) {
      if (!circuit._options.hop.enabled) {
        log15("HOP request received but we are not acting as a relay");
        return streamHandler.end({
          type: CircuitPB.Type.STATUS,
          code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY
        });
      }
      try {
        validateAddrs(request, streamHandler);
      } catch (err) {
        return log15.error("invalid hop request via peer %s", connection.remotePeer.toB58String(), err);
      }
      if (!request.dstPeer) {
        log15("HOP request received but we do not receive a dstPeer");
        return;
      }
      const destinationPeer = new PeerId2(request.dstPeer.id);
      const destinationConnection = circuit._connectionManager.get(destinationPeer);
      if (!destinationConnection && !circuit._options.hop.active) {
        log15("HOP request received but we are not connected to the destination peer");
        return streamHandler.end({
          type: CircuitPB.Type.STATUS,
          code: CircuitPB.Status.HOP_NO_CONN_TO_DST
        });
      }
      if (!destinationConnection) {
        return;
      }
      const stopRequest = {
        type: CircuitPB.Type.STOP,
        dstPeer: request.dstPeer,
        srcPeer: request.srcPeer
      };
      let destinationStream;
      try {
        destinationStream = await stop({
          connection: destinationConnection,
          request: stopRequest
        });
      } catch (err) {
        return log15.error(err);
      }
      log15("hop request from %s is valid", connection.remotePeer.toB58String());
      streamHandler.write({
        type: CircuitPB.Type.STATUS,
        code: CircuitPB.Status.SUCCESS
      });
      const sourceStream = streamHandler.rest();
      return pipe4(sourceStream, destinationStream, sourceStream);
    }
    async function hop({
      connection,
      request
    }) {
      const { stream } = await connection.newStream([multicodec.relay]);
      const streamHandler = new StreamHandler({ stream });
      streamHandler.write(request);
      const response = await streamHandler.read();
      if (!response) {
        throw errCode32(new Error("HOP request had no response"), Errors8.ERR_HOP_REQUEST_FAILED);
      }
      if (response.code === CircuitPB.Status.SUCCESS) {
        log15("hop request was successful");
        return streamHandler.rest();
      }
      log15("hop request failed with code %d, closing stream", response.code);
      streamHandler.close();
      throw errCode32(new Error(`HOP request failed with code ${response.code}`), Errors8.ERR_HOP_REQUEST_FAILED);
    }
    async function canHop({
      connection
    }) {
      const { stream } = await connection.newStream([multicodec.relay]);
      const streamHandler = new StreamHandler({ stream });
      streamHandler.write({
        type: CircuitPB.Type.CAN_HOP
      });
      const response = await streamHandler.read();
      await streamHandler.close();
      if (!response || response.code !== CircuitPB.Status.SUCCESS) {
        return false;
      }
      return true;
    }
    function handleCanHop({
      connection,
      streamHandler,
      circuit
    }) {
      const canHop2 = circuit._options.hop.enabled;
      log15("can hop (%s) request from %s", canHop2, connection.remotePeer.toB58String());
      streamHandler.end({
        type: CircuitPB.Type.STATUS,
        code: canHop2 ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY
      });
    }
    module2.exports = {
      handleHop,
      hop,
      canHop,
      handleCanHop
    };
  }
});

// node_modules/libp2p/src/circuit/transport.js
var require_transport2 = __commonJS({
  "node_modules/libp2p/src/circuit/transport.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:circuit"), {
      error: debug17("libp2p:circuit:err")
    });
    var errCode32 = require_err_code();
    var mafmt = require_src2();
    var { Multiaddr: Multiaddr18 } = require_src();
    var PeerId2 = require_src6();
    var { CircuitRelay: CircuitPB } = require_protocol();
    var { codes } = require_errors4();
    var toConnection = require_stream_to_ma_conn();
    var { relay: multicodec } = require_multicodec();
    var createListener = require_listener2();
    var { handleCanHop, handleHop, hop } = require_hop();
    var { handleStop } = require_stop2();
    var StreamHandler = require_stream_handler();
    var transportSymbol = Symbol.for("@libp2p/js-libp2p-circuit/circuit");
    var Circuit = class {
      constructor({ libp2p, upgrader }) {
        this._dialer = libp2p.dialer;
        this._registrar = libp2p.registrar;
        this._connectionManager = libp2p.connectionManager;
        this._upgrader = upgrader;
        this._options = libp2p._config.relay;
        this._libp2p = libp2p;
        this.peerId = libp2p.peerId;
        this._registrar.handle(multicodec, this._onProtocol.bind(this));
      }
      async _onProtocol({ connection, stream }) {
        const streamHandler = new StreamHandler({ stream });
        const request = await streamHandler.read();
        if (!request) {
          return;
        }
        const circuit = this;
        let virtualConnection;
        switch (request.type) {
          case CircuitPB.Type.CAN_HOP: {
            log15("received CAN_HOP request from %s", connection.remotePeer.toB58String());
            await handleCanHop({ circuit, connection, streamHandler });
            break;
          }
          case CircuitPB.Type.HOP: {
            log15("received HOP request from %s", connection.remotePeer.toB58String());
            virtualConnection = await handleHop({
              connection,
              request,
              streamHandler,
              circuit
            });
            break;
          }
          case CircuitPB.Type.STOP: {
            log15("received STOP request from %s", connection.remotePeer.toB58String());
            virtualConnection = await handleStop({
              connection,
              request,
              streamHandler
            });
            break;
          }
          default: {
            log15("Request of type %s not supported", request.type);
          }
        }
        if (virtualConnection) {
          const remoteAddr = new Multiaddr18(request.dstPeer.addrs[0]);
          const localAddr = new Multiaddr18(request.srcPeer.addrs[0]);
          const maConn = toConnection({
            stream: virtualConnection,
            remoteAddr,
            localAddr
          });
          const type = request.type === CircuitPB.Type.HOP ? "relay" : "inbound";
          log15("new %s connection %s", type, maConn.remoteAddr);
          const conn = await this._upgrader.upgradeInbound(maConn);
          log15("%s connection %s upgraded", type, maConn.remoteAddr);
          this.handler && this.handler(conn);
        }
      }
      async dial(ma, options) {
        const addrs = ma.toString().split("/p2p-circuit");
        const relayAddr = new Multiaddr18(addrs[0]);
        const destinationAddr = new Multiaddr18(addrs[addrs.length - 1]);
        const relayId = relayAddr.getPeerId();
        const destinationId = destinationAddr.getPeerId();
        if (!relayId || !destinationId) {
          const errMsg = "Circuit relay dial failed as addresses did not have peer id";
          log15.error(errMsg);
          throw errCode32(new Error(errMsg), codes.ERR_RELAYED_DIAL);
        }
        const relayPeer = PeerId2.createFromB58String(relayId);
        const destinationPeer = PeerId2.createFromB58String(destinationId);
        let disconnectOnFailure = false;
        let relayConnection = this._connectionManager.get(relayPeer);
        if (!relayConnection) {
          relayConnection = await this._dialer.connectToPeer(relayAddr, options);
          disconnectOnFailure = true;
        }
        try {
          const virtualConnection = await hop({
            connection: relayConnection,
            request: {
              type: CircuitPB.Type.HOP,
              srcPeer: {
                id: this.peerId.toBytes(),
                addrs: this._libp2p.multiaddrs.map((addr) => addr.bytes)
              },
              dstPeer: {
                id: destinationPeer.toBytes(),
                addrs: [new Multiaddr18(destinationAddr).bytes]
              }
            }
          });
          const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toB58String()}`);
          const maConn = toConnection({
            stream: virtualConnection,
            remoteAddr: ma,
            localAddr
          });
          log15("new outbound connection %s", maConn.remoteAddr);
          return this._upgrader.upgradeOutbound(maConn);
        } catch (err) {
          log15.error("Circuit relay dial failed", err);
          disconnectOnFailure && await relayConnection.close();
          throw err;
        }
      }
      createListener(options, handler) {
        if (typeof options === "function") {
          handler = options;
          options = {};
        }
        this.handler = handler;
        return createListener(this._libp2p);
      }
      filter(multiaddrs) {
        multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
        return multiaddrs.filter((ma) => {
          return mafmt.Circuit.matches(ma);
        });
      }
      get [Symbol.toStringTag]() {
        return "Circuit";
      }
      static isTransport(other) {
        return Boolean(other && other[transportSymbol]);
      }
    };
    module2.exports = Circuit;
  }
});

// node_modules/libp2p/src/circuit/utils.js
var require_utils20 = __commonJS({
  "node_modules/libp2p/src/circuit/utils.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { CID: CID2 } = (init_cid(), cid_exports);
    var { sha256: sha2562 } = (init_sha2_browser(), sha2_browser_exports);
    module2.exports.namespaceToCid = async (namespace3) => {
      const bytes3 = new TextEncoder().encode(namespace3);
      const hash2 = await sha2562.digest(bytes3);
      return CID2.createV0(hash2);
    };
  }
});

// node_modules/libp2p/src/circuit/auto-relay.js
var require_auto_relay = __commonJS({
  "node_modules/libp2p/src/circuit/auto-relay.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:auto-relay"), {
      error: debug17("libp2p:auto-relay:err")
    });
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { Multiaddr: Multiaddr18 } = require_src();
    var PeerId2 = require_src6();
    var { relay: multicodec } = require_multicodec();
    var { canHop } = require_hop();
    var { namespaceToCid } = require_utils20();
    var {
      CIRCUIT_PROTO_CODE,
      HOP_METADATA_KEY,
      HOP_METADATA_VALUE,
      RELAY_RENDEZVOUS_NS
    } = require_constants12();
    var AutoRelay = class {
      constructor({ libp2p, maxListeners: maxListeners2 = 1, onError }) {
        this._libp2p = libp2p;
        this._peerId = libp2p.peerId;
        this._peerStore = libp2p.peerStore;
        this._connectionManager = libp2p.connectionManager;
        this._transportManager = libp2p.transportManager;
        this._addressSorter = libp2p.dialer.addressSorter;
        this.maxListeners = maxListeners2;
        this._listenRelays = new Set();
        this._onProtocolChange = this._onProtocolChange.bind(this);
        this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
        this._peerStore.on("change:protocols", this._onProtocolChange);
        this._connectionManager.on("peer:disconnect", this._onPeerDisconnected);
        this._onError = (error, msg) => {
          log15.error(msg || error);
          onError && onError(error, msg);
        };
      }
      async _onProtocolChange({ peerId, protocols }) {
        const id = peerId.toB58String();
        const hasProtocol = protocols.find((protocol) => protocol === multicodec);
        if (!hasProtocol && this._listenRelays.has(id)) {
          this._removeListenRelay(id);
          return;
        } else if (!hasProtocol || this._listenRelays.has(id)) {
          return;
        }
        try {
          const connection = this._connectionManager.get(peerId);
          if (!connection) {
            return;
          }
          if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {
            log15(`relayed connection to ${id} will not be used to hop on`);
            return;
          }
          const supportsHop = await canHop({ connection });
          if (supportsHop) {
            this._peerStore.metadataBook.set(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));
            await this._addListenRelay(connection, id);
          }
        } catch (err) {
          this._onError(err);
        }
      }
      _onPeerDisconnected(connection) {
        const peerId = connection.remotePeer;
        const id = peerId.toB58String();
        if (!this._listenRelays.has(id)) {
          return;
        }
        this._removeListenRelay(id);
      }
      async _addListenRelay(connection, id) {
        if (this._listenRelays.size >= this.maxListeners) {
          return;
        }
        const remoteAddrs = this._peerStore.addressBook.getMultiaddrsForPeer(connection.remotePeer, this._addressSorter);
        if (!remoteAddrs || !remoteAddrs.length) {
          return;
        }
        const listenAddr = `${remoteAddrs[0].toString()}/p2p-circuit`;
        this._listenRelays.add(id);
        try {
          await this._transportManager.listen([new Multiaddr18(listenAddr)]);
        } catch (err) {
          this._onError(err);
          this._listenRelays.delete(id);
        }
      }
      _removeListenRelay(id) {
        if (this._listenRelays.delete(id)) {
          this._listenOnAvailableHopRelays([id]);
        }
      }
      async _listenOnAvailableHopRelays(peersToIgnore = []) {
        if (this._listenRelays.size >= this.maxListeners) {
          return;
        }
        const knownHopsToDial = [];
        for (const [id, metadataMap] of this._peerStore.metadataBook.data.entries()) {
          if (this._listenRelays.has(id) || peersToIgnore.includes(id)) {
            continue;
          }
          const supportsHop = metadataMap.get(HOP_METADATA_KEY);
          if (!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {
            continue;
          }
          const peerId = PeerId2.createFromB58String(id);
          const connection = this._connectionManager.get(peerId);
          if (!connection) {
            knownHopsToDial.push(peerId);
            continue;
          }
          await this._addListenRelay(connection, id);
          if (this._listenRelays.size >= this.maxListeners) {
            return;
          }
        }
        for (const peerId of knownHopsToDial) {
          await this._tryToListenOnRelay(peerId);
          if (this._listenRelays.size >= this.maxListeners) {
            return;
          }
        }
        try {
          const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
          for await (const provider of this._libp2p.contentRouting.findProviders(cid)) {
            if (!provider.multiaddrs.length) {
              continue;
            }
            const peerId = provider.id;
            this._peerStore.addressBook.add(peerId, provider.multiaddrs);
            await this._tryToListenOnRelay(peerId);
            if (this._listenRelays.size >= this.maxListeners) {
              return;
            }
          }
        } catch (err) {
          this._onError(err);
        }
      }
      async _tryToListenOnRelay(peerId) {
        try {
          const connection = await this._libp2p.dial(peerId);
          await this._addListenRelay(connection, peerId.toB58String());
        } catch (err) {
          this._onError(err, `could not connect and listen on known hop relay ${peerId.toB58String()}`);
        }
      }
    };
    module2.exports = AutoRelay;
  }
});

// node_modules/libp2p/src/circuit/index.js
var require_circuit = __commonJS({
  "node_modules/libp2p/src/circuit/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:relay"), {
      error: debug17("libp2p:relay:err")
    });
    var {
      setDelayedInterval,
      clearDelayedInterval
    } = require_src25();
    var AutoRelay = require_auto_relay();
    var { namespaceToCid } = require_utils20();
    var {
      RELAY_RENDEZVOUS_NS
    } = require_constants12();
    var Relay = class {
      constructor(libp2p) {
        this._libp2p = libp2p;
        this._options = {
          ...libp2p._config.relay
        };
        this._autoRelay = this._options.autoRelay.enabled && new AutoRelay({ libp2p, ...this._options.autoRelay });
        this._advertiseService = this._advertiseService.bind(this);
      }
      start() {
        const canHop = this._options.hop.enabled;
        if (canHop && this._options.advertise.enabled) {
          this._timeout = setDelayedInterval(this._advertiseService, this._options.advertise.ttl, this._options.advertise.bootDelay);
        }
      }
      stop() {
        clearDelayedInterval(this._timeout);
      }
      async _advertiseService() {
        try {
          const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
          await this._libp2p.contentRouting.provide(cid);
        } catch (err) {
          if (err.code === "NO_ROUTERS_AVAILABLE") {
            log15.error("a content router, such as a DHT, must be provided in order to advertise the relay service", err);
            this.stop();
          } else {
            log15.error(err);
          }
        }
      }
    };
    module2.exports = Relay;
  }
});

// node_modules/p-fifo/index.js
var require_p_fifo = __commonJS({
  "node_modules/p-fifo/index.js"(exports2, module2) {
    init_node_globals();
    var Fifo = require_fast_fifo();
    var defer = require_p_defer();
    module2.exports = class PFifo {
      constructor() {
        this._buffer = new Fifo();
        this._waitingConsumers = new Fifo();
      }
      push(chunk) {
        const { promise, resolve: resolve6 } = defer();
        this._buffer.push({ chunk, resolve: resolve6 });
        this._consume();
        return promise;
      }
      _consume() {
        while (!this._waitingConsumers.isEmpty() && !this._buffer.isEmpty()) {
          const nextConsumer = this._waitingConsumers.shift();
          const nextChunk = this._buffer.shift();
          nextConsumer.resolve(nextChunk.chunk);
          nextChunk.resolve();
        }
      }
      shift() {
        const { promise, resolve: resolve6 } = defer();
        this._waitingConsumers.push({ resolve: resolve6 });
        this._consume();
        return promise;
      }
      isEmpty() {
        return this._buffer.isEmpty();
      }
    };
  }
});

// node_modules/p-cancelable/index.js
var require_p_cancelable = __commonJS({
  "node_modules/p-cancelable/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var CancelError = class extends Error {
      constructor(reason) {
        super(reason || "Promise was canceled");
        this.name = "CancelError";
      }
      get isCanceled() {
        return true;
      }
    };
    var PCancelable = class {
      static fn(userFn) {
        return (...arguments_) => {
          return new PCancelable((resolve6, reject, onCancel) => {
            arguments_.push(onCancel);
            userFn(...arguments_).then(resolve6, reject);
          });
        };
      }
      constructor(executor) {
        this._cancelHandlers = [];
        this._isPending = true;
        this._isCanceled = false;
        this._rejectOnCancel = true;
        this._promise = new Promise((resolve6, reject) => {
          this._reject = reject;
          const onResolve = (value) => {
            if (!this._isCanceled || !onCancel.shouldReject) {
              this._isPending = false;
              resolve6(value);
            }
          };
          const onReject = (error) => {
            this._isPending = false;
            reject(error);
          };
          const onCancel = (handler) => {
            if (!this._isPending) {
              throw new Error("The `onCancel` handler was attached after the promise settled.");
            }
            this._cancelHandlers.push(handler);
          };
          Object.defineProperties(onCancel, {
            shouldReject: {
              get: () => this._rejectOnCancel,
              set: (boolean) => {
                this._rejectOnCancel = boolean;
              }
            }
          });
          return executor(onResolve, onReject, onCancel);
        });
      }
      then(onFulfilled, onRejected) {
        return this._promise.then(onFulfilled, onRejected);
      }
      catch(onRejected) {
        return this._promise.catch(onRejected);
      }
      finally(onFinally) {
        return this._promise.finally(onFinally);
      }
      cancel(reason) {
        if (!this._isPending || this._isCanceled) {
          return;
        }
        this._isCanceled = true;
        if (this._cancelHandlers.length > 0) {
          try {
            for (const handler of this._cancelHandlers) {
              handler();
            }
          } catch (error) {
            this._reject(error);
            return;
          }
        }
        if (this._rejectOnCancel) {
          this._reject(new CancelError(reason));
        }
      }
      get isCanceled() {
        return this._isCanceled;
      }
    };
    Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
    module2.exports = PCancelable;
    module2.exports.CancelError = CancelError;
  }
});

// node_modules/p-some/index.js
var require_p_some = __commonJS({
  "node_modules/p-some/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var AggregateError2 = require_aggregate_error();
    var PCancelable = require_p_cancelable();
    var FilterError = class extends Error {
    };
    var pSome = (iterable, options) => new PCancelable((resolve6, reject, onCancel) => {
      const {
        count,
        filter: filter8 = () => true
      } = options;
      if (!Number.isFinite(count)) {
        reject(new TypeError(`Expected a finite number, got ${typeof options.count}`));
        return;
      }
      const values = [];
      const errors2 = [];
      let elementCount = 0;
      let isSettled = false;
      const completed = new Set();
      const maybeSettle = () => {
        if (values.length === count) {
          resolve6(values);
          isSettled = true;
        }
        if (elementCount - errors2.length < count) {
          reject(new AggregateError2(errors2));
          isSettled = true;
        }
        return isSettled;
      };
      const cancelPending = () => {
        for (const promise of iterable) {
          if (!completed.has(promise) && typeof promise.cancel === "function") {
            promise.cancel();
          }
        }
      };
      onCancel(cancelPending);
      for (const element of iterable) {
        elementCount++;
        (async () => {
          try {
            const value = await element;
            if (isSettled) {
              return;
            }
            if (!filter8(value)) {
              throw new FilterError("Value does not satisfy filter");
            }
            values.push(value);
          } catch (error) {
            errors2.push(error);
          } finally {
            completed.add(element);
            if (!isSettled && maybeSettle()) {
              cancelPending();
            }
          }
        })();
      }
      if (count > elementCount) {
        reject(new RangeError(`Expected input to contain at least ${options.count} items, but contains ${elementCount} items`));
        cancelPending();
      }
    });
    module2.exports = pSome;
    module2.exports.AggregateError = AggregateError2;
    module2.exports.FilterError = FilterError;
  }
});

// node_modules/p-any/index.js
var require_p_any = __commonJS({
  "node_modules/p-any/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var pSome = require_p_some();
    var PCancelable = require_p_cancelable();
    module2.exports = (iterable, options) => {
      const anyCancelable = pSome(iterable, { ...options, count: 1 });
      return PCancelable.fn(async (onCancel) => {
        onCancel(() => {
          anyCancelable.cancel();
        });
        const [value] = await anyCancelable;
        return value;
      })();
    };
    module2.exports.AggregateError = pSome.AggregateError;
  }
});

// node_modules/libp2p/src/dialer/dial-request.js
var require_dial_request = __commonJS({
  "node_modules/libp2p/src/dialer/dial-request.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errCode32 = require_err_code();
    var AbortController13 = require_browser3().default;
    var { anySignal: anySignal4 } = require_any_signal();
    var FIFO = require_p_fifo();
    var pAny = require_p_any();
    var DialRequest = class {
      constructor({
        addrs,
        dialAction,
        dialer
      }) {
        this.addrs = addrs;
        this.dialer = dialer;
        this.dialAction = dialAction;
      }
      async run(options = {}) {
        const tokens = this.dialer.getTokens(this.addrs.length);
        if (tokens.length < 1) {
          throw errCode32(new Error("No dial tokens available"), "ERR_NO_DIAL_TOKENS");
        }
        const tokenHolder = new FIFO();
        tokens.forEach((token) => tokenHolder.push(token));
        const dialAbortControllers = this.addrs.map(() => new AbortController13());
        let completedDials = 0;
        try {
          return await pAny(this.addrs.map(async (addr, i) => {
            const token = await tokenHolder.shift();
            let conn;
            try {
              const signal = dialAbortControllers[i].signal;
              conn = await this.dialAction(addr, { ...options, signal: options.signal ? anySignal4([signal, options.signal]) : signal });
              dialAbortControllers.splice(i, 1);
            } finally {
              completedDials++;
              if (this.addrs.length - completedDials >= tokens.length) {
                tokenHolder.push(token);
              } else {
                this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
              }
            }
            return conn;
          }));
        } finally {
          dialAbortControllers.map((c) => c.abort());
          tokens.forEach((token) => this.dialer.releaseToken(token));
        }
      }
    };
    module2.exports = DialRequest;
  }
});

// node_modules/libp2p/src/dialer/index.js
var require_dialer = __commonJS({
  "node_modules/libp2p/src/dialer/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:dialer"), {
      error: debug17("libp2p:dialer:err")
    });
    var errCode32 = require_err_code();
    var { Multiaddr: Multiaddr18 } = require_src();
    var TimeoutController2 = require_timeout_abort_controller();
    var { AbortError } = require_abortable_iterator();
    var { anySignal: anySignal4 } = require_any_signal();
    var DialRequest = require_dial_request();
    var { publicAddressesFirst } = require_address_sort();
    var getPeer = require_get_peer();
    var { codes } = require_errors4();
    var {
      DIAL_TIMEOUT,
      MAX_PARALLEL_DIALS,
      MAX_PER_PEER_DIALS,
      MAX_ADDRS_TO_DIAL
    } = require_constants11();
    var Dialer = class {
      constructor({
        transportManager,
        peerStore,
        addressSorter = publicAddressesFirst,
        maxParallelDials = MAX_PARALLEL_DIALS,
        maxAddrsToDial = MAX_ADDRS_TO_DIAL,
        dialTimeout = DIAL_TIMEOUT,
        maxDialsPerPeer = MAX_PER_PEER_DIALS,
        resolvers: resolvers2 = {}
      }) {
        this.transportManager = transportManager;
        this.peerStore = peerStore;
        this.addressSorter = addressSorter;
        this.maxParallelDials = maxParallelDials;
        this.maxAddrsToDial = maxAddrsToDial;
        this.timeout = dialTimeout;
        this.maxDialsPerPeer = maxDialsPerPeer;
        this.tokens = [...new Array(maxParallelDials)].map((_, index) => index);
        this._pendingDials = new Map();
        this._pendingDialTargets = new Map();
        for (const [key, value] of Object.entries(resolvers2)) {
          Multiaddr18.resolvers.set(key, value);
        }
      }
      destroy() {
        for (const dial of this._pendingDials.values()) {
          try {
            dial.controller.abort();
          } catch (err) {
            log15.error(err);
          }
        }
        this._pendingDials.clear();
        for (const pendingTarget of this._pendingDialTargets.values()) {
          pendingTarget.reject(new AbortError("Dialer was destroyed"));
        }
        this._pendingDialTargets.clear();
      }
      async connectToPeer(peer, options = {}) {
        const dialTarget = await this._createCancellableDialTarget(peer);
        if (!dialTarget.addrs.length) {
          throw errCode32(new Error("The dial request has no valid addresses"), codes.ERR_NO_VALID_ADDRESSES);
        }
        const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);
        try {
          const connection = await pendingDial.promise;
          log15("dial succeeded to %s", dialTarget.id);
          return connection;
        } catch (err) {
          if (pendingDial.controller.signal.aborted) {
            err.code = codes.ERR_TIMEOUT;
          }
          log15.error(err);
          throw err;
        } finally {
          pendingDial.destroy();
        }
      }
      async _createCancellableDialTarget(peer) {
        const id = `${parseInt(String(Math.random() * 1e9), 10).toString() + Date.now()}`;
        const cancellablePromise = new Promise((resolve6, reject) => {
          this._pendingDialTargets.set(id, { resolve: resolve6, reject });
        });
        const dialTarget = await Promise.race([
          this._createDialTarget(peer),
          cancellablePromise
        ]);
        this._pendingDialTargets.delete(id);
        return dialTarget;
      }
      async _createDialTarget(peer) {
        const { id, multiaddrs } = getPeer(peer);
        if (multiaddrs) {
          this.peerStore.addressBook.add(id, multiaddrs);
        }
        let knownAddrs = this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter) || [];
        if (Multiaddr18.isMultiaddr(peer)) {
          knownAddrs = knownAddrs.filter((addr) => !peer.equals(addr));
          knownAddrs.unshift(peer);
        }
        const addrs = [];
        for (const a of knownAddrs) {
          const resolvedAddrs = await this._resolve(a);
          resolvedAddrs.forEach((ra) => addrs.push(ra));
        }
        const supportedAddrs = addrs.filter((a) => this.transportManager.transportForMultiaddr(a));
        if (supportedAddrs.length > this.maxAddrsToDial) {
          this.peerStore.delete(id);
          throw errCode32(new Error("dial with more addresses than allowed"), codes.ERR_TOO_MANY_ADDRESSES);
        }
        return {
          id: id.toB58String(),
          addrs: supportedAddrs
        };
      }
      _createPendingDial(dialTarget, options = {}) {
        const dialAction = (addr, options2) => {
          if (options2.signal.aborted)
            throw errCode32(new Error("already aborted"), codes.ERR_ALREADY_ABORTED);
          return this.transportManager.dial(addr, options2);
        };
        const dialRequest = new DialRequest({
          addrs: dialTarget.addrs,
          dialAction,
          dialer: this
        });
        const timeoutController = new TimeoutController2(this.timeout);
        const signals = [timeoutController.signal];
        options.signal && signals.push(options.signal);
        const signal = anySignal4(signals);
        const pendingDial = {
          dialRequest,
          controller: timeoutController,
          promise: dialRequest.run({ ...options, signal }),
          destroy: () => {
            timeoutController.clear();
            this._pendingDials.delete(dialTarget.id);
          }
        };
        this._pendingDials.set(dialTarget.id, pendingDial);
        return pendingDial;
      }
      getTokens(num) {
        const total = Math.min(num, this.maxDialsPerPeer, this.tokens.length);
        const tokens = this.tokens.splice(0, total);
        log15("%d tokens request, returning %d, %d remaining", num, total, this.tokens.length);
        return tokens;
      }
      releaseToken(token) {
        if (this.tokens.indexOf(token) > -1)
          return;
        log15("token %d released", token);
        this.tokens.push(token);
      }
      async _resolve(ma) {
        const resolvableProto = ma.protoNames().includes("dnsaddr");
        if (!resolvableProto) {
          return [ma];
        }
        const resolvedMultiaddrs = await this._resolveRecord(ma);
        const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map((nm) => {
          return this._resolve(nm);
        }));
        const addrs = recursiveMultiaddrs.flat();
        return addrs.reduce((array2, newM) => {
          if (!array2.find((m) => m.equals(newM))) {
            array2.push(newM);
          }
          return array2;
        }, []);
      }
      async _resolveRecord(ma) {
        try {
          ma = new Multiaddr18(ma.toString());
          const multiaddrs = await ma.resolve();
          return multiaddrs;
        } catch (_) {
          log15.error(`multiaddr ${ma} could not be resolved`);
          return [];
        }
      }
    };
    module2.exports = Dialer;
  }
});

// node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS({
  "node_modules/truncate-utf8-bytes/lib/truncate.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function truncate(getLength, string3, byteLength) {
      if (typeof string3 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string3.length;
      var curByteLength = 0;
      var codePoint;
      var segment;
      for (var i = 0; i < charLength; i += 1) {
        codePoint = string3.charCodeAt(i);
        segment = string3[i];
        if (isHighSurrogate(codePoint) && isLowSurrogate(string3.charCodeAt(i + 1))) {
          i += 1;
          segment += string3[i];
        }
        curByteLength += getLength(segment);
        if (curByteLength === byteLength) {
          return string3.slice(0, i + 1);
        } else if (curByteLength > byteLength) {
          return string3.slice(0, i - segment.length + 1);
        }
      }
      return string3;
    };
  }
});

// node_modules/utf8-byte-length/browser.js
var require_browser11 = __commonJS({
  "node_modules/utf8-byte-length/browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function isHighSurrogate(codePoint) {
      return codePoint >= 55296 && codePoint <= 56319;
    }
    function isLowSurrogate(codePoint) {
      return codePoint >= 56320 && codePoint <= 57343;
    }
    module2.exports = function getByteLength(string3) {
      if (typeof string3 !== "string") {
        throw new Error("Input must be string");
      }
      var charLength = string3.length;
      var byteLength = 0;
      var codePoint = null;
      var prevCodePoint = null;
      for (var i = 0; i < charLength; i++) {
        codePoint = string3.charCodeAt(i);
        if (isLowSurrogate(codePoint)) {
          if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
            byteLength += 1;
          } else {
            byteLength += 3;
          }
        } else if (codePoint <= 127) {
          byteLength += 1;
        } else if (codePoint >= 128 && codePoint <= 2047) {
          byteLength += 2;
        } else if (codePoint >= 2048 && codePoint <= 65535) {
          byteLength += 3;
        }
        prevCodePoint = codePoint;
      }
      return byteLength;
    };
  }
});

// node_modules/truncate-utf8-bytes/browser.js
var require_browser12 = __commonJS({
  "node_modules/truncate-utf8-bytes/browser.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var truncate = require_truncate();
    var getLength = require_browser11();
    module2.exports = truncate.bind(null, getLength);
  }
});

// node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS({
  "node_modules/sanitize-filename/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var truncate = require_browser12();
    var illegalRe = /[\/\?<>\\:\*\|"]/g;
    var controlRe = /[\x00-\x1f\x80-\x9f]/g;
    var reservedRe = /^\.+$/;
    var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
    var windowsTrailingRe = /[\. ]+$/;
    function sanitize(input, replacement) {
      if (typeof input !== "string") {
        throw new Error("Input must be string");
      }
      var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
      return truncate(sanitized, 255);
    }
    module2.exports = function(input, options) {
      var replacement = options && options.replacement || "";
      var output = sanitize(input, replacement);
      if (replacement === "") {
        return output;
      }
      return sanitize(output, "");
    };
  }
});

// node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "node_modules/node-forge/lib/pkcs7asn1.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_asn1();
    require_util();
    var asn1 = forge.asn1;
    var p7v = module2.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
    forge.pkcs7 = forge.pkcs7 || {};
    forge.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "node_modules/node-forge/lib/mgf1.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_util();
    forge.mgf = forge.mgf || {};
    var mgf1 = module2.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        generate: function(seed, maskLen) {
          var t = new forge.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i = 0; i < len; i++) {
            var c = new forge.util.ByteBuffer();
            c.putInt32(i);
            md.start();
            md.update(seed + c.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }
      };
      return mgf;
    };
  }
});

// node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "node_modules/node-forge/lib/mgf.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_mgf1();
    module2.exports = forge.mgf = forge.mgf || {};
    forge.mgf.mgf1 = forge.mgf1;
  }
});

// node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "node_modules/node-forge/lib/pss.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_random();
    require_util();
    var pss = module2.exports = forge.pss = forge.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash2 = options.md;
      var mgf = options.mgf;
      var hLen = hash2.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h = hash2.digest().getBytes();
        var ps = new forge.util.ByteBuffer();
        ps.fillWithByte(0, emLen - sLen - hLen - 2);
        ps.putByte(1);
        ps.putBytes(salt);
        var db = ps.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i = 0; i < maskLen; i++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = "";
        for (i = 0; i < maskLen; i++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i = 0; i < checkLen; i++) {
          if (db.charCodeAt(i) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h_ = hash2.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});

// node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "node_modules/node-forge/lib/x509.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util();
    var asn1 = forge.asn1;
    var pki = module2.exports = forge.pki = forge.pki || {};
    var oids = pki.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          publicKeyValidator,
          {
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set = rdn.value[si];
        for (var i = 0; i < set.value.length; ++i) {
          obj = {};
          attr = set.value[i];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi = 0; vi < values.length; ++vi) {
          var obj = {};
          obj.type = type;
          obj.value = values[vi].value;
          obj.valueTagClass = values[vi].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
        attr = obj.attributes[i];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    var _readSignatureParameters = function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors2)) {
        var error = new Error("Cannot read RSASSA-PSS parameter block.");
        error.errors = errors2;
        throw error;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    };
    pki.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificateFromAsn1(obj, computeHash);
    };
    pki.certificateToPem = function(cert, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.publicKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.publicKeyFromAsn1(obj);
    };
    pki.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge.md.sha1.create();
      var type = options.type || "RSAPublicKey";
      var bytes3;
      switch (type) {
        case "RSAPublicKey":
          bytes3 = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes3 = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes3);
      var digest = md.digest();
      if (options.encoding === "hex") {
        var hex = digest.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest;
    };
    pki.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificationRequestFromAsn1(obj, computeHash);
    };
    pki.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.createCertificate = function() {
      var cert = {};
      cert.version = 2;
      cert.serialNumber = "00";
      cert.signatureOid = null;
      cert.signature = null;
      cert.siginfo = {};
      cert.siginfo.algorithmOid = null;
      cert.validity = {};
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.issuer = {};
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = [];
      cert.issuer.hash = null;
      cert.subject = {};
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = [];
      cert.subject.hash = null;
      cert.extensions = [];
      cert.publicKey = null;
      cert.md = null;
      cert.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.subject.attributes = attrs;
        delete cert.subject.uniqueId;
        if (uniqueId) {
          cert.subject.uniqueId = uniqueId;
        }
        cert.subject.hash = null;
      };
      cert.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert.issuer.attributes = attrs;
        delete cert.issuer.uniqueId;
        if (uniqueId) {
          cert.issuer.uniqueId = uniqueId;
        }
        cert.issuer.hash = null;
      };
      cert.setExtensions = function(exts) {
        for (var i = 0; i < exts.length; ++i) {
          _fillMissingExtensionFields(exts[i], { cert });
        }
        cert.extensions = exts;
      };
      cert.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
          ext = cert.extensions[i];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert.sign = function(key, md) {
        cert.md = md || forge.md.sha1.create();
        var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error.algorithm = cert.md.algorithm;
          throw error;
        }
        cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
        cert.tbsCertificate = pki.getTBSCertificate(cert);
        var bytes3 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes3.getBytes());
        cert.signature = key.sign(cert.md);
      };
      cert.verify = function(child) {
        var rval = false;
        if (!cert.issued(child)) {
          var issuer = child.issuer;
          var subject = cert.subject;
          var error = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
          error.expectedIssuer = issuer.attributes;
          error.actualIssuer = subject.attributes;
          throw error;
        }
        var md = child.md;
        if (md === null) {
          if (child.signatureOid in oids) {
            var oid = oids[child.signatureOid];
            switch (oid) {
              case "sha1WithRSAEncryption":
                md = forge.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                md = forge.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                md = forge.md.sha256.create();
                break;
              case "sha384WithRSAEncryption":
                md = forge.md.sha384.create();
                break;
              case "sha512WithRSAEncryption":
                md = forge.md.sha512.create();
                break;
              case "RSASSA-PSS":
                md = forge.md.sha256.create();
                break;
            }
          }
          if (md === null) {
            var error = new Error("Could not compute certificate digest. Unknown signature OID.");
            error.signatureOid = child.signatureOid;
            throw error;
          }
          var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
          var bytes3 = asn1.toDer(tbsCertificate);
          md.update(bytes3.getBytes());
        }
        if (md !== null) {
          var scheme;
          switch (child.signatureOid) {
            case oids.sha1WithRSAEncryption:
              scheme = void 0;
              break;
            case oids["RSASSA-PSS"]:
              var hash2, mgf;
              hash2 = oids[child.signatureParameters.mgf.hash.algorithmOid];
              if (hash2 === void 0 || forge.md[hash2] === void 0) {
                var error = new Error("Unsupported MGF hash function.");
                error.oid = child.signatureParameters.mgf.hash.algorithmOid;
                error.name = hash2;
                throw error;
              }
              mgf = oids[child.signatureParameters.mgf.algorithmOid];
              if (mgf === void 0 || forge.mgf[mgf] === void 0) {
                var error = new Error("Unsupported MGF function.");
                error.oid = child.signatureParameters.mgf.algorithmOid;
                error.name = mgf;
                throw error;
              }
              mgf = forge.mgf[mgf].create(forge.md[hash2].create());
              hash2 = oids[child.signatureParameters.hash.algorithmOid];
              if (hash2 === void 0 || forge.md[hash2] === void 0) {
                throw {
                  message: "Unsupported RSASSA-PSS hash function.",
                  oid: child.signatureParameters.hash.algorithmOid,
                  name: hash2
                };
              }
              scheme = forge.pss.create(forge.md[hash2].create(), mgf, child.signatureParameters.saltLength);
              break;
          }
          rval = cert.publicKey.verify(md.digest().getBytes(), child.signature, scheme);
        }
        return rval;
      };
      cert.isIssuer = function(parent2) {
        var rval = false;
        var i = cert.issuer;
        var s = parent2.subject;
        if (i.hash && s.hash) {
          rval = i.hash === s.hash;
        } else if (i.attributes.length === s.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n = 0; rval && n < i.attributes.length; ++n) {
            iattr = i.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert.issued = function(child) {
        return child.isIssuer(cert);
      };
      cert.generateSubjectKeyIdentifier = function() {
        return pki.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
      };
      cert.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i = 0; i < cert.extensions.length; ++i) {
          var ext = cert.extensions[i];
          if (ext.id === oid) {
            var ski = cert.generateSubjectKeyIdentifier().getBytes();
            return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert;
    };
    pki.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors2)) {
        var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert = pki.createCertificate();
      cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge.util.createBuffer(capture.certSerialNumber);
      cert.serialNumber = serial.toHex();
      cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
      cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
      cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
      cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
      cert.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert.validity.notBefore = validity[0];
      cert.validity.notAfter = validity[1];
      cert.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert.md = null;
        if (cert.signatureOid in oids) {
          var oid = oids[cert.signatureOid];
          switch (oid) {
            case "sha1WithRSAEncryption":
              cert.md = forge.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              cert.md = forge.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              cert.md = forge.md.sha256.create();
              break;
            case "sha384WithRSAEncryption":
              cert.md = forge.md.sha384.create();
              break;
            case "sha512WithRSAEncryption":
              cert.md = forge.md.sha512.create();
              break;
            case "RSASSA-PSS":
              cert.md = forge.md.sha256.create();
              break;
          }
        }
        if (cert.md === null) {
          var error = new Error("Could not compute certificate digest. Unknown signature OID.");
          error.signatureOid = cert.signatureOid;
          throw error;
        }
        var bytes3 = asn1.toDer(cert.tbsCertificate);
        cert.md.update(bytes3.getBytes());
      }
      var imd = forge.md.sha1.create();
      cert.issuer.getField = function(sn) {
        return _getAttribute(cert.issuer, sn);
      };
      cert.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.issuer.attributes.push(attr);
      };
      cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);
      if (capture.certIssuerUniqueId) {
        cert.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert.issuer.hash = imd.digest().toHex();
      var smd = forge.md.sha1.create();
      cert.subject.getField = function(sn) {
        return _getAttribute(cert.subject, sn);
      };
      cert.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert.subject.attributes.push(attr);
      };
      cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);
      if (capture.certSubjectUniqueId) {
        cert.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert.extensions = [];
      }
      cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert;
    };
    pki.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i = 0; i < exts.value.length; ++i) {
        var extseq = exts.value[i];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === "keyUsage") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 128) === 128;
          e.nonRepudiation = (b2 & 64) === 64;
          e.keyEncipherment = (b2 & 32) === 32;
          e.dataEncipherment = (b2 & 16) === 16;
          e.keyAgreement = (b2 & 8) === 8;
          e.keyCertSign = (b2 & 4) === 4;
          e.cRLSign = (b2 & 2) === 2;
          e.encipherOnly = (b2 & 1) === 1;
          e.decipherOnly = (b3 & 128) === 128;
        } else if (e.name === "basicConstraints") {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e.name === "extKeyUsage") {
          var ev = asn1.fromDer(e.value);
          for (var vi = 0; vi < ev.value.length; ++vi) {
            var oid = asn1.derToOid(ev.value[vi].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === "nsCertType") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 128) === 128;
          e.server = (b2 & 64) === 64;
          e.email = (b2 & 32) === 32;
          e.objsign = (b2 & 16) === 16;
          e.reserved = (b2 & 8) === 8;
          e.sslCA = (b2 & 4) === 4;
          e.emailCA = (b2 & 2) === 2;
          e.objCA = (b2 & 1) === 1;
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.altNames = [];
          var gn;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn = ev.value[n];
            var altName = {
              type: gn.type,
              value: gn.value
            };
            e.altNames.push(altName);
            switch (gn.type) {
              case 1:
              case 2:
              case 6:
                break;
              case 7:
                altName.ip = forge.util.bytesToIP(gn.value);
                break;
              case 8:
                altName.oid = asn1.derToOid(gn.value);
                break;
              default:
            }
          }
        } else if (e.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error.errors = errors2;
        throw error;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
      csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = null;
        if (csr.signatureOid in oids) {
          var oid = oids[csr.signatureOid];
          switch (oid) {
            case "sha1WithRSAEncryption":
              csr.md = forge.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              csr.md = forge.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              csr.md = forge.md.sha256.create();
              break;
            case "sha384WithRSAEncryption":
              csr.md = forge.md.sha384.create();
              break;
            case "sha512WithRSAEncryption":
              csr.md = forge.md.sha512.create();
              break;
            case "RSASSA-PSS":
              csr.md = forge.md.sha256.create();
              break;
          }
        }
        if (csr.md === null) {
          var error = new Error("Could not compute certification request digest. Unknown signature OID.");
          error.signatureOid = csr.signatureOid;
          throw error;
        }
        var bytes3 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes3.getBytes());
      }
      var smd = forge.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
      return csr;
    };
    pki.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error.algorithm = csr.md.algorithm;
          throw error;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
        var bytes3 = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes3.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          if (csr.signatureOid in oids) {
            var oid = oids[csr.signatureOid];
            switch (oid) {
              case "sha1WithRSAEncryption":
                md = forge.md.sha1.create();
                break;
              case "md5WithRSAEncryption":
                md = forge.md.md5.create();
                break;
              case "sha256WithRSAEncryption":
                md = forge.md.sha256.create();
                break;
              case "sha384WithRSAEncryption":
                md = forge.md.sha384.create();
                break;
              case "sha512WithRSAEncryption":
                md = forge.md.sha512.create();
                break;
              case "RSASSA-PSS":
                md = forge.md.sha256.create();
                break;
            }
          }
          if (md === null) {
            var error = new Error("Could not compute certification request digest. Unknown signature OID.");
            error.signatureOid = csr.signatureOid;
            throw error;
          }
          var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
          var bytes3 = asn1.toDer(cri);
          md.update(bytes3.getBytes());
        }
        if (md !== null) {
          var scheme;
          switch (csr.signatureOid) {
            case oids.sha1WithRSAEncryption:
              break;
            case oids["RSASSA-PSS"]:
              var hash2, mgf;
              hash2 = oids[csr.signatureParameters.mgf.hash.algorithmOid];
              if (hash2 === void 0 || forge.md[hash2] === void 0) {
                var error = new Error("Unsupported MGF hash function.");
                error.oid = csr.signatureParameters.mgf.hash.algorithmOid;
                error.name = hash2;
                throw error;
              }
              mgf = oids[csr.signatureParameters.mgf.algorithmOid];
              if (mgf === void 0 || forge.mgf[mgf] === void 0) {
                var error = new Error("Unsupported MGF function.");
                error.oid = csr.signatureParameters.mgf.algorithmOid;
                error.name = mgf;
                throw error;
              }
              mgf = forge.mgf[mgf].create(forge.md[hash2].create());
              hash2 = oids[csr.signatureParameters.hash.algorithmOid];
              if (hash2 === void 0 || forge.md[hash2] === void 0) {
                var error = new Error("Unsupported RSASSA-PSS hash function.");
                error.oid = csr.signatureParameters.hash.algorithmOid;
                error.name = hash2;
                throw error;
              }
              scheme = forge.pss.create(forge.md[hash2].create(), mgf, csr.signatureParameters.saltLength);
              break;
          }
          rval = csr.publicKey.verify(md.digest().getBytes(), csr.signature, scheme);
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var attr, set;
      var attrs = obj.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge.util.encodeUtf8(value);
          }
        }
        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set);
      }
      return rval;
    }
    function _fillMissingFields(attrs) {
      var attr;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki.oids) {
            attr.name = pki.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki.oids) {
            attr.type = pki.oids[attr.name];
          } else {
            var error = new Error("Attribute type not specified.");
            error.attribute = attr;
            throw error;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error = new Error("Attribute value not specified.");
          error.attribute = attr;
          throw error;
        }
      }
    }
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === "undefined") {
        if (e.id && e.id in pki.oids) {
          e.name = pki.oids[e.id];
        }
      }
      if (typeof e.id === "undefined") {
        if (e.name && e.name in pki.oids) {
          e.id = pki.oids[e.name];
        } else {
          var error = new Error("Extension ID not specified.");
          error.extension = e;
          throw error;
        }
      }
      if (typeof e.value !== "undefined") {
        return e;
      }
      if (e.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
      } else if (e.name === "basicConstraints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        if (e.cA) {
          e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
        }
        if ("pathLenConstraint" in e) {
          e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));
        }
      } else if (e.name === "extKeyUsage") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));
          } else if (key.indexOf(".") !== -1) {
            seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));
          }
        }
      } else if (e.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
        }
      } else if (e.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
      } else if (e.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
      } else if (e.name === "authorityKeyIdentifier" && options.cert) {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        if (e.keyIdentifier) {
          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
        }
        if (e.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
            ])
          ];
          seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
        }
        if (e.serialNumber) {
          var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
          seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
        }
      } else if (e.name === "cRLDistributionPoints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
              error.extension = e;
              throw error;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
        }
        subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
        seq.push(subSeq);
      }
      if (typeof e.value === "undefined") {
        var error = new Error("Extension value not specified.");
        error.extension = e;
        throw error;
      }
      return e;
    }
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        var attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
      } else {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
      }
    }
    pki.getTBSCertificate = function(cert) {
      var notBefore = _dateToAsn1(cert.validity.notBefore);
      var notAfter = _dateToAsn1(cert.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),
          _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)
        ]),
        _dnToAsn1(cert.issuer),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        _dnToAsn1(cert.subject),
        pki.publicKeyToAsn1(cert.publicKey)
      ]);
      if (cert.issuer.uniqueId) {
        tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.issuer.uniqueId)
        ]));
      }
      if (cert.subject.uniqueId) {
        tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.subject.uniqueId)
        ]));
      }
      if (cert.extensions.length > 0) {
        tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
      }
      return tbs;
    };
    pki.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()),
        _dnToAsn1(csr.subject),
        pki.publicKeyToAsn1(csr.publicKey),
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki.certificateToAsn1 = function(cert) {
      var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        tbsCertificate,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()),
          _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.signature)
      ]);
    };
    pki.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i = 0; i < exts.length; ++i) {
        seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
      }
      return rval;
    };
    pki.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes()));
      if (ext.critical) {
        extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
      }
      var value = ext.value;
      if (typeof ext.value !== "string") {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));
      return extseq;
    };
    pki.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        cri,
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()),
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + csr.signature)
      ]);
    };
    pki.createCaStore = function(certs) {
      var caStore = {
        certs: {}
      };
      caStore.getIssuer = function(cert2) {
        var rval = getBySubject(cert2.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          if (cert2.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert2.subject.hash];
            if (!forge.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert2);
            caStore.certs[cert2.subject.hash] = tmp;
          } else {
            caStore.certs[cert2.subject.hash] = cert2;
          }
        }
      };
      caStore.hasCertificate = function(cert2) {
        if (typeof cert2 === "string") {
          cert2 = forge.pki.certificateFromPem(cert2);
        }
        var match = getBySubject(cert2.subject);
        if (!match) {
          return false;
        }
        if (!forge.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash2 in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash2)) {
            var value = caStore.certs[hash2];
            if (!forge.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i2 = 0; i2 < value.length; ++i2) {
                certList.push(value[i2]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert2) {
        var result;
        if (typeof cert2 === "string") {
          cert2 = forge.pki.certificateFromPem(cert2);
        }
        ensureSubjectHasHash(cert2.subject);
        if (!caStore.hasCertificate(cert2)) {
          return null;
        }
        var match = getBySubject(cert2.subject);
        if (!forge.util.isArray(match)) {
          result = caStore.certs[cert2.subject.hash];
          delete caStore.certs[cert2.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            result = match[i2];
            match.splice(i2, 1);
          }
        }
        if (match.length === 0) {
          delete caStore.certs[cert2.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge.md.sha1.create();
          subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      if (certs) {
        for (var i = 0; i < certs.length; ++i) {
          var cert = certs[i];
          caStore.addCertificate(cert);
        }
      }
      return caStore;
    };
    pki.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = new Date();
      }
      var first3 = true;
      var error = null;
      var depth = 0;
      do {
        var cert = chain.shift();
        var parent2 = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
            error = {
              message: "Certificate is not valid yet or has expired.",
              error: pki.certificateError.certificate_expired,
              notBefore: cert.validity.notBefore,
              notAfter: cert.validity.notAfter,
              now: validityCheckDate
            };
          }
        }
        if (error === null) {
          parent2 = chain[0] || caStore.getIssuer(cert);
          if (parent2 === null) {
            if (cert.isIssuer(cert)) {
              selfSigned = true;
              parent2 = cert;
            }
          }
          if (parent2) {
            var parents = parent2;
            if (!forge.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent2 = parents.shift();
              try {
                verified = parent2.verify(cert);
              } catch (ex) {
              }
            }
            if (!verified) {
              error = {
                message: "Certificate signature is invalid.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && (!parent2 || selfSigned) && !caStore.hasCertificate(cert)) {
            error = {
              message: "Certificate is not trusted.",
              error: pki.certificateError.unknown_ca
            };
          }
        }
        if (error === null && parent2 && !cert.isIssuer(parent2)) {
          error = {
            message: "Certificate issuer is invalid.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (error === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i = 0; error === null && i < cert.extensions.length; ++i) {
            var ext = cert.extensions[i];
            if (ext.critical && !(ext.name in se)) {
              error = {
                message: "Certificate has an unsupported critical extension.",
                error: pki.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error === null && (!first3 || chain.length === 0 && (!parent2 || selfSigned))) {
          var bcExt = cert.getExtension("basicConstraints");
          var keyUsageExt = cert.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error === null && bcExt !== null && !bcExt.cA) {
            error = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error === null ? true : error.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error = null;
        } else {
          if (vfd === true) {
            error = {
              message: "The application rejected the certificate.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge.util.isArray(ret)) {
              if (ret.message) {
                error.message = ret.message;
              }
              if (ret.error) {
                error.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error.error = ret;
            }
          }
          throw error;
        }
        first3 = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});

// node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "node_modules/node-forge/lib/pkcs7.js"(exports2, module2) {
    init_node_globals();
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util();
    require_x509();
    var asn1 = forge.asn1;
    var p7 = module2.exports = forge.pkcs7 = forge.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error.headerType = msg.type;
        throw error;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error.errors = errors2;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        signers: [],
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i = 0; i < certs.length; ++i) {
              msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
            }
          }
        },
        toAsn1: function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i = 0; i < msg.certificates.length; ++i) {
            certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers),
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
          }
          signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos));
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
            signedData
          ]);
        },
        addSigner: function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert = signer.certificate;
            if (typeof cert === "string") {
              cert = forge.pki.certificateFromPem(cert);
            }
            issuer = cert.issuer.attributes;
            serialNumber = cert.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error("Could not add PKCS#7 signer; no private key specified.");
          }
          if (typeof key === "string") {
            key = forge.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge.pki.oids.sha1:
            case forge.pki.oids.sha256:
            case forge.pki.oids.sha384:
            case forge.pki.oids.sha512:
            case forge.pki.oids.md5:
              break;
            default:
              throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm);
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i = 0; i < authenticatedAttributes.length; ++i) {
              var attr = authenticatedAttributes[i];
              if (!contentType && attr.type === forge.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        },
        sign: function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())
            ]);
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)
                ]));
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        },
        verify: function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        },
        addCertificate: function(cert) {
          if (typeof cert === "string") {
            cert = forge.pki.certificateFromPem(cert);
          }
          msg.certificates.push(cert);
        },
        addCertificateRevokationList: function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge.md[forge.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge.md[forge.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ]));
        }
        return mds;
      }
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes3 = asn1.toDer(content);
        bytes3.getByte();
        asn1.getBerValueLength(bytes3);
        bytes3 = bytes3.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes3);
        }
        var signingTime = new Date();
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge.pki.oids.data) {
              throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
            var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes3 = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes3);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        },
        decrypt: function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge.pki.oids["aes256-CBC"]
        },
        fromAsn1: function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        },
        toAsn1: function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))
              ])
            ])
          ]);
        },
        findRecipient: function(cert) {
          var sAttr = cert.issuer.attributes;
          for (var i = 0; i < msg.recipients.length; ++i) {
            var r = msg.recipients[i];
            var rAttr = r.issuer;
            if (r.serialNumber !== cert.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r;
            }
          }
          return null;
        },
        decrypt: function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
              case forge.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        },
        addRecipient: function(cert) {
          msg.recipients.push({
            version: 0,
            issuer: cert.issuer.attributes,
            serialNumber: cert.serialNumber,
            encryptedContent: {
              algorithm: forge.pki.oids.rsaEncryption,
              key: cert.publicKey
            }
          });
        },
        encrypt: function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge.util.createBuffer(forge.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i = 0; i < msg.recipients.length; ++i) {
            var recipient = msg.recipients[i];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error.errors = errors2;
        throw error;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter.value,
          content: capture.encKey
        }
      };
    }
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)
      ]);
    }
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i = 0; i < infos.length; ++i) {
        ret.push(_recipientFromAsn1(infos[i]));
      }
      return ret;
    }
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i = 0; i < recipients.length; ++i) {
        ret.push(_recipientToAsn1(recipients[i]));
      }
      return ret;
    }
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
        ]),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
          var attr = obj.unauthenticatedAttributes[i];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i = 0; i < signers.length; ++i) {
        ret.push(_signerToAsn1(signers[i]));
      }
      return ret;
    }
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge.pki.oids.contentType) {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());
      } else if (attr.type === forge.pki.oids.messageDigest) {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());
      } else if (attr.type === forge.pki.oids.signingTime) {
        var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
        } else {
          value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          value
        ])
      ]);
    }
    function _encryptedContentToAsn1(ec) {
      return [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())
        ]),
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())
        ])
      ];
    }
    function _fromAsn1(msg, obj, validator3) {
      var capture = {};
      var errors2 = [];
      if (!asn1.validate(obj, validator3, capture, errors2)) {
        var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error.errors = error;
        throw error;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge.util.isArray(capture.encryptedContent)) {
          for (var i = 0; i < capture.encryptedContent.length; ++i) {
            if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge.util.createBuffer(capture.encParameter.value),
          content: forge.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge.util.isArray(capture.content)) {
          for (var i = 0; i < capture.content.length; ++i) {
            if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge.pki.oids["aes128-CBC"]:
          case forge.pki.oids["aes192-CBC"]:
          case forge.pki.oids["aes256-CBC"]:
            ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge.pki.oids["desCBC"]:
          case forge.pki.oids["des-EDE3-CBC"]:
            ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
  }
});

// node_modules/libp2p/src/keychain/util.js
var require_util7 = __commonJS({
  "node_modules/libp2p/src/keychain/util.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    require_x509();
    var forge = require_forge();
    var pki = forge.pki;
    var certificateForKey = (key, privateKey) => {
      const publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e);
      const cert = pki.createCertificate();
      cert.publicKey = publicKey;
      cert.serialNumber = "01";
      cert.validity.notBefore = new Date();
      cert.validity.notAfter = new Date();
      cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);
      const attrs = [{
        name: "organizationName",
        value: "ipfs"
      }, {
        shortName: "OU",
        value: "keystore"
      }, {
        name: "commonName",
        value: key.id
      }];
      cert.setSubject(attrs);
      cert.setIssuer(attrs);
      cert.setExtensions([{
        name: "basicConstraints",
        cA: true
      }, {
        name: "keyUsage",
        keyCertSign: true,
        digitalSignature: true,
        nonRepudiation: true,
        keyEncipherment: true,
        dataEncipherment: true
      }, {
        name: "extKeyUsage",
        serverAuth: true,
        clientAuth: true,
        codeSigning: true,
        emailProtection: true,
        timeStamping: true
      }, {
        name: "nsCertType",
        client: true,
        server: true,
        email: true,
        objsign: true,
        sslCA: true,
        emailCA: true,
        objCA: true
      }]);
      cert.sign(privateKey);
      return cert;
    };
    async function findAsync(array2, asyncCompare) {
      const promises = array2.map(asyncCompare);
      const results = await Promise.all(promises);
      const index = results.findIndex((result) => result);
      return array2[index];
    }
    module2.exports = {
      certificateForKey,
      findAsync
    };
  }
});

// node_modules/libp2p/src/keychain/cms.js
var require_cms = __commonJS({
  "node_modules/libp2p/src/keychain/cms.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    require_pkcs7();
    require_pbe();
    var forge = require_forge();
    var { certificateForKey, findAsync } = require_util7();
    var errcode7 = require_err_code();
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var privates = new WeakMap();
    var CMS = class {
      constructor(keychain, dek) {
        if (!keychain) {
          throw errcode7(new Error("keychain is required"), "ERR_KEYCHAIN_REQUIRED");
        }
        this.keychain = keychain;
        privates.set(this, { dek });
      }
      async encrypt(name5, plain) {
        if (!(plain instanceof Uint8Array)) {
          throw errcode7(new Error("Plain data must be a Uint8Array"), "ERR_INVALID_PARAMS");
        }
        const key = await this.keychain.findKeyByName(name5);
        const pem = await this.keychain._getPrivateKey(name5);
        const dek = privates.get(this).dek;
        const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);
        const certificate = await certificateForKey(key, privateKey);
        const p7 = forge.pkcs7.createEnvelopedData();
        p7.addRecipient(certificate);
        p7.content = forge.util.createBuffer(plain);
        p7.encrypt();
        const der = forge.asn1.toDer(p7.toAsn1()).getBytes();
        return uint8ArrayFromString(der, "ascii");
      }
      async decrypt(cmsData) {
        if (!(cmsData instanceof Uint8Array)) {
          throw errcode7(new Error("CMS data is required"), "ERR_INVALID_PARAMS");
        }
        let cms;
        try {
          const buf2 = forge.util.createBuffer(uint8ArrayToString(cmsData, "ascii"));
          const obj = forge.asn1.fromDer(buf2);
          cms = forge.pkcs7.messageFromAsn1(obj);
        } catch (err) {
          throw errcode7(new Error("Invalid CMS: " + err.message), "ERR_INVALID_CMS");
        }
        const recipients = cms.recipients.filter((r2) => r2.issuer.find((a) => a.shortName === "O" && a.value === "ipfs")).filter((r2) => r2.issuer.find((a) => a.shortName === "CN")).map((r2) => {
          return {
            recipient: r2,
            keyId: r2.issuer.find((a) => a.shortName === "CN").value
          };
        });
        const r = await findAsync(recipients, async (recipient) => {
          try {
            const key2 = await this.keychain.findKeyById(recipient.keyId);
            if (key2)
              return true;
          } catch (err) {
            return false;
          }
          return false;
        });
        if (!r) {
          const missingKeys = recipients.map((r2) => r2.keyId);
          throw errcode7(new Error("Decryption needs one of the key(s): " + missingKeys.join(", ")), "ERR_MISSING_KEYS", {
            missingKeys
          });
        }
        const key = await this.keychain.findKeyById(r.keyId);
        if (!key) {
          throw errcode7(new Error("No key available to decrypto"), "ERR_NO_KEY");
        }
        const pem = await this.keychain._getPrivateKey(key.name);
        const dek = privates.get(this).dek;
        const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);
        cms.decrypt(r.recipient, privateKey);
        return uint8ArrayFromString(cms.content.getBytes(), "ascii");
      }
    };
    module2.exports = CMS;
  }
});

// node_modules/libp2p/src/keychain/index.js
var require_keychain = __commonJS({
  "node_modules/libp2p/src/keychain/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:keychain"), {
      error: debug17("libp2p:keychain:err")
    });
    var sanitize = require_sanitize_filename();
    var mergeOptions2 = require_merge_options();
    var crypto3 = require_src7();
    var { Key: Key2 } = (init_key(), key_exports);
    var CMS = require_cms();
    var errcode7 = require_err_code();
    var { toString: uint8ArrayToString } = (init_to_string(), to_string_exports);
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    require_sha512();
    var keyPrefix = "/pkcs8/";
    var infoPrefix = "/info/";
    var privates = new WeakMap();
    var NIST = {
      minKeyLength: 112 / 8,
      minSaltLength: 128 / 8,
      minIterationCount: 1e3
    };
    var defaultOptions4 = {
      dek: {
        keyLength: 512 / 8,
        iterationCount: 1e4,
        salt: "you should override this value with a crypto secure random number",
        hash: "sha2-512"
      }
    };
    function validateKeyName(name5) {
      if (!name5)
        return false;
      if (typeof name5 !== "string")
        return false;
      return name5 === sanitize(name5.trim());
    }
    async function throwDelayed(err) {
      const min = 200;
      const max = 1e3;
      const delay = Math.random() * (max - min) + min;
      await new Promise((resolve6) => setTimeout(resolve6, delay));
      throw err;
    }
    function DsName(name5) {
      return new Key2(keyPrefix + name5);
    }
    function DsInfoName(name5) {
      return new Key2(infoPrefix + name5);
    }
    var Keychain = class {
      constructor(store, options) {
        if (!store) {
          throw new Error("store is required");
        }
        this.store = store;
        this.opts = mergeOptions2(defaultOptions4, options);
        if (this.opts.pass && this.opts.pass.length < 20) {
          throw new Error("pass must be least 20 characters");
        }
        if (this.opts.dek.keyLength < NIST.minKeyLength) {
          throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
        }
        if (this.opts.dek.salt.length < NIST.minSaltLength) {
          throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
        }
        if (this.opts.dek.iterationCount < NIST.minIterationCount) {
          throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
        }
        const dek = this.opts.pass ? crypto3.pbkdf2(this.opts.pass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : "";
        privates.set(this, { dek });
      }
      get cms() {
        return new CMS(this, privates.get(this).dek);
      }
      static generateOptions() {
        const options = Object.assign({}, defaultOptions4);
        const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
        options.dek.salt = uint8ArrayToString(crypto3.randomBytes(saltLength), "base64");
        return options;
      }
      static get options() {
        return defaultOptions4;
      }
      async createKey(name5, type, size = 2048) {
        const self2 = this;
        if (!validateKeyName(name5) || name5 === "self") {
          return throwDelayed(errcode7(new Error(`Invalid key name '${name5}'`), "ERR_INVALID_KEY_NAME"));
        }
        if (typeof type !== "string") {
          return throwDelayed(errcode7(new Error(`Invalid key type '${type}'`), "ERR_INVALID_KEY_TYPE"));
        }
        const dsname = DsName(name5);
        const exists = await self2.store.has(dsname);
        if (exists)
          return throwDelayed(errcode7(new Error(`Key '${name5}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
        switch (type.toLowerCase()) {
          case "rsa":
            if (!Number.isSafeInteger(size) || size < 2048) {
              return throwDelayed(errcode7(new Error(`Invalid RSA key size ${size}`), "ERR_INVALID_KEY_SIZE"));
            }
            break;
          default:
            break;
        }
        let keyInfo;
        try {
          const keypair = await crypto3.keys.generateKeyPair(type, size);
          const kid = await keypair.id();
          const dek = privates.get(this).dek;
          const pem = await keypair.export(dek);
          keyInfo = {
            name: name5,
            id: kid
          };
          const batch3 = self2.store.batch();
          batch3.put(dsname, uint8ArrayFromString(pem));
          batch3.put(DsInfoName(name5), uint8ArrayFromString(JSON.stringify(keyInfo)));
          await batch3.commit();
        } catch (err) {
          return throwDelayed(err);
        }
        return keyInfo;
      }
      async listKeys() {
        const self2 = this;
        const query = {
          prefix: infoPrefix
        };
        const info = [];
        for await (const value of self2.store.query(query)) {
          info.push(JSON.parse(uint8ArrayToString(value.value)));
        }
        return info;
      }
      async findKeyById(id) {
        try {
          const keys = await this.listKeys();
          return keys.find((k) => k.id === id);
        } catch (err) {
          return throwDelayed(err);
        }
      }
      async findKeyByName(name5) {
        if (!validateKeyName(name5)) {
          return throwDelayed(errcode7(new Error(`Invalid key name '${name5}'`), "ERR_INVALID_KEY_NAME"));
        }
        const dsname = DsInfoName(name5);
        try {
          const res = await this.store.get(dsname);
          return JSON.parse(uint8ArrayToString(res));
        } catch (err) {
          return throwDelayed(errcode7(new Error(`Key '${name5}' does not exist. ${err.message}`), "ERR_KEY_NOT_FOUND"));
        }
      }
      async removeKey(name5) {
        const self2 = this;
        if (!validateKeyName(name5) || name5 === "self") {
          return throwDelayed(errcode7(new Error(`Invalid key name '${name5}'`), "ERR_INVALID_KEY_NAME"));
        }
        const dsname = DsName(name5);
        const keyInfo = await self2.findKeyByName(name5);
        const batch3 = self2.store.batch();
        batch3.delete(dsname);
        batch3.delete(DsInfoName(name5));
        await batch3.commit();
        return keyInfo;
      }
      async renameKey(oldName, newName) {
        const self2 = this;
        if (!validateKeyName(oldName) || oldName === "self") {
          return throwDelayed(errcode7(new Error(`Invalid old key name '${oldName}'`), "ERR_OLD_KEY_NAME_INVALID"));
        }
        if (!validateKeyName(newName) || newName === "self") {
          return throwDelayed(errcode7(new Error(`Invalid new key name '${newName}'`), "ERR_NEW_KEY_NAME_INVALID"));
        }
        const oldDsname = DsName(oldName);
        const newDsname = DsName(newName);
        const oldInfoName = DsInfoName(oldName);
        const newInfoName = DsInfoName(newName);
        const exists = await self2.store.has(newDsname);
        if (exists)
          return throwDelayed(errcode7(new Error(`Key '${newName}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
        try {
          const pem = await self2.store.get(oldDsname);
          const res = await self2.store.get(oldInfoName);
          const keyInfo = JSON.parse(uint8ArrayToString(res));
          keyInfo.name = newName;
          const batch3 = self2.store.batch();
          batch3.put(newDsname, pem);
          batch3.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)));
          batch3.delete(oldDsname);
          batch3.delete(oldInfoName);
          await batch3.commit();
          return keyInfo;
        } catch (err) {
          return throwDelayed(err);
        }
      }
      async exportKey(name5, password) {
        if (!validateKeyName(name5)) {
          return throwDelayed(errcode7(new Error(`Invalid key name '${name5}'`), "ERR_INVALID_KEY_NAME"));
        }
        if (!password) {
          return throwDelayed(errcode7(new Error("Password is required"), "ERR_PASSWORD_REQUIRED"));
        }
        const dsname = DsName(name5);
        try {
          const res = await this.store.get(dsname);
          const pem = uint8ArrayToString(res);
          const dek = privates.get(this).dek;
          const privateKey = await crypto3.keys.import(pem, dek);
          return privateKey.export(password);
        } catch (err) {
          return throwDelayed(err);
        }
      }
      async importKey(name5, pem, password) {
        const self2 = this;
        if (!validateKeyName(name5) || name5 === "self") {
          return throwDelayed(errcode7(new Error(`Invalid key name '${name5}'`), "ERR_INVALID_KEY_NAME"));
        }
        if (!pem) {
          return throwDelayed(errcode7(new Error("PEM encoded key is required"), "ERR_PEM_REQUIRED"));
        }
        const dsname = DsName(name5);
        const exists = await self2.store.has(dsname);
        if (exists)
          return throwDelayed(errcode7(new Error(`Key '${name5}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
        let privateKey;
        try {
          privateKey = await crypto3.keys.import(pem, password);
        } catch (err) {
          return throwDelayed(errcode7(new Error("Cannot read the key, most likely the password is wrong"), "ERR_CANNOT_READ_KEY"));
        }
        let kid;
        try {
          kid = await privateKey.id();
          const dek = privates.get(this).dek;
          pem = await privateKey.export(dek);
        } catch (err) {
          return throwDelayed(err);
        }
        const keyInfo = {
          name: name5,
          id: kid
        };
        const batch3 = self2.store.batch();
        batch3.put(dsname, uint8ArrayFromString(pem));
        batch3.put(DsInfoName(name5), uint8ArrayFromString(JSON.stringify(keyInfo)));
        await batch3.commit();
        return keyInfo;
      }
      async importPeer(name5, peer) {
        const self2 = this;
        if (!validateKeyName(name5)) {
          return throwDelayed(errcode7(new Error(`Invalid key name '${name5}'`), "ERR_INVALID_KEY_NAME"));
        }
        if (!peer || !peer.privKey) {
          return throwDelayed(errcode7(new Error("Peer.privKey is required"), "ERR_MISSING_PRIVATE_KEY"));
        }
        const privateKey = peer.privKey;
        const dsname = DsName(name5);
        const exists = await self2.store.has(dsname);
        if (exists)
          return throwDelayed(errcode7(new Error(`Key '${name5}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
        try {
          const kid = await privateKey.id();
          const dek = privates.get(this).dek;
          const pem = await privateKey.export(dek);
          const keyInfo = {
            name: name5,
            id: kid
          };
          const batch3 = self2.store.batch();
          batch3.put(dsname, uint8ArrayFromString(pem));
          batch3.put(DsInfoName(name5), uint8ArrayFromString(JSON.stringify(keyInfo)));
          await batch3.commit();
          return keyInfo;
        } catch (err) {
          return throwDelayed(err);
        }
      }
      async _getPrivateKey(name5) {
        if (!validateKeyName(name5)) {
          return throwDelayed(errcode7(new Error(`Invalid key name '${name5}'`), "ERR_INVALID_KEY_NAME"));
        }
        try {
          const dsname = DsName(name5);
          const res = await this.store.get(dsname);
          return uint8ArrayToString(res);
        } catch (err) {
          return throwDelayed(errcode7(new Error(`Key '${name5}' does not exist. ${err.message}`), "ERR_KEY_NOT_FOUND"));
        }
      }
      async rotateKeychainPass(oldPass, newPass) {
        if (typeof oldPass !== "string") {
          return throwDelayed(errcode7(new Error(`Invalid old pass type '${typeof oldPass}'`), "ERR_INVALID_OLD_PASS_TYPE"));
        }
        if (typeof newPass !== "string") {
          return throwDelayed(errcode7(new Error(`Invalid new pass type '${typeof newPass}'`), "ERR_INVALID_NEW_PASS_TYPE"));
        }
        if (newPass.length < 20) {
          return throwDelayed(errcode7(new Error(`Invalid pass length ${newPass.length}`), "ERR_INVALID_PASS_LENGTH"));
        }
        log15("recreating keychain");
        const oldDek = privates.get(this).dek;
        this.opts.pass = newPass;
        const newDek = newPass ? crypto3.pbkdf2(newPass, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : "";
        privates.set(this, { dek: newDek });
        const keys = await this.listKeys();
        for (const key of keys) {
          const res = await this.store.get(DsName(key.name));
          const pem = uint8ArrayToString(res);
          const privateKey = await crypto3.keys.import(pem, oldDek);
          const password = newDek.toString();
          const keyAsPEM = await privateKey.export(password);
          const batch3 = this.store.batch();
          const keyInfo = {
            name: key.name,
            id: key.id
          };
          batch3.put(DsName(key.name), uint8ArrayFromString(keyAsPEM));
          batch3.put(DsInfoName(key.name), uint8ArrayFromString(JSON.stringify(keyInfo)));
          await batch3.commit();
        }
        log15("keychain reconstructed");
      }
    };
    module2.exports = Keychain;
  }
});

// node_modules/libp2p/src/metrics/old-peers.js
var require_old_peers = __commonJS({
  "node_modules/libp2p/src/metrics/old-peers.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var LRU = require_hashlru();
    module2.exports = (maxSize) => {
      const patched = LRU(maxSize);
      patched.delete = patched.remove;
      return patched;
    };
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports2, module2) {
    init_node_globals();
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2))
            return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++)
                  ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v)))
                return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0)
                e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0)
                return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1)
              str = str.replace(".", "");
            else
              e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++)
            ;
          for (len = str.length; str.charCodeAt(--len) === 48; )
            ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0)
                i += LOG_BASE;
              if (i < len) {
                if (i)
                  x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0")
                ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object")
                  FORMAT = v;
                else
                  throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true)
            return false;
          if (!BigNumber2.DEBUG)
            return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out:
            if ({}.toString.call(c) == "[object Array]") {
              if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
                if (c[0] === 0) {
                  if (e === 0 && c.length === 1)
                    return true;
                  break out;
                }
                i = (e + 1) % LOG_BASE;
                if (i < 1)
                  i += LOG_BASE;
                if (String(c[0]).length == i) {
                  for (i = 0; i < c.length; i++) {
                    n = c[i];
                    if (n < 0 || n >= BASE || n !== mathfloor(n))
                      break out;
                  }
                  if (n !== 0)
                    return true;
                }
              }
            } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
              return true;
            }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, P.lt);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, P.gt);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null)
              dp = DECIMAL_PLACES;
            else
              intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15)
                  c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--)
              ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
                ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
                ;
              if (i < LOG_BASE)
                e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; )
            sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
                ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null)
                    arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign2, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop())
              ;
            if (!xc[0])
              return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign2;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; )
                ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
                ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = function() {
          function multiply(x, k, base3) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base3 | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base3;
            }
            if (carry)
              x = [carry].concat(x);
            return x;
          }
          function compare4(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base3) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base3 + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1))
              ;
          }
          return function(x, y, dp, rm, base3) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base3) {
              base3 = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++)
              ;
            if (yc[i] > (xc[i] || 0))
              e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base3 / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base3);
                xc = multiply(xc, n, base3);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0)
                ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base3 / 2)
                yc0++;
              do {
                n = 0;
                cmp = compare4(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL)
                    rem0 = rem0 * base3 + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base3)
                      n = base3 - 1;
                    prod = multiply(yc, n, base3);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare4(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base3);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL)
                    prod = [0].concat(prod);
                  subtract(rem, prod, remL, base3);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare4(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base3);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0])
                qc.splice(0, 1);
            }
            if (base3 == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
                ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          if (!n.c)
            return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++)
                ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0)
                  for (str += "."; i--; str += "0")
                    ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len)
                    str += ".";
                  for (; i--; str += "0")
                    ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, method) {
          var n, i = 1, m = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            n = new BigNumber2(args[i]);
            if (!n.s) {
              m = n;
              break;
            } else if (method.call(m, n)) {
              m = n;
            }
          }
          return m;
        }
        function normalise2(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop())
            ;
          for (j = c[0]; j >= 10; j /= 10, i++)
            ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base3, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base3 = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base3 ? p1 : m;
                });
                if (b) {
                  base3 = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s)
                  return new BigNumber2(s, base3);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
                ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = n / pows10[d - j - 1] % 10 | 0;
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0))
                      ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++)
                    ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
                }
              }
              r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                      ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++)
                      ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE)
                        xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE)
                      break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop())
                ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null)
            return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0)
            x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare3(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c))
            return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v])
            for (; v % 10 == 0; v /= 10, n--)
              ;
          if (n < 0)
            n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null)
            m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s)
              return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp)
              x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1)
              k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg)
              n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c)
                break;
              if (k) {
                if (y.c.length > k)
                  y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0)
                  break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k)
                x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp)
            return y;
          if (nIsNeg)
            y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare3(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare3(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare3(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare3(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare3(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0))
              ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy)
            t = xc, xc = yc, yc = t, y.s = -y.s;
          b = (j = yc.length) - (i = xc.length);
          if (b > 0)
            for (; b--; xc[i++] = 0)
              ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b)
                ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye)
            ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise2(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1)
            y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base3, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL)
            zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
          for (i = xcL + ycL, zc = []; i--; zc.push(0))
            ;
          base3 = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base3 | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base3;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise2(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b)
            return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc)
              return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0])
              return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0))
              ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0)
            t = yc, yc = xc, xc = t, b = a;
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise2(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null)
              rm = ROUNDING_MODE;
            else
              intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c))
            return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--)
              ;
            for (v = c[0]; v >= 10; v /= 10, n++)
              ;
          }
          if (sd && x.e + 1 > n)
            n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0)
              n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3)
              s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e)
                  --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2)
              i = g1, g1 = g2, g2 = i, len -= i;
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1)
                intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0)
                intPart += groupSeparator + intDigits.slice(i);
              if (isNeg)
                intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc)
            return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1)
              break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null)
            intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0)
                str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0])
              str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null)
          BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s)
            ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; )
          ;
        return r.slice(0, j + 1 || 1);
      }
      function compare3(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j)
          return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b)
          return a ? b ? 0 : -j : i;
        if (i != j)
          return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc)
          return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b)
          return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++)
          if (xc[i] != yc[i])
            return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name5) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name5 || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z)
            ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z)
              ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module2 != "undefined" && module2.exports) {
        module2.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports2);
  }
});

// node_modules/@vascosantos/moving-average/index.js
var require_moving_average = __commonJS({
  "node_modules/@vascosantos/moving-average/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var exp = Math.exp;
    exports2 = module2.exports = function MovingAverage2(timespan) {
      if (typeof timespan !== "number") {
        throw new Error("must provide a timespan to the moving average constructor");
      }
      if (timespan <= 0) {
        throw new Error("must provide a timespan > 0 to the moving average constructor");
      }
      let ma;
      let v = 0;
      let d = 0;
      let f = 0;
      let previousTime;
      let ret = {};
      function alpha(t, pt) {
        return 1 - exp(-(t - pt) / timespan);
      }
      ret.push = function push(time, value) {
        if (previousTime) {
          const a = alpha(time, previousTime);
          const diff = value - ma;
          const incr = a * diff;
          ma = a * value + (1 - a) * ma;
          v = (1 - a) * (v + diff * incr);
          d = Math.sqrt(v);
          f = ma + a * diff;
        } else {
          ma = value;
        }
        previousTime = time;
      };
      ret.movingAverage = function movingAverage() {
        return ma;
      };
      ret.variance = function variance() {
        return v;
      };
      ret.deviation = function deviation() {
        return d;
      };
      ret.forecast = function forecast() {
        return f;
      };
      return ret;
    };
  }
});

// node_modules/libp2p/src/metrics/stats.js
var require_stats2 = __commonJS({
  "node_modules/libp2p/src/metrics/stats.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var { EventEmitter: EventEmitter4 } = require_events();
    var { BigNumber: Big } = require_bignumber();
    var MovingAverage2 = require_moving_average();
    var retimer = require_retimer2();
    var Stats2 = class extends EventEmitter4 {
      constructor(initialCounters, options) {
        super();
        this._options = options;
        this._queue = [];
        this._stats = {
          dataReceived: Big(0),
          dataSent: Big(0)
        };
        this._frequencyLastTime = Date.now();
        this._frequencyAccumulators = {};
        this._movingAverages = {};
        this._update = this._update.bind(this);
        const intervals = this._options.movingAverageIntervals;
        for (let i = 0; i < initialCounters.length; i++) {
          const key = initialCounters[i];
          this._stats[key] = Big(0);
          this._movingAverages[key] = {};
          for (let k = 0; k < intervals.length; k++) {
            const interval = intervals[k];
            const ma = this._movingAverages[key][interval] = MovingAverage2(interval);
            ma.push(this._frequencyLastTime, 0);
          }
        }
      }
      start() {
        if (this._queue.length) {
          this._resetComputeTimeout();
        }
      }
      stop() {
        if (this._timeout) {
          this._timeout.clear();
          this._timeout = null;
        }
      }
      get snapshot() {
        return Object.assign({}, this._stats);
      }
      get movingAverages() {
        return Object.assign({}, this._movingAverages);
      }
      toJSON() {
        const snapshot = this.snapshot;
        const movingAverages = this.movingAverages;
        const data = {
          dataReceived: snapshot.dataReceived.toString(),
          dataSent: snapshot.dataSent.toString(),
          movingAverages: {}
        };
        const counters = Object.keys(movingAverages);
        for (const key of counters) {
          data.movingAverages[key] = {};
          for (const interval of Object.keys(movingAverages[key])) {
            data.movingAverages[key][interval] = movingAverages[key][interval].movingAverage();
          }
        }
        return data;
      }
      push(counter, inc) {
        this._queue.push([counter, inc, Date.now()]);
        this._resetComputeTimeout();
      }
      _resetComputeTimeout() {
        this._timeout = retimer(this._update, this._nextTimeout());
      }
      _nextTimeout() {
        const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
        const timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
        return timeout;
      }
      _update() {
        this._timeout = null;
        if (this._queue.length) {
          let last6;
          for (last6 of this._queue) {
            this._applyOp(last6);
          }
          this._queue = [];
          this._updateFrequency(last6[2]);
          this.emit("update", this._stats);
        }
      }
      _updateFrequency(latestTime) {
        const timeDiff = latestTime - this._frequencyLastTime;
        Object.keys(this._stats).forEach((key) => {
          this._updateFrequencyFor(key, timeDiff, latestTime);
        });
        this._frequencyLastTime = latestTime;
      }
      _updateFrequencyFor(key, timeDiffMS, latestTime) {
        const count = this._frequencyAccumulators[key] || 0;
        this._frequencyAccumulators[key] = 0;
        const safeTimeDiff = timeDiffMS || 1;
        const hz = count / safeTimeDiff * 1e3;
        let movingAverages = this._movingAverages[key];
        if (!movingAverages) {
          movingAverages = this._movingAverages[key] = {};
        }
        const intervals = this._options.movingAverageIntervals;
        for (let i = 0; i < intervals.length; i++) {
          const movingAverageInterval = intervals[i];
          let movingAverage = movingAverages[movingAverageInterval];
          if (!movingAverage) {
            movingAverage = movingAverages[movingAverageInterval] = MovingAverage2(movingAverageInterval);
          }
          movingAverage.push(latestTime, hz);
        }
      }
      _applyOp(op) {
        const key = op[0];
        const inc = op[1];
        if (typeof inc !== "number") {
          throw new Error(`invalid increment number: ${inc}`);
        }
        let n;
        if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
          n = this._stats[key] = Big(0);
        } else {
          n = this._stats[key];
        }
        this._stats[key] = n.plus(inc);
        if (!this._frequencyAccumulators[key]) {
          this._frequencyAccumulators[key] = 0;
        }
        this._frequencyAccumulators[key] += inc;
      }
    };
    module2.exports = Stats2;
  }
});

// node_modules/libp2p/src/metrics/index.js
var require_metrics = __commonJS({
  "node_modules/libp2p/src/metrics/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var mergeOptions2 = require_merge_options();
    var { pipe: pipe4 } = require_it_pipe();
    var { tap } = require_dist2();
    var oldPeerLRU = require_old_peers();
    var { METRICS: defaultOptions4 } = require_constants11();
    var Stats2 = require_stats2();
    var initialCounters = [
      "dataReceived",
      "dataSent"
    ];
    var directionToEvent = {
      in: "dataReceived",
      out: "dataSent"
    };
    var Metrics = class {
      constructor(options) {
        this._options = mergeOptions2(defaultOptions4, options);
        this._globalStats = new Stats2(initialCounters, this._options);
        this._peerStats = new Map();
        this._protocolStats = new Map();
        this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);
        this._running = false;
        this._onMessage = this._onMessage.bind(this);
        this._connectionManager = options.connectionManager;
        this._connectionManager.on("peer:disconnect", (connection) => {
          this.onPeerDisconnected(connection.remotePeer);
        });
      }
      start() {
        this._running = true;
      }
      stop() {
        this._running = false;
        this._globalStats.stop();
        for (const stats of this._peerStats.values()) {
          stats.stop();
        }
        for (const stats of this._protocolStats.values()) {
          stats.stop();
        }
      }
      get global() {
        return this._globalStats;
      }
      get peers() {
        return Array.from(this._peerStats.keys());
      }
      forPeer(peerId) {
        const idString = peerId.toB58String();
        return this._peerStats.get(idString) || this._oldPeers.get(idString);
      }
      get protocols() {
        return Array.from(this._protocolStats.keys());
      }
      forProtocol(protocol) {
        return this._protocolStats.get(protocol);
      }
      onPeerDisconnected(peerId) {
        const idString = peerId.toB58String();
        const peerStats = this._peerStats.get(idString);
        if (peerStats) {
          peerStats.stop();
          this._peerStats.delete(idString);
          this._oldPeers.set(idString, peerStats);
        }
      }
      _onMessage({ remotePeer, protocol, direction, dataLength }) {
        if (!this._running)
          return;
        const key = directionToEvent[direction];
        let peerStats = this.forPeer(remotePeer);
        if (!peerStats) {
          peerStats = new Stats2(initialCounters, this._options);
          this._peerStats.set(remotePeer.toB58String(), peerStats);
        }
        peerStats.push(key, dataLength);
        this._globalStats.push(key, dataLength);
        if (protocol) {
          let protocolStats = this.forProtocol(protocol);
          if (!protocolStats) {
            protocolStats = new Stats2(initialCounters, this._options);
            this._protocolStats.set(protocol, protocolStats);
          }
          protocolStats.push(key, dataLength);
        }
      }
      updatePlaceholder(placeholder, peerId) {
        if (!this._running)
          return;
        const placeholderStats = this.forPeer(placeholder);
        const peerIdString = peerId.toB58String();
        const existingStats = this.forPeer(peerId);
        let mergedStats = placeholderStats;
        if (existingStats) {
          mergedStats = Metrics.mergeStats(existingStats, mergedStats);
          this._oldPeers.delete(peerIdString);
        }
        this._peerStats.delete(placeholder.toB58String());
        this._peerStats.set(peerIdString, mergedStats);
        mergedStats.start();
      }
      trackStream({ stream, remotePeer, protocol }) {
        const metrics = this;
        const _source = stream.source;
        stream.source = tap((chunk) => metrics._onMessage({
          remotePeer,
          protocol,
          direction: "in",
          dataLength: chunk.length
        }))(_source);
        const _sink = stream.sink;
        stream.sink = (source) => {
          return pipe4(source, tap((chunk) => metrics._onMessage({
            remotePeer,
            protocol,
            direction: "out",
            dataLength: chunk.length
          })), _sink);
        };
        return stream;
      }
      static mergeStats(target, other) {
        target.stop();
        other.stop();
        target._queue = [...target._queue, ...other._queue];
        return target;
      }
    };
    module2.exports = Metrics;
  }
});

// node_modules/multistream-select/src/multistream.js
var require_multistream = __commonJS({
  "node_modules/multistream-select/src/multistream.js"(exports2) {
    init_node_globals();
    "use strict";
    var BufferList3 = require_BufferList();
    var lp2 = require_src12();
    var pipe4 = require_it_pipe();
    var errCode32 = require_err_code();
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var first3 = require_it_first();
    var NewLine = uint8ArrayFromString("\n");
    exports2.encode = (buffer2) => lp2.encode.single(new BufferList3([buffer2, NewLine]));
    exports2.write = (writer, buffer2) => writer.push(exports2.encode(buffer2));
    exports2.writeAll = (writer, buffers) => {
      writer.push(buffers.reduce((bl, buffer2) => bl.append(exports2.encode(buffer2)), new BufferList3()));
    };
    exports2.read = async (reader) => {
      let byteLength = 1;
      const varByteSource = {
        [Symbol.asyncIterator]() {
          return this;
        },
        next: () => reader.next(byteLength)
      };
      const onLength = (l) => {
        byteLength = l;
      };
      const buf2 = await pipe4(varByteSource, lp2.decode({ onLength }), first3);
      if (buf2.get(buf2.length - 1) !== NewLine[0]) {
        throw errCode32(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
      }
      return buf2.shallowSlice(0, -1);
    };
  }
});

// node_modules/multistream-select/src/select.js
var require_select = __commonJS({
  "node_modules/multistream-select/src/select.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var log15 = require_browser2()("mss:select");
    var errCode32 = require_err_code();
    var multistream = require_multistream();
    var handshake = require_src20();
    module2.exports = async (stream, protocols, protocolId) => {
      protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
      const { reader, writer, rest, stream: shakeStream } = handshake(stream);
      const protocol = protocols.shift();
      if (protocolId) {
        log15('select: write ["%s", "%s"]', protocolId, protocol);
        multistream.writeAll(writer, [protocolId, protocol]);
      } else {
        log15('select: write "%s"', protocol);
        multistream.write(writer, protocol);
      }
      let response = (await multistream.read(reader)).toString();
      log15('select: read "%s"', response);
      if (response === protocolId) {
        response = (await multistream.read(reader)).toString();
        log15('select: read "%s"', response);
      }
      if (response === protocol) {
        rest();
        return { stream: shakeStream, protocol };
      }
      for (const protocol2 of protocols) {
        log15('select: write "%s"', protocol2);
        multistream.write(writer, protocol2);
        const response2 = (await multistream.read(reader)).toString();
        log15('select: read "%s" for "%s"', response2, protocol2);
        if (response2 === protocol2) {
          rest();
          return { stream: shakeStream, protocol: protocol2 };
        }
      }
      rest();
      throw errCode32(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL");
    };
  }
});

// node_modules/multistream-select/src/constants.js
var require_constants13 = __commonJS({
  "node_modules/multistream-select/src/constants.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.PROTOCOL_ID = "/multistream/1.0.0";
  }
});

// node_modules/multistream-select/src/handle.js
var require_handle = __commonJS({
  "node_modules/multistream-select/src/handle.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var log15 = require_browser2()("mss:handle");
    var BufferList3 = require_BufferList();
    var multistream = require_multistream();
    var handshake = require_src20();
    var { PROTOCOL_ID } = require_constants13();
    module2.exports = async (stream, protocols) => {
      protocols = Array.isArray(protocols) ? protocols : [protocols];
      const { writer, reader, rest, stream: shakeStream } = handshake(stream);
      while (true) {
        const protocol = (await multistream.read(reader)).toString();
        log15('read "%s"', protocol);
        if (protocol === PROTOCOL_ID) {
          log15('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
          multistream.write(writer, PROTOCOL_ID);
          continue;
        }
        if (protocols.includes(protocol)) {
          multistream.write(writer, protocol);
          log15('respond with "%s" for "%s"', protocol, protocol);
          rest();
          return { stream: shakeStream, protocol };
        }
        if (protocol === "ls") {
          multistream.write(writer, new BufferList3(protocols.map((p) => multistream.encode(p))));
          log15('respond with "%s" for %s', protocols, protocol);
          continue;
        }
        multistream.write(writer, "na");
        log15('respond with "na" for "%s"', protocol);
      }
    };
  }
});

// node_modules/multistream-select/src/ls.js
var require_ls4 = __commonJS({
  "node_modules/multistream-select/src/ls.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var Reader = require_it_reader();
    var log15 = require_browser2()("it-multistream-select:ls");
    var multistream = require_multistream();
    var handshake = require_src20();
    var lp2 = require_src12();
    var pipe4 = require_it_pipe();
    module2.exports = async (stream) => {
      const { reader, writer, rest, stream: shakeStream } = handshake(stream);
      log15('write "ls"');
      multistream.write(writer, "ls");
      rest();
      const res = await multistream.read(reader);
      const protocolsReader = Reader([res]);
      const protocols = [];
      await pipe4(protocolsReader, lp2.decode(), async (source) => {
        for await (const protocol of source) {
          protocols.push(protocol.shallowSlice(0, -1).toString());
        }
      });
      return { stream: shakeStream, protocols };
    };
  }
});

// node_modules/multistream-select/src/index.js
var require_src27 = __commonJS({
  "node_modules/multistream-select/src/index.js"(exports2) {
    init_node_globals();
    "use strict";
    var select = require_select();
    var handle = require_handle();
    var ls = require_ls4();
    var { PROTOCOL_ID } = require_constants13();
    exports2.PROTOCOL_ID = PROTOCOL_ID;
    var MultistreamSelect = class {
      constructor(stream) {
        this._stream = stream;
        this._shaken = false;
      }
      async _handshake() {
        if (this._shaken)
          return;
        const { stream } = await select(this._stream, PROTOCOL_ID);
        this._stream = stream;
        this._shaken = true;
      }
    };
    var Dialer = class extends MultistreamSelect {
      select(protocols) {
        return select(this._stream, protocols, this._shaken ? null : PROTOCOL_ID);
      }
      async ls() {
        await this._handshake();
        const { stream, protocols } = await ls(this._stream);
        this._stream = stream;
        return protocols;
      }
    };
    exports2.Dialer = Dialer;
    var Listener = class extends MultistreamSelect {
      handle(protocols) {
        return handle(this._stream, protocols);
      }
    };
    exports2.Listener = Listener;
  }
});

// node_modules/libp2p-interfaces/src/connection/status.js
var require_status = __commonJS({
  "node_modules/libp2p-interfaces/src/connection/status.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var STATUS = {
      OPEN: "open",
      CLOSING: "closing",
      CLOSED: "closed"
    };
    module2.exports = STATUS;
  }
});

// node_modules/libp2p-interfaces/src/connection/connection.js
var require_connection = __commonJS({
  "node_modules/libp2p-interfaces/src/connection/connection.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var PeerId2 = require_src6();
    var { Multiaddr: Multiaddr18 } = require_src();
    var errCode32 = require_err_code();
    var { OPEN, CLOSING, CLOSED } = require_status();
    var connectionSymbol = Symbol.for("@libp2p/interface-connection/connection");
    var Connection = class {
      constructor({ localAddr, remoteAddr, localPeer, remotePeer, newStream, close, getStreams, stat }) {
        validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat);
        this.id = parseInt(String(Math.random() * 1e9)).toString(36) + Date.now();
        this.localAddr = localAddr;
        this.remoteAddr = remoteAddr;
        this.localPeer = localPeer;
        this.remotePeer = remotePeer;
        this._stat = {
          ...stat,
          status: OPEN
        };
        this._newStream = newStream;
        this._close = close;
        this._getStreams = getStreams;
        this.registry = new Map();
        this.tags = [];
      }
      get [Symbol.toStringTag]() {
        return "Connection";
      }
      get [connectionSymbol]() {
        return true;
      }
      static isConnection(other) {
        return Boolean(other && other[connectionSymbol]);
      }
      get stat() {
        return this._stat;
      }
      get streams() {
        return this._getStreams();
      }
      async newStream(protocols) {
        if (this.stat.status === CLOSING) {
          throw errCode32(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED");
        }
        if (this.stat.status === CLOSED) {
          throw errCode32(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED");
        }
        if (!Array.isArray(protocols))
          protocols = [protocols];
        const { stream, protocol } = await this._newStream(protocols);
        this.addStream(stream, { protocol });
        return {
          stream,
          protocol
        };
      }
      addStream(muxedStream, { protocol, metadata = {} }) {
        this.registry.set(muxedStream.id, {
          protocol,
          ...metadata
        });
      }
      removeStream(id) {
        this.registry.delete(id);
      }
      async close() {
        if (this.stat.status === CLOSED) {
          return;
        }
        if (this._closing) {
          return this._closing;
        }
        this.stat.status = CLOSING;
        this._closing = await this._close();
        this._stat.timeline.close = Date.now();
        this.stat.status = CLOSED;
      }
    };
    module2.exports = Connection;
    function validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {
      if (localAddr && !Multiaddr18.isMultiaddr(localAddr)) {
        throw errCode32(new Error("localAddr must be an instance of multiaddr"), "ERR_INVALID_PARAMETERS");
      }
      if (!PeerId2.isPeerId(localPeer)) {
        throw errCode32(new Error("localPeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS");
      }
      if (!PeerId2.isPeerId(remotePeer)) {
        throw errCode32(new Error("remotePeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS");
      }
      if (typeof newStream !== "function") {
        throw errCode32(new Error("new stream must be a function"), "ERR_INVALID_PARAMETERS");
      }
      if (typeof close !== "function") {
        throw errCode32(new Error("close must be a function"), "ERR_INVALID_PARAMETERS");
      }
      if (typeof getStreams !== "function") {
        throw errCode32(new Error("getStreams must be a function"), "ERR_INVALID_PARAMETERS");
      }
      if (!stat) {
        throw errCode32(new Error("connection metadata object must be provided"), "ERR_INVALID_PARAMETERS");
      }
      if (stat.direction !== "inbound" && stat.direction !== "outbound") {
        throw errCode32(new Error('direction must be "inbound" or "outbound"'), "ERR_INVALID_PARAMETERS");
      }
      if (!stat.timeline) {
        throw errCode32(new Error("connection timeline object must be provided in the stat object"), "ERR_INVALID_PARAMETERS");
      }
      if (!stat.timeline.open) {
        throw errCode32(new Error("connection open timestamp must be provided"), "ERR_INVALID_PARAMETERS");
      }
      if (!stat.timeline.upgraded) {
        throw errCode32(new Error("connection upgraded timestamp must be provided"), "ERR_INVALID_PARAMETERS");
      }
    }
  }
});

// node_modules/libp2p-interfaces/src/connection/index.js
var require_connection2 = __commonJS({
  "node_modules/libp2p-interfaces/src/connection/index.js"(exports2) {
    init_node_globals();
    "use strict";
    exports2.Connection = require_connection();
  }
});

// node_modules/mutable-proxy/build/index.js
var require_build = __commonJS({
  "node_modules/mutable-proxy/build/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function _toConsumableArray(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }
        return arr2;
      } else {
        return Array.from(arr);
      }
    }
    module2.exports = function mutableProxyFactory(defaultTarget) {
      var mutableHandler = void 0;
      var mutableTarget = void 0;
      function setTarget(target) {
        if (!(target instanceof Object)) {
          throw new Error('Target "' + target + '" is not an object');
        }
        mutableTarget = target;
      }
      function setHandler(handler2) {
        Object.keys(handler2).forEach(function(key) {
          var value = handler2[key];
          if (typeof value !== "function") {
            throw new Error('Trap "' + key + ": " + value + '" is not a function');
          }
          if (!Reflect[key]) {
            throw new Error('Trap "' + key + ": " + value + '" is not a valid trap');
          }
        });
        mutableHandler = handler2;
      }
      setTarget(function() {
      });
      if (defaultTarget) {
        setTarget(defaultTarget);
      }
      setHandler(Reflect);
      var handler = new Proxy({}, {
        get: function get2(target, property) {
          return function() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            return mutableHandler[property].apply(null, [mutableTarget].concat(_toConsumableArray(args.slice(1))));
          };
        }
      });
      return {
        setTarget,
        setHandler,
        getTarget: function getTarget() {
          return mutableTarget;
        },
        getHandler: function getHandler() {
          return mutableHandler;
        },
        proxy: new Proxy(mutableTarget, handler)
      };
    };
  }
});

// node_modules/libp2p/src/upgrader.js
var require_upgrader = __commonJS({
  "node_modules/libp2p/src/upgrader.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:upgrader"), {
      error: debug17("libp2p:upgrader:err")
    });
    var errCode32 = require_err_code();
    var Multistream = require_src27();
    var { Connection } = require_connection2();
    var PeerId2 = require_src6();
    var { pipe: pipe4 } = require_it_pipe();
    var mutableProxy = require_build();
    var { codes } = require_errors4();
    var Upgrader = class {
      constructor({
        localPeer,
        metrics,
        cryptos = new Map(),
        muxers = new Map(),
        onConnectionEnd = () => {
        },
        onConnection = () => {
        }
      }) {
        this.localPeer = localPeer;
        this.metrics = metrics;
        this.cryptos = cryptos;
        this.muxers = muxers;
        this.protector = null;
        this.protocols = new Map();
        this.onConnection = onConnection;
        this.onConnectionEnd = onConnectionEnd;
      }
      async upgradeInbound(maConn) {
        let encryptedConn;
        let remotePeer;
        let upgradedConn;
        let Muxer;
        let cryptoProtocol;
        let setPeer;
        let proxyPeer;
        if (this.metrics) {
          ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy());
          const idString = (Math.random() * 1e9).toString(36) + Date.now();
          setPeer({ toB58String: () => idString });
          maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
        }
        log15("Starting the inbound connection upgrade");
        let protectedConn = maConn;
        if (this.protector) {
          protectedConn = await this.protector.protect(maConn);
        }
        try {
          ({
            conn: encryptedConn,
            remotePeer,
            protocol: cryptoProtocol
          } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos));
          if (this.muxers.size) {
            ({ stream: upgradedConn, Muxer } = await this._multiplexInbound(encryptedConn, this.muxers));
          } else {
            upgradedConn = encryptedConn;
          }
        } catch (err) {
          log15.error("Failed to upgrade inbound connection", err);
          await maConn.close(err);
          throw err;
        }
        if (this.metrics) {
          this.metrics.updatePlaceholder(proxyPeer, remotePeer);
          setPeer(remotePeer);
        }
        log15("Successfully upgraded inbound connection");
        return this._createConnection({
          cryptoProtocol,
          direction: "inbound",
          maConn,
          upgradedConn,
          Muxer,
          remotePeer
        });
      }
      async upgradeOutbound(maConn) {
        const idStr = maConn.remoteAddr.getPeerId();
        if (!idStr) {
          throw errCode32(new Error("outbound connection must have a peer id"), codes.ERR_INVALID_MULTIADDR);
        }
        const remotePeerId = PeerId2.createFromB58String(idStr);
        let encryptedConn;
        let remotePeer;
        let upgradedConn;
        let cryptoProtocol;
        let Muxer;
        let setPeer;
        let proxyPeer;
        if (this.metrics) {
          ({ setTarget: setPeer, proxy: proxyPeer } = mutableProxy());
          const idString = (Math.random() * 1e9).toString(36) + Date.now();
          setPeer({ toB58String: () => idString });
          maConn = this.metrics.trackStream({ stream: maConn, remotePeer: proxyPeer });
        }
        log15("Starting the outbound connection upgrade");
        let protectedConn = maConn;
        if (this.protector) {
          protectedConn = await this.protector.protect(maConn);
        }
        try {
          ({
            conn: encryptedConn,
            remotePeer,
            protocol: cryptoProtocol
          } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos));
          if (this.muxers.size) {
            ({ stream: upgradedConn, Muxer } = await this._multiplexOutbound(encryptedConn, this.muxers));
          } else {
            upgradedConn = encryptedConn;
          }
        } catch (err) {
          log15.error("Failed to upgrade outbound connection", err);
          await maConn.close(err);
          throw err;
        }
        if (this.metrics) {
          this.metrics.updatePlaceholder(proxyPeer, remotePeer);
          setPeer(remotePeer);
        }
        log15("Successfully upgraded outbound connection");
        return this._createConnection({
          cryptoProtocol,
          direction: "outbound",
          maConn,
          upgradedConn,
          Muxer,
          remotePeer
        });
      }
      _createConnection({
        cryptoProtocol,
        direction,
        maConn,
        upgradedConn,
        Muxer,
        remotePeer
      }) {
        let muxer;
        let newStream;
        let connection;
        if (Muxer) {
          muxer = new Muxer({
            onStream: async (muxedStream) => {
              if (!connection)
                return;
              const mss = new Multistream.Listener(muxedStream);
              try {
                const { stream, protocol } = await mss.handle(Array.from(this.protocols.keys()));
                log15("%s: incoming stream opened on %s", direction, protocol);
                if (this.metrics)
                  this.metrics.trackStream({ stream, remotePeer, protocol });
                connection.addStream(muxedStream, { protocol });
                this._onStream({ connection, stream: { ...muxedStream, ...stream }, protocol });
              } catch (err) {
                log15.error(err);
              }
            },
            onStreamEnd: (muxedStream) => {
              connection.removeStream(muxedStream.id);
            }
          });
          newStream = async (protocols) => {
            log15("%s: starting new stream on %s", direction, protocols);
            const muxedStream = muxer.newStream();
            const mss = new Multistream.Dialer(muxedStream);
            try {
              const { stream, protocol } = await mss.select(protocols);
              if (this.metrics)
                this.metrics.trackStream({ stream, remotePeer, protocol });
              return { stream: { ...muxedStream, ...stream }, protocol };
            } catch (err) {
              log15.error("could not create new stream", err);
              throw errCode32(err, codes.ERR_UNSUPPORTED_PROTOCOL);
            }
          };
          pipe4(upgradedConn, muxer, upgradedConn).catch(log15.error);
        }
        const _timeline = maConn.timeline;
        maConn.timeline = new Proxy(_timeline, {
          set: (...args) => {
            if (connection && args[1] === "close" && args[2] && !_timeline.close) {
              (async () => {
                try {
                  if (connection.stat.status === "open") {
                    await connection.close();
                  }
                } catch (err) {
                  log15.error(err);
                } finally {
                  this.onConnectionEnd(connection);
                }
              })();
            }
            return Reflect.set(...args);
          }
        });
        maConn.timeline.upgraded = Date.now();
        const errConnectionNotMultiplexed = () => {
          throw errCode32(new Error("connection is not multiplexed"), "ERR_CONNECTION_NOT_MULTIPLEXED");
        };
        connection = new Connection({
          localAddr: maConn.localAddr,
          remoteAddr: maConn.remoteAddr,
          localPeer: this.localPeer,
          remotePeer,
          stat: {
            direction,
            timeline: maConn.timeline,
            multiplexer: Muxer && Muxer.multicodec,
            encryption: cryptoProtocol
          },
          newStream: newStream || errConnectionNotMultiplexed,
          getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed(),
          close: async () => {
            await maConn.close();
            if (muxer) {
              muxer.streams.map((stream) => stream.abort());
            }
          }
        });
        this.onConnection(connection);
        return connection;
      }
      _onStream({ connection, stream, protocol }) {
        const handler = this.protocols.get(protocol);
        handler({ connection, stream, protocol });
      }
      async _encryptInbound(localPeer, connection, cryptos) {
        const mss = new Multistream.Listener(connection);
        const protocols = Array.from(cryptos.keys());
        log15("handling inbound crypto protocol selection", protocols);
        try {
          const { stream, protocol } = await mss.handle(protocols);
          const crypto3 = cryptos.get(protocol);
          log15("encrypting inbound connection...");
          if (!crypto3) {
            throw new Error(`no crypto module found for ${protocol}`);
          }
          return {
            ...await crypto3.secureInbound(localPeer, stream),
            protocol
          };
        } catch (err) {
          throw errCode32(err, codes.ERR_ENCRYPTION_FAILED);
        }
      }
      async _encryptOutbound(localPeer, connection, remotePeerId, cryptos) {
        const mss = new Multistream.Dialer(connection);
        const protocols = Array.from(cryptos.keys());
        log15("selecting outbound crypto protocol", protocols);
        try {
          const { stream, protocol } = await mss.select(protocols);
          const crypto3 = cryptos.get(protocol);
          log15("encrypting outbound connection to %j", remotePeerId);
          if (!crypto3) {
            throw new Error(`no crypto module found for ${protocol}`);
          }
          return {
            ...await crypto3.secureOutbound(localPeer, stream, remotePeerId),
            protocol
          };
        } catch (err) {
          throw errCode32(err, codes.ERR_ENCRYPTION_FAILED);
        }
      }
      async _multiplexOutbound(connection, muxers) {
        const dialer = new Multistream.Dialer(connection);
        const protocols = Array.from(muxers.keys());
        log15("outbound selecting muxer %s", protocols);
        try {
          const { stream, protocol } = await dialer.select(protocols);
          log15("%s selected as muxer protocol", protocol);
          const Muxer = muxers.get(protocol);
          return { stream, Muxer };
        } catch (err) {
          throw errCode32(err, codes.ERR_MUXER_UNAVAILABLE);
        }
      }
      async _multiplexInbound(connection, muxers) {
        const listener = new Multistream.Listener(connection);
        const protocols = Array.from(muxers.keys());
        log15("inbound handling muxers %s", protocols);
        try {
          const { stream, protocol } = await listener.handle(protocols);
          const Muxer = muxers.get(protocol);
          return { stream, Muxer };
        } catch (err) {
          throw errCode32(err, codes.ERR_MUXER_UNAVAILABLE);
        }
      }
    };
    module2.exports = Upgrader;
  }
});

// node_modules/libp2p/src/peer-store/book.js
var require_book = __commonJS({
  "node_modules/libp2p/src/peer-store/book.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var PeerId2 = require_src6();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors4();
    var passthrough = (data) => data;
    var Book = class {
      constructor({ peerStore, eventName, eventProperty, eventTransformer = passthrough }) {
        this._ps = peerStore;
        this.eventName = eventName;
        this.eventProperty = eventProperty;
        this.eventTransformer = eventTransformer;
        this.data = new Map();
      }
      set(peerId, data) {
        throw errcode7(new Error("set must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED");
      }
      _setData(peerId, data, { emit = true } = {}) {
        const b58key = peerId.toB58String();
        this.data.set(b58key, data);
        emit && this._emit(peerId, data);
      }
      _emit(peerId, data) {
        this._ps.emit(this.eventName, {
          peerId,
          [this.eventProperty]: this.eventTransformer(data)
        });
      }
      get(peerId) {
        if (!PeerId2.isPeerId(peerId)) {
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const rec = this.data.get(peerId.toB58String());
        return rec ? [...rec] : void 0;
      }
      delete(peerId) {
        if (!PeerId2.isPeerId(peerId)) {
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        if (!this.data.delete(peerId.toB58String())) {
          return false;
        }
        this._emit(peerId, []);
        return true;
      }
    };
    module2.exports = Book;
  }
});

// node_modules/libp2p/src/peer-store/address-book.js
var require_address_book = __commonJS({
  "node_modules/libp2p/src/peer-store/address-book.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:peer-store:address-book"), {
      error: debug17("libp2p:peer-store:address-book:err")
    });
    var errcode7 = require_err_code();
    var { Multiaddr: Multiaddr18 } = require_src();
    var PeerId2 = require_src6();
    var Book = require_book();
    var PeerRecord = require_peer_record2();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors4();
    var Envelope = require_envelope2();
    var AddressBook = class extends Book {
      constructor(peerStore) {
        super({
          peerStore,
          eventName: "change:multiaddrs",
          eventProperty: "multiaddrs",
          eventTransformer: (data) => {
            if (!data.addresses) {
              return [];
            }
            return data.addresses.map((address) => address.multiaddr);
          }
        });
        this.data = new Map();
      }
      consumePeerRecord(envelope) {
        let peerRecord;
        try {
          peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
        } catch (err) {
          log15.error("invalid peer record received");
          return false;
        }
        if (!peerRecord.peerId.equals(envelope.peerId)) {
          log15("signing key does not match PeerId in the PeerRecord");
          return false;
        }
        if (!peerRecord.multiaddrs || !peerRecord.multiaddrs.length) {
          return false;
        }
        const peerId = peerRecord.peerId;
        const id = peerId.toB58String();
        const entry = this.data.get(id) || { record: void 0 };
        const storedRecord = entry.record;
        if (storedRecord && storedRecord.seqNumber >= peerRecord.seqNumber) {
          return false;
        }
        const addresses = this._toAddresses(peerRecord.multiaddrs, true);
        this._setData(peerId, {
          addresses,
          record: {
            raw: envelope.marshal(),
            seqNumber: peerRecord.seqNumber
          }
        });
        log15(`stored provided peer record for ${id}`);
        return true;
      }
      getRawEnvelope(peerId) {
        const entry = this.data.get(peerId.toB58String());
        if (!entry || !entry.record || !entry.record.raw) {
          return void 0;
        }
        return entry.record.raw;
      }
      getPeerRecord(peerId) {
        const raw7 = this.getRawEnvelope(peerId);
        if (!raw7) {
          return void 0;
        }
        return Envelope.createFromProtobuf(raw7);
      }
      set(peerId, multiaddrs) {
        if (!PeerId2.isPeerId(peerId)) {
          log15.error("peerId must be an instance of peer-id to store data");
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const addresses = this._toAddresses(multiaddrs);
        if (!addresses.length) {
          return this;
        }
        const id = peerId.toB58String();
        const entry = this.data.get(id);
        if (entry && entry.addresses && entry.addresses.length === addresses.length) {
          const intersection = entry.addresses.filter((addr) => addresses.some((newAddr) => addr.multiaddr.equals(newAddr.multiaddr)));
          if (intersection.length === entry.addresses.length) {
            log15(`the addresses provided to store are equal to the already stored for ${id}`);
            return this;
          }
        }
        this._setData(peerId, {
          addresses,
          record: entry && entry.record
        });
        log15(`stored provided multiaddrs for ${id}`);
        if (!entry) {
          this._ps.emit("peer", peerId);
        }
        return this;
      }
      add(peerId, multiaddrs) {
        if (!PeerId2.isPeerId(peerId)) {
          log15.error("peerId must be an instance of peer-id to store data");
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const addresses = this._toAddresses(multiaddrs);
        const id = peerId.toB58String();
        if (!addresses.length) {
          return this;
        }
        const entry = this.data.get(id);
        if (entry && entry.addresses) {
          entry.addresses.forEach((addr) => {
            if (!addresses.find((r) => r.multiaddr.equals(addr.multiaddr))) {
              addresses.push(addr);
            }
          });
          if (entry.addresses.length === addresses.length) {
            log15(`the addresses provided to store are already stored for ${id}`);
            return this;
          }
        }
        this._setData(peerId, {
          addresses,
          record: entry && entry.record
        });
        log15(`added provided multiaddrs for ${id}`);
        if (!(entry && entry.addresses)) {
          this._ps.emit("peer", peerId);
        }
        return this;
      }
      get(peerId) {
        if (!PeerId2.isPeerId(peerId)) {
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const entry = this.data.get(peerId.toB58String());
        return entry && entry.addresses ? [...entry.addresses] : void 0;
      }
      _toAddresses(multiaddrs, isCertified = false) {
        if (!multiaddrs) {
          log15.error("multiaddrs must be provided to store data");
          throw errcode7(new Error("multiaddrs must be provided"), ERR_INVALID_PARAMETERS);
        }
        const addresses = [];
        multiaddrs.forEach((addr) => {
          if (!Multiaddr18.isMultiaddr(addr)) {
            log15.error(`multiaddr ${addr} must be an instance of multiaddr`);
            throw errcode7(new Error(`multiaddr ${addr} must be an instance of multiaddr`), ERR_INVALID_PARAMETERS);
          }
          if (!addresses.find((a) => a.multiaddr.equals(addr))) {
            addresses.push({
              multiaddr: addr,
              isCertified
            });
          }
        });
        return addresses;
      }
      getMultiaddrsForPeer(peerId, addressSorter = (ms) => ms) {
        if (!PeerId2.isPeerId(peerId)) {
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const entry = this.data.get(peerId.toB58String());
        if (!entry || !entry.addresses) {
          return void 0;
        }
        return addressSorter(entry.addresses || []).map((address) => {
          const multiaddr = address.multiaddr;
          const idString = multiaddr.getPeerId();
          if (idString && idString === peerId.toB58String())
            return multiaddr;
          return multiaddr.encapsulate(`/p2p/${peerId.toB58String()}`);
        });
      }
    };
    module2.exports = AddressBook;
  }
});

// node_modules/libp2p/src/peer-store/key-book.js
var require_key_book = __commonJS({
  "node_modules/libp2p/src/peer-store/key-book.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:peer-store:key-book"), {
      error: debug17("libp2p:peer-store:key-book:err")
    });
    var errcode7 = require_err_code();
    var PeerId2 = require_src6();
    var Book = require_book();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors4();
    var KeyBook = class extends Book {
      constructor(peerStore) {
        super({
          peerStore,
          eventName: "change:pubkey",
          eventProperty: "pubkey",
          eventTransformer: (data) => data.pubKey
        });
        this.data = new Map();
      }
      set(peerId, publicKey) {
        if (!PeerId2.isPeerId(peerId)) {
          log15.error("peerId must be an instance of peer-id to store data");
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const id = peerId.toB58String();
        const recPeerId = this.data.get(id);
        if (!recPeerId && publicKey) {
          peerId.pubKey = publicKey;
          this._setData(peerId, peerId);
          log15(`stored provided public key for ${id}`);
        }
        return this;
      }
      get(peerId) {
        if (!PeerId2.isPeerId(peerId)) {
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const rec = this.data.get(peerId.toB58String());
        return rec ? rec.pubKey : void 0;
      }
    };
    module2.exports = KeyBook;
  }
});

// node_modules/libp2p/src/peer-store/metadata-book.js
var require_metadata_book = __commonJS({
  "node_modules/libp2p/src/peer-store/metadata-book.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:peer-store:proto-book"), {
      error: debug17("libp2p:peer-store:proto-book:err")
    });
    var errcode7 = require_err_code();
    var { equals: uint8ArrayEquals } = (init_equals(), equals_exports);
    var PeerId2 = require_src6();
    var Book = require_book();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors4();
    var MetadataBook = class extends Book {
      constructor(peerStore) {
        super({
          peerStore,
          eventName: "change:metadata",
          eventProperty: "metadata"
        });
        this.data = new Map();
      }
      set(peerId, key, value) {
        if (!PeerId2.isPeerId(peerId)) {
          log15.error("peerId must be an instance of peer-id to store data");
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        if (typeof key !== "string" || !(value instanceof Uint8Array)) {
          log15.error("valid key and value must be provided to store data");
          throw errcode7(new Error("valid key and value must be provided"), ERR_INVALID_PARAMETERS);
        }
        this._setValue(peerId, key, value);
        return this;
      }
      _setValue(peerId, key, value, { emit = true } = {}) {
        const id = peerId.toB58String();
        const rec = this.data.get(id) || new Map();
        const recMap = rec.get(key);
        if (recMap && uint8ArrayEquals(value, recMap)) {
          log15(`the metadata provided to store is equal to the already stored for ${id} on ${key}`);
          return;
        }
        rec.set(key, value);
        this.data.set(id, rec);
        emit && this._emit(peerId, key);
      }
      get(peerId) {
        if (!PeerId2.isPeerId(peerId)) {
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        return this.data.get(peerId.toB58String());
      }
      getValue(peerId, key) {
        if (!PeerId2.isPeerId(peerId)) {
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const rec = this.data.get(peerId.toB58String());
        return rec && rec.get(key);
      }
      delete(peerId) {
        if (!PeerId2.isPeerId(peerId)) {
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        if (!this.data.delete(peerId.toB58String())) {
          return false;
        }
        this._emit(peerId);
        return true;
      }
      deleteValue(peerId, key) {
        if (!PeerId2.isPeerId(peerId)) {
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const rec = this.data.get(peerId.toB58String());
        if (!rec || !rec.delete(key)) {
          return false;
        }
        this._emit(peerId, key);
        return true;
      }
    };
    module2.exports = MetadataBook;
  }
});

// node_modules/libp2p/src/peer-store/proto-book.js
var require_proto_book = __commonJS({
  "node_modules/libp2p/src/peer-store/proto-book.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:peer-store:proto-book"), {
      error: debug17("libp2p:peer-store:proto-book:err")
    });
    var errcode7 = require_err_code();
    var PeerId2 = require_src6();
    var Book = require_book();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors4();
    var ProtoBook = class extends Book {
      constructor(peerStore) {
        super({
          peerStore,
          eventName: "change:protocols",
          eventProperty: "protocols",
          eventTransformer: (data) => Array.from(data)
        });
        this.data = new Map();
      }
      set(peerId, protocols) {
        if (!PeerId2.isPeerId(peerId)) {
          log15.error("peerId must be an instance of peer-id to store data");
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        if (!protocols) {
          log15.error("protocols must be provided to store data");
          throw errcode7(new Error("protocols must be provided"), ERR_INVALID_PARAMETERS);
        }
        const id = peerId.toB58String();
        const recSet = this.data.get(id);
        const newSet = new Set(protocols);
        const isSetEqual = (a, b) => a.size === b.size && [...a].every((value) => b.has(value));
        if (recSet && isSetEqual(recSet, newSet)) {
          log15(`the protocols provided to store are equal to the already stored for ${id}`);
          return this;
        }
        this._setData(peerId, newSet);
        log15(`stored provided protocols for ${id}`);
        return this;
      }
      add(peerId, protocols) {
        if (!PeerId2.isPeerId(peerId)) {
          log15.error("peerId must be an instance of peer-id to store data");
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        if (!protocols) {
          log15.error("protocols must be provided to store data");
          throw errcode7(new Error("protocols must be provided"), ERR_INVALID_PARAMETERS);
        }
        const id = peerId.toB58String();
        const recSet = this.data.get(id) || new Set();
        const newSet = new Set([...recSet, ...protocols]);
        if (recSet.size === newSet.size) {
          log15(`the protocols provided to store are already stored for ${id}`);
          return this;
        }
        this._setData(peerId, newSet);
        log15(`added provided protocols for ${id}`);
        return this;
      }
      remove(peerId, protocols) {
        if (!PeerId2.isPeerId(peerId)) {
          log15.error("peerId must be an instance of peer-id to store data");
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        if (!protocols) {
          log15.error("protocols must be provided to store data");
          throw errcode7(new Error("protocols must be provided"), ERR_INVALID_PARAMETERS);
        }
        const id = peerId.toB58String();
        const recSet = this.data.get(id);
        if (recSet) {
          const newSet = new Set([
            ...recSet
          ].filter((p) => !protocols.includes(p)));
          if (recSet.size === newSet.size) {
            return this;
          }
          this._setData(peerId, newSet);
          log15(`removed provided protocols for ${id}`);
        }
        return this;
      }
    };
    module2.exports = ProtoBook;
  }
});

// node_modules/libp2p/src/peer-store/index.js
var require_peer_store = __commonJS({
  "node_modules/libp2p/src/peer-store/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var errcode7 = require_err_code();
    var { EventEmitter: EventEmitter4 } = require_events();
    var PeerId2 = require_src6();
    var AddressBook = require_address_book();
    var KeyBook = require_key_book();
    var MetadataBook = require_metadata_book();
    var ProtoBook = require_proto_book();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors4();
    var PeerStore = class extends EventEmitter4 {
      constructor({ peerId }) {
        super();
        this._peerId = peerId;
        this.addressBook = new AddressBook(this);
        this.keyBook = new KeyBook(this);
        this.metadataBook = new MetadataBook(this);
        this.protoBook = new ProtoBook(this);
      }
      start() {
      }
      stop() {
      }
      get peers() {
        const storedPeers = new Set([
          ...this.addressBook.data.keys(),
          ...this.keyBook.data.keys(),
          ...this.protoBook.data.keys(),
          ...this.metadataBook.data.keys()
        ]);
        this._peerId && storedPeers.delete(this._peerId.toB58String());
        const peersData = new Map();
        storedPeers.forEach((idStr) => {
          peersData.set(idStr, this.get(PeerId2.createFromB58String(idStr)));
        });
        return peersData;
      }
      delete(peerId) {
        const addressesDeleted = this.addressBook.delete(peerId);
        const keyDeleted = this.keyBook.delete(peerId);
        const protocolsDeleted = this.protoBook.delete(peerId);
        const metadataDeleted = this.metadataBook.delete(peerId);
        return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted;
      }
      get(peerId) {
        if (!PeerId2.isPeerId(peerId)) {
          throw errcode7(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
        }
        const id = this.keyBook.data.get(peerId.toB58String());
        const addresses = this.addressBook.get(peerId);
        const metadata = this.metadataBook.get(peerId);
        const protocols = this.protoBook.get(peerId);
        if (!id && !addresses && !metadata && !protocols) {
          return void 0;
        }
        return {
          id: id || peerId,
          addresses: addresses || [],
          protocols: protocols || [],
          metadata
        };
      }
    };
    module2.exports = PeerStore;
  }
});

// node_modules/libp2p/src/pubsub-adapter.js
var require_pubsub_adapter = __commonJS({
  "node_modules/libp2p/src/pubsub-adapter.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function pubsubAdapter(PubsubRouter, libp2p, options) {
      const pubsub = new PubsubRouter(libp2p, options);
      pubsub._subscribeAdapter = pubsub.subscribe;
      pubsub._unsubscribeAdapter = pubsub.unsubscribe;
      function subscribe(topic, handler) {
        handler && pubsub.on(topic, handler);
        pubsub._subscribeAdapter(topic);
      }
      function unsubscribe(topic, handler) {
        if (!handler) {
          pubsub.removeAllListeners(topic);
        } else {
          pubsub.removeListener(topic, handler);
        }
        if (pubsub.listenerCount(topic) === 0) {
          pubsub._unsubscribeAdapter(topic);
        }
      }
      pubsub.subscribe = subscribe;
      pubsub.unsubscribe = unsubscribe;
      return pubsub;
    }
    module2.exports = pubsubAdapter;
  }
});

// node_modules/libp2p/src/peer-store/persistent/consts.js
var require_consts3 = __commonJS({
  "node_modules/libp2p/src/peer-store/persistent/consts.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports.NAMESPACE_COMMON = "/peers/";
    module2.exports.NAMESPACE_ADDRESS = "/peers/addrs/";
    module2.exports.NAMESPACE_KEYS = "/peers/keys/";
    module2.exports.NAMESPACE_METADATA = "/peers/metadata/";
    module2.exports.NAMESPACE_PROTOCOL = "/peers/protos/";
  }
});

// node_modules/libp2p/src/peer-store/persistent/pb/address-book.js
var require_address_book2 = __commonJS({
  "node_modules/libp2p/src/peer-store/persistent/pb/address-book.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var $protobuf5 = require_minimal2();
    var $Reader5 = $protobuf5.Reader;
    var $Writer5 = $protobuf5.Writer;
    var $util5 = $protobuf5.util;
    var $root5 = $protobuf5.roots["libp2p-address-book"] || ($protobuf5.roots["libp2p-address-book"] = {});
    $root5.Addresses = function() {
      function Addresses(p) {
        this.addrs = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Addresses.prototype.addrs = $util5.emptyArray;
      Addresses.prototype.certifiedRecord = null;
      Addresses.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        if (m.addrs != null && m.addrs.length) {
          for (var i = 0; i < m.addrs.length; ++i)
            $root5.Addresses.Address.encode(m.addrs[i], w.uint32(10).fork()).ldelim();
        }
        if (m.certifiedRecord != null && Object.hasOwnProperty.call(m, "certifiedRecord"))
          $root5.Addresses.CertifiedRecord.encode(m.certifiedRecord, w.uint32(18).fork()).ldelim();
        return w;
      };
      Addresses.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Addresses();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              if (!(m.addrs && m.addrs.length))
                m.addrs = [];
              m.addrs.push($root5.Addresses.Address.decode(r, r.uint32()));
              break;
            case 2:
              m.certifiedRecord = $root5.Addresses.CertifiedRecord.decode(r, r.uint32());
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Addresses.fromObject = function fromObject(d) {
        if (d instanceof $root5.Addresses)
          return d;
        var m = new $root5.Addresses();
        if (d.addrs) {
          if (!Array.isArray(d.addrs))
            throw TypeError(".Addresses.addrs: array expected");
          m.addrs = [];
          for (var i = 0; i < d.addrs.length; ++i) {
            if (typeof d.addrs[i] !== "object")
              throw TypeError(".Addresses.addrs: object expected");
            m.addrs[i] = $root5.Addresses.Address.fromObject(d.addrs[i]);
          }
        }
        if (d.certifiedRecord != null) {
          if (typeof d.certifiedRecord !== "object")
            throw TypeError(".Addresses.certifiedRecord: object expected");
          m.certifiedRecord = $root5.Addresses.CertifiedRecord.fromObject(d.certifiedRecord);
        }
        return m;
      };
      Addresses.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.addrs = [];
        }
        if (o.defaults) {
          d.certifiedRecord = null;
        }
        if (m.addrs && m.addrs.length) {
          d.addrs = [];
          for (var j = 0; j < m.addrs.length; ++j) {
            d.addrs[j] = $root5.Addresses.Address.toObject(m.addrs[j], o);
          }
        }
        if (m.certifiedRecord != null && m.hasOwnProperty("certifiedRecord")) {
          d.certifiedRecord = $root5.Addresses.CertifiedRecord.toObject(m.certifiedRecord, o);
        }
        return d;
      };
      Addresses.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      Addresses.Address = function() {
        function Address(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Address.prototype.multiaddr = $util5.newBuffer([]);
        Address.prototype.isCertified = false;
        Address.encode = function encode10(m, w) {
          if (!w)
            w = $Writer5.create();
          if (m.multiaddr != null && Object.hasOwnProperty.call(m, "multiaddr"))
            w.uint32(10).bytes(m.multiaddr);
          if (m.isCertified != null && Object.hasOwnProperty.call(m, "isCertified"))
            w.uint32(16).bool(m.isCertified);
          return w;
        };
        Address.decode = function decode12(r, l) {
          if (!(r instanceof $Reader5))
            r = $Reader5.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Addresses.Address();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.multiaddr = r.bytes();
                break;
              case 2:
                m.isCertified = r.bool();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        Address.fromObject = function fromObject(d) {
          if (d instanceof $root5.Addresses.Address)
            return d;
          var m = new $root5.Addresses.Address();
          if (d.multiaddr != null) {
            if (typeof d.multiaddr === "string")
              $util5.base64.decode(d.multiaddr, m.multiaddr = $util5.newBuffer($util5.base64.length(d.multiaddr)), 0);
            else if (d.multiaddr.length)
              m.multiaddr = d.multiaddr;
          }
          if (d.isCertified != null) {
            m.isCertified = Boolean(d.isCertified);
          }
          return m;
        };
        Address.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            if (o.bytes === String)
              d.multiaddr = "";
            else {
              d.multiaddr = [];
              if (o.bytes !== Array)
                d.multiaddr = $util5.newBuffer(d.multiaddr);
            }
            d.isCertified = false;
          }
          if (m.multiaddr != null && m.hasOwnProperty("multiaddr")) {
            d.multiaddr = o.bytes === String ? $util5.base64.encode(m.multiaddr, 0, m.multiaddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.multiaddr) : m.multiaddr;
          }
          if (m.isCertified != null && m.hasOwnProperty("isCertified")) {
            d.isCertified = m.isCertified;
          }
          return d;
        };
        Address.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
        };
        return Address;
      }();
      Addresses.CertifiedRecord = function() {
        function CertifiedRecord(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        CertifiedRecord.prototype.seq = $util5.Long ? $util5.Long.fromBits(0, 0, true) : 0;
        CertifiedRecord.prototype.raw = $util5.newBuffer([]);
        CertifiedRecord.encode = function encode10(m, w) {
          if (!w)
            w = $Writer5.create();
          if (m.seq != null && Object.hasOwnProperty.call(m, "seq"))
            w.uint32(8).uint64(m.seq);
          if (m.raw != null && Object.hasOwnProperty.call(m, "raw"))
            w.uint32(18).bytes(m.raw);
          return w;
        };
        CertifiedRecord.decode = function decode12(r, l) {
          if (!(r instanceof $Reader5))
            r = $Reader5.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Addresses.CertifiedRecord();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.seq = r.uint64();
                break;
              case 2:
                m.raw = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        CertifiedRecord.fromObject = function fromObject(d) {
          if (d instanceof $root5.Addresses.CertifiedRecord)
            return d;
          var m = new $root5.Addresses.CertifiedRecord();
          if (d.seq != null) {
            if ($util5.Long)
              (m.seq = $util5.Long.fromValue(d.seq)).unsigned = true;
            else if (typeof d.seq === "string")
              m.seq = parseInt(d.seq, 10);
            else if (typeof d.seq === "number")
              m.seq = d.seq;
            else if (typeof d.seq === "object")
              m.seq = new $util5.LongBits(d.seq.low >>> 0, d.seq.high >>> 0).toNumber(true);
          }
          if (d.raw != null) {
            if (typeof d.raw === "string")
              $util5.base64.decode(d.raw, m.raw = $util5.newBuffer($util5.base64.length(d.raw)), 0);
            else if (d.raw.length)
              m.raw = d.raw;
          }
          return m;
        };
        CertifiedRecord.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            if ($util5.Long) {
              var n = new $util5.Long(0, 0, true);
              d.seq = o.longs === String ? n.toString() : o.longs === Number ? n.toNumber() : n;
            } else
              d.seq = o.longs === String ? "0" : 0;
            if (o.bytes === String)
              d.raw = "";
            else {
              d.raw = [];
              if (o.bytes !== Array)
                d.raw = $util5.newBuffer(d.raw);
            }
          }
          if (m.seq != null && m.hasOwnProperty("seq")) {
            if (typeof m.seq === "number")
              d.seq = o.longs === String ? String(m.seq) : m.seq;
            else
              d.seq = o.longs === String ? $util5.Long.prototype.toString.call(m.seq) : o.longs === Number ? new $util5.LongBits(m.seq.low >>> 0, m.seq.high >>> 0).toNumber(true) : m.seq;
          }
          if (m.raw != null && m.hasOwnProperty("raw")) {
            d.raw = o.bytes === String ? $util5.base64.encode(m.raw, 0, m.raw.length) : o.bytes === Array ? Array.prototype.slice.call(m.raw) : m.raw;
          }
          return d;
        };
        CertifiedRecord.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
        };
        return CertifiedRecord;
      }();
      return Addresses;
    }();
    module2.exports = $root5;
  }
});

// node_modules/libp2p/src/peer-store/persistent/pb/proto-book.js
var require_proto_book2 = __commonJS({
  "node_modules/libp2p/src/peer-store/persistent/pb/proto-book.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var $protobuf5 = require_minimal2();
    var $Reader5 = $protobuf5.Reader;
    var $Writer5 = $protobuf5.Writer;
    var $util5 = $protobuf5.util;
    var $root5 = $protobuf5.roots["libp2p-proto-book"] || ($protobuf5.roots["libp2p-proto-book"] = {});
    $root5.Protocols = function() {
      function Protocols(p) {
        this.protocols = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Protocols.prototype.protocols = $util5.emptyArray;
      Protocols.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        if (m.protocols != null && m.protocols.length) {
          for (var i = 0; i < m.protocols.length; ++i)
            w.uint32(10).string(m.protocols[i]);
        }
        return w;
      };
      Protocols.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Protocols();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              if (!(m.protocols && m.protocols.length))
                m.protocols = [];
              m.protocols.push(r.string());
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Protocols.fromObject = function fromObject(d) {
        if (d instanceof $root5.Protocols)
          return d;
        var m = new $root5.Protocols();
        if (d.protocols) {
          if (!Array.isArray(d.protocols))
            throw TypeError(".Protocols.protocols: array expected");
          m.protocols = [];
          for (var i = 0; i < d.protocols.length; ++i) {
            m.protocols[i] = String(d.protocols[i]);
          }
        }
        return m;
      };
      Protocols.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.protocols = [];
        }
        if (m.protocols && m.protocols.length) {
          d.protocols = [];
          for (var j = 0; j < m.protocols.length; ++j) {
            d.protocols[j] = m.protocols[j];
          }
        }
        return d;
      };
      Protocols.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      return Protocols;
    }();
    module2.exports = $root5;
  }
});

// node_modules/libp2p/src/peer-store/persistent/index.js
var require_persistent = __commonJS({
  "node_modules/libp2p/src/peer-store/persistent/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:persistent-peer-store"), {
      error: debug17("libp2p:persistent-peer-store:err")
    });
    var { Key: Key2 } = (init_key(), key_exports);
    var { Multiaddr: Multiaddr18 } = require_src();
    var PeerId2 = require_src6();
    var { base32: base322 } = (init_base32(), base32_exports);
    var PeerStore = require_peer_store();
    var {
      NAMESPACE_ADDRESS,
      NAMESPACE_COMMON,
      NAMESPACE_KEYS,
      NAMESPACE_METADATA,
      NAMESPACE_PROTOCOL
    } = require_consts3();
    var { Addresses } = require_address_book2();
    var { Protocols } = require_proto_book2();
    var PersistentPeerStore = class extends PeerStore {
      constructor({ peerId, datastore, threshold = 5 }) {
        super({ peerId });
        this._datastore = datastore;
        this._dirtyPeers = new Set();
        this._dirtyMetadata = new Map();
        this.threshold = threshold;
        this._addDirtyPeer = this._addDirtyPeer.bind(this);
      }
      async start() {
        log15("PeerStore is starting");
        this.on("change:protocols", this._addDirtyPeer);
        this.on("change:multiaddrs", this._addDirtyPeer);
        this.on("change:pubkey", this._addDirtyPeerKey);
        this.on("change:metadata", this._addDirtyPeerMetadata);
        for await (const entry of this._datastore.query({ prefix: NAMESPACE_COMMON })) {
          await this._processDatastoreEntry(entry);
        }
        log15("PeerStore started");
      }
      async stop() {
        log15("PeerStore is stopping");
        this.removeAllListeners();
        await this._commitData();
        log15("PeerStore stopped");
      }
      _addDirtyPeer({ peerId }) {
        const peerIdstr = peerId.toB58String();
        log15("add dirty peer", peerIdstr);
        this._dirtyPeers.add(peerIdstr);
        if (this._dirtyPeers.size >= this.threshold) {
          this._commitData().catch((err) => {
            log15.error("error committing data", err);
          });
        }
      }
      _addDirtyPeerKey({ peerId }) {
        if (peerId.hasInlinePublicKey()) {
          return;
        }
        const peerIdstr = peerId.toB58String();
        log15("add dirty peer key", peerIdstr);
        this._dirtyPeers.add(peerIdstr);
        if (this._dirtyPeers.size >= this.threshold) {
          this._commitData().catch((err) => {
            log15.error("error committing data", err);
          });
        }
      }
      _addDirtyPeerMetadata({ peerId, metadata }) {
        const peerIdstr = peerId.toB58String();
        log15("add dirty metadata peer", peerIdstr);
        this._dirtyPeers.add(peerIdstr);
        const mData = this._dirtyMetadata.get(peerIdstr) || new Set();
        mData.add(metadata);
        this._dirtyMetadata.set(peerIdstr, mData);
        if (this._dirtyPeers.size >= this.threshold) {
          this._commitData().catch((err) => {
            log15.error("error committing data", err);
          });
        }
      }
      async _commitData() {
        const commitPeers = Array.from(this._dirtyPeers);
        if (!commitPeers.length) {
          return;
        }
        this._dirtyPeers.clear();
        log15("create batch commit");
        const batch3 = this._datastore.batch();
        for (const peerIdStr of commitPeers) {
          const peerId = this.keyBook.data.get(peerIdStr) || PeerId2.createFromB58String(peerIdStr);
          this._batchAddressBook(peerId, batch3);
          !peerId.hasInlinePublicKey() && this._batchKeyBook(peerId, batch3);
          this._batchMetadataBook(peerId, batch3);
          this._batchProtoBook(peerId, batch3);
        }
        await batch3.commit();
        log15("batch committed");
      }
      _batchAddressBook(peerId, batch3) {
        const b32key = peerId.toString();
        const key = new Key2(`${NAMESPACE_ADDRESS}${b32key}`);
        const entry = this.addressBook.data.get(peerId.toB58String());
        try {
          if (!entry) {
            batch3.delete(key);
            return;
          }
          const encodedData = Addresses.encode({
            addrs: entry.addresses.map((address) => ({
              multiaddr: address.multiaddr.bytes,
              isCertified: address.isCertified
            })),
            certifiedRecord: entry.record ? {
              seq: entry.record.seqNumber,
              raw: entry.record.raw
            } : void 0
          }).finish();
          batch3.put(key, encodedData);
        } catch (err) {
          log15.error(err);
        }
      }
      _batchKeyBook(peerId, batch3) {
        const b32key = peerId.toString();
        const key = new Key2(`${NAMESPACE_KEYS}${b32key}`);
        try {
          if (!peerId.pubKey) {
            batch3.delete(key);
            return;
          }
          const encodedData = peerId.marshalPubKey();
          batch3.put(key, encodedData);
        } catch (err) {
          log15.error(err);
        }
      }
      _batchMetadataBook(peerId, batch3) {
        const b32key = peerId.toString();
        const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];
        try {
          dirtyMetada.forEach((dirtyKey) => {
            const key = new Key2(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`);
            const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey);
            if (dirtyValue) {
              batch3.put(key, dirtyValue);
            } else {
              batch3.delete(key);
            }
          });
        } catch (err) {
          log15.error(err);
        }
      }
      _batchProtoBook(peerId, batch3) {
        const b32key = peerId.toString();
        const key = new Key2(`${NAMESPACE_PROTOCOL}${b32key}`);
        const protocols = this.protoBook.get(peerId);
        try {
          if (!protocols) {
            batch3.delete(key);
            return;
          }
          const encodedData = Protocols.encode({ protocols }).finish();
          batch3.put(key, encodedData);
        } catch (err) {
          log15.error(err);
        }
      }
      async _processDatastoreEntry({ key, value }) {
        try {
          const keyParts = key.toString().split("/");
          const peerId = PeerId2.createFromBytes(base322.decode(keyParts[3]));
          let decoded;
          switch (keyParts[2]) {
            case "addrs":
              decoded = Addresses.decode(value);
              this.addressBook._setData(peerId, {
                addresses: decoded.addrs.map((address) => ({
                  multiaddr: new Multiaddr18(address.multiaddr),
                  isCertified: Boolean(address.isCertified)
                })),
                record: decoded.certifiedRecord ? {
                  raw: decoded.certifiedRecord.raw,
                  seqNumber: decoded.certifiedRecord.seq
                } : void 0
              }, { emit: false });
              break;
            case "keys":
              decoded = await PeerId2.createFromPubKey(value);
              this.keyBook._setData(decoded, decoded, { emit: false });
              break;
            case "metadata":
              this.metadataBook._setValue(peerId, keyParts[4], value, { emit: false });
              break;
            case "protos":
              decoded = Protocols.decode(value);
              this.protoBook._setData(peerId, new Set(decoded.protocols), { emit: false });
              break;
            default:
              log15("invalid data persisted for: ", key.toString());
          }
        } catch (err) {
          log15.error(err);
        }
      }
    };
    module2.exports = PersistentPeerStore;
  }
});

// node_modules/libp2p/src/registrar.js
var require_registrar = __commonJS({
  "node_modules/libp2p/src/registrar.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:registrar"), {
      error: debug17("libp2p:registrar:err")
    });
    var errcode7 = require_err_code();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors4();
    var Topology = require_topology();
    var Registrar = class {
      constructor({ peerStore, connectionManager }) {
        this.peerStore = peerStore;
        this.connectionManager = connectionManager;
        this.topologies = new Map();
        this._handle = void 0;
        this._onDisconnect = this._onDisconnect.bind(this);
        this.connectionManager.on("peer:disconnect", this._onDisconnect);
      }
      get handle() {
        return this._handle;
      }
      set handle(handle) {
        this._handle = handle;
      }
      getConnection(peerId) {
        return this.connectionManager.get(peerId);
      }
      register(topology) {
        if (!Topology.isTopology(topology)) {
          log15.error("topology must be an instance of interfaces/topology");
          throw errcode7(new Error("topology must be an instance of interfaces/topology"), ERR_INVALID_PARAMETERS);
        }
        const id = (Math.random() * 1e9).toString(36) + Date.now();
        this.topologies.set(id, topology);
        topology.registrar = this;
        return id;
      }
      unregister(id) {
        return this.topologies.delete(id);
      }
      _onDisconnect(connection) {
        for (const [, topology] of this.topologies) {
          topology.disconnect(connection.remotePeer);
        }
      }
    };
    module2.exports = Registrar;
  }
});

// node_modules/libp2p/src/ping/constants.js
var require_constants14 = __commonJS({
  "node_modules/libp2p/src/ping/constants.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    module2.exports = {
      PROTOCOL: "/ipfs/ping/1.0.0",
      PING_LENGTH: 32,
      PROTOCOL_VERSION: "1.0.0",
      PROTOCOL_NAME: "ping"
    };
  }
});

// node_modules/libp2p/src/ping/index.js
var require_ping2 = __commonJS({
  "node_modules/libp2p/src/ping/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:ping"), {
      error: debug17("libp2p:ping:err")
    });
    var errCode32 = require_err_code();
    var crypto3 = require_src7();
    var { pipe: pipe4 } = require_it_pipe();
    var { toBuffer } = require_it_buffer();
    var { collect, take: take5 } = require_dist2();
    var { equals: equals4 } = (init_equals(), equals_exports);
    var { PROTOCOL_NAME, PING_LENGTH, PROTOCOL_VERSION } = require_constants14();
    async function ping(node, peer) {
      const protocol = `/${node._config.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`;
      log15("dialing %s to %s", protocol, peer.toB58String ? peer.toB58String() : peer);
      const connection = await node.dial(peer);
      const { stream } = await connection.newStream(protocol);
      const start = Date.now();
      const data = crypto3.randomBytes(PING_LENGTH);
      const [result] = await pipe4([data], stream, (stream2) => take5(1, stream2), toBuffer, collect);
      const end = Date.now();
      if (!equals4(data, result)) {
        throw errCode32(new Error("Received wrong ping ack"), "ERR_WRONG_PING_ACK");
      }
      return end - start;
    }
    function mount(node) {
      node.handle(`/${node._config.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`, ({ stream }) => pipe4(stream, stream));
    }
    function unmount(node) {
      node.unhandle(`/${node._config.protocolPrefix}/${PROTOCOL_NAME}/${PROTOCOL_VERSION}`);
    }
    exports2 = module2.exports = ping;
    exports2.mount = mount;
    exports2.unmount = unmount;
  }
});

// node_modules/libp2p/src/identify/message.js
var require_message2 = __commonJS({
  "node_modules/libp2p/src/identify/message.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var $protobuf5 = require_minimal2();
    var $Reader5 = $protobuf5.Reader;
    var $Writer5 = $protobuf5.Writer;
    var $util5 = $protobuf5.util;
    var $root5 = $protobuf5.roots["libp2p-identify"] || ($protobuf5.roots["libp2p-identify"] = {});
    $root5.Identify = function() {
      function Identify(p) {
        this.listenAddrs = [];
        this.protocols = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Identify.prototype.protocolVersion = "";
      Identify.prototype.agentVersion = "";
      Identify.prototype.publicKey = $util5.newBuffer([]);
      Identify.prototype.listenAddrs = $util5.emptyArray;
      Identify.prototype.observedAddr = $util5.newBuffer([]);
      Identify.prototype.protocols = $util5.emptyArray;
      Identify.prototype.signedPeerRecord = $util5.newBuffer([]);
      Identify.encode = function encode10(m, w) {
        if (!w)
          w = $Writer5.create();
        if (m.publicKey != null && Object.hasOwnProperty.call(m, "publicKey"))
          w.uint32(10).bytes(m.publicKey);
        if (m.listenAddrs != null && m.listenAddrs.length) {
          for (var i = 0; i < m.listenAddrs.length; ++i)
            w.uint32(18).bytes(m.listenAddrs[i]);
        }
        if (m.protocols != null && m.protocols.length) {
          for (var i = 0; i < m.protocols.length; ++i)
            w.uint32(26).string(m.protocols[i]);
        }
        if (m.observedAddr != null && Object.hasOwnProperty.call(m, "observedAddr"))
          w.uint32(34).bytes(m.observedAddr);
        if (m.protocolVersion != null && Object.hasOwnProperty.call(m, "protocolVersion"))
          w.uint32(42).string(m.protocolVersion);
        if (m.agentVersion != null && Object.hasOwnProperty.call(m, "agentVersion"))
          w.uint32(50).string(m.agentVersion);
        if (m.signedPeerRecord != null && Object.hasOwnProperty.call(m, "signedPeerRecord"))
          w.uint32(66).bytes(m.signedPeerRecord);
        return w;
      };
      Identify.decode = function decode12(r, l) {
        if (!(r instanceof $Reader5))
          r = $Reader5.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root5.Identify();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 5:
              m.protocolVersion = r.string();
              break;
            case 6:
              m.agentVersion = r.string();
              break;
            case 1:
              m.publicKey = r.bytes();
              break;
            case 2:
              if (!(m.listenAddrs && m.listenAddrs.length))
                m.listenAddrs = [];
              m.listenAddrs.push(r.bytes());
              break;
            case 4:
              m.observedAddr = r.bytes();
              break;
            case 3:
              if (!(m.protocols && m.protocols.length))
                m.protocols = [];
              m.protocols.push(r.string());
              break;
            case 8:
              m.signedPeerRecord = r.bytes();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Identify.fromObject = function fromObject(d) {
        if (d instanceof $root5.Identify)
          return d;
        var m = new $root5.Identify();
        if (d.protocolVersion != null) {
          m.protocolVersion = String(d.protocolVersion);
        }
        if (d.agentVersion != null) {
          m.agentVersion = String(d.agentVersion);
        }
        if (d.publicKey != null) {
          if (typeof d.publicKey === "string")
            $util5.base64.decode(d.publicKey, m.publicKey = $util5.newBuffer($util5.base64.length(d.publicKey)), 0);
          else if (d.publicKey.length)
            m.publicKey = d.publicKey;
        }
        if (d.listenAddrs) {
          if (!Array.isArray(d.listenAddrs))
            throw TypeError(".Identify.listenAddrs: array expected");
          m.listenAddrs = [];
          for (var i = 0; i < d.listenAddrs.length; ++i) {
            if (typeof d.listenAddrs[i] === "string")
              $util5.base64.decode(d.listenAddrs[i], m.listenAddrs[i] = $util5.newBuffer($util5.base64.length(d.listenAddrs[i])), 0);
            else if (d.listenAddrs[i].length)
              m.listenAddrs[i] = d.listenAddrs[i];
          }
        }
        if (d.observedAddr != null) {
          if (typeof d.observedAddr === "string")
            $util5.base64.decode(d.observedAddr, m.observedAddr = $util5.newBuffer($util5.base64.length(d.observedAddr)), 0);
          else if (d.observedAddr.length)
            m.observedAddr = d.observedAddr;
        }
        if (d.protocols) {
          if (!Array.isArray(d.protocols))
            throw TypeError(".Identify.protocols: array expected");
          m.protocols = [];
          for (var i = 0; i < d.protocols.length; ++i) {
            m.protocols[i] = String(d.protocols[i]);
          }
        }
        if (d.signedPeerRecord != null) {
          if (typeof d.signedPeerRecord === "string")
            $util5.base64.decode(d.signedPeerRecord, m.signedPeerRecord = $util5.newBuffer($util5.base64.length(d.signedPeerRecord)), 0);
          else if (d.signedPeerRecord.length)
            m.signedPeerRecord = d.signedPeerRecord;
        }
        return m;
      };
      Identify.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.listenAddrs = [];
          d.protocols = [];
        }
        if (o.defaults) {
          if (o.bytes === String)
            d.publicKey = "";
          else {
            d.publicKey = [];
            if (o.bytes !== Array)
              d.publicKey = $util5.newBuffer(d.publicKey);
          }
          if (o.bytes === String)
            d.observedAddr = "";
          else {
            d.observedAddr = [];
            if (o.bytes !== Array)
              d.observedAddr = $util5.newBuffer(d.observedAddr);
          }
          d.protocolVersion = "";
          d.agentVersion = "";
          if (o.bytes === String)
            d.signedPeerRecord = "";
          else {
            d.signedPeerRecord = [];
            if (o.bytes !== Array)
              d.signedPeerRecord = $util5.newBuffer(d.signedPeerRecord);
          }
        }
        if (m.publicKey != null && m.hasOwnProperty("publicKey")) {
          d.publicKey = o.bytes === String ? $util5.base64.encode(m.publicKey, 0, m.publicKey.length) : o.bytes === Array ? Array.prototype.slice.call(m.publicKey) : m.publicKey;
        }
        if (m.listenAddrs && m.listenAddrs.length) {
          d.listenAddrs = [];
          for (var j = 0; j < m.listenAddrs.length; ++j) {
            d.listenAddrs[j] = o.bytes === String ? $util5.base64.encode(m.listenAddrs[j], 0, m.listenAddrs[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.listenAddrs[j]) : m.listenAddrs[j];
          }
        }
        if (m.protocols && m.protocols.length) {
          d.protocols = [];
          for (var j = 0; j < m.protocols.length; ++j) {
            d.protocols[j] = m.protocols[j];
          }
        }
        if (m.observedAddr != null && m.hasOwnProperty("observedAddr")) {
          d.observedAddr = o.bytes === String ? $util5.base64.encode(m.observedAddr, 0, m.observedAddr.length) : o.bytes === Array ? Array.prototype.slice.call(m.observedAddr) : m.observedAddr;
        }
        if (m.protocolVersion != null && m.hasOwnProperty("protocolVersion")) {
          d.protocolVersion = m.protocolVersion;
        }
        if (m.agentVersion != null && m.hasOwnProperty("agentVersion")) {
          d.agentVersion = m.agentVersion;
        }
        if (m.signedPeerRecord != null && m.hasOwnProperty("signedPeerRecord")) {
          d.signedPeerRecord = o.bytes === String ? $util5.base64.encode(m.signedPeerRecord, 0, m.signedPeerRecord.length) : o.bytes === Array ? Array.prototype.slice.call(m.signedPeerRecord) : m.signedPeerRecord;
        }
        return d;
      };
      Identify.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, $protobuf5.util.toJSONOptions);
      };
      return Identify;
    }();
    module2.exports = $root5;
  }
});

// node_modules/libp2p/src/identify/index.js
var require_identify = __commonJS({
  "node_modules/libp2p/src/identify/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p:identify"), {
      error: debug17("libp2p:identify:err")
    });
    var errCode32 = require_err_code();
    var lp2 = require_src12();
    var { pipe: pipe4 } = require_it_pipe();
    var { collect, take: take5, consume } = require_dist2();
    var { fromString: uint8ArrayFromString } = (init_from_string(), from_string_exports);
    var PeerId2 = require_src6();
    var { Multiaddr: Multiaddr18 } = require_src();
    var { toBuffer } = require_it_buffer();
    var Message2 = require_message2();
    var Envelope = require_envelope2();
    var PeerRecord = require_peer_record2();
    var {
      MULTICODEC_IDENTIFY,
      MULTICODEC_IDENTIFY_PUSH,
      IDENTIFY_PROTOCOL_VERSION,
      MULTICODEC_IDENTIFY_PROTOCOL_NAME,
      MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME,
      MULTICODEC_IDENTIFY_PROTOCOL_VERSION,
      MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION
    } = require_consts();
    var { codes } = require_errors4();
    var IdentifyService = class {
      static getProtocolStr(libp2p) {
        return {
          identifyProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PROTOCOL_VERSION}`,
          identifyPushProtocolStr: `/${libp2p._config.protocolPrefix}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_NAME}/${MULTICODEC_IDENTIFY_PUSH_PROTOCOL_VERSION}`
        };
      }
      constructor({ libp2p }) {
        this._libp2p = libp2p;
        this.peerStore = libp2p.peerStore;
        this.addressManager = libp2p.addressManager;
        this.connectionManager = libp2p.connectionManager;
        this.peerId = libp2p.peerId;
        this.handleMessage = this.handleMessage.bind(this);
        const protocolStr = IdentifyService.getProtocolStr(libp2p);
        this.identifyProtocolStr = protocolStr.identifyProtocolStr;
        this.identifyPushProtocolStr = protocolStr.identifyPushProtocolStr;
        this._host = {
          protocolVersion: `${libp2p._config.protocolPrefix}/${IDENTIFY_PROTOCOL_VERSION}`,
          ...libp2p._options.host
        };
        this.peerStore.metadataBook.set(this.peerId, "AgentVersion", uint8ArrayFromString(this._host.agentVersion));
        this.peerStore.metadataBook.set(this.peerId, "ProtocolVersion", uint8ArrayFromString(this._host.protocolVersion));
        this.connectionManager.on("peer:connect", (connection) => {
          this.identify(connection).catch(log15.error);
        });
        this.peerStore.on("change:multiaddrs", ({ peerId }) => {
          if (peerId.toString() === this.peerId.toString()) {
            this.pushToPeerStore();
          }
        });
        this.peerStore.on("change:protocols", ({ peerId }) => {
          if (peerId.toString() === this.peerId.toString()) {
            this.pushToPeerStore();
          }
        });
      }
      async push(connections) {
        const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId);
        const listenAddrs = this._libp2p.multiaddrs.map((ma) => ma.bytes);
        const protocols = this.peerStore.protoBook.get(this.peerId) || [];
        const pushes = connections.map(async (connection) => {
          try {
            const { stream } = await connection.newStream(this.identifyPushProtocolStr);
            await pipe4([Message2.Identify.encode({
              listenAddrs,
              signedPeerRecord,
              protocols
            }).finish()], lp2.encode(), stream, consume);
          } catch (err) {
            log15.error("could not push identify update to peer", err);
          }
        });
        return Promise.all(pushes);
      }
      pushToPeerStore() {
        if (!this._libp2p.isStarted()) {
          return;
        }
        const connections = [];
        let connection;
        for (const peer of this.peerStore.peers.values()) {
          if (peer.protocols.includes(this.identifyPushProtocolStr) && (connection = this.connectionManager.get(peer.id))) {
            connections.push(connection);
          }
        }
        this.push(connections);
      }
      async identify(connection) {
        const { stream } = await connection.newStream(this.identifyProtocolStr);
        const [data] = await pipe4([], stream, lp2.decode(), take5(1), toBuffer, collect);
        if (!data) {
          throw errCode32(new Error("No data could be retrieved"), codes.ERR_CONNECTION_ENDED);
        }
        let message;
        try {
          message = Message2.Identify.decode(data);
        } catch (err) {
          throw errCode32(err, codes.ERR_INVALID_MESSAGE);
        }
        const {
          publicKey,
          listenAddrs,
          protocols,
          observedAddr,
          signedPeerRecord
        } = message;
        const id = await PeerId2.createFromPubKey(publicKey);
        if (connection.remotePeer.toB58String() !== id.toB58String()) {
          throw errCode32(new Error("identified peer does not match the expected peer"), codes.ERR_INVALID_PEER);
        }
        const cleanObservedAddr = IdentifyService.getCleanMultiaddr(observedAddr);
        try {
          const envelope = await Envelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);
          if (this.peerStore.addressBook.consumePeerRecord(envelope)) {
            this.peerStore.protoBook.set(id, protocols);
            this.peerStore.metadataBook.set(id, "AgentVersion", uint8ArrayFromString(message.agentVersion));
            this.peerStore.metadataBook.set(id, "ProtocolVersion", uint8ArrayFromString(message.protocolVersion));
            return;
          }
        } catch (err) {
          log15("received invalid envelope, discard it and fallback to listenAddrs is available", err);
        }
        try {
          this.peerStore.addressBook.set(id, listenAddrs.map((addr) => new Multiaddr18(addr)));
        } catch (err) {
          log15.error("received invalid addrs", err);
        }
        this.peerStore.protoBook.set(id, protocols);
        this.peerStore.metadataBook.set(id, "AgentVersion", uint8ArrayFromString(message.agentVersion));
        this.peerStore.metadataBook.set(id, "ProtocolVersion", uint8ArrayFromString(message.protocolVersion));
        log15("received observed address of %s", cleanObservedAddr);
      }
      handleMessage({ connection, stream, protocol }) {
        switch (protocol) {
          case this.identifyProtocolStr:
            return this._handleIdentify({ connection, stream });
          case this.identifyPushProtocolStr:
            return this._handlePush({ connection, stream });
          default:
            log15.error("cannot handle unknown protocol %s", protocol);
        }
      }
      async _handleIdentify({ connection, stream }) {
        let publicKey = new Uint8Array(0);
        if (this.peerId.pubKey) {
          publicKey = this.peerId.pubKey.bytes;
        }
        const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId);
        const protocols = this.peerStore.protoBook.get(this.peerId) || [];
        const message = Message2.Identify.encode({
          protocolVersion: this._host.protocolVersion,
          agentVersion: this._host.agentVersion,
          publicKey,
          listenAddrs: this._libp2p.multiaddrs.map((ma) => ma.bytes),
          signedPeerRecord,
          observedAddr: connection.remoteAddr.bytes,
          protocols
        }).finish();
        try {
          await pipe4([message], lp2.encode(), stream, consume);
        } catch (err) {
          log15.error("could not respond to identify request", err);
        }
      }
      async _handlePush({ connection, stream }) {
        let message;
        try {
          const [data] = await pipe4([], stream, lp2.decode(), take5(1), toBuffer, collect);
          message = Message2.Identify.decode(data);
        } catch (err) {
          return log15.error("received invalid message", err);
        }
        const id = connection.remotePeer;
        try {
          const envelope = await Envelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN);
          if (this.peerStore.addressBook.consumePeerRecord(envelope)) {
            this.peerStore.protoBook.set(id, message.protocols);
            return;
          }
        } catch (err) {
          log15("received invalid envelope, discard it and fallback to listenAddrs is available", err);
        }
        try {
          this.peerStore.addressBook.set(id, message.listenAddrs.map((addr) => new Multiaddr18(addr)));
        } catch (err) {
          log15.error("received invalid addrs", err);
        }
        this.peerStore.protoBook.set(id, message.protocols);
      }
      static getCleanMultiaddr(addr) {
        if (addr && addr.length > 0) {
          try {
            return new Multiaddr18(addr);
          } catch (_) {
            return null;
          }
        }
        return null;
      }
    };
    var multicodecs = {
      IDENTIFY: MULTICODEC_IDENTIFY,
      IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH
    };
    IdentifyService.multicodecs = multicodecs;
    IdentifyService.Messsage = Message2;
    module2.exports = IdentifyService;
  }
});

// (disabled):node_modules/@motrix/nat-api/index.js
var require_nat_api = __commonJS({
  "(disabled):node_modules/@motrix/nat-api/index.js"() {
    init_node_globals();
  }
});

// node_modules/es6-promisify/dist/promisify.js
var require_promisify = __commonJS({
  "node_modules/es6-promisify/dist/promisify.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true }), exports2.promisify = promisify;
    var customArgumentsToken = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__";
    function promisify(a) {
      if (typeof a != "function")
        throw new TypeError("Argument to promisify must be a function");
      var b = a[customArgumentsToken], c = promisify.Promise || Promise;
      if (typeof c != "function")
        throw new Error("No Promise implementation found; do you need a polyfill?");
      return function() {
        for (var d = this, e = arguments.length, f = Array(e), g = 0; g < e; g++)
          f[g] = arguments[g];
        return new c(function(c2, e2) {
          f.push(function(a2) {
            if (a2)
              return e2(a2);
            for (var d2 = arguments.length, f2 = Array(1 < d2 ? d2 - 1 : 0), g2 = 1; g2 < d2; g2++)
              f2[g2 - 1] = arguments[g2];
            if (f2.length === 1 || !b)
              return c2(f2[0]);
            var h = {};
            f2.forEach(function(a3, c3) {
              var d3 = b[c3];
              d3 && (h[d3] = a3);
            }), c2(h);
          }), a.apply(d, f);
        });
      };
    }
    promisify.argumentNames = "__ES6-PROMISIFY--CUSTOM-ARGUMENTS__", promisify.Promise = void 0;
  }
});

// node_modules/wherearewe/src/index.js
var require_src28 = __commonJS({
  "node_modules/wherearewe/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var isElectron = require_is_electron();
    var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
    var IS_ELECTRON = isElectron();
    var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
    var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
    var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
    var IS_NODE = typeof __require === "function" && typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
    var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
    var IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && false;
    module2.exports = {
      isTest: IS_TEST,
      isElectron: IS_ELECTRON,
      isElectronMain: IS_ELECTRON_MAIN,
      isElectronRenderer: IS_ELECTRON_RENDERER,
      isNode: IS_NODE,
      isBrowser: IS_BROWSER,
      isWebWorker: IS_WEBWORKER,
      isEnvWithDom: IS_ENV_WITH_DOM
    };
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS({
  "node_modules/retry/lib/retry_operation.js"(exports2, module2) {
    init_node_globals();
    function RetryOperation(timeouts, options) {
      if (typeof options === "boolean") {
        options = { forever: options };
      }
      this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
      this._timeouts = timeouts;
      this._options = options || {};
      this._maxRetryTime = options && options.maxRetryTime || Infinity;
      this._fn = null;
      this._errors = [];
      this._attempts = 1;
      this._operationTimeout = null;
      this._operationTimeoutCb = null;
      this._timeout = null;
      this._operationStart = null;
      this._timer = null;
      if (this._options.forever) {
        this._cachedTimeouts = this._timeouts.slice(0);
      }
    }
    module2.exports = RetryOperation;
    RetryOperation.prototype.reset = function() {
      this._attempts = 1;
      this._timeouts = this._originalTimeouts.slice(0);
    };
    RetryOperation.prototype.stop = function() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (this._timer) {
        clearTimeout(this._timer);
      }
      this._timeouts = [];
      this._cachedTimeouts = null;
    };
    RetryOperation.prototype.retry = function(err) {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      if (!err) {
        return false;
      }
      var currentTime = new Date().getTime();
      if (err && currentTime - this._operationStart >= this._maxRetryTime) {
        this._errors.push(err);
        this._errors.unshift(new Error("RetryOperation timeout occurred"));
        return false;
      }
      this._errors.push(err);
      var timeout = this._timeouts.shift();
      if (timeout === void 0) {
        if (this._cachedTimeouts) {
          this._errors.splice(0, this._errors.length - 1);
          timeout = this._cachedTimeouts.slice(-1);
        } else {
          return false;
        }
      }
      var self2 = this;
      this._timer = setTimeout(function() {
        self2._attempts++;
        if (self2._operationTimeoutCb) {
          self2._timeout = setTimeout(function() {
            self2._operationTimeoutCb(self2._attempts);
          }, self2._operationTimeout);
          if (self2._options.unref) {
            self2._timeout.unref();
          }
        }
        self2._fn(self2._attempts);
      }, timeout);
      if (this._options.unref) {
        this._timer.unref();
      }
      return true;
    };
    RetryOperation.prototype.attempt = function(fn, timeoutOps) {
      this._fn = fn;
      if (timeoutOps) {
        if (timeoutOps.timeout) {
          this._operationTimeout = timeoutOps.timeout;
        }
        if (timeoutOps.cb) {
          this._operationTimeoutCb = timeoutOps.cb;
        }
      }
      var self2 = this;
      if (this._operationTimeoutCb) {
        this._timeout = setTimeout(function() {
          self2._operationTimeoutCb();
        }, self2._operationTimeout);
      }
      this._operationStart = new Date().getTime();
      this._fn(this._attempts);
    };
    RetryOperation.prototype.try = function(fn) {
      console.log("Using RetryOperation.try() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = function(fn) {
      console.log("Using RetryOperation.start() is deprecated");
      this.attempt(fn);
    };
    RetryOperation.prototype.start = RetryOperation.prototype.try;
    RetryOperation.prototype.errors = function() {
      return this._errors;
    };
    RetryOperation.prototype.attempts = function() {
      return this._attempts;
    };
    RetryOperation.prototype.mainError = function() {
      if (this._errors.length === 0) {
        return null;
      }
      var counts = {};
      var mainError = null;
      var mainErrorCount = 0;
      for (var i = 0; i < this._errors.length; i++) {
        var error = this._errors[i];
        var message = error.message;
        var count = (counts[message] || 0) + 1;
        counts[message] = count;
        if (count >= mainErrorCount) {
          mainError = error;
          mainErrorCount = count;
        }
      }
      return mainError;
    };
  }
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS({
  "node_modules/retry/lib/retry.js"(exports2) {
    init_node_globals();
    var RetryOperation = require_retry_operation();
    exports2.operation = function(options) {
      var timeouts = exports2.timeouts(options);
      return new RetryOperation(timeouts, {
        forever: options && (options.forever || options.retries === Infinity),
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
      });
    };
    exports2.timeouts = function(options) {
      if (options instanceof Array) {
        return [].concat(options);
      }
      var opts = {
        retries: 10,
        factor: 2,
        minTimeout: 1 * 1e3,
        maxTimeout: Infinity,
        randomize: false
      };
      for (var key in options) {
        opts[key] = options[key];
      }
      if (opts.minTimeout > opts.maxTimeout) {
        throw new Error("minTimeout is greater than maxTimeout");
      }
      var timeouts = [];
      for (var i = 0; i < opts.retries; i++) {
        timeouts.push(this.createTimeout(i, opts));
      }
      if (options && options.forever && !timeouts.length) {
        timeouts.push(this.createTimeout(i, opts));
      }
      timeouts.sort(function(a, b) {
        return a - b;
      });
      return timeouts;
    };
    exports2.createTimeout = function(attempt, opts) {
      var random2 = opts.randomize ? Math.random() + 1 : 1;
      var timeout = Math.round(random2 * Math.max(opts.minTimeout, 1) * Math.pow(opts.factor, attempt));
      timeout = Math.min(timeout, opts.maxTimeout);
      return timeout;
    };
    exports2.wrap = function(obj, options, methods) {
      if (options instanceof Array) {
        methods = options;
        options = null;
      }
      if (!methods) {
        methods = [];
        for (var key in obj) {
          if (typeof obj[key] === "function") {
            methods.push(key);
          }
        }
      }
      for (var i = 0; i < methods.length; i++) {
        var method = methods[i];
        var original = obj[method];
        obj[method] = function retryWrapper(original2) {
          var op = exports2.operation(options);
          var args = Array.prototype.slice.call(arguments, 1);
          var callback = args.pop();
          args.push(function(err) {
            if (op.retry(err)) {
              return;
            }
            if (err) {
              arguments[0] = op.mainError();
            }
            callback.apply(this, arguments);
          });
          op.attempt(function() {
            original2.apply(obj, args);
          });
        }.bind(obj, original);
        obj[method].options = options;
      }
    };
  }
});

// node_modules/retry/index.js
var require_retry2 = __commonJS({
  "node_modules/retry/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = require_retry();
  }
});

// node_modules/p-retry/index.js
var require_p_retry = __commonJS({
  "node_modules/p-retry/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var retry = require_retry2();
    var networkErrorMsgs = [
      "Failed to fetch",
      "NetworkError when attempting to fetch resource.",
      "The Internet connection appears to be offline.",
      "Network request failed"
    ];
    var AbortError = class extends Error {
      constructor(message) {
        super();
        if (message instanceof Error) {
          this.originalError = message;
          ({ message } = message);
        } else {
          this.originalError = new Error(message);
          this.originalError.stack = this.stack;
        }
        this.name = "AbortError";
        this.message = message;
      }
    };
    var decorateErrorWithCounts = (error, attemptNumber, options) => {
      const retriesLeft = options.retries - (attemptNumber - 1);
      error.attemptNumber = attemptNumber;
      error.retriesLeft = retriesLeft;
      return error;
    };
    var isNetworkError = (errorMessage) => networkErrorMsgs.includes(errorMessage);
    var pRetry = (input, options) => new Promise((resolve6, reject) => {
      options = {
        onFailedAttempt: () => {
        },
        retries: 10,
        ...options
      };
      const operation = retry.operation(options);
      operation.attempt(async (attemptNumber) => {
        try {
          resolve6(await input(attemptNumber));
        } catch (error) {
          if (!(error instanceof Error)) {
            reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
            return;
          }
          if (error instanceof AbortError) {
            operation.stop();
            reject(error.originalError);
          } else if (error instanceof TypeError && !isNetworkError(error.message)) {
            operation.stop();
            reject(error);
          } else {
            decorateErrorWithCounts(error, attemptNumber, options);
            try {
              await options.onFailedAttempt(error);
            } catch (error2) {
              reject(error2);
              return;
            }
            if (!operation.retry(error)) {
              reject(operation.mainError());
            }
          }
        }
      });
    });
    module2.exports = pRetry;
    module2.exports.default = pRetry;
    module2.exports.AbortError = AbortError;
  }
});

// node_modules/is-loopback-addr/index.js
var require_is_loopback_addr = __commonJS({
  "node_modules/is-loopback-addr/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    function isLoopbackAddr(ip) {
      return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
    }
    module2.exports = isLoopbackAddr;
  }
});

// node_modules/libp2p-utils/src/multiaddr/is-loopback.js
var require_is_loopback = __commonJS({
  "node_modules/libp2p-utils/src/multiaddr/is-loopback.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var isLoopbackAddr = require_is_loopback_addr();
    function isLoopback(ma) {
      const { address } = ma.nodeAddress();
      return isLoopbackAddr(address);
    }
    module2.exports = isLoopback;
  }
});

// node_modules/libp2p/src/nat-manager.js
var require_nat_manager = __commonJS({
  "node_modules/libp2p/src/nat-manager.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var NatAPI = require_nat_api();
    var debug17 = require_browser2();
    var { promisify } = require_promisify();
    var { Multiaddr: Multiaddr18 } = require_src();
    var log15 = Object.assign(debug17("libp2p:nat"), {
      error: debug17("libp2p:nat:err")
    });
    var { isBrowser: isBrowser2 } = require_src28();
    var retry = require_p_retry();
    var isPrivateIp = require_private_ip();
    var pkg = require_package2();
    var errcode7 = require_err_code();
    var {
      codes: { ERR_INVALID_PARAMETERS }
    } = require_errors4();
    var isLoopback = require_is_loopback();
    var DEFAULT_TTL = 7200;
    function highPort(min = 1024, max = 65535) {
      return Math.floor(Math.random() * (max - min + 1) + min);
    }
    var NatManager = class {
      constructor({ peerId, addressManager, transportManager, ...options }) {
        this._peerId = peerId;
        this._addressManager = addressManager;
        this._transportManager = transportManager;
        this._enabled = options.enabled;
        this._externalIp = options.externalIp;
        this._options = {
          description: options.description || `${pkg.name}@${pkg.version} ${this._peerId}`,
          ttl: options.ttl || DEFAULT_TTL,
          autoUpdate: options.keepAlive || true,
          gateway: options.gateway,
          enablePMP: Boolean(options.pmp && options.pmp.enabled)
        };
        if (this._options.ttl < DEFAULT_TTL) {
          throw errcode7(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), ERR_INVALID_PARAMETERS);
        }
      }
      start() {
        if (isBrowser2 || !this._enabled) {
          return;
        }
        this._start().catch((err) => {
          log15.error(err);
        });
      }
      async _start() {
        const addrs = this._transportManager.getAddrs();
        for (const addr of addrs) {
          const { family, host, port, transport } = addr.toOptions();
          if (!addr.isThinWaistAddress() || transport !== "tcp") {
            continue;
          }
          if (isLoopback(addr)) {
            continue;
          }
          if (family !== 4) {
            continue;
          }
          const client = this._getClient();
          const publicIp = this._externalIp || await client.externalIp();
          if (isPrivateIp(publicIp)) {
            throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
          }
          const publicPort = highPort();
          log15(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);
          await client.map({
            publicPort,
            privatePort: port,
            protocol: transport.toUpperCase()
          });
          this._addressManager.addObservedAddr(Multiaddr18.fromNodeAddress({
            family: 4,
            address: publicIp,
            port: publicPort
          }, transport));
        }
      }
      _getClient() {
        if (this._client) {
          return this._client;
        }
        const client = new NatAPI(this._options);
        const map8 = promisify(client.map.bind(client));
        const destroy = promisify(client.destroy.bind(client));
        const externalIp = promisify(client.externalIp.bind(client));
        this._client = {
          map: (...args) => retry(() => map8(...args), { onFailedAttempt: log15.error, unref: true }),
          destroy: (...args) => retry(() => destroy(...args), { onFailedAttempt: log15.error, unref: true }),
          externalIp: (...args) => retry(() => externalIp(...args), { onFailedAttempt: log15.error, unref: true })
        };
        return this._client;
      }
      async stop() {
        if (isBrowser2 || !this._client) {
          return;
        }
        try {
          await this._client.destroy();
          this._client = null;
        } catch (err) {
          log15.error(err);
        }
      }
    };
    module2.exports = NatManager;
  }
});

// node_modules/libp2p/src/index.js
var require_src29 = __commonJS({
  "node_modules/libp2p/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var debug17 = require_browser2();
    var log15 = Object.assign(debug17("libp2p"), {
      error: debug17("libp2p:err")
    });
    var { EventEmitter: EventEmitter4 } = require_events();
    var errCode32 = require_err_code();
    var PeerId2 = require_src6();
    var { Multiaddr: Multiaddr18 } = require_src();
    var PeerRouting = require_peer_routing2();
    var ContentRouting = require_content_routing2();
    var getPeer = require_get_peer();
    var { validate: validateConfig } = require_config3();
    var { codes, messages } = require_errors4();
    var AddressManager = require_address_manager();
    var ConnectionManager = require_connection_manager();
    var Circuit = require_transport2();
    var Relay = require_circuit();
    var Dialer = require_dialer();
    var Keychain = require_keychain();
    var Metrics = require_metrics();
    var TransportManager = require_transport_manager();
    var Upgrader = require_upgrader();
    var PeerStore = require_peer_store();
    var PubsubAdapter = require_pubsub_adapter();
    var PersistentPeerStore = require_persistent();
    var Registrar = require_registrar();
    var ping = require_ping2();
    var IdentifyService = require_identify();
    var NatManager = require_nat_manager();
    var { updateSelfPeerRecord } = require_utils18();
    var Libp2p = class extends EventEmitter4 {
      static async create(options) {
        if (options.peerId) {
          return new Libp2p(options);
        }
        const peerId = await PeerId2.create();
        options.peerId = peerId;
        return new Libp2p(options);
      }
      constructor(_options) {
        super();
        this._options = validateConfig(_options);
        this.peerId = this._options.peerId;
        this.datastore = this._options.datastore;
        this.peerStore = this.datastore && this._options.peerStore.persistence ? new PersistentPeerStore({
          peerId: this.peerId,
          datastore: this.datastore,
          ...this._options.peerStore
        }) : new PeerStore({ peerId: this.peerId });
        this.addresses = this._options.addresses;
        this.addressManager = new AddressManager(this.peerId, this._options.addresses);
        this.addressManager.on("change:addresses", () => {
          updateSelfPeerRecord(this).catch((err) => {
            log15.error("Error updating self peer record", err);
          });
        });
        this._modules = this._options.modules;
        this._config = this._options.config;
        this._transport = [];
        this._discovery = new Map();
        this.connectionManager = new ConnectionManager(this, {
          autoDial: this._config.peerDiscovery.autoDial,
          ...this._options.connectionManager
        });
        if (this._options.metrics.enabled) {
          this.metrics = new Metrics({
            ...this._options.metrics,
            connectionManager: this.connectionManager
          });
        }
        if (this._options.keychain && this._options.keychain.datastore) {
          log15("creating keychain");
          const keychainOpts = Keychain.generateOptions();
          this.keychain = new Keychain(this._options.keychain.datastore, {
            ...keychainOpts,
            ...this._options.keychain
          });
          log15("keychain constructed");
        }
        this.upgrader = new Upgrader({
          localPeer: this.peerId,
          metrics: this.metrics,
          onConnection: (connection) => this.connectionManager.onConnect(connection),
          onConnectionEnd: (connection) => this.connectionManager.onDisconnect(connection)
        });
        this.transportManager = new TransportManager({
          libp2p: this,
          upgrader: this.upgrader,
          faultTolerance: this._options.transportManager.faultTolerance
        });
        this.natManager = new NatManager({
          peerId: this.peerId,
          addressManager: this.addressManager,
          transportManager: this.transportManager,
          ...this._options.config.nat
        });
        this.registrar = new Registrar({
          peerStore: this.peerStore,
          connectionManager: this.connectionManager
        });
        this.handle = this.handle.bind(this);
        this.registrar.handle = this.handle;
        if (!this._modules.connEncryption || !this._modules.connEncryption.length) {
          throw errCode32(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);
        }
        const cryptos = this._modules.connEncryption;
        cryptos.forEach((crypto3) => {
          this.upgrader.cryptos.set(crypto3.protocol, crypto3);
        });
        this.dialer = new Dialer({
          transportManager: this.transportManager,
          peerStore: this.peerStore,
          ...this._options.dialer
        });
        this._modules.transport.forEach((Transport) => {
          const key = Transport.prototype[Symbol.toStringTag];
          const transportOptions = this._config.transport[key];
          this.transportManager.add(key, Transport, transportOptions);
        });
        if (this._config.relay.enabled) {
          this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);
          this.relay = new Relay(this);
        }
        if (this._modules.streamMuxer) {
          const muxers = this._modules.streamMuxer;
          muxers.forEach((muxer) => {
            this.upgrader.muxers.set(muxer.multicodec, muxer);
          });
          this.identifyService = new IdentifyService({ libp2p: this });
          this.handle(Object.values(IdentifyService.getProtocolStr(this)), this.identifyService.handleMessage);
        }
        if (this._modules.connProtector) {
          this.upgrader.protector = this._modules.connProtector;
        } else if (globalThis.process !== void 0 && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {
          throw new Error("Private network is enforced, but no protector was provided");
        }
        if (this._modules.dht) {
          const DHT = this._modules.dht;
          this._dht = new DHT({
            libp2p: this,
            dialer: this.dialer,
            peerId: this.peerId,
            peerStore: this.peerStore,
            registrar: this.registrar,
            datastore: this.datastore,
            ...this._config.dht
          });
        }
        if (this._modules.pubsub) {
          const Pubsub = this._modules.pubsub;
          this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub);
        }
        this.peerRouting = new PeerRouting(this);
        this.contentRouting = new ContentRouting(this);
        ping.mount(this);
        this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this);
      }
      emit(eventName, ...args) {
        if (eventName === "error" && !this._events.error) {
          log15.error(args);
          return false;
        } else {
          return super.emit(eventName, ...args);
        }
      }
      async start() {
        log15("libp2p is starting");
        try {
          await this._onStarting();
          await this._onDidStart();
          log15("libp2p has started");
        } catch (err) {
          this.emit("error", err);
          log15.error("An error occurred starting libp2p", err);
          await this.stop();
          throw err;
        }
      }
      async stop() {
        log15("libp2p is stopping");
        try {
          this._isStarted = false;
          this.relay && this.relay.stop();
          this.peerRouting.stop();
          for (const service of this._discovery.values()) {
            service.removeListener("peer", this._onDiscoveryPeer);
          }
          await Promise.all(Array.from(this._discovery.values(), (s) => s.stop()));
          this._discovery = new Map();
          await this.peerStore.stop();
          await this.connectionManager.stop();
          await Promise.all([
            this.pubsub && this.pubsub.stop(),
            this._dht && this._dht.stop(),
            this.metrics && this.metrics.stop()
          ]);
          await this.natManager.stop();
          await this.transportManager.close();
          ping.unmount(this);
          this.dialer.destroy();
        } catch (err) {
          if (err) {
            log15.error(err);
            this.emit("error", err);
          }
        }
        log15("libp2p has stopped");
      }
      async loadKeychain() {
        if (!this.keychain) {
          return;
        }
        try {
          await this.keychain.findKeyByName("self");
        } catch (err) {
          await this.keychain.importPeer("self", this.peerId);
        }
      }
      isStarted() {
        return this._isStarted;
      }
      get connections() {
        return this.connectionManager.connections;
      }
      dial(peer, options) {
        return this._dial(peer, options);
      }
      async dialProtocol(peer, protocols, options) {
        if (!protocols || !protocols.length) {
          throw errCode32(new Error("no protocols were provided to open a stream"), codes.ERR_INVALID_PROTOCOLS_FOR_STREAM);
        }
        const connection = await this._dial(peer, options);
        return connection.newStream(protocols);
      }
      async _dial(peer, options) {
        const { id, multiaddrs } = getPeer(peer);
        if (id.equals(this.peerId)) {
          throw errCode32(new Error("Cannot dial self"), codes.ERR_DIALED_SELF);
        }
        let connection = this.connectionManager.get(id);
        if (!connection) {
          connection = await this.dialer.connectToPeer(peer, options);
        } else if (multiaddrs) {
          this.peerStore.addressBook.add(id, multiaddrs);
        }
        return connection;
      }
      get multiaddrs() {
        let addrs = this.addressManager.getAnnounceAddrs().map((ma) => ma.toString());
        if (!addrs.length) {
          addrs = this.transportManager.getAddrs().map((ma) => ma.toString());
        }
        addrs = addrs.concat(this.addressManager.getObservedAddrs().map((ma) => ma.toString()));
        const announceFilter = this._options.addresses.announceFilter;
        const addrSet = new Set(addrs);
        return announceFilter(Array.from(addrSet).map((str) => new Multiaddr18(str)));
      }
      async hangUp(peer) {
        const { id } = getPeer(peer);
        const connections = this.connectionManager.connections.get(id.toB58String());
        if (!connections) {
          return;
        }
        await Promise.all(connections.map((connection) => {
          return connection.close();
        }));
      }
      ping(peer) {
        const { id, multiaddrs } = getPeer(peer);
        if (multiaddrs) {
          return ping(this, multiaddrs[0]);
        }
        return ping(this, id);
      }
      handle(protocols, handler) {
        protocols = Array.isArray(protocols) ? protocols : [protocols];
        protocols.forEach((protocol) => {
          this.upgrader.protocols.set(protocol, handler);
        });
        this.peerStore.protoBook.add(this.peerId, protocols);
      }
      unhandle(protocols) {
        protocols = Array.isArray(protocols) ? protocols : [protocols];
        protocols.forEach((protocol) => {
          this.upgrader.protocols.delete(protocol);
        });
        this.peerStore.protoBook.remove(this.peerId, protocols);
      }
      async _onStarting() {
        const addrs = this.addressManager.getListenAddrs();
        await this.transportManager.listen(addrs);
        this.natManager.start();
        await this.peerStore.start();
        if (this._config.pubsub.enabled) {
          this.pubsub && this.pubsub.start();
        }
        if (this._config.dht.enabled) {
          this._dht && this._dht.start();
          this._dht.on("peer", this._onDiscoveryPeer);
        }
        this.metrics && this.metrics.start();
      }
      async _onDidStart() {
        this._isStarted = true;
        this.peerStore.on("peer", (peerId) => {
          this.emit("peer:discovery", peerId);
          this._maybeConnect(peerId);
        });
        for (const peer of this.peerStore.peers.values()) {
          this.emit("peer:discovery", peer.id);
        }
        this.connectionManager.start();
        await this._setupPeerDiscovery();
        this.relay && this.relay.start();
        this.peerRouting.start();
      }
      _onDiscoveryPeer(peer) {
        if (peer.id.toB58String() === this.peerId.toB58String()) {
          log15.error(new Error(codes.ERR_DISCOVERED_SELF));
          return;
        }
        peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs);
        peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols);
      }
      async _maybeConnect(peerId) {
        if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {
          const minConnections = this._options.connectionManager.minConnections || 0;
          if (minConnections > this.connectionManager.size) {
            log15("connecting to discovered peer %s", peerId.toB58String());
            try {
              await this.dialer.connectToPeer(peerId);
            } catch (err) {
              log15.error(`could not connect to discovered peer ${peerId.toB58String()} with ${err}`);
            }
          }
        }
      }
      async _setupPeerDiscovery() {
        const setupService = (DiscoveryService) => {
          let config2 = {
            enabled: true
          };
          if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {
            config2 = { ...config2, ...this._config.peerDiscovery[DiscoveryService.tag] };
          }
          if (config2.enabled && !this._discovery.has(DiscoveryService.tag)) {
            let discoveryService;
            if (typeof DiscoveryService === "function") {
              discoveryService = new DiscoveryService(Object.assign({}, config2, {
                peerId: this.peerId,
                libp2p: this
              }));
            } else {
              discoveryService = DiscoveryService;
            }
            discoveryService.on("peer", this._onDiscoveryPeer);
            this._discovery.set(DiscoveryService.tag, discoveryService);
          }
        };
        for (const DiscoveryService of this._modules.peerDiscovery || []) {
          setupService(DiscoveryService);
        }
        for (const Transport of this.transportManager.getTransports()) {
          if (Transport.discovery) {
            setupService(Transport.discovery);
          }
        }
        await Promise.all(Array.from(this._discovery.values(), (d) => d.start()));
      }
    };
    module2.exports = Libp2p;
  }
});

// node_modules/ipfs-core/cjs/src/components/libp2p.js
var require_libp2p = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/libp2p.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var get2 = require_dlv_umd();
    var mergeOpts = require_merge_options();
    var errCode32 = require_err_code();
    var libp2pPubsubRouters = (init_libp2p_pubsub_routers_browser(), libp2p_pubsub_routers_browser_exports);
    var DelegatedPeerRouter = require_src15();
    var DelegatedContentRouter = require_src16();
    var ipfsHttpClient = (init_src14(), src_exports7);
    var multiaddr = require_src();
    var version3 = require_version();
    var libp2p = (init_libp2p_browser(), libp2p_browser_exports);
    var bootstrap = require_src24();
    var Libp2p = require_src29();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var get__default = /* @__PURE__ */ _interopDefaultLegacy(get2);
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var DelegatedPeerRouter__default = /* @__PURE__ */ _interopDefaultLegacy(DelegatedPeerRouter);
    var DelegatedContentRouter__default = /* @__PURE__ */ _interopDefaultLegacy(DelegatedContentRouter);
    var bootstrap__default = /* @__PURE__ */ _interopDefaultLegacy(bootstrap);
    var Libp2p__default = /* @__PURE__ */ _interopDefaultLegacy(Libp2p);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    function createLibp2p({ options = {}, peerId, multiaddrs = [], repo, keychainConfig = {}, config: config2 = {} }) {
      const { datastore, keys } = repo;
      const libp2pOptions = getLibp2pOptions({
        options,
        config: config2,
        datastore,
        keys,
        keychainConfig,
        peerId,
        multiaddrs
      });
      if (typeof options.libp2p === "function") {
        return options.libp2p({
          libp2pOptions,
          options,
          config: config2,
          datastore,
          peerId
        });
      }
      return Libp2p__default["default"].create(libp2pOptions);
    }
    function getLibp2pOptions({ options, config: config2, datastore, keys, keychainConfig, peerId, multiaddrs }) {
      const getPubsubRouter = () => {
        const router = get__default["default"](config2, "Pubsub.Router") || "gossipsub";
        if (!libp2pPubsubRouters.routers[router]) {
          throw errCode__default["default"](new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), "ERR_NOT_SUPPORTED");
        }
        return libp2pPubsubRouters.routers[router];
      };
      const libp2pDefaults = {
        datastore,
        peerId,
        modules: {}
      };
      const libp2pOptions = {
        modules: {
          pubsub: getPubsubRouter(),
          contentRouting: [],
          peerRouting: []
        },
        config: {
          peerDiscovery: {
            mdns: { enabled: get__default["default"](options, "config.Discovery.MDNS.Enabled", get__default["default"](config2, "Discovery.MDNS.Enabled", true)) },
            webRTCStar: { enabled: get__default["default"](options, "config.Discovery.webRTCStar.Enabled", get__default["default"](config2, "Discovery.webRTCStar.Enabled", true)) },
            bootstrap: { list: get__default["default"](options, "config.Bootstrap", get__default["default"](config2, "Bootstrap", [])) }
          },
          relay: {
            enabled: get__default["default"](options, "relay.enabled", get__default["default"](config2, "relay.enabled", true)),
            hop: {
              enabled: get__default["default"](options, "relay.hop.enabled", get__default["default"](config2, "relay.hop.enabled", false)),
              active: get__default["default"](options, "relay.hop.active", get__default["default"](config2, "relay.hop.active", false))
            }
          },
          dht: {
            enabled: get__default["default"](config2, "Routing.Type", "none") !== "none",
            clientMode: get__default["default"](config2, "Routing.Type", "dht") !== "dhtserver",
            kBucketSize: get__default["default"](options, "dht.kBucketSize", 20)
          },
          pubsub: { enabled: get__default["default"](options, "config.Pubsub.Enabled", get__default["default"](config2, "Pubsub.Enabled", true)) },
          nat: { enabled: !get__default["default"](config2, "Swarm.DisableNatPortMap", false) }
        },
        addresses: {
          listen: multiaddrs.map((ma) => ma.toString()),
          announce: get__default["default"](options, "addresses.announce", get__default["default"](config2, "Addresses.Announce", [])),
          noAnnounce: get__default["default"](options, "addresses.noAnnounce", get__default["default"](config2, "Addresses.NoAnnounce", []))
        },
        connectionManager: get__default["default"](options, "connectionManager", {
          maxConnections: get__default["default"](options, "config.Swarm.ConnMgr.HighWater", get__default["default"](config2, "Swarm.ConnMgr.HighWater")),
          minConnections: get__default["default"](options, "config.Swarm.ConnMgr.LowWater", get__default["default"](config2, "Swarm.ConnMgr.LowWater"))
        }),
        keychain: {
          datastore: keys,
          ...keychainConfig
        },
        host: { agentVersion: `js-ipfs/${version3.ipfsCore}` }
      };
      let constructorOptions = get__default["default"](options, "libp2p", void 0);
      if (typeof constructorOptions === "function") {
        constructorOptions = void 0;
      }
      const libp2pConfig2 = mergeOptions2(libp2pDefaults, libp2p.libp2pConfig(), libp2pOptions, constructorOptions);
      const bootstrapList = get__default["default"](libp2pConfig2, "config.peerDiscovery.bootstrap.list", []);
      if (bootstrapList.length > 0) {
        libp2pConfig2.modules.peerDiscovery.push(bootstrap__default["default"]);
      }
      const delegateHosts = get__default["default"](options, "config.Addresses.Delegates", get__default["default"](config2, "Addresses.Delegates", []));
      if (delegateHosts.length > 0) {
        const delegateString = delegateHosts[Math.floor(Math.random() * delegateHosts.length)];
        const delegateAddr = new multiaddr.Multiaddr(delegateString).toOptions();
        const delegateApiOptions = {
          host: delegateAddr.host,
          protocol: parseInt(delegateAddr.port) === 443 ? "https" : "http",
          port: delegateAddr.port
        };
        const delegateHttpClient = ipfsHttpClient.create(delegateApiOptions);
        libp2pOptions.modules.contentRouting = libp2pOptions.modules.contentRouting || [];
        libp2pOptions.modules.contentRouting.push(new DelegatedContentRouter__default["default"](peerId, delegateHttpClient));
        libp2pOptions.modules.peerRouting = libp2pOptions.modules.peerRouting || [];
        libp2pOptions.modules.peerRouting.push(new DelegatedPeerRouter__default["default"](delegateHttpClient));
      }
      return libp2pConfig2;
    }
    exports2.createLibp2p = createLibp2p;
  }
});

// node_modules/ipfs-core/cjs/src/components/storage.js
var require_storage = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/storage.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var debug17 = require_browser2();
    var repo = (init_repo_browser(), repo_browser_exports);
    var getDefaultConfig = (init_config_browser(), config_browser_exports);
    var fromString4 = (init_from_string(), from_string_exports);
    var toString4 = (init_to_string(), to_string_exports);
    var PeerId2 = require_src6();
    var mergeOpts = require_merge_options();
    var profiles = require_profiles();
    var errors$1 = require_errors();
    var libp2p = require_libp2p();
    var errors2 = (init_errors5(), errors_exports3);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var getDefaultConfig__default = /* @__PURE__ */ _interopDefaultLegacy(getDefaultConfig);
    var PeerId__default = /* @__PURE__ */ _interopDefaultLegacy(PeerId2);
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var log15 = debug__default["default"]("ipfs:components:peer:storage");
    var Storage = class {
      constructor(peerId, keychain, repo2, print, isNew) {
        this.print = print;
        this.peerId = peerId;
        this.keychain = keychain;
        this.repo = repo2;
        this.print = print;
        this.isNew = isNew;
      }
      static async start(print, codecs2, options) {
        const {
          repoAutoMigrate,
          repo: inputRepo,
          onMigrationProgress
        } = options;
        const repo$1 = typeof inputRepo === "string" || inputRepo == null ? repo.createRepo(print, codecs2, {
          path: inputRepo,
          autoMigrate: repoAutoMigrate,
          onMigrationProgress
        }) : inputRepo;
        const { peerId, keychain, isNew } = await loadRepo(print, repo$1, options);
        return new Storage(peerId, keychain, repo$1, print, isNew);
      }
    };
    var loadRepo = async (print, repo2, options) => {
      if (!repo2.closed) {
        return {
          ...await configureRepo(repo2, options),
          isNew: false
        };
      }
      try {
        await repo2.open();
        return {
          ...await configureRepo(repo2, options),
          isNew: false
        };
      } catch (err) {
        if (err.code !== errors2.ERR_REPO_NOT_INITIALIZED) {
          throw err;
        }
        if (options.init && options.init.allowNew === false) {
          throw new errors$1.NotEnabledError("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");
        }
        return {
          ...await initRepo(print, repo2, options),
          isNew: true
        };
      }
    };
    var initRepo = async (print, repo2, options) => {
      const initOptions = options.init || {};
      const exists = await repo2.exists();
      log15("repo exists?", exists);
      if (exists === true) {
        throw new Error("repo already exists");
      }
      const peerId = initOptions.privateKey ? await decodePeerId(initOptions.privateKey) : await initPeerId(print, initOptions);
      const identity3 = peerIdToIdentity(peerId);
      log15("peer identity: %s", identity3.PeerID);
      const config2 = {
        ...mergeOptions2(applyProfiles(getDefaultConfig__default["default"](), initOptions.profiles), options.config),
        Identity: identity3
      };
      await repo2.init(config2);
      await repo2.open();
      log15("repo opened");
      const keychainConfig = { pass: options.pass };
      try {
        keychainConfig.dek = await repo2.config.get("Keychain.DEK");
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      const libp2p$1 = await libp2p.createLibp2p({
        options: void 0,
        multiaddrs: void 0,
        peerId,
        repo: repo2,
        config: config2,
        keychainConfig
      });
      if (libp2p$1.keychain && libp2p$1.keychain.opts) {
        await libp2p$1.loadKeychain();
        await repo2.config.set("Keychain", { DEK: libp2p$1.keychain.opts.dek });
      }
      return {
        peerId,
        keychain: libp2p$1.keychain
      };
    };
    var decodePeerId = (peerId) => {
      log15("using user-supplied private-key");
      return typeof peerId === "object" ? peerId : PeerId__default["default"].createFromPrivKey(fromString4.fromString(peerId, "base64pad"));
    };
    var initPeerId = (print, { algorithm = "Ed25519", bits = 2048 }) => {
      print("generating %s keypair...", algorithm);
      return PeerId__default["default"].create({
        keyType: algorithm,
        bits
      });
    };
    var peerIdToIdentity = (peerId) => ({
      PeerID: peerId.toB58String(),
      PrivKey: toString4.toString(peerId.privKey.bytes, "base64pad")
    });
    var configureRepo = async (repo2, options) => {
      const config2 = options.config;
      const profiles2 = options.init && options.init.profiles || [];
      const pass = options.pass;
      const original = await repo2.config.getAll();
      const changed = mergeConfigs(applyProfiles(original, profiles2), config2);
      if (original !== changed) {
        await repo2.config.replace(changed);
      }
      if (!changed.Identity || !changed.Identity.PrivKey) {
        throw new errors$1.NotInitializedError("No private key was found in the config, please intialize the repo");
      }
      const peerId = await PeerId__default["default"].createFromPrivKey(changed.Identity.PrivKey);
      const libp2p$1 = await libp2p.createLibp2p({
        options: void 0,
        multiaddrs: void 0,
        peerId,
        repo: repo2,
        config: changed,
        keychainConfig: {
          pass,
          ...changed.Keychain
        }
      });
      if (libp2p$1.keychain) {
        await libp2p$1.loadKeychain();
      }
      return {
        peerId,
        keychain: libp2p$1.keychain
      };
    };
    var mergeConfigs = (config2, changes) => changes ? mergeOptions2(config2, changes) : config2;
    var applyProfiles = (config2, profiles$1) => {
      return (profiles$1 || []).reduce((config3, name5) => {
        const profile = profiles.profiles[name5];
        if (!profile) {
          throw new Error(`Could not find profile with name '${name5}'`);
        }
        log15("applying profile %s", name5);
        return profile.transform(config3);
      }, config2);
    };
    exports2.Storage = Storage;
  }
});

// node_modules/varint-decoder/node_modules/varint/encode.js
var require_encode3 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/encode.js"(exports2, module2) {
    init_node_globals();
    module2.exports = encode10;
    var MSB2 = 128;
    var REST2 = 127;
    var MSBALL2 = ~REST2;
    var INT2 = Math.pow(2, 31);
    function encode10(num, out, offset) {
      out = out || [];
      offset = offset || 0;
      var oldOffset = offset;
      while (num >= INT2) {
        out[offset++] = num & 255 | MSB2;
        num /= 128;
      }
      while (num & MSBALL2) {
        out[offset++] = num & 255 | MSB2;
        num >>>= 7;
      }
      out[offset] = num | 0;
      encode10.bytes = offset - oldOffset + 1;
      return out;
    }
  }
});

// node_modules/varint-decoder/node_modules/varint/decode.js
var require_decode4 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/decode.js"(exports2, module2) {
    init_node_globals();
    module2.exports = read2;
    var MSB2 = 128;
    var REST2 = 127;
    function read2(buf2, offset) {
      var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf2.length;
      do {
        if (counter >= l) {
          read2.bytes = 0;
          throw new RangeError("Could not decode varint");
        }
        b = buf2[counter++];
        res += shift < 28 ? (b & REST2) << shift : (b & REST2) * Math.pow(2, shift);
        shift += 7;
      } while (b >= MSB2);
      read2.bytes = counter - offset;
      return res;
    }
  }
});

// node_modules/varint-decoder/node_modules/varint/length.js
var require_length2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/length.js"(exports2, module2) {
    init_node_globals();
    var N12 = Math.pow(2, 7);
    var N22 = Math.pow(2, 14);
    var N32 = Math.pow(2, 21);
    var N42 = Math.pow(2, 28);
    var N52 = Math.pow(2, 35);
    var N62 = Math.pow(2, 42);
    var N72 = Math.pow(2, 49);
    var N82 = Math.pow(2, 56);
    var N92 = Math.pow(2, 63);
    module2.exports = function(value) {
      return value < N12 ? 1 : value < N22 ? 2 : value < N32 ? 3 : value < N42 ? 4 : value < N52 ? 5 : value < N62 ? 6 : value < N72 ? 7 : value < N82 ? 8 : value < N92 ? 9 : 10;
    };
  }
});

// node_modules/varint-decoder/node_modules/varint/index.js
var require_varint2 = __commonJS({
  "node_modules/varint-decoder/node_modules/varint/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = {
      encode: require_encode3(),
      decode: require_decode4(),
      encodingLength: require_length2()
    };
  }
});

// node_modules/varint-decoder/src/index.js
var require_src30 = __commonJS({
  "node_modules/varint-decoder/src/index.js"(exports2, module2) {
    init_node_globals();
    "use strict";
    var varint7 = require_varint2();
    module2.exports = (buf2) => {
      if (!(buf2 instanceof Uint8Array)) {
        throw new Error("arg needs to be a Uint8Array");
      }
      const result = [];
      while (buf2.length > 0) {
        const num = varint7.decode(buf2);
        result.push(num);
        buf2 = buf2.slice(varint7.decode.bytes);
      }
      return result;
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/types/wantlist/entry.js
var WantListEntry;
var init_entry = __esm({
  "node_modules/ipfs-bitswap/esm/src/types/wantlist/entry.js"() {
    init_node_globals();
    init_base58();
    WantListEntry = class {
      constructor(cid, priority, wantType) {
        this._refCounter = 1;
        this.cid = cid;
        this.priority = priority || 1;
        this.wantType = wantType;
      }
      inc() {
        this._refCounter += 1;
      }
      dec() {
        this._refCounter = Math.max(0, this._refCounter - 1);
      }
      hasRefs() {
        return this._refCounter > 0;
      }
      get [Symbol.toStringTag]() {
        const cidStr = this.cid.toString(base58btc);
        return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`;
      }
      equals(other) {
        return this._refCounter === other._refCounter && this.cid.equals(other.cid) && this.priority === other.priority && this.wantType === other.wantType;
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/types/message/message.js
var import_minimal4, $Reader4, $Writer4, $util4, $root4, Message;
var init_message = __esm({
  "node_modules/ipfs-bitswap/esm/src/types/message/message.js"() {
    init_node_globals();
    import_minimal4 = __toModule(require_minimal2());
    $Reader4 = import_minimal4.default.Reader;
    $Writer4 = import_minimal4.default.Writer;
    $util4 = import_minimal4.default.util;
    $root4 = import_minimal4.default.roots["ipfs-bitswap"] || (import_minimal4.default.roots["ipfs-bitswap"] = {});
    Message = $root4.Message = (() => {
      function Message2(p) {
        this.blocks = [];
        this.payload = [];
        this.blockPresences = [];
        if (p) {
          for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
            if (p[ks[i]] != null)
              this[ks[i]] = p[ks[i]];
        }
      }
      Message2.prototype.wantlist = null;
      Message2.prototype.blocks = $util4.emptyArray;
      Message2.prototype.payload = $util4.emptyArray;
      Message2.prototype.blockPresences = $util4.emptyArray;
      Message2.prototype.pendingBytes = 0;
      Message2.encode = function encode10(m, w) {
        if (!w)
          w = $Writer4.create();
        if (m.wantlist != null && Object.hasOwnProperty.call(m, "wantlist"))
          $root4.Message.Wantlist.encode(m.wantlist, w.uint32(10).fork()).ldelim();
        if (m.blocks != null && m.blocks.length) {
          for (var i = 0; i < m.blocks.length; ++i)
            w.uint32(18).bytes(m.blocks[i]);
        }
        if (m.payload != null && m.payload.length) {
          for (var i = 0; i < m.payload.length; ++i)
            $root4.Message.Block.encode(m.payload[i], w.uint32(26).fork()).ldelim();
        }
        if (m.blockPresences != null && m.blockPresences.length) {
          for (var i = 0; i < m.blockPresences.length; ++i)
            $root4.Message.BlockPresence.encode(m.blockPresences[i], w.uint32(34).fork()).ldelim();
        }
        if (m.pendingBytes != null && Object.hasOwnProperty.call(m, "pendingBytes"))
          w.uint32(40).int32(m.pendingBytes);
        return w;
      };
      Message2.decode = function decode12(r, l) {
        if (!(r instanceof $Reader4))
          r = $Reader4.create(r);
        var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Message();
        while (r.pos < c) {
          var t = r.uint32();
          switch (t >>> 3) {
            case 1:
              m.wantlist = $root4.Message.Wantlist.decode(r, r.uint32());
              break;
            case 2:
              if (!(m.blocks && m.blocks.length))
                m.blocks = [];
              m.blocks.push(r.bytes());
              break;
            case 3:
              if (!(m.payload && m.payload.length))
                m.payload = [];
              m.payload.push($root4.Message.Block.decode(r, r.uint32()));
              break;
            case 4:
              if (!(m.blockPresences && m.blockPresences.length))
                m.blockPresences = [];
              m.blockPresences.push($root4.Message.BlockPresence.decode(r, r.uint32()));
              break;
            case 5:
              m.pendingBytes = r.int32();
              break;
            default:
              r.skipType(t & 7);
              break;
          }
        }
        return m;
      };
      Message2.fromObject = function fromObject(d) {
        if (d instanceof $root4.Message)
          return d;
        var m = new $root4.Message();
        if (d.wantlist != null) {
          if (typeof d.wantlist !== "object")
            throw TypeError(".Message.wantlist: object expected");
          m.wantlist = $root4.Message.Wantlist.fromObject(d.wantlist);
        }
        if (d.blocks) {
          if (!Array.isArray(d.blocks))
            throw TypeError(".Message.blocks: array expected");
          m.blocks = [];
          for (var i = 0; i < d.blocks.length; ++i) {
            if (typeof d.blocks[i] === "string")
              $util4.base64.decode(d.blocks[i], m.blocks[i] = $util4.newBuffer($util4.base64.length(d.blocks[i])), 0);
            else if (d.blocks[i].length)
              m.blocks[i] = d.blocks[i];
          }
        }
        if (d.payload) {
          if (!Array.isArray(d.payload))
            throw TypeError(".Message.payload: array expected");
          m.payload = [];
          for (var i = 0; i < d.payload.length; ++i) {
            if (typeof d.payload[i] !== "object")
              throw TypeError(".Message.payload: object expected");
            m.payload[i] = $root4.Message.Block.fromObject(d.payload[i]);
          }
        }
        if (d.blockPresences) {
          if (!Array.isArray(d.blockPresences))
            throw TypeError(".Message.blockPresences: array expected");
          m.blockPresences = [];
          for (var i = 0; i < d.blockPresences.length; ++i) {
            if (typeof d.blockPresences[i] !== "object")
              throw TypeError(".Message.blockPresences: object expected");
            m.blockPresences[i] = $root4.Message.BlockPresence.fromObject(d.blockPresences[i]);
          }
        }
        if (d.pendingBytes != null) {
          m.pendingBytes = d.pendingBytes | 0;
        }
        return m;
      };
      Message2.toObject = function toObject(m, o) {
        if (!o)
          o = {};
        var d = {};
        if (o.arrays || o.defaults) {
          d.blocks = [];
          d.payload = [];
          d.blockPresences = [];
        }
        if (o.defaults) {
          d.wantlist = null;
          d.pendingBytes = 0;
        }
        if (m.wantlist != null && m.hasOwnProperty("wantlist")) {
          d.wantlist = $root4.Message.Wantlist.toObject(m.wantlist, o);
        }
        if (m.blocks && m.blocks.length) {
          d.blocks = [];
          for (var j = 0; j < m.blocks.length; ++j) {
            d.blocks[j] = o.bytes === String ? $util4.base64.encode(m.blocks[j], 0, m.blocks[j].length) : o.bytes === Array ? Array.prototype.slice.call(m.blocks[j]) : m.blocks[j];
          }
        }
        if (m.payload && m.payload.length) {
          d.payload = [];
          for (var j = 0; j < m.payload.length; ++j) {
            d.payload[j] = $root4.Message.Block.toObject(m.payload[j], o);
          }
        }
        if (m.blockPresences && m.blockPresences.length) {
          d.blockPresences = [];
          for (var j = 0; j < m.blockPresences.length; ++j) {
            d.blockPresences[j] = $root4.Message.BlockPresence.toObject(m.blockPresences[j], o);
          }
        }
        if (m.pendingBytes != null && m.hasOwnProperty("pendingBytes")) {
          d.pendingBytes = m.pendingBytes;
        }
        return d;
      };
      Message2.prototype.toJSON = function toJSON() {
        return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
      };
      Message2.Wantlist = function() {
        function Wantlist2(p) {
          this.entries = [];
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Wantlist2.prototype.entries = $util4.emptyArray;
        Wantlist2.prototype.full = false;
        Wantlist2.encode = function encode10(m, w) {
          if (!w)
            w = $Writer4.create();
          if (m.entries != null && m.entries.length) {
            for (var i = 0; i < m.entries.length; ++i)
              $root4.Message.Wantlist.Entry.encode(m.entries[i], w.uint32(10).fork()).ldelim();
          }
          if (m.full != null && Object.hasOwnProperty.call(m, "full"))
            w.uint32(16).bool(m.full);
          return w;
        };
        Wantlist2.decode = function decode12(r, l) {
          if (!(r instanceof $Reader4))
            r = $Reader4.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Message.Wantlist();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                if (!(m.entries && m.entries.length))
                  m.entries = [];
                m.entries.push($root4.Message.Wantlist.Entry.decode(r, r.uint32()));
                break;
              case 2:
                m.full = r.bool();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        Wantlist2.fromObject = function fromObject(d) {
          if (d instanceof $root4.Message.Wantlist)
            return d;
          var m = new $root4.Message.Wantlist();
          if (d.entries) {
            if (!Array.isArray(d.entries))
              throw TypeError(".Message.Wantlist.entries: array expected");
            m.entries = [];
            for (var i = 0; i < d.entries.length; ++i) {
              if (typeof d.entries[i] !== "object")
                throw TypeError(".Message.Wantlist.entries: object expected");
              m.entries[i] = $root4.Message.Wantlist.Entry.fromObject(d.entries[i]);
            }
          }
          if (d.full != null) {
            m.full = Boolean(d.full);
          }
          return m;
        };
        Wantlist2.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.arrays || o.defaults) {
            d.entries = [];
          }
          if (o.defaults) {
            d.full = false;
          }
          if (m.entries && m.entries.length) {
            d.entries = [];
            for (var j = 0; j < m.entries.length; ++j) {
              d.entries[j] = $root4.Message.Wantlist.Entry.toObject(m.entries[j], o);
            }
          }
          if (m.full != null && m.hasOwnProperty("full")) {
            d.full = m.full;
          }
          return d;
        };
        Wantlist2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
        };
        Wantlist2.WantType = function() {
          const valuesById = {}, values = Object.create(valuesById);
          values[valuesById[0] = "Block"] = 0;
          values[valuesById[1] = "Have"] = 1;
          return values;
        }();
        Wantlist2.Entry = function() {
          function Entry(p) {
            if (p) {
              for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
                if (p[ks[i]] != null)
                  this[ks[i]] = p[ks[i]];
            }
          }
          Entry.prototype.block = $util4.newBuffer([]);
          Entry.prototype.priority = 0;
          Entry.prototype.cancel = false;
          Entry.prototype.wantType = 0;
          Entry.prototype.sendDontHave = false;
          Entry.encode = function encode10(m, w) {
            if (!w)
              w = $Writer4.create();
            if (m.block != null && Object.hasOwnProperty.call(m, "block"))
              w.uint32(10).bytes(m.block);
            if (m.priority != null && Object.hasOwnProperty.call(m, "priority"))
              w.uint32(16).int32(m.priority);
            if (m.cancel != null && Object.hasOwnProperty.call(m, "cancel"))
              w.uint32(24).bool(m.cancel);
            if (m.wantType != null && Object.hasOwnProperty.call(m, "wantType"))
              w.uint32(32).int32(m.wantType);
            if (m.sendDontHave != null && Object.hasOwnProperty.call(m, "sendDontHave"))
              w.uint32(40).bool(m.sendDontHave);
            return w;
          };
          Entry.decode = function decode12(r, l) {
            if (!(r instanceof $Reader4))
              r = $Reader4.create(r);
            var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Message.Wantlist.Entry();
            while (r.pos < c) {
              var t = r.uint32();
              switch (t >>> 3) {
                case 1:
                  m.block = r.bytes();
                  break;
                case 2:
                  m.priority = r.int32();
                  break;
                case 3:
                  m.cancel = r.bool();
                  break;
                case 4:
                  m.wantType = r.int32();
                  break;
                case 5:
                  m.sendDontHave = r.bool();
                  break;
                default:
                  r.skipType(t & 7);
                  break;
              }
            }
            return m;
          };
          Entry.fromObject = function fromObject(d) {
            if (d instanceof $root4.Message.Wantlist.Entry)
              return d;
            var m = new $root4.Message.Wantlist.Entry();
            if (d.block != null) {
              if (typeof d.block === "string")
                $util4.base64.decode(d.block, m.block = $util4.newBuffer($util4.base64.length(d.block)), 0);
              else if (d.block.length)
                m.block = d.block;
            }
            if (d.priority != null) {
              m.priority = d.priority | 0;
            }
            if (d.cancel != null) {
              m.cancel = Boolean(d.cancel);
            }
            switch (d.wantType) {
              case "Block":
              case 0:
                m.wantType = 0;
                break;
              case "Have":
              case 1:
                m.wantType = 1;
                break;
            }
            if (d.sendDontHave != null) {
              m.sendDontHave = Boolean(d.sendDontHave);
            }
            return m;
          };
          Entry.toObject = function toObject(m, o) {
            if (!o)
              o = {};
            var d = {};
            if (o.defaults) {
              if (o.bytes === String)
                d.block = "";
              else {
                d.block = [];
                if (o.bytes !== Array)
                  d.block = $util4.newBuffer(d.block);
              }
              d.priority = 0;
              d.cancel = false;
              d.wantType = o.enums === String ? "Block" : 0;
              d.sendDontHave = false;
            }
            if (m.block != null && m.hasOwnProperty("block")) {
              d.block = o.bytes === String ? $util4.base64.encode(m.block, 0, m.block.length) : o.bytes === Array ? Array.prototype.slice.call(m.block) : m.block;
            }
            if (m.priority != null && m.hasOwnProperty("priority")) {
              d.priority = m.priority;
            }
            if (m.cancel != null && m.hasOwnProperty("cancel")) {
              d.cancel = m.cancel;
            }
            if (m.wantType != null && m.hasOwnProperty("wantType")) {
              d.wantType = o.enums === String ? $root4.Message.Wantlist.WantType[m.wantType] : m.wantType;
            }
            if (m.sendDontHave != null && m.hasOwnProperty("sendDontHave")) {
              d.sendDontHave = m.sendDontHave;
            }
            return d;
          };
          Entry.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
          };
          return Entry;
        }();
        return Wantlist2;
      }();
      Message2.Block = function() {
        function Block2(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        Block2.prototype.prefix = $util4.newBuffer([]);
        Block2.prototype.data = $util4.newBuffer([]);
        Block2.encode = function encode10(m, w) {
          if (!w)
            w = $Writer4.create();
          if (m.prefix != null && Object.hasOwnProperty.call(m, "prefix"))
            w.uint32(10).bytes(m.prefix);
          if (m.data != null && Object.hasOwnProperty.call(m, "data"))
            w.uint32(18).bytes(m.data);
          return w;
        };
        Block2.decode = function decode12(r, l) {
          if (!(r instanceof $Reader4))
            r = $Reader4.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Message.Block();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.prefix = r.bytes();
                break;
              case 2:
                m.data = r.bytes();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        Block2.fromObject = function fromObject(d) {
          if (d instanceof $root4.Message.Block)
            return d;
          var m = new $root4.Message.Block();
          if (d.prefix != null) {
            if (typeof d.prefix === "string")
              $util4.base64.decode(d.prefix, m.prefix = $util4.newBuffer($util4.base64.length(d.prefix)), 0);
            else if (d.prefix.length)
              m.prefix = d.prefix;
          }
          if (d.data != null) {
            if (typeof d.data === "string")
              $util4.base64.decode(d.data, m.data = $util4.newBuffer($util4.base64.length(d.data)), 0);
            else if (d.data.length)
              m.data = d.data;
          }
          return m;
        };
        Block2.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            if (o.bytes === String)
              d.prefix = "";
            else {
              d.prefix = [];
              if (o.bytes !== Array)
                d.prefix = $util4.newBuffer(d.prefix);
            }
            if (o.bytes === String)
              d.data = "";
            else {
              d.data = [];
              if (o.bytes !== Array)
                d.data = $util4.newBuffer(d.data);
            }
          }
          if (m.prefix != null && m.hasOwnProperty("prefix")) {
            d.prefix = o.bytes === String ? $util4.base64.encode(m.prefix, 0, m.prefix.length) : o.bytes === Array ? Array.prototype.slice.call(m.prefix) : m.prefix;
          }
          if (m.data != null && m.hasOwnProperty("data")) {
            d.data = o.bytes === String ? $util4.base64.encode(m.data, 0, m.data.length) : o.bytes === Array ? Array.prototype.slice.call(m.data) : m.data;
          }
          return d;
        };
        Block2.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
        };
        return Block2;
      }();
      Message2.BlockPresenceType = function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "Have"] = 0;
        values[valuesById[1] = "DontHave"] = 1;
        return values;
      }();
      Message2.BlockPresence = function() {
        function BlockPresence(p) {
          if (p) {
            for (var ks = Object.keys(p), i = 0; i < ks.length; ++i)
              if (p[ks[i]] != null)
                this[ks[i]] = p[ks[i]];
          }
        }
        BlockPresence.prototype.cid = $util4.newBuffer([]);
        BlockPresence.prototype.type = 0;
        BlockPresence.encode = function encode10(m, w) {
          if (!w)
            w = $Writer4.create();
          if (m.cid != null && Object.hasOwnProperty.call(m, "cid"))
            w.uint32(10).bytes(m.cid);
          if (m.type != null && Object.hasOwnProperty.call(m, "type"))
            w.uint32(16).int32(m.type);
          return w;
        };
        BlockPresence.decode = function decode12(r, l) {
          if (!(r instanceof $Reader4))
            r = $Reader4.create(r);
          var c = l === void 0 ? r.len : r.pos + l, m = new $root4.Message.BlockPresence();
          while (r.pos < c) {
            var t = r.uint32();
            switch (t >>> 3) {
              case 1:
                m.cid = r.bytes();
                break;
              case 2:
                m.type = r.int32();
                break;
              default:
                r.skipType(t & 7);
                break;
            }
          }
          return m;
        };
        BlockPresence.fromObject = function fromObject(d) {
          if (d instanceof $root4.Message.BlockPresence)
            return d;
          var m = new $root4.Message.BlockPresence();
          if (d.cid != null) {
            if (typeof d.cid === "string")
              $util4.base64.decode(d.cid, m.cid = $util4.newBuffer($util4.base64.length(d.cid)), 0);
            else if (d.cid.length)
              m.cid = d.cid;
          }
          switch (d.type) {
            case "Have":
            case 0:
              m.type = 0;
              break;
            case "DontHave":
            case 1:
              m.type = 1;
              break;
          }
          return m;
        };
        BlockPresence.toObject = function toObject(m, o) {
          if (!o)
            o = {};
          var d = {};
          if (o.defaults) {
            if (o.bytes === String)
              d.cid = "";
            else {
              d.cid = [];
              if (o.bytes !== Array)
                d.cid = $util4.newBuffer(d.cid);
            }
            d.type = o.enums === String ? "Have" : 0;
          }
          if (m.cid != null && m.hasOwnProperty("cid")) {
            d.cid = o.bytes === String ? $util4.base64.encode(m.cid, 0, m.cid.length) : o.bytes === Array ? Array.prototype.slice.call(m.cid) : m.cid;
          }
          if (m.type != null && m.hasOwnProperty("type")) {
            d.type = o.enums === String ? $root4.Message.BlockPresenceType[m.type] : m.type;
          }
          return d;
        };
        BlockPresence.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, import_minimal4.default.util.toJSONOptions);
        };
        return BlockPresence;
      }();
      return Message2;
    })();
  }
});

// node_modules/ipfs-bitswap/esm/src/types/wantlist/index.js
var WantType, sortBy, Wantlist;
var init_wantlist2 = __esm({
  "node_modules/ipfs-bitswap/esm/src/types/wantlist/index.js"() {
    init_node_globals();
    init_entry();
    init_base58();
    init_message();
    WantType = {
      Block: Message.Wantlist.WantType.Block,
      Have: Message.Wantlist.WantType.Have
    };
    sortBy = (fn, list) => {
      return Array.prototype.slice.call(list, 0).sort((a, b) => {
        const aa = fn(a);
        const bb = fn(b);
        return aa < bb ? -1 : aa > bb ? 1 : 0;
      });
    };
    Wantlist = class {
      constructor(stats) {
        this.set = new Map();
        this._stats = stats;
      }
      get length() {
        return this.set.size;
      }
      add(cid, priority, wantType) {
        const cidStr = cid.toString(base58btc);
        const entry = this.set.get(cidStr);
        if (entry) {
          entry.inc();
          entry.priority = priority;
          if (entry.wantType === WantType.Have && wantType === WantType.Block) {
            entry.wantType = wantType;
          }
        } else {
          this.set.set(cidStr, new WantListEntry(cid, priority, wantType));
          if (this._stats) {
            this._stats.push(null, "wantListSize", 1);
          }
        }
      }
      remove(cid) {
        const cidStr = cid.toString(base58btc);
        const entry = this.set.get(cidStr);
        if (!entry) {
          return;
        }
        entry.dec();
        if (entry.hasRefs()) {
          return;
        }
        this.set.delete(cidStr);
        if (this._stats) {
          this._stats.push(null, "wantListSize", -1);
        }
      }
      removeForce(cidStr) {
        if (this.set.has(cidStr)) {
          this.set.delete(cidStr);
        }
      }
      forEach(fn) {
        return this.set.forEach(fn);
      }
      entries() {
        return this.set.entries();
      }
      sortedEntries() {
        return new Map(sortBy((o) => o[1].key, Array.from(this.set.entries())));
      }
      contains(cid) {
        const cidStr = cid.toString(base58btc);
        return this.set.has(cidStr);
      }
      get(cid) {
        const cidStr = cid.toString(base58btc);
        return this.set.get(cidStr);
      }
    };
    Wantlist.Entry = WantListEntry;
  }
});

// node_modules/ipfs-bitswap/esm/src/types/message/entry.js
var WantlistEntry, BitswapMessageEntry;
var init_entry2 = __esm({
  "node_modules/ipfs-bitswap/esm/src/types/message/entry.js"() {
    init_node_globals();
    init_wantlist2();
    init_base58();
    WantlistEntry = Wantlist.Entry;
    BitswapMessageEntry = class {
      constructor(cid, priority, wantType, cancel, sendDontHave) {
        this.entry = new WantlistEntry(cid, priority, wantType);
        this.cancel = Boolean(cancel);
        this.sendDontHave = Boolean(sendDontHave);
      }
      get cid() {
        return this.entry.cid;
      }
      set cid(cid) {
        this.entry.cid = cid;
      }
      get priority() {
        return this.entry.priority;
      }
      set priority(val) {
        this.entry.priority = val;
      }
      get wantType() {
        return this.entry.wantType;
      }
      set wantType(val) {
        this.entry.wantType = val;
      }
      get [Symbol.toStringTag]() {
        const cidStr = this.cid.toString(base58btc);
        return `BitswapMessageEntry ${cidStr} <cancel: ${this.cancel}, priority: ${this.priority}>`;
      }
      equals(other) {
        return this.cancel === other.cancel && this.sendDontHave === other.sendDontHave && this.wantType === other.wantType && this.entry.equals(other.entry);
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/utils/index.js
var import_debug16, logger, isMapEqual;
var init_utils9 = __esm({
  "node_modules/ipfs-bitswap/esm/src/utils/index.js"() {
    init_node_globals();
    import_debug16 = __toModule(require_browser2());
    init_equals();
    init_entry2();
    logger = (id, subsystem) => {
      const name5 = ["bitswap"];
      if (subsystem) {
        name5.push(subsystem);
      }
      if (id) {
        name5.push(`${id.toB58String().slice(0, 8)}`);
      }
      return Object.assign((0, import_debug16.default)(name5.join(":")), { error: (0, import_debug16.default)(name5.concat(["error"]).join(":")) });
    };
    isMapEqual = (a, b) => {
      if (a.size !== b.size) {
        return false;
      }
      for (const [key, valueA] of a) {
        const valueB = b.get(key);
        if (valueB === void 0) {
          return false;
        }
        if (valueA instanceof Uint8Array && valueB instanceof Uint8Array && !equals3(valueA, valueB)) {
          return false;
        }
        if (valueA instanceof BitswapMessageEntry && valueB instanceof BitswapMessageEntry && !valueA.equals(valueB)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/types/message/index.js
var import_varint_decoder, import_err_code36, BitswapMessage;
var init_message2 = __esm({
  "node_modules/ipfs-bitswap/esm/src/types/message/index.js"() {
    init_node_globals();
    init_cid();
    init_sha2_browser();
    init_base58();
    import_varint_decoder = __toModule(require_src30());
    init_utils9();
    init_message();
    init_entry2();
    init_concat();
    import_err_code36 = __toModule(require_err_code());
    BitswapMessage = class {
      constructor(full) {
        this.full = full;
        this.wantlist = new Map();
        this.blocks = new Map();
        this.blockPresences = new Map();
        this.pendingBytes = 0;
      }
      get empty() {
        return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;
      }
      addEntry(cid, priority, wantType, cancel, sendDontHave) {
        if (wantType == null) {
          wantType = BitswapMessage.WantType.Block;
        }
        const cidStr = cid.toString(base58btc);
        const entry = this.wantlist.get(cidStr);
        if (entry) {
          if (entry.wantType === wantType) {
            entry.priority = priority;
          }
          if (cancel) {
            entry.cancel = Boolean(cancel);
          }
          if (sendDontHave) {
            entry.sendDontHave = Boolean(sendDontHave);
          }
          if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {
            entry.wantType = wantType;
          }
        } else {
          this.wantlist.set(cidStr, new BitswapMessageEntry(cid, priority, wantType, cancel, sendDontHave));
        }
      }
      addBlock(cid, block) {
        const cidStr = cid.toString(base58btc);
        this.blocks.set(cidStr, block);
      }
      addHave(cid) {
        const cidStr = cid.toString(base58btc);
        if (!this.blockPresences.has(cidStr)) {
          this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);
        }
      }
      addDontHave(cid) {
        const cidStr = cid.toString(base58btc);
        if (!this.blockPresences.has(cidStr)) {
          this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);
        }
      }
      cancel(cid) {
        const cidStr = cid.toString(base58btc);
        this.wantlist.delete(cidStr);
        this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);
      }
      setPendingBytes(size) {
        this.pendingBytes = size;
      }
      serializeToBitswap100() {
        const msg = {
          wantlist: {
            entries: Array.from(this.wantlist.values()).map((entry) => {
              return {
                block: entry.cid.bytes,
                priority: Number(entry.priority),
                cancel: Boolean(entry.cancel)
              };
            }),
            full: this.full ? true : void 0
          },
          blocks: Array.from(this.blocks.values())
        };
        return Message.encode(msg).finish();
      }
      serializeToBitswap110() {
        const msg = {
          wantlist: {
            entries: Array.from(this.wantlist.values()).map((entry) => {
              return {
                block: entry.cid.bytes,
                priority: Number(entry.priority),
                wantType: entry.wantType,
                cancel: Boolean(entry.cancel),
                sendDontHave: Boolean(entry.sendDontHave)
              };
            }),
            full: this.full ? true : void 0
          },
          blockPresences: [],
          payload: [],
          pendingBytes: this.pendingBytes
        };
        for (const [cidStr, data] of this.blocks.entries()) {
          const cid = CID.parse(cidStr);
          const codec = Uint8Array.from([cid.code]);
          const multihash = cid.multihash.bytes.subarray(0, 2);
          const prefix = concat2([
            [cid.version],
            codec,
            multihash
          ], 1 + codec.byteLength + multihash.byteLength);
          msg.payload.push(new Message.Block({
            prefix,
            data
          }));
        }
        for (const [cidStr, bpType] of this.blockPresences) {
          msg.blockPresences.push(new Message.BlockPresence({
            cid: CID.parse(cidStr).bytes,
            type: bpType
          }));
        }
        if (this.pendingBytes > 0) {
          msg.pendingBytes = this.pendingBytes;
        }
        return Message.encode(msg).finish();
      }
      equals(other) {
        if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || !isMapEqual(this.blockPresences, other.blockPresences)) {
          return false;
        }
        return true;
      }
      get [Symbol.toStringTag]() {
        const list = Array.from(this.wantlist.keys());
        const blocks = Array.from(this.blocks.keys());
        return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;
      }
    };
    BitswapMessage.deserialize = async (raw7, hashers = {}) => {
      const decoded = Message.decode(raw7);
      const isFull = decoded.wantlist && decoded.wantlist.full || false;
      const msg = new BitswapMessage(isFull);
      if (decoded.wantlist && decoded.wantlist.entries) {
        decoded.wantlist.entries.forEach((entry) => {
          if (!entry.block) {
            return;
          }
          const cid = CID.decode(entry.block);
          msg.addEntry(cid, entry.priority || 0, entry.wantType, Boolean(entry.cancel), Boolean(entry.sendDontHave));
        });
      }
      if (decoded.blockPresences) {
        decoded.blockPresences.forEach((blockPresence) => {
          if (!blockPresence.cid) {
            return;
          }
          const cid = CID.decode(blockPresence.cid);
          if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {
            msg.addHave(cid);
          } else {
            msg.addDontHave(cid);
          }
        });
      }
      if (decoded.blocks.length > 0) {
        await Promise.all(decoded.blocks.map(async (b) => {
          const hash2 = await sha256.digest(b);
          const cid = CID.createV0(hash2);
          msg.addBlock(cid, b);
        }));
        return msg;
      }
      if (decoded.payload.length > 0) {
        await Promise.all(decoded.payload.map(async (p) => {
          if (!p.prefix || !p.data) {
            return;
          }
          const values = (0, import_varint_decoder.default)(p.prefix);
          const cidVersion = values[0];
          const multicodec = values[1];
          const hashAlg = values[2];
          const hasher = hashAlg === sha256.code ? sha256 : hashers[hashAlg];
          if (!hasher) {
            throw (0, import_err_code36.default)(new Error("Unknown hash algorithm"), "ERR_UNKNOWN_HASH_ALG");
          }
          const hash2 = await hasher.digest(p.data);
          const cid = CID.create(cidVersion, multicodec, hash2);
          msg.addBlock(cid, p.data);
        }));
        msg.setPendingBytes(decoded.pendingBytes);
        return msg;
      }
      return msg;
    };
    BitswapMessage.blockPresenceSize = (cid) => {
      return cid.bytes.length + 1;
    };
    BitswapMessage.Entry = BitswapMessageEntry;
    BitswapMessage.WantType = {
      Block: Message.Wantlist.WantType.Block,
      Have: Message.Wantlist.WantType.Have
    };
    BitswapMessage.BlockPresenceType = {
      Have: Message.BlockPresenceType.Have,
      DontHave: Message.BlockPresenceType.DontHave
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/constants.js
var SECOND, maxProvidersPerRequest, providerRequestTimeout, hasBlockTimeout, provideTimeout, kMaxPriority, maxListeners, wantlistSendDebounceMs;
var init_constants2 = __esm({
  "node_modules/ipfs-bitswap/esm/src/constants.js"() {
    init_node_globals();
    SECOND = 1e3;
    maxProvidersPerRequest = 3;
    providerRequestTimeout = 10 * SECOND;
    hasBlockTimeout = 15 * SECOND;
    provideTimeout = 15 * SECOND;
    kMaxPriority = Math.pow(2, 31) - 1;
    maxListeners = 1e3;
    wantlistSendDebounceMs = 1;
  }
});

// node_modules/just-debounce-it/index.js
var require_just_debounce_it = __commonJS({
  "node_modules/just-debounce-it/index.js"(exports2, module2) {
    init_node_globals();
    module2.exports = debounce2;
    function debounce2(fn, wait, callFirst) {
      var timeout = null;
      var debouncedFn = null;
      var clear = function() {
        if (timeout) {
          clearTimeout(timeout);
          debouncedFn = null;
          timeout = null;
        }
      };
      var flush2 = function() {
        var call = debouncedFn;
        clear();
        if (call) {
          call();
        }
      };
      var debounceWrapper = function() {
        if (!wait) {
          return fn.apply(this, arguments);
        }
        var context = this;
        var args = arguments;
        var callNow = callFirst && !timeout;
        clear();
        debouncedFn = function() {
          fn.apply(context, args);
        };
        timeout = setTimeout(function() {
          timeout = null;
          if (!callNow) {
            var call = debouncedFn;
            debouncedFn = null;
            return call();
          }
        }, wait);
        if (callNow) {
          return debouncedFn();
        }
      };
      debounceWrapper.cancel = clear;
      debounceWrapper.flush = flush2;
      return debounceWrapper;
    }
  }
});

// node_modules/ipfs-bitswap/esm/src/want-manager/msg-queue.js
var import_just_debounce_it, MsgQueue;
var init_msg_queue = __esm({
  "node_modules/ipfs-bitswap/esm/src/want-manager/msg-queue.js"() {
    init_node_globals();
    import_just_debounce_it = __toModule(require_just_debounce_it());
    init_message2();
    init_utils9();
    init_constants2();
    MsgQueue = class {
      constructor(selfPeerId, otherPeerId, network) {
        this.peerId = otherPeerId;
        this.network = network;
        this.refcnt = 1;
        this._entries = [];
        this._log = logger(selfPeerId, "msgqueue");
        this.sendEntries = (0, import_just_debounce_it.default)(this._sendEntries.bind(this), wantlistSendDebounceMs);
      }
      addMessage(msg) {
        if (msg.empty) {
          return;
        }
        this.send(msg);
      }
      addEntries(entries) {
        this._entries = this._entries.concat(entries);
        this.sendEntries();
      }
      _sendEntries() {
        if (!this._entries.length) {
          return;
        }
        const msg = new BitswapMessage(false);
        this._entries.forEach((entry) => {
          if (entry.cancel) {
            msg.cancel(entry.cid);
          } else {
            msg.addEntry(entry.cid, entry.priority);
          }
        });
        this._entries = [];
        this.addMessage(msg);
      }
      async send(msg) {
        try {
          await this.network.connectTo(this.peerId);
        } catch (err) {
          this._log.error("cant connect to peer %s: %s", this.peerId.toB58String(), err.message);
          return;
        }
        this._log("sending message to peer %s", this.peerId.toB58String());
        this.network.sendMessage(this.peerId, msg).catch((err) => {
          this._log.error("send error: %s", err.message);
        });
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/want-manager/index.js
var WantManager;
var init_want_manager = __esm({
  "node_modules/ipfs-bitswap/esm/src/want-manager/index.js"() {
    init_node_globals();
    init_message2();
    init_wantlist2();
    init_constants2();
    init_msg_queue();
    init_utils9();
    init_base58();
    WantManager = class {
      constructor(peerId, network, stats) {
        this.peers = new Map();
        this.wantlist = new Wantlist(stats);
        this.network = network;
        this._stats = stats;
        this._peerId = peerId;
        this._log = logger(peerId, "want");
      }
      _addEntries(cids, cancel, force) {
        const entries = cids.map((cid, i) => {
          return new BitswapMessage.Entry(cid, kMaxPriority - i, BitswapMessage.WantType.Block, cancel);
        });
        entries.forEach((e) => {
          if (e.cancel) {
            if (force) {
              this.wantlist.removeForce(e.cid.toString(base58btc));
            } else {
              this.wantlist.remove(e.cid);
            }
          } else {
            this._log("adding to wl");
            this.wantlist.add(e.cid, e.priority);
          }
        });
        for (const p of this.peers.values()) {
          p.addEntries(entries);
        }
      }
      _startPeerHandler(peerId) {
        let mq = this.peers.get(peerId.toB58String());
        if (mq) {
          mq.refcnt++;
          return;
        }
        mq = new MsgQueue(this._peerId, peerId, this.network);
        const fullwantlist = new BitswapMessage(true);
        for (const entry of this.wantlist.entries()) {
          fullwantlist.addEntry(entry[1].cid, entry[1].priority);
        }
        mq.addMessage(fullwantlist);
        this.peers.set(peerId.toB58String(), mq);
        return mq;
      }
      _stopPeerHandler(peerId) {
        const mq = this.peers.get(peerId.toB58String());
        if (!mq) {
          return;
        }
        mq.refcnt--;
        if (mq.refcnt > 0) {
          return;
        }
        this.peers.delete(peerId.toB58String());
      }
      wantBlocks(cids, options = {}) {
        this._addEntries(cids, false);
        if (options && options.signal) {
          options.signal.addEventListener("abort", () => {
            this.cancelWants(cids);
          });
        }
      }
      unwantBlocks(cids) {
        this._log("unwant blocks: %s", cids.length);
        this._addEntries(cids, true, true);
      }
      cancelWants(cids) {
        this._log("cancel wants: %s", cids.length);
        this._addEntries(cids, true);
      }
      connectedPeers() {
        return Array.from(this.peers.keys());
      }
      connected(peerId) {
        this._startPeerHandler(peerId);
      }
      disconnected(peerId) {
        this._stopPeerHandler(peerId);
      }
      start() {
      }
      stop() {
        this.peers.forEach((mq) => this.disconnected(mq.peerId));
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/network.js
async function writeMessage(stream, msg, log15) {
  try {
    await (0, import_it_pipe3.pipe)([msg], import_it_length_prefixed.default.encode(), stream);
  } catch (err) {
    log15(err);
  }
}
var import_it_length_prefixed, import_it_pipe3, import_multicodec_topology, BITSWAP100, BITSWAP110, BITSWAP120, Network;
var init_network = __esm({
  "node_modules/ipfs-bitswap/esm/src/network.js"() {
    init_node_globals();
    import_it_length_prefixed = __toModule(require_src12());
    import_it_pipe3 = __toModule(require_it_pipe());
    import_multicodec_topology = __toModule(require_multicodec_topology());
    init_message2();
    init_constants2();
    init_utils9();
    BITSWAP100 = "/ipfs/bitswap/1.0.0";
    BITSWAP110 = "/ipfs/bitswap/1.1.0";
    BITSWAP120 = "/ipfs/bitswap/1.2.0";
    Network = class {
      constructor(libp2p, bitswap, stats, options = {}) {
        this._log = logger(libp2p.peerId, "network");
        this._libp2p = libp2p;
        this._bitswap = bitswap;
        this._protocols = [BITSWAP100];
        if (!options.b100Only) {
          this._protocols.unshift(BITSWAP110);
          this._protocols.unshift(BITSWAP120);
        }
        this._stats = stats;
        this._running = false;
        this._onPeerConnect = this._onPeerConnect.bind(this);
        this._onPeerDisconnect = this._onPeerDisconnect.bind(this);
        this._onConnection = this._onConnection.bind(this);
        this._hashers = options.hashers || {};
      }
      start() {
        this._running = true;
        this._libp2p.handle(this._protocols, this._onConnection);
        const topology = new import_multicodec_topology.default({
          multicodecs: this._protocols,
          handlers: {
            onConnect: this._onPeerConnect,
            onDisconnect: this._onPeerDisconnect
          }
        });
        this._registrarId = this._libp2p.registrar.register(topology);
        for (const peer of this._libp2p.peerStore.peers.values()) {
          const conn = this._libp2p.connectionManager.get(peer.id);
          conn && this._onPeerConnect(conn.remotePeer);
        }
      }
      stop() {
        this._running = false;
        this._libp2p.unhandle(this._protocols);
        if (this._registrarId != null) {
          this._libp2p.registrar.unregister(this._registrarId);
        }
      }
      async _onConnection({ protocol, stream, connection }) {
        if (!this._running) {
          return;
        }
        this._log("incoming new bitswap %s connection from %s", protocol, connection.remotePeer.toB58String());
        try {
          await (0, import_it_pipe3.pipe)(stream, import_it_length_prefixed.default.decode(), async (source) => {
            for await (const data of source) {
              try {
                const message = await BitswapMessage.deserialize(data.slice(), this._hashers);
                await this._bitswap._receiveMessage(connection.remotePeer, message);
              } catch (err) {
                this._bitswap._receiveError(err);
                break;
              }
            }
          });
        } catch (err) {
          this._log(err);
        }
      }
      _onPeerConnect(peerId) {
        this._bitswap._onPeerConnected(peerId);
      }
      _onPeerDisconnect(peerId) {
        this._bitswap._onPeerDisconnected(peerId);
      }
      findProviders(cid, maxProviders, options = {}) {
        return this._libp2p.contentRouting.findProviders(cid, {
          timeout: providerRequestTimeout,
          maxNumProviders: maxProviders
        });
      }
      async findAndConnect(cid, options) {
        const connectAttempts = [];
        for await (const provider of this.findProviders(cid, maxProvidersPerRequest, options)) {
          this._log(`connecting to provider ${provider.id}`);
          connectAttempts.push(this.connectTo(provider.id, options).catch((err) => {
            this._log.error(err);
          }));
        }
        await Promise.all(connectAttempts);
      }
      async provide(cid, options) {
        await this._libp2p.contentRouting.provide(cid, options);
      }
      async sendMessage(peer, msg) {
        if (!this._running)
          throw new Error("network isn't running");
        const stringId = peer.toB58String();
        this._log("sendMessage to %s", stringId, msg);
        const connection = await this._libp2p.dial(peer);
        const { stream, protocol } = await connection.newStream([
          BITSWAP120,
          BITSWAP110,
          BITSWAP100
        ]);
        let serialized;
        switch (protocol) {
          case BITSWAP100:
            serialized = msg.serializeToBitswap100();
            break;
          case BITSWAP110:
          case BITSWAP120:
            serialized = msg.serializeToBitswap110();
            break;
          default:
            throw new Error("Unknown protocol: " + protocol);
        }
        writeMessage(stream, serialized, this._log);
        this._updateSentStats(peer, msg.blocks);
      }
      async connectTo(peer, options) {
        if (!this._running) {
          throw new Error("network isn't running");
        }
        return this._libp2p.dial(peer, options);
      }
      _updateSentStats(peer, blocks) {
        const peerId = peer.toB58String();
        if (this._stats) {
          for (const block of blocks.values()) {
            this._stats.push(peerId, "dataSent", block.length);
          }
          this._stats.push(peerId, "blocksSent", blocks.size);
        }
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/decision-engine/ledger.js
var Ledger;
var init_ledger = __esm({
  "node_modules/ipfs-bitswap/esm/src/decision-engine/ledger.js"() {
    init_node_globals();
    init_wantlist2();
    Ledger = class {
      constructor(peerId) {
        this.partner = peerId;
        this.wantlist = new Wantlist();
        this.exchangeCount = 0;
        this.sentToPeer = new Map();
        this.accounting = {
          bytesSent: 0,
          bytesRecv: 0
        };
      }
      sentBytes(n) {
        this.exchangeCount++;
        this.lastExchange = new Date().getTime();
        this.accounting.bytesSent += n;
      }
      receivedBytes(n) {
        this.exchangeCount++;
        this.lastExchange = new Date().getTime();
        this.accounting.bytesRecv += n;
      }
      wants(cid, priority, wantType) {
        this.wantlist.add(cid, priority, wantType);
      }
      cancelWant(cid) {
        this.wantlist.remove(cid);
      }
      wantlistContains(cid) {
        return this.wantlist.get(cid);
      }
      debtRatio() {
        return this.accounting.bytesSent / (this.accounting.bytesRecv + 1);
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/utils/sorted-map.js
var SortedMap;
var init_sorted_map = __esm({
  "node_modules/ipfs-bitswap/esm/src/utils/sorted-map.js"() {
    init_node_globals();
    SortedMap = class extends Map {
      constructor(entries, cmp) {
        super();
        this._cmp = cmp || this._defaultSort;
        this._keys = [];
        for (const [k, v] of entries || []) {
          this.set(k, v);
        }
      }
      update(i) {
        if (i < 0 || i >= this._keys.length) {
          return;
        }
        const k = this._keys[i];
        this._keys.splice(i, 1);
        const newIdx = this._find(k);
        this._keys.splice(newIdx, 0, k);
      }
      set(k, v) {
        if (this.has(k)) {
          const i2 = this.indexOf(k);
          this._keys.splice(i2, 1);
        }
        super.set(k, v);
        const i = this._find(k);
        this._keys.splice(i, 0, k);
        return this;
      }
      clear() {
        super.clear();
        this._keys = [];
      }
      delete(k) {
        if (!this.has(k)) {
          return false;
        }
        const i = this.indexOf(k);
        this._keys.splice(i, 1);
        return super.delete(k);
      }
      indexOf(k) {
        if (!this.has(k)) {
          return -1;
        }
        const i = this._find(k);
        if (this._keys[i] === k) {
          return i;
        }
        for (let j = 1; j < this._keys.length; j++) {
          if (this._keys[i + j] === k)
            return i + j;
          if (this._keys[i - j] === k)
            return i - j;
        }
        return -1;
      }
      _find(k) {
        let lower = 0;
        let upper = this._keys.length;
        while (lower < upper) {
          const pivot = lower + upper >>> 1;
          const cmp = this._kCmp(this._keys[pivot], k);
          if (cmp < 0) {
            lower = pivot + 1;
          } else if (cmp > 0) {
            upper = pivot;
          } else {
            return pivot;
          }
        }
        return lower;
      }
      *keys() {
        for (const k of this._keys) {
          yield k;
        }
        return void 0;
      }
      *values() {
        for (const k of this._keys) {
          yield this.get(k);
        }
        return void 0;
      }
      *entries() {
        for (const k of this._keys) {
          yield [
            k,
            this.get(k)
          ];
        }
        return void 0;
      }
      *[Symbol.iterator]() {
        yield* this.entries();
      }
      forEach(cb, thisArg) {
        if (!cb) {
          return;
        }
        for (const k of this._keys) {
          cb.apply(thisArg, [[
            k,
            this.get(k)
          ]]);
        }
      }
      _defaultSort(a, b) {
        if (a[0] < b[0])
          return -1;
        if (b[0] < a[0])
          return 1;
        return 0;
      }
      _kCmp(a, b) {
        return this._cmp([
          a,
          this.get(a)
        ], [
          b,
          this.get(b)
        ]);
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/decision-engine/req-queue.js
var DefaultTaskMerger, RequestQueue, PeerTasks, PendingTasks;
var init_req_queue = __esm({
  "node_modules/ipfs-bitswap/esm/src/decision-engine/req-queue.js"() {
    init_node_globals();
    init_sorted_map();
    DefaultTaskMerger = {
      hasNewInfo() {
        return false;
      },
      merge() {
      }
    };
    RequestQueue = class {
      constructor(taskMerger = DefaultTaskMerger) {
        this._taskMerger = taskMerger;
        this._byPeer = new SortedMap([], PeerTasks.compare);
      }
      pushTasks(peerId, tasks) {
        let peerTasks = this._byPeer.get(peerId.toB58String());
        if (!peerTasks) {
          peerTasks = new PeerTasks(peerId, this._taskMerger);
        }
        peerTasks.pushTasks(tasks);
        this._byPeer.set(peerId.toB58String(), peerTasks);
      }
      popTasks(targetMinBytes) {
        const peerTasks = this._head();
        if (peerTasks === void 0) {
          return {
            tasks: [],
            pendingSize: 0
          };
        }
        const { tasks, pendingSize } = peerTasks.popTasks(targetMinBytes);
        if (tasks.length === 0) {
          return {
            tasks,
            pendingSize
          };
        }
        const peerId = peerTasks.peerId;
        if (peerTasks.isIdle()) {
          this._byPeer.delete(peerId.toB58String());
        } else {
          this._byPeer.update(0);
        }
        return {
          peerId,
          tasks,
          pendingSize
        };
      }
      _head() {
        if (this._byPeer.size === 0) {
          return void 0;
        }
        for (const [, v] of this._byPeer) {
          return v;
        }
        return void 0;
      }
      remove(topic, peerId) {
        const peerTasks = this._byPeer.get(peerId.toB58String());
        peerTasks && peerTasks.remove(topic);
      }
      tasksDone(peerId, tasks) {
        const peerTasks = this._byPeer.get(peerId.toB58String());
        if (!peerTasks) {
          return;
        }
        const i = this._byPeer.indexOf(peerId.toB58String());
        for (const task of tasks) {
          peerTasks.taskDone(task);
        }
        this._byPeer.update(i);
      }
    };
    PeerTasks = class {
      constructor(peerId, taskMerger) {
        this.peerId = peerId;
        this._taskMerger = taskMerger;
        this._activeTotalSize = 0;
        this._pending = new PendingTasks();
        this._active = new Set();
      }
      pushTasks(tasks) {
        for (const t of tasks) {
          this._pushTask(t);
        }
      }
      _pushTask(task) {
        if (!this._taskHasMoreInfoThanActiveTasks(task)) {
          return;
        }
        const existingTask = this._pending.get(task.topic);
        if (existingTask) {
          if (task.priority > existingTask.priority) {
            this._pending.updatePriority(task.topic, task.priority);
          }
          this._taskMerger.merge(task, existingTask);
          return;
        }
        this._pending.add(task);
      }
      _taskHasMoreInfoThanActiveTasks(task) {
        const tasksWithTopic = [];
        for (const activeTask of this._active) {
          if (activeTask.topic === task.topic) {
            tasksWithTopic.push(activeTask);
          }
        }
        if (tasksWithTopic.length === 0) {
          return true;
        }
        return this._taskMerger.hasNewInfo(task, tasksWithTopic);
      }
      popTasks(targetMinBytes) {
        let size = 0;
        const tasks = [];
        const pendingTasks = this._pending.tasks();
        for (let i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {
          const task = pendingTasks[i];
          tasks.push(task);
          size += task.size;
          this._pending.delete(task.topic);
          this._activeTotalSize += task.size;
          this._active.add(task);
        }
        return {
          tasks,
          pendingSize: this._pending.totalSize
        };
      }
      taskDone(task) {
        if (this._active.has(task)) {
          this._activeTotalSize -= task.size;
          this._active.delete(task);
        }
      }
      remove(topic) {
        this._pending.delete(topic);
      }
      isIdle() {
        return this._pending.length === 0 && this._active.size === 0;
      }
      static compare(a, b) {
        if (a[1]._pending.length === 0) {
          return 1;
        }
        if (b[1]._pending.length === 0) {
          return -1;
        }
        if (a[1]._activeTotalSize === b[1]._activeTotalSize) {
          return b[1]._pending.length - a[1]._pending.length;
        }
        return a[1]._activeTotalSize - b[1]._activeTotalSize;
      }
    };
    PendingTasks = class {
      constructor() {
        this._tasks = new SortedMap([], this._compare);
      }
      get length() {
        return this._tasks.size;
      }
      get totalSize() {
        return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0);
      }
      get(topic) {
        return (this._tasks.get(topic) || {}).task;
      }
      add(task) {
        this._tasks.set(task.topic, {
          created: Date.now(),
          task
        });
      }
      delete(topic) {
        this._tasks.delete(topic);
      }
      tasks() {
        return [...this._tasks.values()].map((i) => i.task);
      }
      updatePriority(topic, priority) {
        const obj = this._tasks.get(topic);
        if (!obj) {
          return;
        }
        const i = this._tasks.indexOf(topic);
        obj.task.priority = priority;
        this._tasks.update(i);
      }
      _compare(a, b) {
        if (a[1].task.priority === b[1].task.priority) {
          return a[1].created - b[1].created;
        }
        return b[1].task.priority - a[1].task.priority;
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/decision-engine/task-merger.js
var TaskMerger;
var init_task_merger = __esm({
  "node_modules/ipfs-bitswap/esm/src/decision-engine/task-merger.js"() {
    init_node_globals();
    TaskMerger = {
      hasNewInfo(task, tasksWithTopic) {
        let haveBlock = false;
        let isWantBlock = false;
        for (const existing of tasksWithTopic) {
          if (existing.data.haveBlock) {
            haveBlock = true;
          }
          if (existing.data.isWantBlock) {
            isWantBlock = true;
          }
        }
        if (!isWantBlock && task.data.isWantBlock) {
          return true;
        }
        if (!haveBlock && task.data.haveBlock) {
          return true;
        }
        return false;
      },
      merge(newTask, existingTask) {
        const taskData = newTask.data;
        const existingData = existingTask.data;
        if (!existingData.haveBlock && taskData.haveBlock) {
          existingData.haveBlock = taskData.haveBlock;
          existingData.blockSize = taskData.blockSize;
        }
        if (!existingData.isWantBlock && taskData.isWantBlock) {
          existingData.isWantBlock = true;
          if (!existingData.haveBlock || taskData.haveBlock) {
            existingData.haveBlock = taskData.haveBlock;
            existingTask.size = newTask.size;
          }
        }
        if (existingData.isWantBlock && existingData.haveBlock) {
          existingTask.size = existingData.blockSize;
        }
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/decision-engine/index.js
var WantType2, TARGET_MESSAGE_SIZE, MAX_SIZE_REPLACE_HAS_WITH_BLOCK, DecisionEngine;
var init_decision_engine = __esm({
  "node_modules/ipfs-bitswap/esm/src/decision-engine/index.js"() {
    init_node_globals();
    init_cid();
    init_base58();
    init_message2();
    init_wantlist2();
    init_ledger();
    init_req_queue();
    init_task_merger();
    init_utils9();
    WantType2 = BitswapMessage.WantType;
    TARGET_MESSAGE_SIZE = 16 * 1024;
    MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
    DecisionEngine = class {
      constructor(peerId, blockstore, network, stats, opts = {}) {
        this._log = logger(peerId, "engine");
        this.blockstore = blockstore;
        this.network = network;
        this._stats = stats;
        this._opts = this._processOpts(opts);
        this.ledgerMap = new Map();
        this._running = false;
        this._requestQueue = new RequestQueue(TaskMerger);
      }
      _processOpts(opts) {
        return {
          maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,
          targetMessageSize: TARGET_MESSAGE_SIZE,
          ...opts
        };
      }
      _scheduleProcessTasks() {
        setTimeout(() => {
          this._processTasks();
        });
      }
      async _processTasks() {
        if (!this._running) {
          return;
        }
        const { peerId, tasks, pendingSize } = this._requestQueue.popTasks(this._opts.targetMessageSize);
        if (tasks.length === 0) {
          return;
        }
        const msg = new BitswapMessage(false);
        msg.setPendingBytes(pendingSize);
        const blockCids = [];
        const blockTasks = new Map();
        for (const task of tasks) {
          const cid = CID.parse(task.topic);
          if (task.data.haveBlock) {
            if (task.data.isWantBlock) {
              blockCids.push(cid);
              blockTasks.set(task.topic, task.data);
            } else {
              msg.addHave(cid);
            }
          } else {
            msg.addDontHave(cid);
          }
        }
        const blocks = await this._getBlocks(blockCids);
        for (const [topic, taskData] of blockTasks) {
          const cid = CID.parse(topic);
          const blk = blocks.get(topic);
          if (blk) {
            msg.addBlock(cid, blk);
          } else {
            if (taskData.sendDontHave) {
              msg.addDontHave(cid);
            }
          }
        }
        if (msg.empty) {
          peerId && this._requestQueue.tasksDone(peerId, tasks);
          this._scheduleProcessTasks();
          return;
        }
        try {
          peerId && await this.network.sendMessage(peerId, msg);
          for (const [cidStr, block] of blocks.entries()) {
            peerId && this.messageSent(peerId, CID.parse(cidStr), block);
          }
        } catch (err) {
          this._log.error(err);
        }
        peerId && this._requestQueue.tasksDone(peerId, tasks);
        this._scheduleProcessTasks();
      }
      wantlistForPeer(peerId) {
        const peerIdStr = peerId.toB58String();
        const ledger = this.ledgerMap.get(peerIdStr);
        return ledger ? ledger.wantlist.sortedEntries() : new Map();
      }
      ledgerForPeer(peerId) {
        const peerIdStr = peerId.toB58String();
        const ledger = this.ledgerMap.get(peerIdStr);
        if (!ledger) {
          return null;
        }
        return {
          peer: ledger.partner,
          value: ledger.debtRatio(),
          sent: ledger.accounting.bytesSent,
          recv: ledger.accounting.bytesRecv,
          exchanged: ledger.exchangeCount
        };
      }
      peers() {
        return Array.from(this.ledgerMap.values()).map((l) => l.partner);
      }
      receivedBlocks(blocks) {
        if (!blocks.length) {
          return;
        }
        for (const ledger of this.ledgerMap.values()) {
          for (const block of blocks) {
            const want = ledger.wantlistContains(block.cid);
            if (!want) {
              continue;
            }
            const blockSize = block.data.length;
            const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
            let entrySize = blockSize;
            if (!isWantBlock) {
              entrySize = BitswapMessage.blockPresenceSize(want.cid);
            }
            this._requestQueue.pushTasks(ledger.partner, [{
              topic: want.cid.toString(base58btc),
              priority: want.priority,
              size: entrySize,
              data: {
                blockSize,
                isWantBlock,
                haveBlock: true,
                sendDontHave: false
              }
            }]);
          }
        }
        this._scheduleProcessTasks();
      }
      async messageReceived(peerId, msg) {
        const ledger = this._findOrCreate(peerId);
        if (msg.empty) {
          return;
        }
        if (msg.full) {
          ledger.wantlist = new Wantlist();
        }
        this._updateBlockAccounting(msg.blocks, ledger);
        if (msg.wantlist.size === 0) {
          this._scheduleProcessTasks();
          return;
        }
        const cancels = [];
        const wants = [];
        msg.wantlist.forEach((entry) => {
          if (entry.cancel) {
            ledger.cancelWant(entry.cid);
            cancels.push(entry.cid);
          } else {
            ledger.wants(entry.cid, entry.priority, entry.wantType);
            wants.push(entry);
          }
        });
        this._cancelWants(peerId, cancels);
        await this._addWants(peerId, wants);
        this._scheduleProcessTasks();
      }
      _cancelWants(peerId, cids) {
        for (const c of cids) {
          this._requestQueue.remove(c.toString(base58btc), peerId);
        }
      }
      async _addWants(peerId, wants) {
        const blockSizes = await this._getBlockSizes(wants.map((w) => w.cid));
        const tasks = [];
        for (const want of wants) {
          const id = want.cid.toString(base58btc);
          const blockSize = blockSizes.get(id);
          if (blockSize == null) {
            if (want.sendDontHave) {
              tasks.push({
                topic: id,
                priority: want.priority,
                size: BitswapMessage.blockPresenceSize(want.cid),
                data: {
                  isWantBlock: want.wantType === WantType2.Block,
                  blockSize: 0,
                  haveBlock: false,
                  sendDontHave: want.sendDontHave
                }
              });
            }
          } else {
            const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
            let entrySize = blockSize;
            if (!isWantBlock) {
              entrySize = BitswapMessage.blockPresenceSize(want.cid);
            }
            tasks.push({
              topic: id,
              priority: want.priority,
              size: entrySize,
              data: {
                isWantBlock,
                blockSize,
                haveBlock: true,
                sendDontHave: want.sendDontHave
              }
            });
          }
          this._requestQueue.pushTasks(peerId, tasks);
        }
      }
      _sendAsBlock(wantType, blockSize) {
        return wantType === WantType2.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;
      }
      async _getBlockSizes(cids) {
        const blocks = await this._getBlocks(cids);
        return new Map([...blocks].map(([k, v]) => [
          k,
          v.length
        ]));
      }
      async _getBlocks(cids) {
        const res = new Map();
        await Promise.all(cids.map(async (cid) => {
          try {
            const block = await this.blockstore.get(cid);
            res.set(cid.toString(base58btc), block);
          } catch (e) {
            if (e.code !== "ERR_NOT_FOUND") {
              this._log.error("failed to query blockstore for %s: %s", cid, e);
            }
          }
        }));
        return res;
      }
      _updateBlockAccounting(blocksMap, ledger) {
        for (const block of blocksMap.values()) {
          this._log("got block (%s bytes)", block.length);
          ledger.receivedBytes(block.length);
        }
      }
      messageSent(peerId, cid, block) {
        const ledger = this._findOrCreate(peerId);
        ledger.sentBytes(block.length);
        ledger.wantlist.remove(cid);
      }
      numBytesSentTo(peerId) {
        return this._findOrCreate(peerId).accounting.bytesSent;
      }
      numBytesReceivedFrom(peerId) {
        return this._findOrCreate(peerId).accounting.bytesRecv;
      }
      peerDisconnected(_peerId) {
      }
      _findOrCreate(peerId) {
        const peerIdStr = peerId.toB58String();
        const ledger = this.ledgerMap.get(peerIdStr);
        if (ledger) {
          return ledger;
        }
        const l = new Ledger(peerId);
        this.ledgerMap.set(peerIdStr, l);
        if (this._stats) {
          this._stats.push(peerIdStr, "peerCount", 1);
        }
        return l;
      }
      start() {
        this._running = true;
      }
      stop() {
        this._running = false;
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/notifications.js
var import_events, unwantEvent, blockEvent, Notifications;
var init_notifications = __esm({
  "node_modules/ipfs-bitswap/esm/src/notifications.js"() {
    init_node_globals();
    import_events = __toModule(require_events());
    init_to_string();
    init_constants2();
    init_utils9();
    unwantEvent = (cid) => `unwant:${toString3(cid.multihash.bytes, "base64")}`;
    blockEvent = (cid) => `block:${toString3(cid.multihash.bytes, "base64")}`;
    Notifications = class extends import_events.EventEmitter {
      constructor(peerId) {
        super();
        this.setMaxListeners(maxListeners);
        this._log = logger(peerId, "notif");
      }
      hasBlock(cid, block) {
        const event = blockEvent(cid);
        this._log(event);
        this.emit(event, block);
      }
      wantBlock(cid, options = {}) {
        if (!cid) {
          throw new Error("Not a valid cid");
        }
        const blockEvt = blockEvent(cid);
        const unwantEvt = unwantEvent(cid);
        this._log(`wantBlock:${cid}`);
        return new Promise((resolve6, reject) => {
          const onUnwant = () => {
            this.removeListener(blockEvt, onBlock);
            reject(new Error(`Block for ${cid} unwanted`));
          };
          const onBlock = (data) => {
            this.removeListener(unwantEvt, onUnwant);
            resolve6(data);
          };
          this.once(unwantEvt, onUnwant);
          this.once(blockEvt, onBlock);
          if (options && options.signal) {
            options.signal.addEventListener("abort", () => {
              this.removeListener(blockEvt, onBlock);
              this.removeListener(unwantEvt, onUnwant);
              reject(new Error(`Want for ${cid} aborted`));
            });
          }
        });
      }
      unwantBlock(cid) {
        const event = unwantEvent(cid);
        this._log(event);
        this.emit(event);
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/stats/stat.js
var import_events2, import_moving_average, Stat;
var init_stat6 = __esm({
  "node_modules/ipfs-bitswap/esm/src/stats/stat.js"() {
    init_node_globals();
    import_events2 = __toModule(require_events());
    import_moving_average = __toModule(require_moving_average());
    Stat = class extends import_events2.EventEmitter {
      constructor(initialCounters, options) {
        super();
        this._options = options;
        this._queue = [];
        this._stats = {};
        this._frequencyLastTime = Date.now();
        this._frequencyAccumulators = {};
        this._movingAverages = {};
        this._update = this._update.bind(this);
        initialCounters.forEach((key) => {
          this._stats[key] = BigInt(0);
          this._movingAverages[key] = {};
          this._options.movingAverageIntervals.forEach((interval) => {
            const ma = this._movingAverages[key][interval] = (0, import_moving_average.default)(interval);
            ma.push(this._frequencyLastTime, 0);
          });
        });
        this._enabled = this._options.enabled;
      }
      enable() {
        this._enabled = true;
      }
      disable() {
        this._disabled = true;
      }
      stop() {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
      }
      get snapshot() {
        return Object.assign({}, this._stats);
      }
      get movingAverages() {
        return Object.assign({}, this._movingAverages);
      }
      push(counter, inc) {
        if (this._enabled) {
          this._queue.push([
            counter,
            inc,
            Date.now()
          ]);
          this._resetComputeTimeout();
        }
      }
      _resetComputeTimeout() {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        this._timeout = setTimeout(this._update, this._nextTimeout());
      }
      _nextTimeout() {
        const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
        return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
      }
      _update() {
        this._timeout = null;
        if (this._queue.length) {
          let last6;
          while (this._queue.length) {
            const op = last6 = this._queue.shift();
            op && this._applyOp(op);
          }
          last6 && this._updateFrequency(last6[2]);
          this.emit("update", this._stats);
        }
      }
      _updateFrequency(latestTime) {
        const timeDiff = latestTime - this._frequencyLastTime;
        if (timeDiff) {
          Object.keys(this._stats).forEach((key) => {
            this._updateFrequencyFor(key, timeDiff, latestTime);
          });
        }
        this._frequencyLastTime = latestTime;
      }
      _updateFrequencyFor(key, timeDiffMS, latestTime) {
        const count = this._frequencyAccumulators[key] || 0;
        this._frequencyAccumulators[key] = 0;
        const hz = count / timeDiffMS * 1e3;
        let movingAverages = this._movingAverages[key];
        if (!movingAverages) {
          movingAverages = this._movingAverages[key] = {};
        }
        this._options.movingAverageIntervals.forEach((movingAverageInterval) => {
          let movingAverage = movingAverages[movingAverageInterval];
          if (!movingAverage) {
            movingAverage = movingAverages[movingAverageInterval] = (0, import_moving_average.default)(movingAverageInterval);
          }
          movingAverage.push(latestTime, hz);
        });
      }
      _applyOp(op) {
        const key = op[0];
        const inc = op[1];
        if (typeof inc !== "number") {
          throw new Error(`invalid increment number: ${inc}`);
        }
        if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
          this._stats[key] = BigInt(0);
        }
        this._stats[key] = BigInt(this._stats[key]) + BigInt(inc);
        if (!this._frequencyAccumulators[key]) {
          this._frequencyAccumulators[key] = 0;
        }
        this._frequencyAccumulators[key] += inc;
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/stats/index.js
var import_events3, defaultOptions2, Stats;
var init_stats2 = __esm({
  "node_modules/ipfs-bitswap/esm/src/stats/index.js"() {
    init_node_globals();
    import_events3 = __toModule(require_events());
    init_stat6();
    defaultOptions2 = {
      enabled: false,
      computeThrottleTimeout: 1e3,
      computeThrottleMaxQueueSize: 1e3,
      movingAverageIntervals: [
        60 * 1e3,
        5 * 60 * 1e3,
        15 * 60 * 1e3
      ]
    };
    Stats = class extends import_events3.EventEmitter {
      constructor(initialCounters = [], _options = defaultOptions2) {
        super();
        const options = Object.assign({}, defaultOptions2, _options);
        if (typeof options.computeThrottleTimeout !== "number") {
          throw new Error("need computeThrottleTimeout");
        }
        if (typeof options.computeThrottleMaxQueueSize !== "number") {
          throw new Error("need computeThrottleMaxQueueSize");
        }
        this._initialCounters = initialCounters;
        this._options = options;
        this._enabled = this._options.enabled;
        this._global = new Stat(initialCounters, options);
        this._global.on("update", (stats) => this.emit("update", stats));
        this._peers = new Map();
      }
      enable() {
        this._enabled = true;
        this._options.enabled = true;
        this._global.enable();
      }
      disable() {
        this._enabled = false;
        this._options.enabled = false;
        this._global.disable();
      }
      stop() {
        this._enabled = false;
        this._global.stop();
        for (const peerStat of this._peers) {
          peerStat[1].stop();
        }
      }
      get snapshot() {
        return this._global.snapshot;
      }
      get movingAverages() {
        return this._global.movingAverages;
      }
      forPeer(peerId) {
        const peerIdStr = typeof peerId !== "string" && peerId.toB58String ? peerId.toB58String() : `${peerId}`;
        return this._peers.get(peerIdStr);
      }
      push(peer, counter, inc) {
        if (this._enabled) {
          this._global.push(counter, inc);
          if (peer) {
            let peerStats = this._peers.get(peer);
            if (!peerStats) {
              peerStats = new Stat(this._initialCounters, this._options);
              this._peers.set(peer, peerStats);
            }
            peerStats.push(counter, inc);
          }
        }
      }
      disconnected(peer) {
        const peerId = peer.toB58String();
        const peerStats = this._peers.get(peerId);
        if (peerStats) {
          peerStats.stop();
          this._peers.delete(peerId);
        }
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/bitswap.js
var import_native_abort_controller12, import_any_signal3, defaultOptions3, statsKeys, Bitswap;
var init_bitswap2 = __esm({
  "node_modules/ipfs-bitswap/esm/src/bitswap.js"() {
    init_node_globals();
    init_want_manager();
    init_network();
    init_decision_engine();
    init_notifications();
    init_utils9();
    init_stats2();
    import_native_abort_controller12 = __toModule(require_src4());
    import_any_signal3 = __toModule(require_any_signal());
    init_base4();
    init_cid();
    defaultOptions3 = {
      statsEnabled: false,
      statsComputeThrottleTimeout: 1e3,
      statsComputeThrottleMaxQueueSize: 1e3
    };
    statsKeys = [
      "blocksReceived",
      "dataReceived",
      "dupBlksReceived",
      "dupDataReceived",
      "blocksSent",
      "dataSent",
      "providesBufferLength",
      "wantListLength",
      "peerCount"
    ];
    Bitswap = class extends BaseBlockstore {
      constructor(libp2p, blockstore, options = {}) {
        super();
        this._libp2p = libp2p;
        this._log = logger(this.peerId);
        this._options = Object.assign({}, defaultOptions3, options);
        this._stats = new Stats(statsKeys, {
          enabled: this._options.statsEnabled,
          computeThrottleTimeout: this._options.statsComputeThrottleTimeout,
          computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize
        });
        this.network = new Network(libp2p, this, this._stats, { hashers: options.hashers });
        this.blockstore = blockstore;
        this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats);
        this.wm = new WantManager(this.peerId, this.network, this._stats);
        this.notifications = new Notifications(this.peerId);
        this.started = false;
      }
      isStarted() {
        return this.started;
      }
      get peerId() {
        return this._libp2p.peerId;
      }
      async _receiveMessage(peerId, incoming) {
        try {
          await this.engine.messageReceived(peerId, incoming);
        } catch (err) {
          this._log("failed to receive message", incoming);
        }
        if (incoming.blocks.size === 0) {
          return;
        }
        const received = [];
        for (const [cidStr, data] of incoming.blocks.entries()) {
          const cid = CID.parse(cidStr);
          received.push({
            wasWanted: this.wm.wantlist.contains(cid),
            cid,
            data
          });
        }
        this.wm.cancelWants(received.filter(({ wasWanted }) => wasWanted).map(({ cid }) => cid));
        await Promise.all(received.map(({ cid, wasWanted, data }) => this._handleReceivedBlock(peerId, cid, data, wasWanted)));
      }
      async _handleReceivedBlock(peerId, cid, data, wasWanted) {
        this._log("received block");
        const has = await this.blockstore.has(cid);
        this._updateReceiveCounters(peerId.toB58String(), cid, data, has);
        if (!wasWanted) {
          return;
        }
        await this.put(cid, data);
      }
      _updateReceiveCounters(peerIdStr, cid, data, exists) {
        this._stats.push(peerIdStr, "blocksReceived", 1);
        this._stats.push(peerIdStr, "dataReceived", data.length);
        if (exists) {
          this._stats.push(peerIdStr, "dupBlksReceived", 1);
          this._stats.push(peerIdStr, "dupDataReceived", data.length);
        }
      }
      _receiveError(err) {
        this._log.error("ReceiveError: %s", err.message);
      }
      _onPeerConnected(peerId) {
        this.wm.connected(peerId);
      }
      _onPeerDisconnected(peerId) {
        this.wm.disconnected(peerId);
        this.engine.peerDisconnected(peerId);
        this._stats.disconnected(peerId);
      }
      enableStats() {
        this._stats.enable();
      }
      disableStats() {
        this._stats.disable();
      }
      wantlistForPeer(peerId, _options) {
        return this.engine.wantlistForPeer(peerId);
      }
      ledgerForPeer(peerId) {
        return this.engine.ledgerForPeer(peerId);
      }
      async get(cid, options = {}) {
        const fetchFromNetwork = (cid2, options2) => {
          this.wm.wantBlocks([cid2], options2);
          return this.notifications.wantBlock(cid2, options2);
        };
        let promptedNetwork = false;
        const loadOrFetchFromNetwork = async (cid2, options2) => {
          try {
            const block2 = await this.blockstore.get(cid2, options2);
            return block2;
          } catch (err) {
            if (err.code !== "ERR_NOT_FOUND") {
              throw err;
            }
            if (!promptedNetwork) {
              promptedNetwork = true;
              this.network.findAndConnect(cid2).catch((err2) => this._log.error(err2));
            }
            return fetchFromNetwork(cid2, options2);
          }
        };
        const controller = new import_native_abort_controller12.AbortController();
        const signal = options.signal ? (0, import_any_signal3.anySignal)([
          options.signal,
          controller.signal
        ]) : controller.signal;
        const block = await Promise.race([
          this.notifications.wantBlock(cid, { signal }),
          loadOrFetchFromNetwork(cid, { signal })
        ]);
        controller.abort();
        return block;
      }
      async *getMany(cids, options = {}) {
        for await (const cid of cids) {
          yield this.get(cid, options);
        }
      }
      unwant(cids) {
        const cidsArray = Array.isArray(cids) ? cids : [cids];
        this.wm.unwantBlocks(cidsArray);
        cidsArray.forEach((cid) => this.notifications.unwantBlock(cid));
      }
      cancelWants(cids) {
        this.wm.cancelWants(Array.isArray(cids) ? cids : [cids]);
      }
      async put(cid, block, _options) {
        await this.blockstore.put(cid, block);
        this._sendHaveBlockNotifications(cid, block);
      }
      async *putMany(source, options) {
        for await (const { key, value } of this.blockstore.putMany(source, options)) {
          this._sendHaveBlockNotifications(key, value);
          yield {
            key,
            value
          };
        }
      }
      _sendHaveBlockNotifications(cid, data) {
        this.notifications.hasBlock(cid, data);
        this.engine.receivedBlocks([{
          cid,
          data
        }]);
        this.network.provide(cid).catch((err) => {
          this._log.error("Failed to provide: %s", err.message);
        });
      }
      getWantlist() {
        return this.wm.wantlist.entries();
      }
      peers() {
        return this.engine.peers();
      }
      stat() {
        return this._stats;
      }
      start() {
        this.wm.start();
        this.network.start();
        this.engine.start();
        this.started = true;
      }
      stop() {
        this._stats.stop();
        this.wm.stop();
        this.network.stop();
        this.engine.stop();
        this.started = false;
      }
      unwrap() {
        return this.blockstore;
      }
    };
  }
});

// node_modules/ipfs-bitswap/esm/src/index.js
var src_exports8 = {};
__export(src_exports8, {
  createBitswap: () => createBitswap2
});
var createBitswap2;
var init_src15 = __esm({
  "node_modules/ipfs-bitswap/esm/src/index.js"() {
    init_node_globals();
    init_bitswap2();
    createBitswap2 = (libp2p, blockstore, options = {}) => {
      return new Bitswap(libp2p, blockstore, options);
    };
  }
});

// node_modules/blockstore-core/esm/src/errors.js
var errors_exports4 = {};
__export(errors_exports4, {
  abortedError: () => abortedError2,
  notFoundError: () => notFoundError2
});
function notFoundError2(err) {
  err = err || new Error("Not Found");
  return (0, import_err_code37.default)(err, "ERR_NOT_FOUND");
}
function abortedError2(err) {
  err = err || new Error("Aborted");
  return (0, import_err_code37.default)(err, "ERR_ABORTED");
}
var import_err_code37;
var init_errors6 = __esm({
  "node_modules/blockstore-core/esm/src/errors.js"() {
    init_node_globals();
    import_err_code37 = __toModule(require_err_code());
  }
});

// node_modules/blockstore-core/esm/src/memory.js
var MemoryBlockstore;
var init_memory3 = __esm({
  "node_modules/blockstore-core/esm/src/memory.js"() {
    init_node_globals();
    init_base4();
    init_base32();
    init_raw();
    init_cid();
    init_digest();
    init_errors6();
    MemoryBlockstore = class extends BaseBlockstore {
      constructor() {
        super();
        this.data = {};
      }
      open() {
        return Promise.resolve();
      }
      close() {
        return Promise.resolve();
      }
      async put(key, val) {
        this.data[base32.encode(key.multihash.bytes)] = val;
      }
      async get(key) {
        const exists = await this.has(key);
        if (!exists)
          throw notFoundError2();
        return this.data[base32.encode(key.multihash.bytes)];
      }
      async has(key) {
        return this.data[base32.encode(key.multihash.bytes)] !== void 0;
      }
      async delete(key) {
        delete this.data[base32.encode(key.multihash.bytes)];
      }
      async *_all() {
        yield* Object.entries(this.data).map(([key, value]) => ({
          key: CID.createV1(code3, decode3(base32.decode(key))),
          value
        }));
      }
      async *_allKeys() {
        yield* Object.entries(this.data).map(([key]) => CID.createV1(code3, decode3(base32.decode(key))));
      }
    };
  }
});

// node_modules/blockstore-core/esm/src/index.js
var src_exports9 = {};
__export(src_exports9, {
  BaseBlockstore: () => BaseBlockstore,
  Errors: () => Errors7,
  MemoryBlockstore: () => MemoryBlockstore
});
var Errors7;
var init_src16 = __esm({
  "node_modules/blockstore-core/esm/src/index.js"() {
    init_node_globals();
    init_errors6();
    init_base4();
    init_memory3();
    Errors7 = { ...errors_exports4 };
  }
});

// node_modules/ipfs-core/cjs/src/block-storage.js
var require_block_storage = __commonJS({
  "node_modules/ipfs-core/cjs/src/block-storage.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var blockstoreCore = (init_src16(), src_exports9);
    var merge4 = require_it_merge();
    var pushable4 = require_it_pushable();
    var filter8 = require_it_filter();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var merge__default = /* @__PURE__ */ _interopDefaultLegacy(merge4);
    var pushable__default = /* @__PURE__ */ _interopDefaultLegacy(pushable4);
    var filter__default = /* @__PURE__ */ _interopDefaultLegacy(filter8);
    var BlockStorage = class extends blockstoreCore.BaseBlockstore {
      constructor(blockstore, bitswap) {
        super();
        this.child = blockstore;
        this.bitswap = bitswap;
      }
      open() {
        return this.child.open();
      }
      close() {
        return this.child.close();
      }
      unwrap() {
        return this.child;
      }
      async put(cid, block, options = {}) {
        if (await this.has(cid)) {
          return;
        }
        if (this.bitswap.isStarted()) {
          await this.bitswap.put(cid, block, options);
        } else {
          await this.child.put(cid, block, options);
        }
      }
      async *putMany(blocks, options = {}) {
        const missingBlocks = filter__default["default"](blocks, async ({ key }) => {
          return !await this.has(key);
        });
        if (this.bitswap.isStarted()) {
          yield* this.bitswap.putMany(missingBlocks, options);
        } else {
          yield* this.child.putMany(missingBlocks, options);
        }
      }
      async get(cid, options = {}) {
        if (!await this.has(cid) && this.bitswap.isStarted()) {
          return this.bitswap.get(cid, options);
        } else {
          return this.child.get(cid, options);
        }
      }
      async *getMany(cids, options = {}) {
        const getFromBitswap = pushable__default["default"]();
        const getFromChild = pushable__default["default"]();
        Promise.resolve().then(async () => {
          for await (const cid of cids) {
            if (!await this.has(cid) && this.bitswap.isStarted()) {
              getFromBitswap.push(cid);
            } else {
              getFromChild.push(cid);
            }
          }
          getFromBitswap.end();
          getFromChild.end();
        });
        yield* merge__default["default"](this.bitswap.getMany(getFromBitswap, options), this.child.getMany(getFromChild, options));
      }
      async delete(cid, options) {
        await this.child.delete(cid, options);
      }
      async *deleteMany(cids, options) {
        yield* this.child.deleteMany(cids, options);
      }
      async has(cid, options = {}) {
        return this.child.has(cid, options);
      }
      async *query(q, options = {}) {
        yield* this.child.query(q, options);
      }
      async *queryKeys(q, options = {}) {
        yield* this.child.queryKeys(q, options);
      }
    };
    exports2.BlockStorage = BlockStorage;
  }
});

// node_modules/ipfs-core/cjs/src/components/network.js
var require_network2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/network.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ipfsBitswap = (init_src15(), src_exports8);
    var libp2p = require_libp2p();
    var multiaddr = require_src();
    var errCode32 = require_err_code();
    var blockStorage = require_block_storage();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var Network2 = class {
      constructor(peerId, libp2p2, bitswap, repo, blockstore) {
        this.peerId = peerId;
        this.libp2p = libp2p2;
        this.bitswap = bitswap;
        this.repo = repo;
        this.blockstore = blockstore;
      }
      static async start({ peerId, repo, print, options }) {
        if (repo.closed) {
          await repo.open();
        }
        const config2 = await repo.config.getAll();
        const libp2p$1 = await libp2p.createLibp2p({
          options,
          repo,
          peerId,
          multiaddrs: readAddrs(peerId, config2),
          config: config2,
          keychainConfig: void 0
        });
        if (libp2p$1.keychain) {
          await libp2p$1.loadKeychain();
        }
        await libp2p$1.start();
        for (const ma of libp2p$1.multiaddrs) {
          print(`Swarm listening on ${ma}/p2p/${peerId.toB58String()}`);
        }
        const bitswap = ipfsBitswap.createBitswap(libp2p$1, repo.blocks, { statsEnabled: true });
        await bitswap.start();
        const blockstore = new blockStorage.BlockStorage(repo.blocks, bitswap);
        repo.blocks = blockstore;
        repo.pins.blockstore = blockstore;
        return new Network2(peerId, libp2p$1, bitswap, repo, blockstore);
      }
      static async stop(network) {
        network.repo.blocks = network.blockstore.unwrap();
        network.repo.pins.blockstore = network.blockstore.unwrap();
        await Promise.all([
          network.bitswap.stop(),
          network.libp2p.stop()
        ]);
      }
    };
    var readAddrs = (peerId, config2) => {
      const peerIdStr = peerId.toB58String();
      const addrs = [];
      const swarm = config2.Addresses && config2.Addresses.Swarm || [];
      for (const addr of swarm) {
        let ma = new multiaddr.Multiaddr(addr);
        if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {
          throw errCode__default["default"](new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"), "ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");
        }
        const maId = ma.getPeerId();
        if (maId && maId !== peerIdStr) {
          ma = ma.encapsulate(`/p2p/${peerIdStr}`);
        }
        addrs.push(ma);
      }
      return addrs;
    };
    var WEBSOCKET_STAR_PROTO_CODE = 479;
    exports2.Network = Network2;
  }
});

// node_modules/ipfs-core/cjs/src/components/swarm/addrs.js
var require_addrs = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/swarm/addrs.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createAddrs2({ network }) {
      async function addrs(options = {}) {
        const peers = [];
        const { libp2p } = await network.use(options);
        for (const [peerId, peer] of libp2p.peerStore.peers.entries()) {
          peers.push({
            id: peerId,
            addrs: peer.addresses.map((mi) => mi.multiaddr)
          });
        }
        return peers;
      }
      return withTimeoutOption2.withTimeoutOption(addrs);
    }
    exports2.createAddrs = createAddrs2;
  }
});

// node_modules/ipfs-core/cjs/src/components/swarm/connect.js
var require_connect = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/swarm/connect.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createConnect2({ network }) {
      async function connect(addr, options = {}) {
        const { libp2p } = await network.use(options);
        await libp2p.dial(addr, options);
      }
      return withTimeoutOption2.withTimeoutOption(connect);
    }
    exports2.createConnect = createConnect2;
  }
});

// node_modules/ipfs-core/cjs/src/components/swarm/disconnect.js
var require_disconnect = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/swarm/disconnect.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createDisconnect2({ network }) {
      async function disconnect(addr, options = {}) {
        const { libp2p } = await network.use(options);
        await libp2p.hangUp(addr);
      }
      return withTimeoutOption2.withTimeoutOption(disconnect);
    }
    exports2.createDisconnect = createDisconnect2;
  }
});

// node_modules/ipfs-core/cjs/src/components/swarm/local-addrs.js
var require_local_addrs = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/swarm/local-addrs.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createLocalAddrs2({ network }) {
      async function localAddrs(options = {}) {
        const { libp2p } = await network.use(options);
        return libp2p.multiaddrs;
      }
      return withTimeoutOption2.withTimeoutOption(localAddrs);
    }
    exports2.createLocalAddrs = createLocalAddrs2;
  }
});

// node_modules/ipfs-core/cjs/src/components/swarm/peers.js
var require_peers = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/swarm/peers.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function createPeers3({ network }) {
      async function peers(options = {}) {
        const { libp2p } = await network.use(options);
        const peers2 = [];
        for (const [peerId, connections] of libp2p.connections) {
          for (const connection of connections) {
            const peer = {
              addr: connection.remoteAddr,
              peer: peerId
            };
            if (options.verbose || options.direction) {
              peer.direction = connection.stat.direction;
            }
            if (options.verbose) {
              peer.muxer = connection.stat.multiplexer;
              peer.latency = "n/a";
              peer.streams = [];
            }
            peers2.push(peer);
          }
        }
        return peers2;
      }
      return withTimeoutOption2.withTimeoutOption(peers);
    }
    exports2.createPeers = createPeers3;
  }
});

// node_modules/ipfs-core/cjs/src/components/swarm/index.js
var require_swarm = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/swarm/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var addrs = require_addrs();
    var connect = require_connect();
    var disconnect = require_disconnect();
    var localAddrs = require_local_addrs();
    var peers = require_peers();
    var SwarmAPI = class {
      constructor({ network }) {
        this.addrs = addrs.createAddrs({ network });
        this.connect = connect.createConnect({ network });
        this.disconnect = disconnect.createDisconnect({ network });
        this.localAddrs = localAddrs.createLocalAddrs({ network });
        this.peers = peers.createPeers({ network });
      }
    };
    exports2.SwarmAPI = SwarmAPI;
  }
});

// node_modules/ipfs-core/cjs/src/components/ping.js
var require_ping3 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/ping.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PeerId2 = require_src6();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var PeerId__default = /* @__PURE__ */ _interopDefaultLegacy(PeerId2);
    var basePacket = {
      success: true,
      time: 0,
      text: ""
    };
    function createPing2({ network }) {
      async function* ping(peerId, options = {}) {
        const { libp2p } = await network.use();
        options.count = options.count || 10;
        const peer = PeerId__default["default"].createFromB58String(peerId);
        const storedPeer = libp2p.peerStore.get(peer);
        let id = storedPeer && storedPeer.id;
        if (!id) {
          yield {
            ...basePacket,
            text: `Looking up peer ${peerId}`
          };
          const remotePeer = await libp2p.peerRouting.findPeer(peer);
          id = remotePeer && remotePeer.id;
        }
        if (!id) {
          throw new Error("Peer was not found");
        }
        yield {
          ...basePacket,
          text: `PING ${id.toB58String()}`
        };
        let packetCount = 0;
        let totalTime = 0;
        for (let i = 0; i < options.count; i++) {
          try {
            const time = await libp2p.ping(id);
            totalTime += time;
            packetCount++;
            yield {
              ...basePacket,
              time
            };
          } catch (err) {
            yield {
              ...basePacket,
              success: false,
              text: err.toString()
            };
          }
        }
        if (packetCount) {
          const average = totalTime / packetCount;
          yield {
            ...basePacket,
            text: `Average latency: ${average}ms`
          };
        }
      }
      return withTimeoutOption2.withTimeoutOption(ping);
    }
    exports2.createPing = createPing2;
  }
});

// node_modules/ipfs-core/cjs/src/components/dht.js
var require_dht2 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/dht.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var PeerId2 = require_src6();
    var errCode32 = require_err_code();
    var errors2 = require_errors();
    var get2 = require_dlv_umd();
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var PeerId__default = /* @__PURE__ */ _interopDefaultLegacy(PeerId2);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var get__default = /* @__PURE__ */ _interopDefaultLegacy(get2);
    function createDht2({ network, repo }) {
      const { get: get3, put, findProvs, findPeer, provide, query } = {
        async get(key, options = {}) {
          const { libp2p } = await use(network, options);
          return libp2p._dht.get(key, options);
        },
        async *put(key, value, options) {
          const { libp2p } = await use(network, options);
          yield* libp2p._dht.put(key, value);
        },
        async *findProvs(cid, options = { numProviders: 20 }) {
          const { libp2p } = await use(network, options);
          for await (const peer of libp2p._dht.findProviders(cid, {
            maxNumProviders: options.numProviders,
            signal: options.signal
          })) {
            yield {
              id: peer.id.toB58String(),
              addrs: peer.addrs
            };
          }
        },
        async findPeer(peerId, options) {
          const { libp2p } = await use(network, options);
          const peer = await libp2p._dht.findPeer(PeerId__default["default"].parse(peerId));
          return {
            id: peer.id.toB58String(),
            addrs: peer.multiaddrs
          };
        },
        async *provide(cids, options = { recursive: false }) {
          const { libp2p } = await use(network, options);
          const cidArr = Array.isArray(cids) ? cids : [cids];
          const hasCids = await Promise.all(cidArr.map((cid) => repo.blocks.has(cid)));
          const hasAll = hasCids.every((has) => has);
          if (!hasAll) {
            throw errCode__default["default"](new Error("block(s) not found locally, cannot provide"), "ERR_BLOCK_NOT_FOUND");
          }
          if (options.recursive) {
            throw errCode__default["default"](new Error("not implemented yet"), "ERR_NOT_IMPLEMENTED_YET");
          }
          for (const cid of cidArr) {
            yield libp2p._dht.provide(cid);
          }
        },
        async *query(peerId, options) {
          const { libp2p } = await use(network, options);
          for await (const closerPeerId of libp2p._dht.getClosestPeers(PeerId__default["default"].parse(peerId).toBytes())) {
            yield {
              id: closerPeerId.toB58String(),
              addrs: []
            };
          }
        }
      };
      return {
        get: withTimeoutOption2.withTimeoutOption(get3),
        put: withTimeoutOption2.withTimeoutOption(put),
        findProvs: withTimeoutOption2.withTimeoutOption(findProvs),
        findPeer: withTimeoutOption2.withTimeoutOption(findPeer),
        provide: withTimeoutOption2.withTimeoutOption(provide),
        query: withTimeoutOption2.withTimeoutOption(query)
      };
    }
    var use = async (network, options) => {
      const net = await network.use(options);
      if (get__default["default"](net.libp2p, "_config.dht.enabled", false)) {
        return net;
      } else {
        throw new errors2.NotEnabledError("dht not enabled");
      }
    };
    exports2.createDht = createDht2;
  }
});

// node_modules/ipfs-core/cjs/src/components/pubsub.js
var require_pubsub3 = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/pubsub.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var withTimeoutOption2 = (init_with_timeout_option(), with_timeout_option_exports);
    var errCode32 = require_err_code();
    var errors2 = require_errors();
    var get2 = require_dlv_umd();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var get__default = /* @__PURE__ */ _interopDefaultLegacy(get2);
    function createPubsub3({ network, config: config2 }) {
      const isEnabled = get__default["default"](config2 || {}, "Pubsub.Enabled", true);
      return {
        subscribe: isEnabled ? withTimeoutOption2.withTimeoutOption(subscribe) : notEnabled,
        unsubscribe: isEnabled ? withTimeoutOption2.withTimeoutOption(unsubscribe) : notEnabled,
        publish: isEnabled ? withTimeoutOption2.withTimeoutOption(publish) : notEnabled,
        ls: isEnabled ? withTimeoutOption2.withTimeoutOption(ls) : notEnabled,
        peers: isEnabled ? withTimeoutOption2.withTimeoutOption(peers) : notEnabled
      };
      async function subscribe(topic, handler, options = {}) {
        const { libp2p } = await network.use(options);
        return libp2p.pubsub.subscribe(topic, handler, options);
      }
      async function unsubscribe(topic, handler, options = {}) {
        const { libp2p } = await network.use(options);
        libp2p.pubsub.unsubscribe(topic, handler, options);
      }
      async function publish(topic, data, options = {}) {
        const { libp2p } = await network.use(options);
        if (!data) {
          throw errCode__default["default"](new Error('argument "data" is required'), "ERR_ARG_REQUIRED");
        }
        await libp2p.pubsub.publish(topic, data);
      }
      async function ls(options = {}) {
        const { libp2p } = await network.use(options);
        return libp2p.pubsub.getTopics();
      }
      async function peers(topic, options = {}) {
        const { libp2p } = await network.use(options);
        return libp2p.pubsub.getSubscribers(topic);
      }
    }
    var notEnabled = async () => {
      throw new errors2.NotEnabledError("pubsub not enabled");
    };
    exports2.createPubsub = createPubsub3;
  }
});

// node_modules/ipfs-core/cjs/src/components/index.js
var require_components = __commonJS({
  "node_modules/ipfs-core/cjs/src/components/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var mergeOpts = require_merge_options();
    var env_js = require_env();
    var debug17 = require_browser2();
    var errCode32 = require_err_code();
    var ipfsUnixfs = (init_src(), src_exports);
    var dagPB = (init_src2(), src_exports2);
    var dagCBOR = (init_esm(), esm_exports);
    var identity3 = (init_identity(), identity_exports);
    var basics = (init_basics(), basics_exports);
    var initAssets2 = (init_init_assets_browser(), init_assets_browser_exports);
    var errors2 = require_errors();
    var fromString4 = (init_from_string(), from_string_exports);
    var start = require_start();
    var stop = require_stop();
    var dns = require_dns();
    var isOnline = require_is_online();
    var resolve6 = require_resolve();
    var index = require_pin();
    var ipns2 = require_ipns2();
    var index$2 = require_name();
    var index$4 = require_refs();
    var local = require_local();
    var index$6 = require_bitswap();
    var index$7 = require_bootstrap();
    var index$1 = require_block();
    var root = require_root();
    var version3 = require_version2();
    var id = require_id();
    var index$8 = require_config2();
    var index$3 = require_dag();
    var preload2 = require_preload();
    var mfsPreload = require_mfs_preload();
    var index$5 = require_files();
    var index$9 = require_key3();
    var index$a = require_object();
    var index$b = require_repo();
    var index$c = require_stats();
    var storage = require_storage();
    var network = require_network2();
    var service = require_service2();
    var index$d = require_swarm();
    var ping = require_ping3();
    var dht = require_dht2();
    var pubsub = require_pubsub3();
    var multicodecs = (init_multicodecs(), multicodecs_exports);
    var multihashes = (init_multihashes(), multihashes_exports);
    var multibases = (init_multibases(), multibases_exports);
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    function _interopNamespace(e) {
      if (e && e.__esModule)
        return e;
      var n = Object.create(null);
      if (e) {
        Object.keys(e).forEach(function(k) {
          if (k !== "default") {
            var d = Object.getOwnPropertyDescriptor(e, k);
            Object.defineProperty(n, k, d.get ? d : {
              enumerable: true,
              get: function() {
                return e[k];
              }
            });
          }
        });
      }
      n["default"] = e;
      return Object.freeze(n);
    }
    var mergeOpts__default = /* @__PURE__ */ _interopDefaultLegacy(mergeOpts);
    var debug__default = /* @__PURE__ */ _interopDefaultLegacy(debug17);
    var errCode__default = /* @__PURE__ */ _interopDefaultLegacy(errCode32);
    var dagPB__namespace = /* @__PURE__ */ _interopNamespace(dagPB);
    var dagCBOR__namespace = /* @__PURE__ */ _interopNamespace(dagCBOR);
    var mergeOptions2 = mergeOpts__default["default"].bind({ ignoreUndefined: true });
    var log15 = debug__default["default"]("ipfs");
    var IPFS = class {
      constructor({ print, storage: storage2, codecs: codecs2, options }) {
        const { peerId, repo, keychain } = storage2;
        const network$1 = service.Service.create(network.Network);
        const preload$1 = preload2.createPreloader(options.preload);
        const dns$1 = dns.createDns();
        const isOnline$1 = isOnline.createIsOnline({ network: network$1 });
        const ipns$1 = new ipns2.IPNSAPI(options);
        const multihashHashers = Object.values(basics.hashes);
        (options.ipld && options.ipld.hashers ? options.ipld.hashers : []).forEach((hasher) => multihashHashers.push(hasher));
        this.hashers = new multihashes.Multihashes({
          hashers: multihashHashers,
          loadHasher: options.ipld && options.ipld.loadHasher
        });
        const multibaseCodecs = Object.values(basics.bases);
        (options.ipld && options.ipld.bases ? options.ipld.bases : []).forEach((base3) => multibaseCodecs.push(base3));
        this.bases = new multibases.Multibases({
          bases: multibaseCodecs,
          loadBase: options.ipld && options.ipld.loadBase
        });
        const pin = new index.PinAPI({
          repo,
          codecs: codecs2
        });
        const block = new index$1.BlockAPI({
          codecs: codecs2,
          hashers: this.hashers,
          preload: preload$1,
          repo
        });
        const name5 = new index$2.NameAPI({
          dns: dns$1,
          ipns: ipns$1,
          repo,
          codecs: codecs2,
          peerId,
          isOnline: isOnline$1,
          keychain,
          options
        });
        const resolve$1 = resolve6.createResolve({
          repo,
          codecs: codecs2,
          bases: this.bases,
          name: name5
        });
        const dag = new index$3.DagAPI({
          repo,
          codecs: codecs2,
          hashers: this.hashers,
          preload: preload$1
        });
        const refs = Object.assign(index$4.createRefs({
          repo,
          codecs: codecs2,
          resolve: resolve$1,
          preload: preload$1
        }), { local: local.createLocal({ repo: storage2.repo }) });
        const { add, addAll, cat, get: get2, ls } = new root.RootAPI({
          preload: preload$1,
          repo,
          options: options.EXPERIMENTAL
        });
        const files = index$5.createFiles({
          repo,
          preload: preload$1,
          hashers: this.hashers,
          options
        });
        const mfsPreload$1 = mfsPreload.createMfsPreloader({
          files,
          preload: preload$1,
          options: options.preload
        });
        this.preload = preload$1;
        this.name = name5;
        this.ipns = ipns$1;
        this.pin = pin;
        this.resolve = resolve$1;
        this.block = block;
        this.refs = refs;
        this.start = start.createStart({
          network: network$1,
          peerId,
          repo,
          preload: preload$1,
          ipns: ipns$1,
          mfsPreload: mfsPreload$1,
          print,
          keychain,
          options
        });
        this.stop = stop.createStop({
          network: network$1,
          preload: preload$1,
          mfsPreload: mfsPreload$1,
          ipns: ipns$1,
          repo
        });
        this.dht = dht.createDht({
          network: network$1,
          repo
        });
        this.pubsub = pubsub.createPubsub({
          network: network$1,
          config: options.config
        });
        this.dns = dns$1;
        this.isOnline = isOnline$1;
        this.id = id.createId({
          network: network$1,
          peerId
        });
        this.version = version3.createVersion({ repo });
        this.bitswap = new index$6.BitswapAPI({ network: network$1 });
        this.bootstrap = new index$7.BootstrapAPI({ repo });
        this.config = index$8.createConfig({ repo });
        this.ping = ping.createPing({ network: network$1 });
        this.add = add;
        this.addAll = addAll;
        this.cat = cat;
        this.get = get2;
        this.ls = ls;
        this.dag = dag;
        this.files = files;
        this.key = new index$9.KeyAPI({ keychain });
        this.object = new index$a.ObjectAPI({
          preload: preload$1,
          codecs: codecs2,
          repo
        });
        this.repo = new index$b.RepoAPI({
          repo,
          hashers: this.hashers
        });
        this.stats = new index$c.StatsAPI({
          repo,
          network: network$1
        });
        this.swarm = new index$d.SwarmAPI({ network: network$1 });
        Object.defineProperty(this, "libp2p", {
          get() {
            const net = network$1.try();
            return net ? net.libp2p : void 0;
          }
        });
        const notImplemented = () => Promise.reject(errCode__default["default"](new Error("Not implemented"), "ERR_NOT_IMPLEMENTED"));
        const notImplementedIter = async function* () {
          throw errCode__default["default"](new Error("Not implemented"), "ERR_NOT_IMPLEMENTED");
        };
        this.commands = notImplemented;
        this.diag = {
          cmds: notImplemented,
          net: notImplemented,
          sys: notImplemented
        };
        this.log = {
          level: notImplemented,
          ls: notImplemented,
          tail: notImplementedIter
        };
        this.mount = notImplemented;
        this.codecs = codecs2;
      }
      async init() {
        throw new errors2.AlreadyInitializedError();
      }
    };
    var addEmptyDir = async (ipfs2) => {
      const buf2 = dagPB__namespace.encode({
        Data: new ipfsUnixfs.UnixFS({ type: "directory" }).marshal(),
        Links: []
      });
      const cid = await ipfs2.block.put(buf2, {
        mhtype: "sha2-256",
        format: "dag-pb"
      });
      await ipfs2.pin.add(cid);
      return cid;
    };
    var getDefaultOptions = () => ({
      start: true,
      EXPERIMENTAL: {},
      preload: {
        enabled: !env_js.isTest,
        addresses: [
          "/dns4/node0.preload.ipfs.io/https",
          "/dns4/node1.preload.ipfs.io/https",
          "/dns4/node2.preload.ipfs.io/https",
          "/dns4/node3.preload.ipfs.io/https"
        ]
      }
    });
    async function create7(options = {}) {
      options = mergeOptions2(getDefaultOptions(), options);
      const initOptions = options.init || {};
      const id2 = {
        name: identity3.identity.name,
        code: identity3.identity.code,
        encode: (id3) => id3,
        decode: (id3) => id3
      };
      const blockCodecs = Object.values(basics.codecs);
      [
        dagPB__namespace,
        dagCBOR__namespace,
        id2
      ].concat(options.ipld && options.ipld.codecs || []).forEach((codec) => blockCodecs.push(codec));
      const multicodecs$1 = new multicodecs.Multicodecs({
        codecs: blockCodecs,
        loadCodec: options.ipld && options.ipld.loadCodec
      });
      const print = options.silent ? log15 : console.log;
      const storage$1 = await storage.Storage.start(print, multicodecs$1, options);
      const config2 = await storage$1.repo.config.getAll();
      const ipfs2 = new IPFS({
        storage: storage$1,
        print,
        codecs: multicodecs$1,
        options: {
          ...options,
          config: config2
        }
      });
      await ipfs2.preload.start();
      ipfs2.ipns.startOffline(storage$1);
      if (storage$1.isNew && !initOptions.emptyRepo) {
        const cid = await addEmptyDir(ipfs2);
        log15("adding default assets");
        await initAssets2.initAssets({
          addAll: ipfs2.addAll,
          print
        });
        log15("initializing IPNS keyspace");
        await ipfs2.ipns.initializeKeyspace(storage$1.peerId.privKey, fromString4.fromString(`/ipfs/${cid}`));
      }
      if (options.start !== false) {
        await ipfs2.start();
      }
      return ipfs2;
    }
    exports2.create = create7;
  }
});

// node_modules/ipfs-core/cjs/src/index.js
var require_src31 = __commonJS({
  "node_modules/ipfs-core/cjs/src/index.js"(exports2) {
    init_node_globals();
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var index = require_components();
    var crypto$1 = require_src7();
    var isIpfs = require_src3();
    var cid = (init_cid(), cid_exports);
    var multiaddr$1 = require_src();
    var PeerId$1 = require_src6();
    var globSourceImport2 = require_glob_source();
    var urlSourceImport = require_url_source();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    var crypto__default = /* @__PURE__ */ _interopDefaultLegacy(crypto$1);
    var isIpfs__default = /* @__PURE__ */ _interopDefaultLegacy(isIpfs);
    var PeerId__default = /* @__PURE__ */ _interopDefaultLegacy(PeerId$1);
    var globSourceImport__default = /* @__PURE__ */ _interopDefaultLegacy(globSourceImport2);
    var urlSourceImport__default = /* @__PURE__ */ _interopDefaultLegacy(urlSourceImport);
    var create7 = index.create;
    var crypto3 = crypto__default["default"];
    var isIPFS = isIpfs__default["default"];
    var CID2 = cid.CID;
    var multiaddr = multiaddr$1.Multiaddr;
    var PeerId2 = PeerId__default["default"];
    var globSource2 = globSourceImport__default["default"];
    var urlSource = urlSourceImport__default["default"];
    exports2.CID = CID2;
    exports2.PeerId = PeerId2;
    exports2.create = create7;
    exports2.crypto = crypto3;
    exports2.globSource = globSource2;
    exports2.isIPFS = isIPFS;
    exports2.multiaddr = multiaddr;
    exports2.urlSource = urlSource;
  }
});
export default require_src31();
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! run-parallel-limit. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/**
 * Timestamp for 64-bit time_t, nanosecond precision and strftime
 *
 * @author Yusuke Kawasaki
 * @license MIT
 * @see https://github.com/kawanet/timestamp-nano
 */
//# sourceMappingURL=ipfs-core.js.map
